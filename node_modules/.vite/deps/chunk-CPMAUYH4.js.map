{
  "version": 3,
  "sources": ["../../primevue/node_modules/@primeuix/utils/src/classnames/index.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/hasClass.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/addClass.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/calculateBodyScrollbarWidth.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/helpers/blockBodyScroll.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/helpers/saveAs.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/helpers/exportCSV.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/removeClass.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/helpers/unblockBodyScroll.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getCSSVariableByRegex.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getHiddenElementDimensions.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getViewport.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getScrollLeft.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getWindowScrollLeft.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getWindowScrollTop.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isRTL.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/absolutePosition.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/addStyle.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getOuterWidth.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/relativePosition.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/alignOverlay.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getParentNode.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isExist.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/toElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getTargetElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/appendChild.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/calculateScrollbarHeight.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/calculateScrollbarWidth.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/clearSelection.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/setAttributes.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/createElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/createStyleMarkup.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/createStyleAsString.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/createStyleElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/createStyleTag.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/fadeIn.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/fadeOut.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/find.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/findSingle.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/focus.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getAttribute.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/resolveUserAgent.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getBrowser.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getBrowserLanguage.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getCSSProperty.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getCursorOffset.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getFocusableElements.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getFirstFocusableElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getHeight.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getHiddenElementOuterHeight.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getHiddenElementOuterWidth.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getIndex.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getInnerWidth.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getLastFocusableElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getNextElementSibling.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getNextFocusableElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getOffset.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getOuterHeight.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getParents.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getPreviousElementSibling.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getScrollableParents.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getSelection.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getUserAgent.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/getWidth.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/hasCSSAnimation.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/hasCSSTransition.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/invokeElementMethod.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isAndroid.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isAttributeEquals.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isAttributeNotEquals.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isClickable.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isClient.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isFocusableElement.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isVisible.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isHidden.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isIOS.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isPrefersReducedMotion.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isServer.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/isTouchDevice.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/nestedPosition.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/remove.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/removeChild.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/removeStyleTag.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/scrollInView.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/setAttribute.ts", "../../primevue/node_modules/@primeuix/utils/src/dom/methods/setCSSProperty.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isEmpty.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/compare.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/deepEquals.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isFunction.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isNotEmpty.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/resolveFieldData.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/equals.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/contains.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isObject.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/deepMerge.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/filter.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/findIndexInList.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/findLast.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/findLastIndex.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/resolve.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isString.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/toFlatCase.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/getKeyValue.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/insertIntoOrderedArray.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isArray.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isDate.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isLetter.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isNumber.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isPrintableCharacter.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/isScalar.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/localeComparator.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/matchRegex.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/mergeKeys.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/minifyCSS.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/nestedKeys.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/omit.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/removeAccents.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/reorderArray.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/sort.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/stringify.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/toCapitalCase.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/toKebabCase.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/toMs.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/toTokenKey.ts", "../../primevue/node_modules/@primeuix/utils/src/object/methods/toValue.ts", "../../primevue/node_modules/@primeuix/utils/src/zindex/index.ts"],
  "sourcesContent": ["export function cn(...args: any[]): string | undefined {\n    if (args) {\n        let classes: any = [];\n\n        for (let i = 0; i < args.length; i++) {\n            const className = args[i];\n\n            if (!className) {\n                continue;\n            }\n\n            const type = typeof className;\n\n            if (type === 'string' || type === 'number') {\n                classes.push(className);\n            } else if (type === 'object') {\n                const _classes = Array.isArray(className) ? [cn(...className)] : Object.entries(className).map(([key, value]) => (value ? key : undefined));\n\n                classes = _classes.length ? classes.concat(_classes.filter((c) => !!c)) : classes;\n            }\n        }\n\n        return classes.join(' ').trim();\n    }\n\n    return undefined;\n}\n\n/**\n * @deprecated Use `cn` instead.\n * @param args\n * @returns\n */\nexport function classNames(...args: any[]): string | undefined {\n    return cn(...args);\n}\n", "export default function hasClass(element: Element, className: string): boolean {\n    if (element) {\n        if (element.classList) return element.classList.contains(className);\n        else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n    }\n\n    return false;\n}\n", "import hasClass from './hasClass';\n\nexport default function addClass(element: Element, className: string | undefined | null | (string | undefined | null)[]): void {\n    if (element && className) {\n        const fn = (_className: string) => {\n            if (!hasClass(element, _className)) {\n                if (element.classList) element.classList.add(_className);\n                else element.className += ' ' + _className;\n            }\n        };\n\n        [className]\n            .flat()\n            .filter(Boolean)\n            .forEach((_classNames) => (_classNames as string).split(' ').forEach(fn));\n    }\n}\n", "export default function calculateBodyScrollbarWidth(): number {\n    return window.innerWidth - document.documentElement.offsetWidth;\n}\n", "import addClass from '../methods/addClass';\nimport calculateBodyScrollbarWidth from '../methods/calculateBodyScrollbarWidth';\n\nexport interface BlockBodyScrollOptions {\n    className?: string;\n    variableName?: string;\n}\n\nexport default function blockBodyScroll(option: string | BlockBodyScrollOptions | undefined): void {\n    if (typeof option === 'string') {\n        addClass(document.body, option || 'p-overflow-hidden');\n    } else {\n        option?.variableName && document.body.style.setProperty(option.variableName, calculateBodyScrollbarWidth() + 'px');\n        addClass(document.body, option?.className || 'p-overflow-hidden');\n    }\n}\n", "export default function saveAs(file: { name: string; src: string }): boolean {\n    if (file) {\n        const link = document.createElement('a');\n\n        if (link.download !== undefined) {\n            const { name, src } = file;\n\n            link.setAttribute('href', src);\n            link.setAttribute('download', name);\n            link.style.display = 'none';\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n\n            return true;\n        }\n    }\n\n    return false;\n}\n", "import saveAs from './saveAs';\n\nexport default function exportCSV(csv: any, filename: string): void {\n    const blob = new Blob([csv], {\n        type: 'application/csv;charset=utf-8;'\n    });\n\n    if ((window.navigator as any).msSaveOrOpenBlob) {\n        (navigator as any).msSaveOrOpenBlob(blob, filename + '.csv');\n    } else {\n        const isDownloaded = saveAs({ name: filename + '.csv', src: URL.createObjectURL(blob) });\n\n        if (!isDownloaded) {\n            csv = 'data:text/csv;charset=utf-8,' + csv;\n            window.open(encodeURI(csv));\n        }\n    }\n}\n", "export default function removeClass(element: Element, className: string | undefined | null | (string | undefined | null)[]): void {\n    if (element && className) {\n        const fn = (_className: string) => {\n            if (element.classList) element.classList.remove(_className);\n            else element.className = element.className.replace(new RegExp('(^|\\\\b)' + _className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        };\n\n        [className]\n            .flat()\n            .filter(Boolean)\n            .forEach((_classNames) => (_classNames as string).split(' ').forEach(fn));\n    }\n}\n", "import removeClass from '../methods/removeClass';\n\nexport interface UnblockBodyScrollOptions {\n    className?: string;\n    variableName?: string;\n}\n\nexport default function unblockBodyScroll(option: string | UnblockBodyScrollOptions | undefined): void {\n    if (typeof option === 'string') {\n        removeClass(document.body, option || 'p-overflow-hidden');\n    } else {\n        if (option?.variableName) document.body.style.removeProperty(option.variableName);\n        removeClass(document.body, option?.className || 'p-overflow-hidden');\n    }\n}\n", "export default function getCSSVariableByRegex(variableRegex: RegExp): { name: string | undefined; value: string | undefined } | null {\n    for (const sheet of document?.styleSheets) {\n        try {\n            for (const rule of sheet?.cssRules) {\n                for (const property of (rule as CSSStyleRule)?.style) {\n                    if (variableRegex.test(property)) {\n                        return { name: property, value: (rule as CSSStyleRule).style.getPropertyValue(property).trim() };\n                    }\n                }\n            }\n        } catch {}\n    }\n\n    return null;\n}\n", "export default function getHiddenElementDimensions(element?: HTMLElement): { width: number; height: number } {\n    const dimensions: { width: number; height: number } = { width: 0, height: 0 };\n\n    if (element) {\n        const [visibility, display] = [element.style.visibility, element.style.display];\n\n        // Temporarily hide the element to get its dimensions\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        dimensions.width = element.offsetWidth;\n        dimensions.height = element.offsetHeight;\n        element.style.display = display;\n        element.style.visibility = visibility;\n    }\n\n    return dimensions;\n}\n", "export default function getViewport(): { width: number; height: number } {\n    const win = window,\n        d = document,\n        e = d.documentElement,\n        g = d.getElementsByTagName('body')[0],\n        w = win.innerWidth || e.clientWidth || g.clientWidth,\n        h = win.innerHeight || e.clientHeight || g.clientHeight;\n\n    return { width: w, height: h };\n}\n", "export default function getScrollLeft(element?: HTMLElement): number {\n    // for RTL scrollLeft should be negative\n    return element ? Math.abs(element.scrollLeft) : 0;\n}\n", "import getScrollLeft from './getScrollLeft';\n\nexport default function getWindowScrollLeft(): number {\n    const doc = document.documentElement;\n\n    return (window.pageXOffset || getScrollLeft(doc)) - (doc.clientLeft || 0);\n}\n", "export default function getWindowScrollTop(): number {\n    const doc = document.documentElement;\n\n    return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n}\n", "export default function isRTL(element?: HTMLElement): boolean {\n    return element ? getComputedStyle(element).direction === 'rtl' : false;\n}\n", "import getCSSVariableByRegex from './getCSSVariableByRegex';\nimport getHiddenElementDimensions from './getHiddenElementDimensions';\nimport getViewport from './getViewport';\nimport getWindowScrollLeft from './getWindowScrollLeft';\nimport getWindowScrollTop from './getWindowScrollTop';\nimport isRTL from './isRTL';\n\nexport default function absolutePosition(element: HTMLElement, target: HTMLElement, gutter: boolean = true): void {\n    if (element) {\n        const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);\n        const elementOuterHeight = elementDimensions.height;\n        const elementOuterWidth = elementDimensions.width;\n        const targetOuterHeight = target.offsetHeight;\n        const targetOuterWidth = target.offsetWidth;\n        const targetOffset = target.getBoundingClientRect();\n        const windowScrollTop = getWindowScrollTop();\n        const windowScrollLeft = getWindowScrollLeft();\n        const viewport = getViewport();\n        let top,\n            left,\n            origin = 'top';\n\n        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {\n            top = targetOffset.top + windowScrollTop - elementOuterHeight;\n            origin = 'bottom';\n\n            if (top < 0) {\n                top = windowScrollTop;\n            }\n        } else {\n            top = targetOuterHeight + targetOffset.top + windowScrollTop;\n        }\n\n        if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);\n        else left = targetOffset.left + windowScrollLeft;\n\n        if (isRTL(element)) {\n            element.style.insetInlineEnd = left + 'px';\n        } else {\n            element.style.insetInlineStart = left + 'px';\n        }\n\n        element.style.top = top + 'px';\n        element.style.transformOrigin = origin;\n        if (gutter) element.style.marginTop = origin === 'bottom' ? `calc(${getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '2px'} * -1)` : (getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '');\n    }\n}\n", "export default function addStyle(element: HTMLElement, style: string | object): void {\n    if (element) {\n        if (typeof style === 'string') {\n            element.style.cssText = style;\n        } else {\n            Object.entries(style || {}).forEach(([key, value]: [string, string]) => ((element.style as any)[key] = value));\n        }\n    }\n}\n", "export default function getOuterWidth(element: unknown, margin?: boolean): number {\n    if (element instanceof HTMLElement) {\n        let width = element.offsetWidth;\n\n        if (margin) {\n            const style = getComputedStyle(element);\n\n            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        }\n\n        return width;\n    }\n\n    return 0;\n}\n", "import getCSSVariableByRegex from './getCSSVariableByRegex';\nimport getHiddenElementDimensions from './getHiddenElementDimensions';\nimport getViewport from './getViewport';\n\nexport default function relativePosition(element: HTMLElement, target: HTMLElement, gutter: boolean = true, fixedOrigin: 'top' | 'bottom' | undefined = undefined): void {\n    if (element) {\n        const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);\n        const targetHeight = target.offsetHeight;\n        const targetOffset = target.getBoundingClientRect();\n        const viewport = getViewport();\n        let top,\n            left,\n            origin = fixedOrigin ?? 'top';\n\n        if (!fixedOrigin && targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {\n            top = -1 * elementDimensions.height;\n            origin = 'bottom';\n\n            if (targetOffset.top + top < 0) {\n                top = -1 * targetOffset.top;\n            }\n        } else {\n            top = targetHeight;\n        }\n\n        if (elementDimensions.width > viewport.width) {\n            // element wider then viewport and cannot fit on screen (align at left side of viewport)\n            left = targetOffset.left * -1;\n        } else if (targetOffset.left + elementDimensions.width > viewport.width) {\n            // element wider then viewport but can be fit on screen (align at right side of viewport)\n            left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;\n        } else {\n            // element fits on screen (align with target)\n            left = 0;\n        }\n\n        element.style.top = top + 'px';\n        element.style.insetInlineStart = left + 'px';\n        element.style.transformOrigin = origin;\n\n        if (gutter) {\n            const gutterValue = getCSSVariableByRegex(/-anchor-gutter$/)?.value;\n\n            element.style.marginTop = origin === 'bottom' ? `calc(${gutterValue ?? '2px'} * -1)` : (gutterValue ?? '');\n        }\n    }\n}\n", "import absolutePosition from './absolutePosition';\nimport getOuterWidth from './getOuterWidth';\nimport relativePosition from './relativePosition';\n\nexport default function alignOverlay(overlay: HTMLElement, target: HTMLElement, appendTo: string, calculateMinWidth: boolean = true) {\n    if (overlay && target) {\n        if (appendTo === 'self') {\n            relativePosition(overlay, target);\n        } else {\n            if (calculateMinWidth) overlay.style.minWidth = getOuterWidth(target) + 'px';\n            absolutePosition(overlay, target);\n        }\n    }\n}\n", "export default function getParentNode(element: Node): ParentNode | null {\n    if (element) {\n        let parent = element.parentNode;\n\n        if (parent && parent instanceof ShadowRoot && parent.host) {\n            parent = parent.host;\n        }\n\n        return parent;\n    }\n\n    return null;\n}\n", "import getParentNode from './getParentNode';\n\nexport default function isExist(element: Node): boolean {\n    return !!(element !== null && typeof element !== 'undefined' && element.nodeName && getParentNode(element));\n}\n", "export default function isElement(element: unknown): element is Element {\n    return typeof Element !== 'undefined' ? element instanceof Element : element !== null && typeof element === 'object' && (element as Element).nodeType === 1 && typeof (element as Element).nodeName === 'string';\n}\n", "import isElement from './isElement';\n\ntype ReactElement = { current: Element | null | undefined };\ntype VueElement = { el: Element | null | undefined };\ntype AngularElement = { el: { nativeElement: Element | undefined } };\n\nexport default function toElement(element: unknown): Element | null | undefined {\n    let target = element;\n\n    if (element && typeof element === 'object') {\n        if (Object.hasOwn(element, 'current')) {\n            // For React\n            target = (element as ReactElement).current;\n        } else if (Object.hasOwn(element, 'el')) {\n            if (Object.hasOwn((element as AngularElement).el, 'nativeElement')) {\n                // For Angular\n                target = (element as AngularElement).el.nativeElement;\n            } else {\n                // For Vue\n                target = (element as VueElement).el;\n            }\n        }\n    }\n\n    return isElement(target) ? target : undefined;\n}\n", "import isExist from './isExist';\nimport toElement from './toElement';\n\nexport default function getTargetElement(target: unknown, currentElement?: Element): Window | Document | Element | null | undefined {\n    if (!target) return undefined;\n\n    switch (target) {\n        case 'document':\n            return document;\n        case 'window':\n            return window;\n        case 'body':\n            return document.body;\n        case '@next':\n            return currentElement?.nextElementSibling;\n        case '@prev':\n            return currentElement?.previousElementSibling;\n        case '@first':\n            return currentElement?.firstElementChild;\n        case '@last':\n            return currentElement?.lastElementChild;\n        case '@child':\n            return currentElement?.children?.[0];\n        case '@parent':\n            return currentElement?.parentElement;\n        case '@grandparent':\n            return currentElement?.parentElement?.parentElement;\n\n        default: {\n            if (typeof target === 'string') {\n                // child selector\n                const match = target.match(/^@child\\[(\\d+)]/);\n\n                if (match) {\n                    return currentElement?.children?.[parseInt(match[1], 10)] || null;\n                }\n\n                return document.querySelector(target) || null;\n            }\n\n            const isFunction = (value: unknown): value is (...args: unknown[]) => unknown => typeof value === 'function' && 'call' in value && 'apply' in value;\n            const computedTarget = isFunction(target) ? target() : target;\n            const element = toElement(computedTarget);\n\n            return isExist(element as Element) ? (element as Element) : (computedTarget as Document)?.nodeType === 9 ? (computedTarget as Document) : undefined;\n        }\n    }\n}\n", "import getTargetElement from './getTargetElement';\n\nexport default function appendChild(element: unknown, child: Node | Element) {\n    const target: Document | Element | null | undefined = getTargetElement(element, child as Element) as Exclude<ReturnType<typeof getTargetElement>, Window>;\n\n    if (target) target.appendChild(child);\n    else throw new Error('Cannot append ' + child + ' to ' + element);\n}\n", "import addStyle from './addStyle';\n\nlet calculatedScrollbarHeight: number | undefined = undefined;\n\nexport default function calculateScrollbarHeight(element?: HTMLElement): number {\n    if (element) {\n        const style = getComputedStyle(element);\n\n        return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);\n    } else {\n        if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;\n\n        const scrollDiv = document.createElement('div');\n\n        addStyle(scrollDiv, {\n            width: '100px',\n            height: '100px',\n            overflow: 'scroll',\n            position: 'absolute',\n            top: '-9999px'\n        });\n        document.body.appendChild(scrollDiv);\n\n        const scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n\n        document.body.removeChild(scrollDiv);\n\n        calculatedScrollbarHeight = scrollbarHeight;\n\n        return scrollbarHeight;\n    }\n}\n", "import addStyle from './addStyle';\n\nlet calculatedScrollbarWidth: number | undefined = undefined;\n\nexport default function calculateScrollbarWidth(element?: HTMLElement): number {\n    if (element) {\n        const style = getComputedStyle(element);\n\n        return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);\n    } else {\n        if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;\n\n        const scrollDiv = document.createElement('div');\n\n        addStyle(scrollDiv, {\n            width: '100px',\n            height: '100px',\n            overflow: 'scroll',\n            position: 'absolute',\n            top: '-9999px'\n        });\n        document.body.appendChild(scrollDiv);\n\n        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n        document.body.removeChild(scrollDiv);\n\n        calculatedScrollbarWidth = scrollbarWidth;\n\n        return scrollbarWidth;\n    }\n}\n", "export default function clearSelection(): void {\n    if (window.getSelection) {\n        const selection: any = window.getSelection() || {};\n\n        if (selection.empty) {\n            selection.empty();\n        } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {\n            selection.removeAllRanges();\n        }\n    }\n}\n", "import isElement from './isElement';\n\nexport default function setAttributes(element: HTMLElement, attributes: { [key: string]: any } = {}): void {\n    if (isElement(element)) {\n        const computedStyles = (rule: string, value: any): string[] => {\n            const styles = (element as any)?.$attrs?.[rule] ? [(element as any)?.$attrs?.[rule]] : [];\n\n            return [value].flat().reduce((cv, v) => {\n                if (v !== null && v !== undefined) {\n                    const type = typeof v;\n\n                    if (type === 'string' || type === 'number') {\n                        cv.push(v);\n                    } else if (type === 'object') {\n                        const _cv = Array.isArray(v) ? computedStyles(rule, v) : Object.entries(v).map(([_k, _v]) => (rule === 'style' && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}:${_v}` : _v ? _k : undefined));\n\n                        cv = _cv.length ? cv.concat(_cv.filter((c) => !!c)) : cv;\n                    }\n                }\n\n                return cv;\n            }, styles);\n        };\n\n        Object.entries(attributes).forEach(([key, value]) => {\n            if (value !== undefined && value !== null) {\n                const matchedEvent = key.match(/^on(.+)/);\n\n                if (matchedEvent) {\n                    element.addEventListener(matchedEvent[1].toLowerCase(), value);\n                } else if (key === 'p-bind' || key === 'pBind') {\n                    setAttributes(element, value);\n                } else {\n                    value = key === 'class' ? [...new Set(computedStyles('class', value))].join(' ').trim() : key === 'style' ? computedStyles('style', value).join(';').trim() : value;\n                    ((element as any).$attrs = (element as any).$attrs || {}) && ((element as any).$attrs[key] = value);\n                    element.setAttribute(key, value);\n                }\n            }\n        });\n    }\n}\n", "import setAttributes from './setAttributes';\n\nexport default function createElement(type: string, attributes: Record<string, unknown> = {}, ...children: (string | Node)[]): HTMLElement | undefined {\n    if (type) {\n        const element = document.createElement(type);\n\n        setAttributes(element, attributes);\n        element.append(...children);\n\n        return element;\n    }\n\n    return undefined;\n}\n", "export default function createStyleMarkup(css?: string, attributes: Record<string, unknown> = {}): string {\n    return css ? `<style${Object.entries(attributes).reduce((s, [k, v]) => s + ` ${k}=\"${v}\"`, '')}>${css}</style>` : '';\n}\n", "import createStyleMarkup from './createStyleMarkup';\n\n/**\n * @deprecated Use `createStyleMarkup` instead.\n */\nexport default function createStyleAsString(css?: string, options: Record<string, unknown> = {}) {\n    return createStyleMarkup(css, options);\n}\n", "import createElement from './createElement';\n\nexport default function createStyleElement(css: string, attributes: Record<string, unknown> = {}, container?: Element): HTMLStyleElement {\n    const element = createElement('style', attributes, css)! as HTMLStyleElement;\n\n    container?.appendChild(element);\n\n    return element;\n}\n", "import createStyleElement from './createStyleElement';\n\n/**\n * @deprecated Use `createStyleElement` instead.\n */\nexport default function createStyleTag(attributes: Record<string, unknown> = {}, container?: Element): HTMLStyleElement {\n    return createStyleElement('', attributes, container || document.head);\n}\n", "export default function fadeIn(element: HTMLElement, duration: number): void {\n    if (element) {\n        element.style.opacity = '0';\n\n        let last = +new Date();\n        let opacity = '0';\n\n        const tick = function () {\n            opacity = `${+element.style.opacity + (new Date().getTime() - last) / duration}`;\n            element.style.opacity = opacity;\n            last = +new Date();\n\n            if (+opacity < 1) {\n                if ('requestAnimationFrame' in window) requestAnimationFrame(tick);\n                else setTimeout(tick, 16);\n            }\n        };\n\n        tick();\n    }\n}\n", "export default function fadeOut(element: HTMLElement, duration: number): void {\n    if (element) {\n        let opacity = 1;\n        const interval = 50;\n        const gap = interval / duration;\n\n        const fading = setInterval(() => {\n            opacity -= gap;\n\n            if (opacity <= 0) {\n                opacity = 0;\n                clearInterval(fading);\n            }\n\n            element.style.opacity = opacity.toString();\n        }, interval);\n    }\n}\n", "import isElement from './isElement';\n\nexport default function find(element: Element, selector: string): Element[] {\n    return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];\n}\n", "import isElement from './isElement';\n\nexport default function findSingle(element: Element, selector: string): Element | null {\n    return isElement(element) ? (element.matches(selector) ? element : element.querySelector(selector)) : null;\n}\n", "export default function focus(element: HTMLElement, options?: FocusOptions): void {\n    if (element && document.activeElement !== element) element.focus(options);\n}\n", "import isElement from './isElement';\n\nexport default function getAttribute(element: Element, name: string): any {\n    if (isElement(element)) {\n        const value = element.getAttribute(name);\n\n        if (!isNaN(value as any)) {\n            return +(value as string);\n        }\n\n        if (value === 'true' || value === 'false') {\n            return value === 'true';\n        }\n\n        return value;\n    }\n\n    return undefined;\n}\n", "export default function resolveUserAgent(): { browser: string | undefined; version: string | undefined } {\n    const ua = navigator.userAgent.toLowerCase();\n    const match = /(chrome)[ ]([\\w.]+)/.exec(ua) || /(webkit)[ ]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || (ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua)) || [];\n\n    return {\n        browser: match[1] || '',\n        version: match[2] || '0'\n    };\n}\n", "import resolveUserAgent from './resolveUserAgent';\n\ntype BrowserType = {\n    [key: string]: string | boolean | undefined;\n};\n\nlet browser: BrowserType | null = null;\n\nexport default function getBrowser(): BrowserType {\n    if (!browser) {\n        browser = {};\n\n        const matched = resolveUserAgent();\n\n        if (matched.browser) {\n            browser[matched.browser] = true;\n            browser['version'] = matched.version;\n        }\n\n        if (browser['chrome']) {\n            browser['webkit'] = true;\n        } else if (browser['webkit']) {\n            browser['safari'] = true;\n        }\n    }\n\n    return browser;\n}\n", "export default function getBrowserLanguage(): string {\n    return (navigator.languages && navigator.languages.length && navigator.languages[0]) || navigator.language || 'en';\n}\n", "export default function getCSSProperty(element?: HTMLElement, property?: string, inline?: boolean): string | null {\n    if (element && property) {\n        return inline ? element?.style?.getPropertyValue(property) : getComputedStyle(element).getPropertyValue(property);\n    }\n\n    return null;\n}\n", "export default function getCursorOffset(element: Element, prevText: string, nextText: string, currentText: string): { top: number | string; left: number | string } {\n    if (element) {\n        const style = getComputedStyle(element);\n        const ghostDiv = document.createElement('div');\n\n        ghostDiv.style.position = 'absolute';\n        ghostDiv.style.top = '0px';\n        ghostDiv.style.left = '0px';\n        ghostDiv.style.visibility = 'hidden';\n        ghostDiv.style.pointerEvents = 'none';\n        ghostDiv.style.overflow = style.overflow;\n        ghostDiv.style.width = style.width;\n        ghostDiv.style.height = style.height;\n        ghostDiv.style.padding = style.padding;\n        ghostDiv.style.border = style.border;\n        ghostDiv.style.overflowWrap = style.overflowWrap;\n        ghostDiv.style.whiteSpace = style.whiteSpace;\n        ghostDiv.style.lineHeight = style.lineHeight;\n        ghostDiv.innerHTML = prevText.replace(/\\r\\n|\\r|\\n/g, '<br />');\n\n        const ghostSpan = document.createElement('span');\n\n        ghostSpan.textContent = currentText;\n        ghostDiv.appendChild(ghostSpan);\n\n        const text = document.createTextNode(nextText);\n\n        ghostDiv.appendChild(text);\n        document.body.appendChild(ghostDiv);\n\n        const { offsetLeft, offsetTop, clientHeight } = ghostSpan;\n\n        document.body.removeChild(ghostDiv);\n\n        return {\n            left: Math.abs(offsetLeft - element.scrollLeft),\n            top: Math.abs(offsetTop - element.scrollTop) + clientHeight\n        };\n    }\n\n    return {\n        top: 'auto',\n        left: 'auto'\n    };\n}\n", "import find from './find';\n\nexport default function getFocusableElements(element: Element, selector: string = ''): Element[] {\n    const focusableElements = find(\n        element,\n        `button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`\n    );\n\n    const visibleFocusableElements: Element[] = [];\n\n    for (const focusableElement of focusableElements) {\n        if (getComputedStyle(focusableElement).display != 'none' && getComputedStyle(focusableElement).visibility != 'hidden') visibleFocusableElements.push(focusableElement);\n    }\n\n    return visibleFocusableElements;\n}\n", "import getFocusableElements from './getFocusableElements';\n\nexport default function getFirstFocusableElement(element: Element, selector?: string): Element | null {\n    const focusableElements = getFocusableElements(element, selector);\n\n    return focusableElements.length > 0 ? focusableElements[0] : null;\n}\n", "export default function getHeight(element: HTMLElement): number {\n    if (element) {\n        let height = element.offsetHeight;\n        const style = getComputedStyle(element);\n\n        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n\n        return height;\n    }\n\n    return 0;\n}\n", "export default function getHiddenElementOuterHeight(element: HTMLElement): number {\n    if (element) {\n        const [visibility, display] = [element.style.visibility, element.style.display];\n\n        // Temporarily hide the element to get its outer height\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        const elementHeight = element.offsetHeight;\n\n        element.style.display = display;\n        element.style.visibility = visibility;\n\n        return elementHeight;\n    }\n\n    return 0;\n}\n", "export default function getHiddenElementOuterWidth(element: HTMLElement): number {\n    if (element) {\n        const [visibility, display] = [element.style.visibility, element.style.display];\n\n        // Temporarily hide the element to get its outer width\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        const elementWidth = element.offsetWidth;\n\n        element.style.display = display;\n        element.style.visibility = visibility;\n\n        return elementWidth;\n    }\n\n    return 0;\n}\n", "import getParentNode from './getParentNode';\n\nexport default function getIndex(element: HTMLElement): number {\n    if (element) {\n        const children = getParentNode(element)?.childNodes;\n        let num = 0;\n\n        if (children) {\n            for (let i = 0; i < children.length; i++) {\n                if (children[i] === element) return num;\n                if (children[i].nodeType === 1) num++;\n            }\n        }\n    }\n\n    return -1;\n}\n", "export default function getInnerWidth(element: HTMLElement): number {\n    if (element) {\n        let width = element.offsetWidth;\n        const style = getComputedStyle(element);\n\n        width -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);\n\n        return width;\n    }\n\n    return 0;\n}\n", "import getFocusableElements from './getFocusableElements';\n\nexport default function getLastFocusableElement(element: Element, selector?: string): Element | null {\n    const focusableElements = getFocusableElements(element, selector);\n\n    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;\n}\n", "export default function getNextElementSibling(element: Element, selector: string): Element | null {\n    let nextElement = element.nextElementSibling;\n\n    while (nextElement) {\n        if (nextElement.matches(selector)) {\n            return nextElement;\n        } else {\n            nextElement = nextElement.nextElementSibling;\n        }\n    }\n\n    return null;\n}\n", "import getFocusableElements from './getFocusableElements';\n\nexport default function getNextFocusableElement(container: Element, element: Element, selector?: string): Element | null {\n    const focusableElements: Element[] = getFocusableElements(container, selector);\n    const index = focusableElements.length > 0 ? focusableElements.findIndex((el) => el === element) : -1;\n    const nextIndex = index > -1 && focusableElements.length >= index + 1 ? index + 1 : -1;\n\n    return nextIndex > -1 ? focusableElements[nextIndex] : null;\n}\n", "import getScrollLeft from './getScrollLeft';\n\nexport default function getOffset(element?: Element | null): { top: number | string; left: number | string } {\n    if (element) {\n        const rect = element.getBoundingClientRect();\n\n        return {\n            top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n            left: rect.left + (window.pageXOffset || getScrollLeft(document.documentElement) || getScrollLeft(document.body) || 0)\n        };\n    }\n\n    return {\n        top: 'auto',\n        left: 'auto'\n    };\n}\n", "export default function getOuterHeight(element: HTMLElement, margin?: boolean): number {\n    if (element) {\n        let height = element.offsetHeight;\n\n        if (margin) {\n            const style = getComputedStyle(element);\n\n            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        }\n\n        return height;\n    }\n\n    return 0;\n}\n", "import getParentNode from './getParentNode';\n\nexport default function getParents(element: Node, parents: ParentNode[] = []): ParentNode[] {\n    const parent = getParentNode(element);\n\n    return parent === null ? parents : getParents(parent, parents.concat([parent]));\n}\n", "export default function getPreviousElementSibling(element: Element, selector: string): Element | null {\n    let previousElement = element.previousElementSibling;\n\n    while (previousElement) {\n        if (previousElement.matches(selector)) {\n            return previousElement;\n        } else {\n            previousElement = previousElement.previousElementSibling;\n        }\n    }\n\n    return null;\n}\n", "import findSingle from './findSingle';\nimport getParents from './getParents';\n\nexport default function getScrollableParents(element: Element): Element[] {\n    const scrollableParents = [];\n\n    if (element) {\n        const parents = getParents(element) as HTMLElement[];\n        const overflowRegex = /(auto|scroll)/;\n\n        const overflowCheck = (node: Element) => {\n            try {\n                const styleDeclaration = window['getComputedStyle'](node, null);\n\n                return overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY'));\n            } catch {\n                return false;\n            }\n        };\n\n        for (const parent of parents) {\n            const scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];\n\n            if (scrollSelectors) {\n                const selectors = scrollSelectors.split(',');\n\n                for (const selector of selectors) {\n                    const el = findSingle(parent, selector);\n\n                    if (el && overflowCheck(el)) {\n                        scrollableParents.push(el);\n                    }\n                }\n            }\n\n            if (parent.nodeType !== 9 && overflowCheck(parent)) {\n                scrollableParents.push(parent);\n            }\n        }\n    }\n\n    return scrollableParents;\n}\n", "export default function getSelection(): string | undefined {\n    if (window.getSelection) return (window.getSelection() as any).toString();\n    else if (document.getSelection) return (document.getSelection() as any).toString();\n\n    return undefined;\n}\n", "export default function getUserAgent(): string {\n    return navigator.userAgent;\n}\n", "export default function getWidth(element: HTMLElement): number {\n    if (element) {\n        let width = element.offsetWidth;\n        const style = getComputedStyle(element);\n\n        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n\n        return width;\n    }\n\n    return 0;\n}\n", "export default function hasCSSAnimation(element: Element): boolean {\n    if (element) {\n        const style = getComputedStyle(element);\n        const animationDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');\n\n        return animationDuration > 0;\n    }\n\n    return false;\n}\n", "export default function hasCSSTransition(element: Element): boolean {\n    if (element) {\n        const style = getComputedStyle(element);\n        const transitionDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');\n\n        return transitionDuration > 0;\n    }\n\n    return false;\n}\n", "export default function invokeElementMethod<T extends keyof Element>(element: Element, methodName: T, args?: unknown[]): void {\n    const method = element[methodName];\n\n    if (typeof method === 'function') {\n        (method as (...args: unknown[]) => void).apply(element, args ?? []);\n    }\n}\n", "export default function isAndroid(): boolean {\n    return /(android)/i.test(navigator.userAgent);\n}\n", "import getAttribute from './getAttribute';\nimport isElement from './isElement';\n\nexport default function isAttributeEquals(element: Element, name: string, value: any): boolean {\n    return isElement(element) ? getAttribute(element, name) === value : false;\n}\n", "import isAttributeEquals from './isAttributeEquals';\n\nexport default function isAttributeNotEquals(element: Element, name: string, value: any): boolean {\n    return !isAttributeEquals(element, name, value);\n}\n", "export default function isClickable(element: Element): boolean {\n    if (element) {\n        const targetNode = element.nodeName;\n        const parentNode = element.parentElement && element.parentElement.nodeName;\n\n        return (\n            targetNode === 'INPUT' ||\n            targetNode === 'TEXTAREA' ||\n            targetNode === 'BUTTON' ||\n            targetNode === 'A' ||\n            parentNode === 'INPUT' ||\n            parentNode === 'TEXTAREA' ||\n            parentNode === 'BUTTON' ||\n            parentNode === 'A' ||\n            !!element.closest('.p-button, .p-checkbox, .p-radiobutton') // @todo Add [data-pc-section=\"button\"]\n        );\n    }\n\n    return false;\n}\n", "export default function isClient(): boolean {\n    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}\n", "import isElement from './isElement';\n\nexport default function isFocusableElement(element: unknown, selector: string = ''): boolean {\n    return isElement(element)\n        ? (element as Element).matches(`button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`)\n        : false;\n}\n", "export default function isVisible(element?: HTMLElement): boolean {\n    return !!(element && element.offsetParent != null);\n}\n", "import isVisible from './isVisible';\n\nexport default function isHidden(element: HTMLElement): boolean {\n    return !isVisible(element);\n}\n", "export default function isIOS(): boolean {\n    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n}\n", "export default function isPrefersReducedMotion(): boolean {\n    if (typeof window === 'undefined' || !window.matchMedia) {\n        return false;\n    }\n\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n\n    return mediaQuery.matches;\n}\n", "import isClient from './isClient';\n\nexport default function isServer(): boolean {\n    return !isClient();\n}\n", "export default function isTouchDevice(): boolean {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || (navigator as Partial<Navigator & { msMaxTouchPoints?: number }>).msMaxTouchPoints! > 0;\n}\n", "import calculateScrollbarWidth from './calculateScrollbarWidth';\nimport getHiddenElementOuterHeight from './getHiddenElementOuterHeight';\nimport getHiddenElementOuterWidth from './getHiddenElementOuterWidth';\nimport getOffset from './getOffset';\nimport getOuterHeight from './getOuterHeight';\nimport getOuterWidth from './getOuterWidth';\nimport getViewport from './getViewport';\n\nexport default function nestedPosition(element: HTMLElement, level: number): void {\n    if (element) {\n        const parentItem = element.parentElement;\n        const elementOffset = getOffset(parentItem);\n        const viewport = getViewport();\n        const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);\n        const sublistHeight = element.offsetParent ? element.offsetHeight : getHiddenElementOuterHeight(element);\n        const itemOuterWidth = getOuterWidth(parentItem?.children?.[0]);\n        const itemOuterHeight = getOuterHeight(parentItem?.children?.[0] as HTMLElement);\n\n        let left: string = '';\n        let top: string = '';\n\n        if ((elementOffset.left as number) + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {\n            if ((elementOffset.left as number) < sublistWidth) {\n                // for too small screens\n                if (level % 2 === 1) {\n                    left = (elementOffset.left as number) ? '-' + (elementOffset.left as number) + 'px' : '100%';\n                } else if (level % 2 === 0) {\n                    left = viewport.width - sublistWidth - calculateScrollbarWidth() + 'px';\n                }\n            } else {\n                left = '-100%';\n            }\n        } else {\n            left = '100%';\n        }\n\n        // getBoundingClientRect returns a top position from the current visible viewport area\n        if (element.getBoundingClientRect().top + itemOuterHeight + sublistHeight > viewport.height) {\n            top = `-${sublistHeight - itemOuterHeight}px`;\n        } else {\n            top = '0px';\n        }\n\n        element.style.top = top;\n        element.style.insetInlineStart = left;\n    }\n}\n", "export default function remove(element: Element) {\n    if (element) {\n        if (!('remove' in Element.prototype)) element.parentNode?.removeChild(element);\n        else element.remove();\n    }\n}\n", "import toElement from './toElement';\n\nexport default function removeChild(element: unknown, child: Node) {\n    const target = toElement(element);\n\n    if (target) target.removeChild(child);\n    else throw new Error('Cannot remove ' + child + ' from ' + element);\n}\n", "import isExist from './isExist';\n\nexport default function removeStyleTag(element: Node): Node | null {\n    if (isExist(element)) {\n        try {\n            element.parentNode?.removeChild(element);\n        } catch {\n            // style element may have already been removed in a fast refresh\n        }\n\n        return null;\n    }\n\n    return element;\n}\n", "import getOuterHeight from './getOuterHeight';\n\nexport default function scrollInView(container: HTMLElement, item: HTMLElement): void {\n    const borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');\n    const borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;\n    const paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');\n    const paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;\n    const containerRect = container.getBoundingClientRect();\n    const itemRect = item.getBoundingClientRect();\n    const offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;\n    const scroll = container.scrollTop;\n    const elementHeight = container.clientHeight;\n    const itemHeight = getOuterHeight(item);\n\n    if (offset < 0) {\n        container.scrollTop = scroll + offset;\n    } else if (offset + itemHeight > elementHeight) {\n        container.scrollTop = scroll + offset - elementHeight + itemHeight;\n    }\n}\n", "import isElement from './isElement';\n\nexport default function setAttribute(element: HTMLElement, attribute: string = '', value: any): void {\n    if (isElement(element) && value !== null && value !== undefined) {\n        element.setAttribute(attribute, value);\n    }\n}\n", "export default function setCSSProperty(element?: HTMLElement, property?: string, value: any = null, priority?: string): void {\n    property && element?.style?.setProperty(property, value, priority);\n}\n", "export default function isEmpty(value: any): boolean {\n    return value === null || value === undefined || value === '' || (Array.isArray(value) && value.length === 0) || (!(value instanceof Date) && typeof value === 'object' && Object.keys(value).length === 0);\n}\n", "import isEmpty from './isEmpty';\n\nexport default function compare<T = unknown>(value1: T, value2: T, comparator: (val1: T, val2: T) => number, order: number = 1): number {\n    let result = -1;\n    const emptyValue1 = isEmpty(value1);\n    const emptyValue2 = isEmpty(value2);\n\n    if (emptyValue1 && emptyValue2) result = 0;\n    else if (emptyValue1) result = order;\n    else if (emptyValue2) result = -order;\n    else if (typeof value1 === 'string' && typeof value2 === 'string') result = comparator(value1, value2);\n    else result = value1 < value2 ? -1 : value1 > value2 ? 1 : 0;\n\n    return result;\n}\n", "function _deepEquals(obj1: unknown, obj2: unknown, visited: WeakSet<object> = new WeakSet()): boolean {\n    // Base case: same object reference\n    if (obj1 === obj2) return true;\n\n    // If one of them is null or not an object, directly return false\n    if (!obj1 || !obj2 || typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n\n    // Check for circular references\n    if (visited.has(obj1) || visited.has(obj2)) return false;\n\n    // Add objects to the visited set\n    visited.add(obj1).add(obj2);\n\n    const arrObj1 = Array.isArray(obj1);\n    const arrObj2 = Array.isArray(obj2);\n    let i, length, key;\n\n    if (arrObj1 && arrObj2) {\n        length = obj1.length;\n        if (length != obj2.length) return false;\n        for (i = length; i-- !== 0; ) if (!_deepEquals(obj1[i], obj2[i], visited)) return false;\n\n        return true;\n    }\n\n    if (arrObj1 != arrObj2) return false;\n\n    const dateObj1 = obj1 instanceof Date,\n        dateObj2 = obj2 instanceof Date;\n\n    if (dateObj1 != dateObj2) return false;\n    if (dateObj1 && dateObj2) return obj1.getTime() == obj2.getTime();\n\n    const regexpObj1 = obj1 instanceof RegExp,\n        regexpObj2 = obj2 instanceof RegExp;\n\n    if (regexpObj1 != regexpObj2) return false;\n    if (regexpObj1 && regexpObj2) return obj1.toString() == obj2.toString();\n\n    const keys = Object.keys(obj1);\n\n    length = keys.length;\n\n    if (length !== Object.keys(obj2).length) return false;\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(obj2, keys[i])) return false;\n\n    for (i = length; i-- !== 0; ) {\n        key = keys[i];\n        if (!_deepEquals((obj1 as Record<string, unknown>)[key], (obj2 as Record<string, unknown>)[key], visited)) return false;\n    }\n\n    return true;\n}\n\nexport default function deepEquals(obj1: unknown, obj2: unknown): boolean {\n    return _deepEquals(obj1, obj2);\n}\n", "export default function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\n    return typeof value === 'function' && 'call' in value && 'apply' in value;\n}\n", "import isEmpty from './isEmpty';\n\nexport default function isNotEmpty(value: any): boolean {\n    return !isEmpty(value);\n}\n", "import isFunction from './isFunction';\nimport isNotEmpty from './isNotEmpty';\n\nexport default function resolveFieldData(data: any, field: any): any {\n    if (!data || !field) {\n        // short circuit if there is nothing to resolve\n        return null;\n    }\n\n    try {\n        const value = data[field];\n\n        if (isNotEmpty(value)) return value;\n    } catch {\n        // Performance optimization: https://github.com/primefaces/primereact/issues/4797\n        // do nothing and continue to other methods to resolve field data\n    }\n\n    if (Object.keys(data).length) {\n        if (isFunction(field)) {\n            return field(data);\n        } else if (field.indexOf('.') === -1) {\n            return data[field];\n        } else {\n            const fields = field.split('.');\n            let value = data;\n\n            for (let i = 0, len = fields.length; i < len; ++i) {\n                if (value == null) {\n                    return null;\n                }\n\n                value = value[fields[i]];\n            }\n\n            return value;\n        }\n    }\n\n    return null;\n}\n", "import deepEquals from './deepEquals';\nimport resolveFieldData from './resolveFieldData';\n\nexport default function equals(obj1: any, obj2: any, field?: string): boolean {\n    if (field) return resolveFieldData(obj1, field) === resolveFieldData(obj2, field);\n    else return deepEquals(obj1, obj2);\n}\n", "import equals from './equals';\n\nexport default function contains<T = unknown>(value: T, list: T[]): boolean {\n    if (value != null && list && list.length) {\n        for (const val of list) {\n            if (equals(value, val)) return true;\n        }\n    }\n\n    return false;\n}\n", "export default function isObject(value: unknown, empty: boolean = true): value is object {\n    return value instanceof Object && value.constructor === Object && (empty || Object.keys(value).length !== 0);\n}\n", "import isObject from './isObject';\n\nfunction _deepMerge(target: Record<string, unknown> = {}, source: Record<string, unknown> = {}): Record<string, unknown> {\n    const mergedObj: Record<string, unknown> = { ...target };\n\n    Object.keys(source).forEach((key) => {\n        const typedKey = key as keyof typeof source;\n\n        if (isObject(source[typedKey]) && typedKey in target && isObject(target[typedKey])) {\n            mergedObj[typedKey] = _deepMerge(target[typedKey] as Record<string, unknown>, source[typedKey] as Record<string, unknown>);\n        } else {\n            mergedObj[typedKey] = source[typedKey];\n        }\n    });\n\n    return mergedObj;\n}\n\n/**\n * Merges multiple objects into one.\n * @param args - Objects to merge.\n * @returns Merged object.\n */\nexport default function deepMerge(...args: Record<string, unknown>[]): Record<string, unknown> {\n    return args.reduce((acc, obj, i) => (i === 0 ? obj : _deepMerge(acc, obj)), {});\n}\n", "import resolveFieldData from './resolveFieldData';\n\nexport default function filter<T = any>(value: T[], fields: string[], filterValue: string): T[] {\n    const filteredItems = [];\n\n    if (value) {\n        for (const item of value) {\n            for (const field of fields) {\n                if (String(resolveFieldData(item, field)).toLowerCase().indexOf(filterValue.toLowerCase()) > -1) {\n                    filteredItems.push(item);\n                    break;\n                }\n            }\n        }\n    }\n\n    return filteredItems;\n}\n", "export default function findIndexInList<T = any>(value: T, list: T[]): number {\n    let index = -1;\n\n    if (list) {\n        for (let i = 0; i < list.length; i++) {\n            if (list[i] === value) {\n                index = i;\n                break;\n            }\n        }\n    }\n\n    return index;\n}\n", "import isNotEmpty from './isNotEmpty';\n\n/**\n * Firefox-v103 does not currently support the \"findLast\" method. It is stated that this method will be supported with Firefox-v104.\n * https://caniuse.com/mdn-javascript_builtins_array_findlast\n */\nexport default function findLast<T = any>(arr: T[], callback: (value: T, index: number, array: T[]) => boolean): T | undefined {\n    let item;\n\n    if (isNotEmpty(arr)) {\n        try {\n            item = (arr as any).findLast(callback);\n        } catch {\n            item = [...arr].reverse().find(callback);\n        }\n    }\n\n    return item;\n}\n", "import isNotEmpty from './isNotEmpty';\n\n/**\n * Firefox-v103 does not currently support the \"findLastIndex\" method. It is stated that this method will be supported with Firefox-v104.\n * https://caniuse.com/mdn-javascript_builtins_array_findlastindex\n */\nexport default function findLastIndex<T = any>(arr: T[], callback: (value: T, index: number, array: T[]) => boolean): number {\n    let index = -1;\n\n    if (isNotEmpty(arr)) {\n        try {\n            index = (arr as any).findLastIndex(callback);\n        } catch {\n            index = arr.lastIndexOf([...arr].reverse().find(callback) as T);\n        }\n    }\n\n    return index;\n}\n", "import isFunction from './isFunction';\n\nexport default function resolve<T, P extends unknown[], R>(obj: T | ((...params: P) => R), ...params: P): T | R {\n    return isFunction(obj) ? (obj as (...params: P) => R)(...params) : (obj as T);\n}\n", "export default function isString(value: unknown, empty: boolean = true): value is string {\n    return typeof value === 'string' && (empty || value !== '');\n}\n", "import isString from './isString';\n\nexport default function toFlatCase(str: string): string {\n    // convert snake, kebab, camel and pascal cases to flat case\n    return isString(str) ? str.replace(/(-|_)/g, '').toLowerCase() : str;\n}\n", "import isObject from './isObject';\nimport resolve from './resolve';\nimport toFlatCase from './toFlatCase';\n\nexport default function getKeyValue<T extends Record<string, unknown>>(obj: T | undefined, key: string = '', params: unknown = {}): unknown {\n    const fKeys = toFlatCase(key).split('.');\n    const fKey = fKeys.shift();\n\n    if (fKey) {\n        if (isObject(obj)) {\n            const matchedKey = Object.keys(obj).find((k) => toFlatCase(k) === fKey) || '';\n\n            return getKeyValue(resolve(obj[matchedKey], params) as Record<string, unknown>, fKeys.join('.'), params);\n        }\n\n        return undefined;\n    }\n\n    return resolve(obj, params);\n}\n", "import findIndexInList from './findIndexInList';\n\nexport default function insertIntoOrderedArray<T>(item: T, index: number, arr: T[], sourceArr: any[]): void {\n    if (arr.length > 0) {\n        let injected = false;\n\n        for (let i = 0; i < arr.length; i++) {\n            const currentItemIndex = findIndexInList(arr[i], sourceArr);\n\n            if (currentItemIndex > index) {\n                arr.splice(i, 0, item);\n                injected = true;\n                break;\n            }\n        }\n\n        if (!injected) {\n            arr.push(item);\n        }\n    } else {\n        arr.push(item);\n    }\n}\n", "export default function isArray(value: any, empty: boolean = true): boolean {\n    return Array.isArray(value) && (empty || value.length !== 0);\n}\n", "export default function isDate(value: unknown): value is Date {\n    return value instanceof Date;\n}\n", "export default function isLetter(char: string): boolean {\n    return /^[a-zA-Z\\u00C0-\\u017F]$/.test(char);\n}\n", "import isNotEmpty from './isNotEmpty';\n\nexport default function isNumber(value: unknown): boolean {\n    return isNotEmpty(value) && !isNaN(value as number);\n}\n", "import isNotEmpty from './isNotEmpty';\n\nexport default function isPrintableCharacter(char: string = ''): boolean {\n    return isNotEmpty(char) && char.length === 1 && !!char.match(/\\S| /);\n}\n", "export default function isScalar(value: any): boolean {\n    return value != null && (typeof value === 'string' || typeof value === 'number' || typeof value === 'bigint' || typeof value === 'boolean');\n}\n", "export default function localeComparator(): (val1: string, val2: string) => number {\n    //performance gain using Int.Collator. It is not recommended to use localeCompare against large arrays.\n    return new Intl.Collator(undefined, { numeric: true }).compare;\n}\n", "export default function matchRegex(str: string, regex?: RegExp): boolean {\n    if (regex) {\n        const match = regex.test(str);\n\n        regex.lastIndex = 0;\n\n        return match;\n    }\n\n    return false;\n}\n", "import deepMerge from './deepMerge';\n\n/**\n * @deprecated Use `deepMerge` instead.\n *\n * Merges multiple objects into one.\n * @param args - Objects to merge.\n * @returns Merged object.\n */\nexport default function mergeKeys(...args: Record<string, unknown>[]): Record<string, unknown> {\n    return deepMerge(...args);\n}\n", "export default function minifyCSS(css?: string): string | undefined {\n    return css\n        ? css\n              .replace(/\\/\\*(?:(?!\\*\\/)[\\s\\S])*\\*\\/|[\\r\\n\\t]+/g, '')\n              .replace(/ {2,}/g, ' ')\n              .replace(/ ([{:}]) /g, '$1')\n              .replace(/([;,]) /g, '$1')\n              .replace(/ !/g, '!')\n              .replace(/: /g, ':')\n              .trim()\n        : css;\n}\n", "import isObject from './isObject';\n\nexport default function nestedKeys(obj: Record<string, any> = {}, parentKey: string = ''): string[] {\n    return Object.entries(obj).reduce<string[]>((o, [key, value]) => {\n        const currentKey = parentKey ? `${parentKey}.${key}` : key;\n\n        isObject(value) ? (o = o.concat(nestedKeys(value, currentKey))) : o.push(currentKey);\n\n        return o;\n    }, []);\n}\n", "import isObject from './isObject';\n\nexport default function omit(obj: unknown, ...keys: string[]): unknown {\n    if (!isObject(obj)) return obj;\n\n    const copy = { ...(obj as Record<string, unknown>) };\n\n    keys?.flat().forEach((key) => delete copy[key]);\n\n    return copy;\n}\n", "export default function removeAccents(str: string): string {\n    // Regular expression to check for any accented characters 'Latin-1 Supplement' and 'Latin Extended-A'\n    const accentCheckRegex = /[\\xC0-\\xFF\\u0100-\\u017E]/;\n\n    if (str && accentCheckRegex.test(str)) {\n        const accentsMap: { [key: string]: RegExp } = {\n            A: /[\\xC0-\\xC5\\u0100\\u0102\\u0104]/g,\n            AE: /[\\xC6]/g,\n            C: /[\\xC7\\u0106\\u0108\\u010A\\u010C]/g,\n            D: /[\\xD0\\u010E\\u0110]/g,\n            E: /[\\xC8-\\xCB\\u0112\\u0114\\u0116\\u0118\\u011A]/g,\n            G: /[\\u011C\\u011E\\u0120\\u0122]/g,\n            H: /[\\u0124\\u0126]/g,\n            I: /[\\xCC-\\xCF\\u0128\\u012A\\u012C\\u012E\\u0130]/g,\n            IJ: /[\\u0132]/g,\n            J: /[\\u0134]/g,\n            K: /[\\u0136]/g,\n            L: /[\\u0139\\u013B\\u013D\\u013F\\u0141]/g,\n            N: /[\\xD1\\u0143\\u0145\\u0147\\u014A]/g,\n            O: /[\\xD2-\\xD6\\xD8\\u014C\\u014E\\u0150]/g,\n            OE: /[\\u0152]/g,\n            R: /[\\u0154\\u0156\\u0158]/g,\n            S: /[\\u015A\\u015C\\u015E\\u0160]/g,\n            T: /[\\u0162\\u0164\\u0166]/g,\n            U: /[\\xD9-\\xDC\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172]/g,\n            W: /[\\u0174]/g,\n            Y: /[\\xDD\\u0176\\u0178]/g,\n            Z: /[\\u0179\\u017B\\u017D]/g,\n\n            a: /[\\xE0-\\xE5\\u0101\\u0103\\u0105]/g,\n            ae: /[\\xE6]/g,\n            c: /[\\xE7\\u0107\\u0109\\u010B\\u010D]/g,\n            d: /[\\u010F\\u0111]/g,\n            e: /[\\xE8-\\xEB\\u0113\\u0115\\u0117\\u0119\\u011B]/g,\n            g: /[\\u011D\\u011F\\u0121\\u0123]/g,\n            i: /[\\xEC-\\xEF\\u0129\\u012B\\u012D\\u012F\\u0131]/g,\n            ij: /[\\u0133]/g,\n            j: /[\\u0135]/g,\n            k: /[\\u0137,\\u0138]/g,\n            l: /[\\u013A\\u013C\\u013E\\u0140\\u0142]/g,\n            n: /[\\xF1\\u0144\\u0146\\u0148\\u014B]/g,\n            p: /[\\xFE]/g,\n            o: /[\\xF2-\\xF6\\xF8\\u014D\\u014F\\u0151]/g,\n            oe: /[\\u0153]/g,\n            r: /[\\u0155\\u0157\\u0159]/g,\n            s: /[\\u015B\\u015D\\u015F\\u0161]/g,\n            t: /[\\u0163\\u0165\\u0167]/g,\n            u: /[\\xF9-\\xFC\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173]/g,\n            w: /[\\u0175]/g,\n            y: /[\\xFD\\xFF\\u0177]/g,\n            z: /[\\u017A\\u017C\\u017E]/g\n        };\n\n        for (const key in accentsMap) {\n            str = str.replace(accentsMap[key], key);\n        }\n    }\n\n    return str;\n}\n", "export default function reorderArray<T>(value: T[], from: number, to: number): void {\n    if (value && from !== to) {\n        if (to >= value.length) {\n            to %= value.length;\n            from %= value.length;\n        }\n\n        value.splice(to, 0, value.splice(from, 1)[0]);\n    }\n}\n", "import compare from './compare';\nimport isEmpty from './isEmpty';\n\nexport default function sort<T>(value1: T, value2: T, order: number = 1, comparator: (val1: T, val2: T) => number, nullSortOrder: number = 1): number {\n    const result = compare(value1, value2, comparator, order);\n    let finalSortOrder = order;\n\n    // nullSortOrder == 1 means Excel like sort nulls at bottom\n    if (isEmpty(value1) || isEmpty(value2)) {\n        finalSortOrder = nullSortOrder === 1 ? order : nullSortOrder;\n    }\n\n    return finalSortOrder * result;\n}\n", "import isArray from './isArray';\nimport isDate from './isDate';\nimport isFunction from './isFunction';\nimport isObject from './isObject';\n\nexport default function stringify(value: unknown, indent: number = 2, currentIndent: number = 0): string {\n    const currentIndentStr = ' '.repeat(currentIndent);\n    const nextIndentStr = ' '.repeat(currentIndent + indent);\n\n    if (isArray(value)) {\n        return '[' + (value as unknown[]).map((v: unknown) => stringify(v, indent, currentIndent + indent)).join(', ') + ']';\n    } else if (isDate(value)) {\n        return value.toISOString();\n    } else if (isFunction(value)) {\n        return value.toString();\n    } else if (isObject(value)) {\n        return (\n            '{\\n' +\n            Object.entries(value)\n                .map(([k, v]) => `${nextIndentStr}${k}: ${stringify(v, indent, currentIndent + indent)}`)\n                .join(',\\n') +\n            `\\n${currentIndentStr}` +\n            '}'\n        );\n    } else {\n        return JSON.stringify(value);\n    }\n}\n", "import isString from './isString';\n\nexport default function toCapitalCase(str: string): string {\n    return isString(str, false) ? str[0].toUpperCase() + str.slice(1) : str;\n}\n", "import isString from './isString';\n\nexport default function toKebabCase(str: string): string {\n    // convert snake, camel and pascal cases to kebab case\n    return isString(str)\n        ? str\n              .replace(/(_)/g, '-')\n              .replace(/[A-Z]/g, (c, i) => (i === 0 ? c : '-' + c.toLowerCase()))\n              .toLowerCase()\n        : str;\n}\n", "export default function toMs(value: string | number): number {\n    if (value === 'auto') return 0;\n\n    if (typeof value === 'number') return value;\n\n    return Number(value.replace(/[^\\d.]/g, '').replace(',', '.')) * 1000;\n}\n", "import isString from './isString';\n\nexport default function toTokenKey(str: string): string {\n    return isString(str) ? str.replace(/[A-Z]/g, (c, i) => (i === 0 ? c : '.' + c.toLowerCase())).toLowerCase() : str;\n}\n", "import resolve from './resolve';\n\ntype ReactRef = { current: unknown };\ntype VueRef = { value: unknown };\n\nexport default function toValue(value: unknown): unknown {\n    if (value && typeof value === 'object') {\n        if (Object.hasOwn(value, 'current')) {\n            // For React\n            return (value as ReactRef).current;\n        } else if (Object.hasOwn(value, 'value')) {\n            // For Vue\n            return (value as VueRef).value;\n        }\n    }\n\n    // For Angular signals and functions usage\n    return resolve(value);\n}\n", "export interface ZIndexOptions {\n    get(element?: HTMLElement): number;\n    set(key: string, element: HTMLElement, baseZIndex?: number): void;\n    clear(element: HTMLElement): void;\n    getCurrent(key: string): number;\n}\n\nfunction handler(): ZIndexOptions {\n    let zIndexes: { key: string; value: number }[] = [];\n\n    const generateZIndex = (key: string, autoZIndex: boolean, baseZIndex: number = 999) => {\n        const lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);\n        const newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;\n\n        zIndexes.push({ key, value: newZIndex });\n\n        return newZIndex;\n    };\n\n    const revertZIndex = (zIndex: number) => {\n        zIndexes = zIndexes.filter((obj) => obj.value !== zIndex);\n    };\n\n    const getCurrentZIndex = (key: string, autoZIndex: boolean) => {\n        return getLastZIndex(key, autoZIndex).value;\n    };\n\n    const getLastZIndex = (key: string, autoZIndex: boolean, baseZIndex: number = 0) => {\n        return [...zIndexes].reverse().find((obj) => (autoZIndex ? true : obj.key === key)) || { key, value: baseZIndex };\n    };\n\n    const getZIndex = (element?: HTMLElement): number => {\n        return element ? parseInt(element.style.zIndex, 10) || 0 : 0;\n    };\n\n    return {\n        get: getZIndex,\n        set: (key: string, element?: HTMLElement, baseZIndex?: number) => {\n            if (element) {\n                element.style.zIndex = String(generateZIndex(key, true, baseZIndex));\n            }\n        },\n        clear: (element?: HTMLElement) => {\n            if (element) {\n                revertZIndex(getZIndex(element));\n                element.style.zIndex = '';\n            }\n        },\n        getCurrent: (key: string) => getCurrentZIndex(key, true)\n    };\n}\n\nexport const ZIndex: ZIndexOptions = handler();\n"],
  "mappings": "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",
  "names": ["cn", "args", "classes", "i", "className", "type", "_classes", "key", "value", "c", "hasClass", "element", "className", "addClass", "fn", "_className", "_classNames", "calculateBodyScrollbarWidth", "blockBodyScroll", "option", "removeClass", "element", "className", "fn", "_className", "_classNames", "unblockBodyScroll", "option", "getCSSVariableByRegex", "variableRegex", "sheet", "rule", "property", "e", "getHiddenElementDimensions", "dimensions", "visibility", "display", "getViewport", "win", "d", "g", "w", "h", "getScrollLeft", "getWindowScrollLeft", "doc", "getWindowScrollTop", "isRTL", "absolutePosition", "target", "gutter", "_a", "_b", "_c", "_d", "elementDimensions", "elementOuterHeight", "elementOuterWidth", "targetOuterHeight", "targetOuterWidth", "targetOffset", "windowScrollTop", "windowScrollLeft", "viewport", "top", "left", "origin", "addStyle", "style", "key", "value", "getOuterWidth", "margin", "width", "relativePosition", "fixedOrigin", "targetHeight", "gutterValue", "getParentNode", "element", "parent", "isElement", "element", "setAttributes", "element", "attributes", "isElement", "computedStyles", "rule", "value", "_a", "_b", "styles", "cv", "v", "type", "_cv", "_k", "_v", "c", "key", "matchedEvent", "createElement", "children", "find", "element", "selector", "isElement", "findSingle", "focus", "options", "getAttribute", "name", "value", "getFocusableElements", "element", "selector", "focusableElements", "find", "visibleFocusableElements", "focusableElement", "getFirstFocusableElement", "getHeight", "height", "style", "getIndex", "element", "_a", "children", "getParentNode", "num", "i", "getLastFocusableElement", "element", "selector", "focusableElements", "getFocusableElements", "getOffset", "element", "rect", "getScrollLeft", "getOuterHeight", "margin", "height", "style", "getWidth", "element", "width", "style", "isAndroid", "isClient", "isFocusableElement", "element", "selector", "isElement", "isVisible", "isTouchDevice", "setAttribute", "element", "attribute", "value", "isElement", "isEmpty", "value", "_deepEquals", "obj1", "obj2", "visited", "arrObj1", "arrObj2", "i", "length", "key", "dateObj1", "dateObj2", "regexpObj1", "regexpObj2", "keys", "deepEquals", "isFunction", "value", "isNotEmpty", "isEmpty", "resolveFieldData", "data", "field", "e", "fields", "len", "equals", "contains", "list", "val", "isObject", "empty", "findLastIndex", "arr", "callback", "index", "isNotEmpty", "e", "resolve", "obj", "params", "isFunction", "isString", "value", "empty", "isNumber", "value", "isNotEmpty", "isPrintableCharacter", "char", "localeComparator", "matchRegex", "str", "regex", "match", "minifyCSS", "css", "toKebabCase", "str", "isString", "c", "i", "handler", "zIndexes", "generateZIndex", "key", "autoZIndex", "baseZIndex", "lastZIndex", "getLastZIndex", "newZIndex", "revertZIndex", "zIndex", "obj", "getCurrentZIndex", "getZIndex", "element", "ZIndex"]
}
