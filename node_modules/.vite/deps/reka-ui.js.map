{
  "version": 3,
  "sources": ["../../reka-ui/src/shared/renderSlotFragments.ts", "../../reka-ui/src/Primitive/Slot.ts", "../../reka-ui/src/Primitive/Primitive.ts", "../../reka-ui/dist/VisuallyHidden/VisuallyHidden.js", "../../reka-ui/node_modules/@vueuse/shared/index.mjs", "../../reka-ui/node_modules/@vueuse/core/index.mjs", "../../reka-ui/src/shared/createContext.ts", "../../ohash/dist/shared/ohash.D__AXeF1.mjs", "../../reka-ui/src/shared/nullish.ts", "../../reka-ui/src/shared/isValueEqualOrExist.ts", "../../reka-ui/src/shared/useSingleOrMultipleValue.ts", "../../reka-ui/src/ConfigProvider/ConfigProvider.vue", "../../reka-ui/src/shared/useDirection.ts", "../../reka-ui/src/shared/useForwardExpose.ts", "../../reka-ui/src/Accordion/AccordionRoot.vue", "../../reka-ui/src/Collapsible/CollapsibleRoot.vue", "../../reka-ui/src/shared/useArrowNavigation.ts", "../../reka-ui/src/Accordion/AccordionItem.vue", "../../reka-ui/src/shared/useId.ts", "../../reka-ui/src/shared/useStateMachine.ts", "../../reka-ui/src/Presence/usePresence.ts", "../../reka-ui/src/Presence/Presence.ts", "../../reka-ui/src/Collapsible/CollapsibleContent.vue", "../../reka-ui/src/Accordion/AccordionContent.vue", "../../reka-ui/src/Accordion/AccordionHeader.vue", "../../reka-ui/src/Collapsible/CollapsibleTrigger.vue", "../../reka-ui/src/Accordion/AccordionTrigger.vue", "../../reka-ui/src/Dialog/DialogRoot.vue", "../../reka-ui/src/Dialog/DialogClose.vue", "../../reka-ui/src/AlertDialog/AlertDialogAction.vue", "../../reka-ui/src/shared/useEmitAsProps.ts", "../../reka-ui/src/shared/getActiveElement.ts", "../../reka-ui/src/Menu/utils.ts", "../../reka-ui/src/Dialog/utils.ts", "../../reka-ui/src/FocusScope/stack.ts", "../../reka-ui/src/FocusScope/utils.ts", "../../reka-ui/src/FocusScope/FocusScope.vue", "../../reka-ui/src/shared/handleAndDispatchCustomEvent.ts", "../../reka-ui/src/DismissableLayer/utils.ts", "../../reka-ui/src/DismissableLayer/DismissableLayer.vue", "../../reka-ui/src/Dialog/DialogContentImpl.vue", "../../aria-hidden/dist/es2015/index.js", "../../reka-ui/src/shared/useHideOthers.ts", "../../reka-ui/src/Dialog/DialogContentModal.vue", "../../reka-ui/src/Dialog/DialogContentNonModal.vue", "../../reka-ui/src/Dialog/DialogContent.vue", "../../reka-ui/src/AlertDialog/AlertDialogContent.vue", "../../reka-ui/src/AlertDialog/AlertDialogCancel.vue", "../../reka-ui/src/Dialog/DialogDescription.vue", "../../reka-ui/src/AlertDialog/AlertDialogDescription.vue", "../../defu/dist/defu.mjs", "../../reka-ui/src/shared/useBodyScrollLock.ts", "../../reka-ui/src/Dialog/DialogOverlayImpl.vue", "../../reka-ui/src/Dialog/DialogOverlay.vue", "../../reka-ui/src/AlertDialog/AlertDialogOverlay.vue", "../../reka-ui/src/Teleport/Teleport.vue", "../../reka-ui/src/AlertDialog/AlertDialogPortal.vue", "../../reka-ui/src/shared/useForwardProps.ts", "../../reka-ui/src/shared/useForwardPropsEmits.ts", "../../reka-ui/src/AlertDialog/AlertDialogRoot.vue", "../../reka-ui/src/Dialog/DialogTitle.vue", "../../reka-ui/src/AlertDialog/AlertDialogTitle.vue", "../../reka-ui/src/Dialog/DialogTrigger.vue", "../../reka-ui/src/AlertDialog/AlertDialogTrigger.vue", "../../reka-ui/src/AspectRatio/AspectRatio.vue", "../../reka-ui/src/Avatar/AvatarRoot.vue", "../../reka-ui/src/Avatar/AvatarFallback.vue", "../../reka-ui/src/Avatar/utils.ts", "../../reka-ui/src/Avatar/AvatarImage.vue", "../../reka-ui/src/shared/date/comparators.ts", "../../reka-ui/src/date/comparators.ts", "../../reka-ui/src/date/utils.ts", "../../reka-ui/src/shared/date/utils.ts", "../../reka-ui/src/date/calendar.ts", "../../reka-ui/src/shared/useDateFormatter.ts", "../../reka-ui/src/Calendar/useCalendar.ts", "../../reka-ui/src/Primitive/usePrimitiveElement.ts", "../../reka-ui/src/shared/useLocale.ts", "../../reka-ui/src/Calendar/CalendarRoot.vue", "../../reka-ui/src/Calendar/CalendarCell.vue", "../../reka-ui/src/Calendar/utils.ts", "../../reka-ui/src/shared/useKbd.ts", "../../reka-ui/src/Calendar/CalendarCellTrigger.vue", "../../reka-ui/src/Calendar/CalendarGrid.vue", "../../reka-ui/src/Calendar/CalendarGridBody.vue", "../../reka-ui/src/Calendar/CalendarGridHead.vue", "../../reka-ui/src/Calendar/CalendarGridRow.vue", "../../reka-ui/src/Calendar/CalendarHeadCell.vue", "../../reka-ui/src/Calendar/CalendarHeader.vue", "../../reka-ui/src/Calendar/CalendarHeading.vue", "../../reka-ui/src/Calendar/CalendarNext.vue", "../../reka-ui/src/Calendar/CalendarPrev.vue", "../../reka-ui/src/shared/useFormControl.ts", "../../reka-ui/src/Collection/Collection.ts", "../../reka-ui/src/RovingFocus/utils.ts", "../../reka-ui/src/RovingFocus/RovingFocusGroup.vue", "../../reka-ui/src/VisuallyHidden/VisuallyHiddenInputBubble.vue", "../../reka-ui/src/VisuallyHidden/VisuallyHiddenInput.vue", "../../reka-ui/src/Checkbox/CheckboxGroupRoot.vue", "../../reka-ui/src/Checkbox/utils.ts", "../../reka-ui/src/RovingFocus/RovingFocusItem.vue", "../../reka-ui/src/Checkbox/CheckboxRoot.vue", "../../reka-ui/src/Checkbox/CheckboxIndicator.vue", "../../reka-ui/src/Popper/PopperRoot.vue", "../../reka-ui/src/Popper/PopperAnchor.vue", "../../reka-ui/src/Combobox/ComboboxAnchor.vue", "../../reka-ui/src/shared/component/Arrow.vue", "../../reka-ui/src/Popper/utils.ts", "../../reka-ui/src/shared/useSize.ts", "../../reka-ui/src/Popper/PopperContent.vue", "../../reka-ui/src/Popper/PopperArrow.vue", "../../reka-ui/src/shared/useFilter.ts", "../../reka-ui/src/Listbox/utils.ts", "../../reka-ui/src/shared/useTypeahead.ts", "../../reka-ui/src/shared/arrays.ts", "../../reka-ui/src/Listbox/ListboxRoot.vue", "../../reka-ui/src/Combobox/ComboboxRoot.vue", "../../reka-ui/src/Listbox/ListboxContent.vue", "../../reka-ui/src/Combobox/ComboboxContentImpl.vue", "../../reka-ui/src/Combobox/ComboboxArrow.vue", "../../reka-ui/src/Combobox/ComboboxCancel.vue", "../../reka-ui/src/Combobox/ComboboxContent.vue", "../../reka-ui/src/Combobox/ComboboxEmpty.vue", "../../reka-ui/src/Listbox/ListboxGroup.vue", "../../reka-ui/src/Combobox/ComboboxGroup.vue", "../../reka-ui/src/Listbox/ListboxFilter.vue", "../../reka-ui/src/Combobox/ComboboxInput.vue", "../../reka-ui/src/Listbox/ListboxItem.vue", "../../reka-ui/src/Combobox/ComboboxItem.vue", "../../reka-ui/src/Listbox/ListboxItemIndicator.vue", "../../reka-ui/src/Combobox/ComboboxItemIndicator.vue", "../../reka-ui/src/Combobox/ComboboxLabel.vue", "../../reka-ui/src/Combobox/ComboboxPortal.vue", "../../reka-ui/src/Combobox/ComboboxSeparator.vue", "../../reka-ui/src/Combobox/ComboboxTrigger.vue", "../../reka-ui/src/shared/useNonce.ts", "../../reka-ui/src/Combobox/ComboboxViewport.vue", "../../@tanstack/virtual-core/src/utils.ts", "../../@tanstack/virtual-core/src/index.ts", "../../@tanstack/vue-virtual/src/index.ts", "../../reka-ui/src/Listbox/ListboxVirtualizer.vue", "../../reka-ui/src/Combobox/ComboboxVirtualizer.vue", "../../reka-ui/src/Menu/MenuArrow.vue", "../../reka-ui/src/ContextMenu/ContextMenuArrow.vue", "../../reka-ui/src/shared/useIsUsingKeyboard.ts", "../../reka-ui/src/Menu/MenuRoot.vue", "../../reka-ui/src/shared/useFocusGuards.ts", "../../reka-ui/src/Menu/MenuContentImpl.vue", "../../reka-ui/src/Menu/MenuItemImpl.vue", "../../reka-ui/src/Menu/MenuItem.vue", "../../reka-ui/src/Menu/MenuItemIndicator.vue", "../../reka-ui/src/Menu/MenuCheckboxItem.vue", "../../reka-ui/src/ContextMenu/ContextMenuCheckboxItem.vue", "../../reka-ui/src/Menu/MenuRootContentModal.vue", "../../reka-ui/src/Menu/MenuRootContentNonModal.vue", "../../reka-ui/src/Menu/MenuContent.vue", "../../reka-ui/src/ContextMenu/ContextMenuRoot.vue", "../../reka-ui/src/ContextMenu/ContextMenuContent.vue", "../../reka-ui/src/Menu/MenuGroup.vue", "../../reka-ui/src/ContextMenu/ContextMenuGroup.vue", "../../reka-ui/src/ContextMenu/ContextMenuItem.vue", "../../reka-ui/src/ContextMenu/ContextMenuItemIndicator.vue", "../../reka-ui/src/Menu/MenuLabel.vue", "../../reka-ui/src/ContextMenu/ContextMenuLabel.vue", "../../reka-ui/src/Menu/MenuPortal.vue", "../../reka-ui/src/ContextMenu/ContextMenuPortal.vue", "../../reka-ui/src/Menu/MenuRadioGroup.vue", "../../reka-ui/src/ContextMenu/ContextMenuRadioGroup.vue", "../../reka-ui/src/Menu/MenuRadioItem.vue", "../../reka-ui/src/ContextMenu/ContextMenuRadioItem.vue", "../../reka-ui/src/Menu/MenuSeparator.vue", "../../reka-ui/src/ContextMenu/ContextMenuSeparator.vue", "../../reka-ui/src/Menu/MenuSub.vue", "../../reka-ui/src/ContextMenu/ContextMenuSub.vue", "../../reka-ui/src/Menu/MenuSubContent.vue", "../../reka-ui/src/ContextMenu/ContextMenuSubContent.vue", "../../reka-ui/src/Menu/MenuAnchor.vue", "../../reka-ui/src/Menu/MenuSubTrigger.vue", "../../reka-ui/src/ContextMenu/ContextMenuSubTrigger.vue", "../../reka-ui/src/ContextMenu/utils.ts", "../../reka-ui/src/ContextMenu/ContextMenuTrigger.vue", "../../reka-ui/src/shared/date/segment.ts", "../../reka-ui/src/shared/date/useDateField.ts", "../../reka-ui/src/shared/date/parts.ts", "../../reka-ui/src/shared/date/placeholders.ts", "../../reka-ui/src/shared/date/parser.ts", "../../reka-ui/src/DateField/DateFieldRoot.vue", "../../reka-ui/src/DateField/DateFieldInput.vue", "../../reka-ui/src/Popover/PopoverRoot.vue", "../../reka-ui/src/Popover/PopoverAnchor.vue", "../../reka-ui/src/Popover/PopoverArrow.vue", "../../reka-ui/src/DatePicker/DatePickerArrow.vue", "../../reka-ui/src/DatePicker/DatePickerRoot.vue", "../../reka-ui/src/DatePicker/DatePickerCalendar.vue", "../../reka-ui/src/DatePicker/DatePickerCell.vue", "../../reka-ui/src/DatePicker/DatePickerCellTrigger.vue", "../../reka-ui/src/Popover/PopoverClose.vue", "../../reka-ui/src/DatePicker/DatePickerClose.vue", "../../reka-ui/src/Popover/PopoverPortal.vue", "../../reka-ui/src/Popover/PopoverContentImpl.vue", "../../reka-ui/src/Popover/PopoverContentModal.vue", "../../reka-ui/src/Popover/PopoverContentNonModal.vue", "../../reka-ui/src/Popover/PopoverContent.vue", "../../reka-ui/src/DatePicker/DatePickerContent.vue", "../../reka-ui/src/DatePicker/DatePickerField.vue", "../../reka-ui/src/DatePicker/DatePickerGrid.vue", "../../reka-ui/src/DatePicker/DatePickerGridBody.vue", "../../reka-ui/src/DatePicker/DatePickerGridHead.vue", "../../reka-ui/src/DatePicker/DatePickerGridRow.vue", "../../reka-ui/src/DatePicker/DatePickerHeadCell.vue", "../../reka-ui/src/DatePicker/DatePickerHeader.vue", "../../reka-ui/src/DatePicker/DatePickerHeading.vue", "../../reka-ui/src/DatePicker/DatePickerInput.vue", "../../reka-ui/src/DatePicker/DatePickerNext.vue", "../../reka-ui/src/DatePicker/DatePickerPrev.vue", "../../reka-ui/src/Popover/PopoverTrigger.vue", "../../reka-ui/src/DatePicker/DatePickerTrigger.vue", "../../reka-ui/src/DateRangeField/DateRangeFieldRoot.vue", "../../reka-ui/src/DateRangeField/DateRangeFieldInput.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerAnchor.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerArrow.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerRoot.vue", "../../reka-ui/src/RangeCalendar/useRangeCalendar.ts", "../../reka-ui/src/RangeCalendar/RangeCalendarRoot.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerCalendar.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarCell.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerCell.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarCellTrigger.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerCellTrigger.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerClose.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerContent.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerField.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarGrid.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerGrid.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarGridBody.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerGridBody.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarGridHead.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerGridHead.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarGridRow.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerGridRow.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarHeadCell.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerHeadCell.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarHeader.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerHeader.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarHeading.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerHeading.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerInput.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarNext.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerNext.vue", "../../reka-ui/src/RangeCalendar/RangeCalendarPrev.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerPrev.vue", "../../reka-ui/src/DateRangePicker/DateRangePickerTrigger.vue", "../../reka-ui/src/Dialog/DialogPortal.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuArrow.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuCheckboxItem.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuRoot.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuContent.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuGroup.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuItem.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuItemIndicator.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuLabel.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuPortal.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuRadioGroup.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuRadioItem.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuSeparator.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuSub.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuSubContent.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuSubTrigger.vue", "../../reka-ui/src/DropdownMenu/DropdownMenuTrigger.vue", "../../reka-ui/src/Editable/EditableRoot.vue", "../../reka-ui/src/Editable/EditableArea.vue", "../../reka-ui/src/Editable/EditableCancelTrigger.vue", "../../reka-ui/src/Editable/EditableEditTrigger.vue", "../../reka-ui/src/Editable/EditableInput.vue", "../../reka-ui/src/Editable/EditablePreview.vue", "../../reka-ui/src/Editable/EditableSubmitTrigger.vue", "../../reka-ui/src/HoverCard/HoverCardArrow.vue", "../../reka-ui/src/HoverCard/utils.ts", "../../reka-ui/src/HoverCard/HoverCardRoot.vue", "../../reka-ui/src/shared/useGraceArea.ts", "../../reka-ui/src/HoverCard/HoverCardContentImpl.vue", "../../reka-ui/src/HoverCard/HoverCardContent.vue", "../../reka-ui/src/HoverCard/HoverCardPortal.vue", "../../reka-ui/src/HoverCard/HoverCardTrigger.vue", "../../reka-ui/src/Label/Label.vue", "../../reka-ui/src/Listbox/ListboxGroupLabel.vue", "../../reka-ui/src/Menubar/MenubarArrow.vue", "../../reka-ui/src/Menubar/MenubarCheckboxItem.vue", "../../reka-ui/src/Menubar/MenubarRoot.vue", "../../reka-ui/src/Menubar/MenubarMenu.vue", "../../reka-ui/src/Menubar/MenubarContent.vue", "../../reka-ui/src/Menubar/MenubarGroup.vue", "../../reka-ui/src/Menubar/MenubarItem.vue", "../../reka-ui/src/Menubar/MenubarItemIndicator.vue", "../../reka-ui/src/Menubar/MenubarLabel.vue", "../../reka-ui/src/Menubar/MenubarPortal.vue", "../../reka-ui/src/Menubar/MenubarRadioGroup.vue", "../../reka-ui/src/Menubar/MenubarRadioItem.vue", "../../reka-ui/src/Menubar/MenubarSeparator.vue", "../../reka-ui/src/Menubar/MenubarSub.vue", "../../reka-ui/src/Menubar/MenubarSubContent.vue", "../../reka-ui/src/Menubar/MenubarSubTrigger.vue", "../../reka-ui/src/Menubar/MenubarTrigger.vue", "../../reka-ui/src/NavigationMenu/utils.ts", "../../reka-ui/src/NavigationMenu/NavigationMenuRoot.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuItem.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuContentImpl.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuContent.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuIndicator.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuLink.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuList.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuSub.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuTrigger.vue", "../../reka-ui/src/NavigationMenu/NavigationMenuViewport.vue", "../../reka-ui/src/NumberField/utils.ts", "../../reka-ui/src/shared/clamp.ts", "../../reka-ui/src/NumberField/NumberFieldRoot.vue", "../../reka-ui/src/NumberField/NumberFieldDecrement.vue", "../../reka-ui/src/NumberField/NumberFieldIncrement.vue", "../../reka-ui/src/NumberField/NumberFieldInput.vue", "../../reka-ui/src/Pagination/PaginationEllipsis.vue", "../../reka-ui/src/Pagination/PaginationRoot.vue", "../../reka-ui/src/Pagination/PaginationFirst.vue", "../../reka-ui/src/Pagination/PaginationLast.vue", "../../reka-ui/src/Pagination/utils.ts", "../../reka-ui/src/Pagination/PaginationList.vue", "../../reka-ui/src/Pagination/PaginationListItem.vue", "../../reka-ui/src/Pagination/PaginationNext.vue", "../../reka-ui/src/Pagination/PaginationPrev.vue", "../../reka-ui/src/PinInput/PinInputRoot.vue", "../../reka-ui/src/PinInput/PinInputInput.vue", "../../reka-ui/src/Progress/ProgressRoot.vue", "../../reka-ui/src/Progress/ProgressIndicator.vue", "../../reka-ui/src/RadioGroup/utils.ts", "../../reka-ui/src/RadioGroup/Radio.vue", "../../reka-ui/src/RadioGroup/RadioGroupRoot.vue", "../../reka-ui/src/RadioGroup/RadioGroupItem.vue", "../../reka-ui/src/RadioGroup/RadioGroupIndicator.vue", "../../reka-ui/src/ScrollArea/ScrollAreaRoot.vue", "../../reka-ui/src/ScrollArea/ScrollAreaCornerImpl.vue", "../../reka-ui/src/ScrollArea/ScrollAreaCorner.vue", "../../reka-ui/src/ScrollArea/utils.ts", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarImpl.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarX.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarY.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarVisible.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarAuto.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarHover.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbarScroll.vue", "../../reka-ui/src/ScrollArea/ScrollAreaScrollbar.vue", "../../reka-ui/src/ScrollArea/ScrollAreaThumb.vue", "../../reka-ui/src/ScrollArea/ScrollAreaViewport.vue", "../../reka-ui/src/Select/utils.ts", "../../reka-ui/src/Select/BubbleSelect.vue", "../../reka-ui/src/Select/SelectRoot.vue", "../../reka-ui/src/Select/SelectItemAlignedPosition.vue", "../../reka-ui/src/Select/SelectPopperPosition.vue", "../../reka-ui/src/Select/SelectContentImpl.vue", "../../reka-ui/src/Select/SelectArrow.vue", "../../reka-ui/src/Select/SelectProvider.vue", "../../reka-ui/src/Select/SelectContent.vue", "../../reka-ui/src/Select/SelectGroup.vue", "../../reka-ui/dist/Select/SelectIcon.js", "../../reka-ui/src/Select/SelectItem.vue", "../../reka-ui/src/Select/SelectItemIndicator.vue", "../../reka-ui/src/Select/SelectItemText.vue", "../../reka-ui/src/Select/SelectLabel.vue", "../../reka-ui/src/Select/SelectPortal.vue", "../../reka-ui/src/Select/SelectScrollButtonImpl.vue", "../../reka-ui/src/Select/SelectScrollDownButton.vue", "../../reka-ui/src/Select/SelectScrollUpButton.vue", "../../reka-ui/src/Select/SelectSeparator.vue", "../../reka-ui/src/Select/SelectTrigger.vue", "../../reka-ui/src/Select/SelectValue.vue", "../../reka-ui/src/Select/SelectViewport.vue", "../../reka-ui/src/shared/component/BaseSeparator.vue", "../../reka-ui/src/Separator/Separator.vue", "../../reka-ui/src/Slider/utils.ts", "../../reka-ui/src/Slider/SliderImpl.vue", "../../reka-ui/src/Slider/SliderHorizontal.vue", "../../reka-ui/src/Slider/SliderVertical.vue", "../../reka-ui/src/Slider/SliderRoot.vue", "../../reka-ui/src/Slider/SliderRange.vue", "../../reka-ui/src/Slider/SliderThumbImpl.vue", "../../reka-ui/src/Slider/SliderThumb.vue", "../../reka-ui/src/Slider/SliderTrack.vue", "../../reka-ui/src/Splitter/utils/assert.ts", "../../reka-ui/src/shared/browser.ts", "../../reka-ui/src/Splitter/utils/dom.ts", "../../reka-ui/src/Splitter/utils/events.ts", "../../reka-ui/src/Splitter/utils/calculate.ts", "../../reka-ui/src/Splitter/utils/callPanelCallbacks.ts", "../../reka-ui/src/Splitter/utils/debounce.ts", "../../reka-ui/src/Splitter/utils/constants.ts", "../../reka-ui/src/Splitter/utils/compare.ts", "../../reka-ui/src/Splitter/utils/resizePanel.ts", "../../reka-ui/src/Splitter/utils/layout.ts", "../../reka-ui/src/Splitter/utils/pivot.ts", "../../reka-ui/src/Splitter/utils/rects.ts", "../../reka-ui/src/Splitter/utils/stackingOrder.ts", "../../reka-ui/src/Splitter/utils/style.ts", "../../reka-ui/src/Splitter/utils/registry.ts", "../../reka-ui/src/Splitter/utils/validation.ts", "../../reka-ui/src/Splitter/utils/composables/useWindowSplitterPanelGroupBehavior.ts", "../../reka-ui/src/Splitter/utils/storage.ts", "../../reka-ui/src/Splitter/SplitterGroup.vue", "../../reka-ui/src/Splitter/SplitterPanel.vue", "../../reka-ui/src/Splitter/utils/composables/useWindowSplitterBehavior.ts", "../../reka-ui/src/Splitter/SplitterResizeHandle.vue", "../../reka-ui/src/Stepper/StepperRoot.vue", "../../reka-ui/src/Stepper/StepperItem.vue", "../../reka-ui/src/Stepper/StepperDescription.vue", "../../reka-ui/src/Stepper/StepperIndicator.vue", "../../reka-ui/src/Stepper/StepperSeparator.vue", "../../reka-ui/src/Stepper/StepperTitle.vue", "../../reka-ui/src/Stepper/StepperTrigger.vue", "../../reka-ui/src/Switch/SwitchRoot.vue", "../../reka-ui/src/Switch/SwitchThumb.vue", "../../reka-ui/src/Tabs/utils.ts", "../../reka-ui/src/Tabs/TabsRoot.vue", "../../reka-ui/src/Tabs/TabsContent.vue", "../../reka-ui/src/Tabs/TabsIndicator.vue", "../../reka-ui/src/Tabs/TabsList.vue", "../../reka-ui/src/Tabs/TabsTrigger.vue", "../../reka-ui/src/TagsInput/TagsInputRoot.vue", "../../reka-ui/src/TagsInput/TagsInputClear.vue", "../../reka-ui/src/TagsInput/TagsInputInput.vue", "../../reka-ui/src/TagsInput/TagsInputItem.vue", "../../reka-ui/src/TagsInput/TagsInputItemDelete.vue", "../../reka-ui/src/TagsInput/TagsInputItemText.vue", "../../reka-ui/src/TimeField/TimeFieldRoot.vue", "../../reka-ui/src/TimeField/TimeFieldInput.vue", "../../reka-ui/dist/Toast/ToastAnnounceExclude.js", "../../reka-ui/src/Toast/ToastProvider.vue", "../../reka-ui/src/Toast/ToastAnnounce.vue", "../../reka-ui/src/Toast/utils.ts", "../../reka-ui/src/Toast/ToastRootImpl.vue", "../../reka-ui/src/Toast/ToastClose.vue", "../../reka-ui/src/Toast/ToastAction.vue", "../../reka-ui/src/Toast/ToastDescription.vue", "../../reka-ui/src/Toast/ToastPortal.vue", "../../reka-ui/src/Toast/ToastRoot.vue", "../../reka-ui/src/Toast/ToastTitle.vue", "../../reka-ui/src/Toast/FocusProxy.vue", "../../reka-ui/src/DismissableLayer/DismissableLayerBranch.vue", "../../reka-ui/src/Toast/ToastViewport.vue", "../../reka-ui/src/ToggleGroup/ToggleGroupRoot.vue", "../../reka-ui/src/Toggle/Toggle.vue", "../../reka-ui/src/ToggleGroup/ToggleGroupItem.vue", "../../reka-ui/src/Toolbar/ToolbarButton.vue", "../../reka-ui/src/Toolbar/ToolbarLink.vue", "../../reka-ui/src/Toolbar/ToolbarRoot.vue", "../../reka-ui/src/Toolbar/ToolbarSeparator.vue", "../../reka-ui/src/Toolbar/ToolbarToggleGroup.vue", "../../reka-ui/src/Toolbar/ToolbarToggleItem.vue", "../../reka-ui/src/Tooltip/TooltipArrow.vue", "../../reka-ui/src/Tooltip/utils.ts", "../../reka-ui/src/Tooltip/TooltipProvider.vue", "../../reka-ui/src/Tooltip/TooltipRoot.vue", "../../reka-ui/src/Tooltip/TooltipContentImpl.vue", "../../reka-ui/src/Tooltip/TooltipContentHoverable.vue", "../../reka-ui/src/Tooltip/TooltipContent.vue", "../../reka-ui/src/Tooltip/TooltipPortal.vue", "../../reka-ui/src/Tooltip/TooltipTrigger.vue", "../../reka-ui/src/Tree/utils.ts", "../../reka-ui/src/shared/useSelectionBehavior.ts", "../../reka-ui/src/Tree/TreeRoot.vue", "../../reka-ui/src/Tree/TreeItem.vue", "../../reka-ui/src/Tree/TreeVirtualizer.vue", "../../reka-ui/src/Viewport/Viewport.vue", "../../reka-ui/src/shared/withDefault.ts", "../../reka-ui/src/DatePicker/DatePickerAnchor.vue"],
  "sourcesContent": ["import type { VNode } from 'vue'\nimport { Fragment } from 'vue'\n\nexport function renderSlotFragments(children?: VNode[]): VNode[] {\n  if (!children)\n    return []\n  return children.flatMap((child) => {\n    if (child.type === Fragment)\n      return renderSlotFragments(child.children as VNode[])\n\n    return [child]\n  })\n}\n", "import { cloneVNode, Comment, defineComponent, mergeProps } from 'vue'\nimport { renderSlotFragments } from '@/shared'\n\nexport const Slot = defineComponent({\n  name: 'PrimitiveSlot',\n  inheritAttrs: false,\n  setup(_, { attrs, slots }) {\n    return () => {\n      if (!slots.default)\n        return null\n\n      const children = renderSlotFragments(slots.default())\n      const firstNonCommentChildrenIndex = children.findIndex(child => child.type !== Comment)\n      if (firstNonCommentChildrenIndex === -1)\n        return children\n\n      const firstNonCommentChildren = children[firstNonCommentChildrenIndex]\n\n      // Remove props ref from being inferred\n      delete firstNonCommentChildren.props?.ref\n\n      // Manually merge props to ensure `firstNonCommentChildren.props`\n      // has higher priority than `attrs` and can override `attrs`.\n      // Otherwise `cloneVNode(firstNonCommentChildren, attrs)` will\n      // prioritize `attrs` and override `firstNonCommentChildren.props`.\n      const mergedProps = firstNonCommentChildren.props\n        ? mergeProps(attrs, firstNonCommentChildren.props)\n        : attrs\n      const cloned = cloneVNode({ ...firstNonCommentChildren, props: {} }, mergedProps)\n\n      if (children.length === 1)\n        return cloned\n\n      children[firstNonCommentChildrenIndex] = cloned\n      return children\n    }\n  },\n})\n", "import type { Component, PropType } from 'vue'\nimport { defineComponent, h } from 'vue'\nimport { Slot } from './Slot'\n\nexport type AsTag =\n  | 'a'\n  | 'button'\n  | 'div'\n  | 'form'\n  | 'h2'\n  | 'h3'\n  | 'img'\n  | 'input'\n  | 'label'\n  | 'li'\n  | 'nav'\n  | 'ol'\n  | 'p'\n  | 'span'\n  | 'svg'\n  | 'ul'\n  | 'template'\n  | ({} & string) // any other string\n\nexport interface PrimitiveProps {\n  /**\n   * Change the default rendered element for the one passed as a child, merging their props and behavior.\n   *\n   * Read our [Composition](https://www.reka-ui.com/docs/guides/composition) guide for more details.\n   */\n  asChild?: boolean\n  /**\n   * The element or component this component should render as. Can be overwritten by `asChild`.\n   * @defaultValue \"div\"\n   */\n  as?: AsTag | Component\n}\n\n// For self closing tags, don't provide default slots because of hydration issue\nconst SELF_CLOSING_TAGS = ['area', 'img', 'input']\n\nexport const Primitive = defineComponent({\n  name: 'Primitive',\n  inheritAttrs: false,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: false,\n    },\n    as: {\n      type: [String, Object] as PropType<AsTag | Component>,\n      default: 'div',\n    },\n  },\n  setup(props, { attrs, slots }) {\n    const asTag = props.asChild ? 'template' : props.as\n\n    if (typeof asTag === 'string' && SELF_CLOSING_TAGS.includes(asTag))\n      return () => h(asTag, attrs)\n\n    if (asTag !== 'template')\n      return () => h(props.as, attrs, { default: slots.default })\n\n    return () => h(Slot, attrs, { default: slots.default })\n  },\n})\n", "import { defineComponent, createBlock, openBlock, unref, withCtx, renderSlot } from 'vue';\nimport { P as Primitive } from '../Primitive/Primitive.js';\n\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  __name: \"VisuallyHidden\",\n  props: {\n    feature: { default: \"focusable\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(__props) {\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(unref(Primitive), {\n        as: _ctx.as,\n        \"as-child\": _ctx.asChild,\n        \"aria-hidden\": _ctx.feature === \"focusable\" ? \"true\" : void 0,\n        \"data-hidden\": _ctx.feature === \"fully-hidden\" ? \"\" : void 0,\n        tabindex: _ctx.feature === \"fully-hidden\" ? \"-1\" : void 0,\n        style: {\n          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n          position: \"absolute\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          margin: \"-1px\",\n          overflow: \"hidden\",\n          clip: \"rect(0, 0, 0, 0)\",\n          clipPath: \"inset(50%)\",\n          whiteSpace: \"nowrap\",\n          wordWrap: \"normal\"\n        }\n      }, {\n        default: withCtx(() => [\n          renderSlot(_ctx.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-hidden\", \"data-hidden\", \"tabindex\"]);\n    };\n  }\n});\n\nexport { _sfc_main as _ };\n//# sourceMappingURL=VisuallyHidden.js.map\n", "import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue';\r\n\r\nfunction computedEager(fn, options) {\r\n  var _a;\r\n  const result = shallowRef();\r\n  watchEffect(() => {\r\n    result.value = fn();\r\n  }, {\r\n    ...options,\r\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\r\n  });\r\n  return readonly(result);\r\n}\r\n\r\nfunction computedWithControl(source, fn) {\r\n  let v = void 0;\r\n  let track;\r\n  let trigger;\r\n  const dirty = shallowRef(true);\r\n  const update = () => {\r\n    dirty.value = true;\r\n    trigger();\r\n  };\r\n  watch(source, update, { flush: \"sync\" });\r\n  const get = typeof fn === \"function\" ? fn : fn.get;\r\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\r\n  const result = customRef((_track, _trigger) => {\r\n    track = _track;\r\n    trigger = _trigger;\r\n    return {\r\n      get() {\r\n        if (dirty.value) {\r\n          v = get(v);\r\n          dirty.value = false;\r\n        }\r\n        track();\r\n        return v;\r\n      },\r\n      set(v2) {\r\n        set == null ? void 0 : set(v2);\r\n      }\r\n    };\r\n  });\r\n  if (Object.isExtensible(result))\r\n    result.trigger = update;\r\n  return result;\r\n}\r\n\r\nfunction tryOnScopeDispose(fn) {\r\n  if (getCurrentScope()) {\r\n    onScopeDispose(fn);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction createEventHook() {\r\n  const fns = /* @__PURE__ */ new Set();\r\n  const off = (fn) => {\r\n    fns.delete(fn);\r\n  };\r\n  const clear = () => {\r\n    fns.clear();\r\n  };\r\n  const on = (fn) => {\r\n    fns.add(fn);\r\n    const offFn = () => off(fn);\r\n    tryOnScopeDispose(offFn);\r\n    return {\r\n      off: offFn\r\n    };\r\n  };\r\n  const trigger = (...args) => {\r\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\r\n  };\r\n  return {\r\n    on,\r\n    off,\r\n    trigger,\r\n    clear\r\n  };\r\n}\r\n\r\nfunction createGlobalState(stateFactory) {\r\n  let initialized = false;\r\n  let state;\r\n  const scope = effectScope(true);\r\n  return (...args) => {\r\n    if (!initialized) {\r\n      state = scope.run(() => stateFactory(...args));\r\n      initialized = true;\r\n    }\r\n    return state;\r\n  };\r\n}\r\n\r\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\r\n\r\nconst injectLocal = (...args) => {\r\n  var _a;\r\n  const key = args[0];\r\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\r\n  if (instance == null && !hasInjectionContext())\r\n    throw new Error(\"injectLocal must be called in setup\");\r\n  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\r\n    return localProvidedStateMap.get(instance)[key];\r\n  return inject(...args);\r\n};\r\n\r\nconst provideLocal = (key, value) => {\r\n  var _a;\r\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\r\n  if (instance == null)\r\n    throw new Error(\"provideLocal must be called in setup\");\r\n  if (!localProvidedStateMap.has(instance))\r\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\r\n  const localProvidedState = localProvidedStateMap.get(instance);\r\n  localProvidedState[key] = value;\r\n  provide(key, value);\r\n};\r\n\r\nfunction createInjectionState(composable, options) {\r\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\r\n  const defaultValue = options == null ? void 0 : options.defaultValue;\r\n  const useProvidingState = (...args) => {\r\n    const state = composable(...args);\r\n    provideLocal(key, state);\r\n    return state;\r\n  };\r\n  const useInjectedState = () => injectLocal(key, defaultValue);\r\n  return [useProvidingState, useInjectedState];\r\n}\r\n\r\nfunction createRef(value, deep) {\r\n  if (deep === true) {\r\n    return ref(value);\r\n  } else {\r\n    return shallowRef(value);\r\n  }\r\n}\r\n\r\nfunction createSharedComposable(composable) {\r\n  let subscribers = 0;\r\n  let state;\r\n  let scope;\r\n  const dispose = () => {\r\n    subscribers -= 1;\r\n    if (scope && subscribers <= 0) {\r\n      scope.stop();\r\n      state = void 0;\r\n      scope = void 0;\r\n    }\r\n  };\r\n  return (...args) => {\r\n    subscribers += 1;\r\n    if (!scope) {\r\n      scope = effectScope(true);\r\n      state = scope.run(() => composable(...args));\r\n    }\r\n    tryOnScopeDispose(dispose);\r\n    return state;\r\n  };\r\n}\r\n\r\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\r\n  for (const [key, value] of Object.entries(extend)) {\r\n    if (key === \"value\")\r\n      continue;\r\n    if (isRef(value) && unwrap) {\r\n      Object.defineProperty(ref, key, {\r\n        get() {\r\n          return value.value;\r\n        },\r\n        set(v) {\r\n          value.value = v;\r\n        },\r\n        enumerable\r\n      });\r\n    } else {\r\n      Object.defineProperty(ref, key, { value, enumerable });\r\n    }\r\n  }\r\n  return ref;\r\n}\r\n\r\nfunction get(obj, key) {\r\n  if (key == null)\r\n    return unref(obj);\r\n  return unref(obj)[key];\r\n}\r\n\r\nfunction isDefined(v) {\r\n  return unref(v) != null;\r\n}\r\n\r\nfunction makeDestructurable(obj, arr) {\r\n  if (typeof Symbol !== \"undefined\") {\r\n    const clone = { ...obj };\r\n    Object.defineProperty(clone, Symbol.iterator, {\r\n      enumerable: false,\r\n      value() {\r\n        let index = 0;\r\n        return {\r\n          next: () => ({\r\n            value: arr[index++],\r\n            done: index > arr.length\r\n          })\r\n        };\r\n      }\r\n    });\r\n    return clone;\r\n  } else {\r\n    return Object.assign([...arr], obj);\r\n  }\r\n}\r\n\r\nfunction reactify(fn, options) {\r\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue$1;\r\n  return function(...args) {\r\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\r\n  };\r\n}\r\n\r\nfunction reactifyObject(obj, optionsOrKeys = {}) {\r\n  let keys = [];\r\n  let options;\r\n  if (Array.isArray(optionsOrKeys)) {\r\n    keys = optionsOrKeys;\r\n  } else {\r\n    options = optionsOrKeys;\r\n    const { includeOwnProperties = true } = optionsOrKeys;\r\n    keys.push(...Object.keys(obj));\r\n    if (includeOwnProperties)\r\n      keys.push(...Object.getOwnPropertyNames(obj));\r\n  }\r\n  return Object.fromEntries(\r\n    keys.map((key) => {\r\n      const value = obj[key];\r\n      return [\r\n        key,\r\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\r\n      ];\r\n    })\r\n  );\r\n}\r\n\r\nfunction toReactive(objectRef) {\r\n  if (!isRef(objectRef))\r\n    return reactive(objectRef);\r\n  const proxy = new Proxy({}, {\r\n    get(_, p, receiver) {\r\n      return unref(Reflect.get(objectRef.value, p, receiver));\r\n    },\r\n    set(_, p, value) {\r\n      if (isRef(objectRef.value[p]) && !isRef(value))\r\n        objectRef.value[p].value = value;\r\n      else\r\n        objectRef.value[p] = value;\r\n      return true;\r\n    },\r\n    deleteProperty(_, p) {\r\n      return Reflect.deleteProperty(objectRef.value, p);\r\n    },\r\n    has(_, p) {\r\n      return Reflect.has(objectRef.value, p);\r\n    },\r\n    ownKeys() {\r\n      return Object.keys(objectRef.value);\r\n    },\r\n    getOwnPropertyDescriptor() {\r\n      return {\r\n        enumerable: true,\r\n        configurable: true\r\n      };\r\n    }\r\n  });\r\n  return reactive(proxy);\r\n}\r\n\r\nfunction reactiveComputed(fn) {\r\n  return toReactive(computed(fn));\r\n}\r\n\r\nfunction reactiveOmit(obj, ...keys) {\r\n  const flatKeys = keys.flat();\r\n  const predicate = flatKeys[0];\r\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\r\n}\r\n\r\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\r\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\r\nconst isDef = (val) => typeof val !== \"undefined\";\r\nconst notNullish = (val) => val != null;\r\nconst assert = (condition, ...infos) => {\r\n  if (!condition)\r\n    console.warn(...infos);\r\n};\r\nconst toString = Object.prototype.toString;\r\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\r\nconst now = () => Date.now();\r\nconst timestamp = () => +Date.now();\r\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\r\nconst noop = () => {\r\n};\r\nconst rand = (min, max) => {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\r\nconst isIOS = /* @__PURE__ */ getIsIOS();\r\nfunction getIsIOS() {\r\n  var _a, _b;\r\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\r\n}\r\n\r\nfunction createFilterWrapper(filter, fn) {\r\n  function wrapper(...args) {\r\n    return new Promise((resolve, reject) => {\r\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\r\n    });\r\n  }\r\n  return wrapper;\r\n}\r\nconst bypassFilter = (invoke) => {\r\n  return invoke();\r\n};\r\nfunction debounceFilter(ms, options = {}) {\r\n  let timer;\r\n  let maxTimer;\r\n  let lastRejector = noop;\r\n  const _clearTimeout = (timer2) => {\r\n    clearTimeout(timer2);\r\n    lastRejector();\r\n    lastRejector = noop;\r\n  };\r\n  let lastInvoker;\r\n  const filter = (invoke) => {\r\n    const duration = toValue$1(ms);\r\n    const maxDuration = toValue$1(options.maxWait);\r\n    if (timer)\r\n      _clearTimeout(timer);\r\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\r\n      if (maxTimer) {\r\n        _clearTimeout(maxTimer);\r\n        maxTimer = null;\r\n      }\r\n      return Promise.resolve(invoke());\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      lastRejector = options.rejectOnCancel ? reject : resolve;\r\n      lastInvoker = invoke;\r\n      if (maxDuration && !maxTimer) {\r\n        maxTimer = setTimeout(() => {\r\n          if (timer)\r\n            _clearTimeout(timer);\r\n          maxTimer = null;\r\n          resolve(lastInvoker());\r\n        }, maxDuration);\r\n      }\r\n      timer = setTimeout(() => {\r\n        if (maxTimer)\r\n          _clearTimeout(maxTimer);\r\n        maxTimer = null;\r\n        resolve(invoke());\r\n      }, duration);\r\n    });\r\n  };\r\n  return filter;\r\n}\r\nfunction throttleFilter(...args) {\r\n  let lastExec = 0;\r\n  let timer;\r\n  let isLeading = true;\r\n  let lastRejector = noop;\r\n  let lastValue;\r\n  let ms;\r\n  let trailing;\r\n  let leading;\r\n  let rejectOnCancel;\r\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\r\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\r\n  else\r\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\r\n  const clear = () => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = void 0;\r\n      lastRejector();\r\n      lastRejector = noop;\r\n    }\r\n  };\r\n  const filter = (_invoke) => {\r\n    const duration = toValue$1(ms);\r\n    const elapsed = Date.now() - lastExec;\r\n    const invoke = () => {\r\n      return lastValue = _invoke();\r\n    };\r\n    clear();\r\n    if (duration <= 0) {\r\n      lastExec = Date.now();\r\n      return invoke();\r\n    }\r\n    if (elapsed > duration && (leading || !isLeading)) {\r\n      lastExec = Date.now();\r\n      invoke();\r\n    } else if (trailing) {\r\n      lastValue = new Promise((resolve, reject) => {\r\n        lastRejector = rejectOnCancel ? reject : resolve;\r\n        timer = setTimeout(() => {\r\n          lastExec = Date.now();\r\n          isLeading = true;\r\n          resolve(invoke());\r\n          clear();\r\n        }, Math.max(0, duration - elapsed));\r\n      });\r\n    }\r\n    if (!leading && !timer)\r\n      timer = setTimeout(() => isLeading = true, duration);\r\n    isLeading = false;\r\n    return lastValue;\r\n  };\r\n  return filter;\r\n}\r\nfunction pausableFilter(extendFilter = bypassFilter, options = {}) {\r\n  const {\r\n    initialState = \"active\"\r\n  } = options;\r\n  const isActive = toRef(initialState === \"active\");\r\n  function pause() {\r\n    isActive.value = false;\r\n  }\r\n  function resume() {\r\n    isActive.value = true;\r\n  }\r\n  const eventFilter = (...args) => {\r\n    if (isActive.value)\r\n      extendFilter(...args);\r\n  };\r\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\r\n}\r\n\r\nfunction cacheStringFunction(fn) {\r\n  const cache = /* @__PURE__ */ Object.create(null);\r\n  return (str) => {\r\n    const hit = cache[str];\r\n    return hit || (cache[str] = fn(str));\r\n  };\r\n}\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\r\nconst camelizeRE = /-(\\w)/g;\r\nconst camelize = cacheStringFunction((str) => {\r\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\r\n});\r\n\r\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\r\n  return new Promise((resolve, reject) => {\r\n    if (throwOnTimeout)\r\n      setTimeout(() => reject(reason), ms);\r\n    else\r\n      setTimeout(resolve, ms);\r\n  });\r\n}\r\nfunction identity(arg) {\r\n  return arg;\r\n}\r\nfunction createSingletonPromise(fn) {\r\n  let _promise;\r\n  function wrapper() {\r\n    if (!_promise)\r\n      _promise = fn();\r\n    return _promise;\r\n  }\r\n  wrapper.reset = async () => {\r\n    const _prev = _promise;\r\n    _promise = void 0;\r\n    if (_prev)\r\n      await _prev;\r\n  };\r\n  return wrapper;\r\n}\r\nfunction invoke(fn) {\r\n  return fn();\r\n}\r\nfunction containsProp(obj, ...props) {\r\n  return props.some((k) => k in obj);\r\n}\r\nfunction increaseWithUnit(target, delta) {\r\n  var _a;\r\n  if (typeof target === \"number\")\r\n    return target + delta;\r\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\r\n  const unit = target.slice(value.length);\r\n  const result = Number.parseFloat(value) + delta;\r\n  if (Number.isNaN(result))\r\n    return target;\r\n  return result + unit;\r\n}\r\nfunction pxValue(px) {\r\n  return px.endsWith(\"rem\") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);\r\n}\r\nfunction objectPick(obj, keys, omitUndefined = false) {\r\n  return keys.reduce((n, k) => {\r\n    if (k in obj) {\r\n      if (!omitUndefined || obj[k] !== void 0)\r\n        n[k] = obj[k];\r\n    }\r\n    return n;\r\n  }, {});\r\n}\r\nfunction objectOmit(obj, keys, omitUndefined = false) {\r\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\r\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\r\n  }));\r\n}\r\nfunction objectEntries(obj) {\r\n  return Object.entries(obj);\r\n}\r\nfunction getLifeCycleTarget(target) {\r\n  return target || getCurrentInstance();\r\n}\r\nfunction toArray(value) {\r\n  return Array.isArray(value) ? value : [value];\r\n}\r\n\r\nfunction toRef(...args) {\r\n  if (args.length !== 1)\r\n    return toRef$1(...args);\r\n  const r = args[0];\r\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\r\n}\r\nconst resolveRef = toRef;\r\n\r\nfunction reactivePick(obj, ...keys) {\r\n  const flatKeys = keys.flat();\r\n  const predicate = flatKeys[0];\r\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue$1(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\r\n}\r\n\r\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\r\n  return customRef((track, trigger) => {\r\n    let value = toValue$1(defaultValue);\r\n    let timer;\r\n    const resetAfter = () => setTimeout(() => {\r\n      value = toValue$1(defaultValue);\r\n      trigger();\r\n    }, toValue$1(afterMs));\r\n    tryOnScopeDispose(() => {\r\n      clearTimeout(timer);\r\n    });\r\n    return {\r\n      get() {\r\n        track();\r\n        return value;\r\n      },\r\n      set(newValue) {\r\n        value = newValue;\r\n        trigger();\r\n        clearTimeout(timer);\r\n        timer = resetAfter();\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nfunction useDebounceFn(fn, ms = 200, options = {}) {\r\n  return createFilterWrapper(\r\n    debounceFilter(ms, options),\r\n    fn\r\n  );\r\n}\r\n\r\nfunction refDebounced(value, ms = 200, options = {}) {\r\n  const debounced = ref(value.value);\r\n  const updater = useDebounceFn(() => {\r\n    debounced.value = value.value;\r\n  }, ms, options);\r\n  watch(value, () => updater());\r\n  return debounced;\r\n}\r\n\r\nfunction refDefault(source, defaultValue) {\r\n  return computed({\r\n    get() {\r\n      var _a;\r\n      return (_a = source.value) != null ? _a : defaultValue;\r\n    },\r\n    set(value) {\r\n      source.value = value;\r\n    }\r\n  });\r\n}\r\n\r\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\r\n  return createFilterWrapper(\r\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\r\n    fn\r\n  );\r\n}\r\n\r\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\r\n  if (delay <= 0)\r\n    return value;\r\n  const throttled = ref(value.value);\r\n  const updater = useThrottleFn(() => {\r\n    throttled.value = value.value;\r\n  }, delay, trailing, leading);\r\n  watch(value, () => updater());\r\n  return throttled;\r\n}\r\n\r\nfunction refWithControl(initial, options = {}) {\r\n  let source = initial;\r\n  let track;\r\n  let trigger;\r\n  const ref = customRef((_track, _trigger) => {\r\n    track = _track;\r\n    trigger = _trigger;\r\n    return {\r\n      get() {\r\n        return get();\r\n      },\r\n      set(v) {\r\n        set(v);\r\n      }\r\n    };\r\n  });\r\n  function get(tracking = true) {\r\n    if (tracking)\r\n      track();\r\n    return source;\r\n  }\r\n  function set(value, triggering = true) {\r\n    var _a, _b;\r\n    if (value === source)\r\n      return;\r\n    const old = source;\r\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\r\n      return;\r\n    source = value;\r\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\r\n    if (triggering)\r\n      trigger();\r\n  }\r\n  const untrackedGet = () => get(false);\r\n  const silentSet = (v) => set(v, false);\r\n  const peek = () => get(false);\r\n  const lay = (v) => set(v, false);\r\n  return extendRef(\r\n    ref,\r\n    {\r\n      get,\r\n      set,\r\n      untrackedGet,\r\n      silentSet,\r\n      peek,\r\n      lay\r\n    },\r\n    { enumerable: true }\r\n  );\r\n}\r\nconst controlledRef = refWithControl;\r\n\r\nfunction set(...args) {\r\n  if (args.length === 2) {\r\n    const [ref, value] = args;\r\n    ref.value = value;\r\n  }\r\n  if (args.length === 3) {\r\n    const [target, key, value] = args;\r\n    target[key] = value;\r\n  }\r\n}\r\n\r\nfunction watchWithFilter(source, cb, options = {}) {\r\n  const {\r\n    eventFilter = bypassFilter,\r\n    ...watchOptions\r\n  } = options;\r\n  return watch(\r\n    source,\r\n    createFilterWrapper(\r\n      eventFilter,\r\n      cb\r\n    ),\r\n    watchOptions\r\n  );\r\n}\r\n\r\nfunction watchPausable(source, cb, options = {}) {\r\n  const {\r\n    eventFilter: filter,\r\n    initialState = \"active\",\r\n    ...watchOptions\r\n  } = options;\r\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });\r\n  const stop = watchWithFilter(\r\n    source,\r\n    cb,\r\n    {\r\n      ...watchOptions,\r\n      eventFilter\r\n    }\r\n  );\r\n  return { stop, pause, resume, isActive };\r\n}\r\n\r\nfunction syncRef(left, right, ...[options]) {\r\n  const {\r\n    flush = \"sync\",\r\n    deep = false,\r\n    immediate = true,\r\n    direction = \"both\",\r\n    transform = {}\r\n  } = options || {};\r\n  const watchers = [];\r\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\r\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\r\n  if (direction === \"both\" || direction === \"ltr\") {\r\n    watchers.push(watchPausable(\r\n      left,\r\n      (newValue) => {\r\n        watchers.forEach((w) => w.pause());\r\n        right.value = transformLTR(newValue);\r\n        watchers.forEach((w) => w.resume());\r\n      },\r\n      { flush, deep, immediate }\r\n    ));\r\n  }\r\n  if (direction === \"both\" || direction === \"rtl\") {\r\n    watchers.push(watchPausable(\r\n      right,\r\n      (newValue) => {\r\n        watchers.forEach((w) => w.pause());\r\n        left.value = transformRTL(newValue);\r\n        watchers.forEach((w) => w.resume());\r\n      },\r\n      { flush, deep, immediate }\r\n    ));\r\n  }\r\n  const stop = () => {\r\n    watchers.forEach((w) => w.stop());\r\n  };\r\n  return stop;\r\n}\r\n\r\nfunction syncRefs(source, targets, options = {}) {\r\n  const {\r\n    flush = \"sync\",\r\n    deep = false,\r\n    immediate = true\r\n  } = options;\r\n  const targetsArray = toArray(targets);\r\n  return watch(\r\n    source,\r\n    (newValue) => targetsArray.forEach((target) => target.value = newValue),\r\n    { flush, deep, immediate }\r\n  );\r\n}\r\n\r\nfunction toRefs(objectRef, options = {}) {\r\n  if (!isRef(objectRef))\r\n    return toRefs$1(objectRef);\r\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\r\n  for (const key in objectRef.value) {\r\n    result[key] = customRef(() => ({\r\n      get() {\r\n        return objectRef.value[key];\r\n      },\r\n      set(v) {\r\n        var _a;\r\n        const replaceRef = (_a = toValue$1(options.replaceRef)) != null ? _a : true;\r\n        if (replaceRef) {\r\n          if (Array.isArray(objectRef.value)) {\r\n            const copy = [...objectRef.value];\r\n            copy[key] = v;\r\n            objectRef.value = copy;\r\n          } else {\r\n            const newObject = { ...objectRef.value, [key]: v };\r\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\r\n            objectRef.value = newObject;\r\n          }\r\n        } else {\r\n          objectRef.value[key] = v;\r\n        }\r\n      }\r\n    }));\r\n  }\r\n  return result;\r\n}\r\n\r\nconst toValue = toValue$1;\r\nconst resolveUnref = toValue$1;\r\n\r\nfunction tryOnBeforeMount(fn, sync = true, target) {\r\n  const instance = getLifeCycleTarget(target);\r\n  if (instance)\r\n    onBeforeMount(fn, target);\r\n  else if (sync)\r\n    fn();\r\n  else\r\n    nextTick(fn);\r\n}\r\n\r\nfunction tryOnBeforeUnmount(fn, target) {\r\n  const instance = getLifeCycleTarget(target);\r\n  if (instance)\r\n    onBeforeUnmount(fn, target);\r\n}\r\n\r\nfunction tryOnMounted(fn, sync = true, target) {\r\n  const instance = getLifeCycleTarget();\r\n  if (instance)\r\n    onMounted(fn, target);\r\n  else if (sync)\r\n    fn();\r\n  else\r\n    nextTick(fn);\r\n}\r\n\r\nfunction tryOnUnmounted(fn, target) {\r\n  const instance = getLifeCycleTarget(target);\r\n  if (instance)\r\n    onUnmounted(fn, target);\r\n}\r\n\r\nfunction createUntil(r, isNot = false) {\r\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\r\n    let stop = null;\r\n    const watcher = new Promise((resolve) => {\r\n      stop = watch(\r\n        r,\r\n        (v) => {\r\n          if (condition(v) !== isNot) {\r\n            if (stop)\r\n              stop();\r\n            else\r\n              nextTick(() => stop == null ? void 0 : stop());\r\n            resolve(v);\r\n          }\r\n        },\r\n        {\r\n          flush,\r\n          deep,\r\n          immediate: true\r\n        }\r\n      );\r\n    });\r\n    const promises = [watcher];\r\n    if (timeout != null) {\r\n      promises.push(\r\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? void 0 : stop())\r\n      );\r\n    }\r\n    return Promise.race(promises);\r\n  }\r\n  function toBe(value, options) {\r\n    if (!isRef(value))\r\n      return toMatch((v) => v === value, options);\r\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\r\n    let stop = null;\r\n    const watcher = new Promise((resolve) => {\r\n      stop = watch(\r\n        [r, value],\r\n        ([v1, v2]) => {\r\n          if (isNot !== (v1 === v2)) {\r\n            if (stop)\r\n              stop();\r\n            else\r\n              nextTick(() => stop == null ? void 0 : stop());\r\n            resolve(v1);\r\n          }\r\n        },\r\n        {\r\n          flush,\r\n          deep,\r\n          immediate: true\r\n        }\r\n      );\r\n    });\r\n    const promises = [watcher];\r\n    if (timeout != null) {\r\n      promises.push(\r\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {\r\n          stop == null ? void 0 : stop();\r\n          return toValue$1(r);\r\n        })\r\n      );\r\n    }\r\n    return Promise.race(promises);\r\n  }\r\n  function toBeTruthy(options) {\r\n    return toMatch((v) => Boolean(v), options);\r\n  }\r\n  function toBeNull(options) {\r\n    return toBe(null, options);\r\n  }\r\n  function toBeUndefined(options) {\r\n    return toBe(void 0, options);\r\n  }\r\n  function toBeNaN(options) {\r\n    return toMatch(Number.isNaN, options);\r\n  }\r\n  function toContains(value, options) {\r\n    return toMatch((v) => {\r\n      const array = Array.from(v);\r\n      return array.includes(value) || array.includes(toValue$1(value));\r\n    }, options);\r\n  }\r\n  function changed(options) {\r\n    return changedTimes(1, options);\r\n  }\r\n  function changedTimes(n = 1, options) {\r\n    let count = -1;\r\n    return toMatch(() => {\r\n      count += 1;\r\n      return count >= n;\r\n    }, options);\r\n  }\r\n  if (Array.isArray(toValue$1(r))) {\r\n    const instance = {\r\n      toMatch,\r\n      toContains,\r\n      changed,\r\n      changedTimes,\r\n      get not() {\r\n        return createUntil(r, !isNot);\r\n      }\r\n    };\r\n    return instance;\r\n  } else {\r\n    const instance = {\r\n      toMatch,\r\n      toBe,\r\n      toBeTruthy,\r\n      toBeNull,\r\n      toBeNaN,\r\n      toBeUndefined,\r\n      changed,\r\n      changedTimes,\r\n      get not() {\r\n        return createUntil(r, !isNot);\r\n      }\r\n    };\r\n    return instance;\r\n  }\r\n}\r\nfunction until(r) {\r\n  return createUntil(r);\r\n}\r\n\r\nfunction defaultComparator(value, othVal) {\r\n  return value === othVal;\r\n}\r\nfunction useArrayDifference(...args) {\r\n  var _a, _b;\r\n  const list = args[0];\r\n  const values = args[1];\r\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\r\n  const {\r\n    symmetric = false\r\n  } = (_b = args[3]) != null ? _b : {};\r\n  if (typeof compareFn === \"string\") {\r\n    const key = compareFn;\r\n    compareFn = (value, othVal) => value[key] === othVal[key];\r\n  }\r\n  const diff1 = computed(() => toValue$1(list).filter((x) => toValue$1(values).findIndex((y) => compareFn(x, y)) === -1));\r\n  if (symmetric) {\r\n    const diff2 = computed(() => toValue$1(values).filter((x) => toValue$1(list).findIndex((y) => compareFn(x, y)) === -1));\r\n    return computed(() => symmetric ? [...toValue$1(diff1), ...toValue$1(diff2)] : toValue$1(diff1));\r\n  } else {\r\n    return diff1;\r\n  }\r\n}\r\n\r\nfunction useArrayEvery(list, fn) {\r\n  return computed(() => toValue$1(list).every((element, index, array) => fn(toValue$1(element), index, array)));\r\n}\r\n\r\nfunction useArrayFilter(list, fn) {\r\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).filter(fn));\r\n}\r\n\r\nfunction useArrayFind(list, fn) {\r\n  return computed(() => toValue$1(\r\n    toValue$1(list).find((element, index, array) => fn(toValue$1(element), index, array))\r\n  ));\r\n}\r\n\r\nfunction useArrayFindIndex(list, fn) {\r\n  return computed(() => toValue$1(list).findIndex((element, index, array) => fn(toValue$1(element), index, array)));\r\n}\r\n\r\nfunction findLast(arr, cb) {\r\n  let index = arr.length;\r\n  while (index-- > 0) {\r\n    if (cb(arr[index], index, arr))\r\n      return arr[index];\r\n  }\r\n  return void 0;\r\n}\r\nfunction useArrayFindLast(list, fn) {\r\n  return computed(() => toValue$1(\r\n    !Array.prototype.findLast ? findLast(toValue$1(list), (element, index, array) => fn(toValue$1(element), index, array)) : toValue$1(list).findLast((element, index, array) => fn(toValue$1(element), index, array))\r\n  ));\r\n}\r\n\r\nfunction isArrayIncludesOptions(obj) {\r\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\r\n}\r\nfunction useArrayIncludes(...args) {\r\n  var _a;\r\n  const list = args[0];\r\n  const value = args[1];\r\n  let comparator = args[2];\r\n  let formIndex = 0;\r\n  if (isArrayIncludesOptions(comparator)) {\r\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\r\n    comparator = comparator.comparator;\r\n  }\r\n  if (typeof comparator === \"string\") {\r\n    const key = comparator;\r\n    comparator = (element, value2) => element[key] === toValue$1(value2);\r\n  }\r\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue$1(value2);\r\n  return computed(() => toValue$1(list).slice(formIndex).some((element, index, array) => comparator(\r\n    toValue$1(element),\r\n    toValue$1(value),\r\n    index,\r\n    toValue$1(array)\r\n  )));\r\n}\r\n\r\nfunction useArrayJoin(list, separator) {\r\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).join(toValue$1(separator)));\r\n}\r\n\r\nfunction useArrayMap(list, fn) {\r\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).map(fn));\r\n}\r\n\r\nfunction useArrayReduce(list, reducer, ...args) {\r\n  const reduceCallback = (sum, value, index) => reducer(toValue$1(sum), toValue$1(value), index);\r\n  return computed(() => {\r\n    const resolved = toValue$1(list);\r\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue$1(args[0]()) : toValue$1(args[0])) : resolved.reduce(reduceCallback);\r\n  });\r\n}\r\n\r\nfunction useArraySome(list, fn) {\r\n  return computed(() => toValue$1(list).some((element, index, array) => fn(toValue$1(element), index, array)));\r\n}\r\n\r\nfunction uniq(array) {\r\n  return Array.from(new Set(array));\r\n}\r\nfunction uniqueElementsBy(array, fn) {\r\n  return array.reduce((acc, v) => {\r\n    if (!acc.some((x) => fn(v, x, array)))\r\n      acc.push(v);\r\n    return acc;\r\n  }, []);\r\n}\r\nfunction useArrayUnique(list, compareFn) {\r\n  return computed(() => {\r\n    const resolvedList = toValue$1(list).map((element) => toValue$1(element));\r\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\r\n  });\r\n}\r\n\r\nfunction useCounter(initialValue = 0, options = {}) {\r\n  let _initialValue = unref(initialValue);\r\n  const count = shallowRef(initialValue);\r\n  const {\r\n    max = Number.POSITIVE_INFINITY,\r\n    min = Number.NEGATIVE_INFINITY\r\n  } = options;\r\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\r\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\r\n  const get = () => count.value;\r\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\r\n  const reset = (val = _initialValue) => {\r\n    _initialValue = val;\r\n    return set(val);\r\n  };\r\n  return { count, inc, dec, get, set, reset };\r\n}\r\n\r\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\r\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|z{1,4}|SSS/g;\r\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\r\n  let m = hours < 12 ? \"AM\" : \"PM\";\r\n  if (hasPeriod)\r\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\r\n  return isLowercase ? m.toLowerCase() : m;\r\n}\r\nfunction formatOrdinal(num) {\r\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\r\n  const v = num % 100;\r\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\r\n}\r\nfunction formatDate(date, formatStr, options = {}) {\r\n  var _a;\r\n  const years = date.getFullYear();\r\n  const month = date.getMonth();\r\n  const days = date.getDate();\r\n  const hours = date.getHours();\r\n  const minutes = date.getMinutes();\r\n  const seconds = date.getSeconds();\r\n  const milliseconds = date.getMilliseconds();\r\n  const day = date.getDay();\r\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\r\n  const stripTimeZone = (dateString) => {\r\n    var _a2;\r\n    return (_a2 = dateString.split(\" \")[1]) != null ? _a2 : \"\";\r\n  };\r\n  const matches = {\r\n    Yo: () => formatOrdinal(years),\r\n    YY: () => String(years).slice(-2),\r\n    YYYY: () => years,\r\n    M: () => month + 1,\r\n    Mo: () => formatOrdinal(month + 1),\r\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\r\n    MMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"short\" }),\r\n    MMMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"long\" }),\r\n    D: () => String(days),\r\n    Do: () => formatOrdinal(days),\r\n    DD: () => `${days}`.padStart(2, \"0\"),\r\n    H: () => String(hours),\r\n    Ho: () => formatOrdinal(hours),\r\n    HH: () => `${hours}`.padStart(2, \"0\"),\r\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\r\n    ho: () => formatOrdinal(hours % 12 || 12),\r\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\r\n    m: () => String(minutes),\r\n    mo: () => formatOrdinal(minutes),\r\n    mm: () => `${minutes}`.padStart(2, \"0\"),\r\n    s: () => String(seconds),\r\n    so: () => formatOrdinal(seconds),\r\n    ss: () => `${seconds}`.padStart(2, \"0\"),\r\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\r\n    d: () => day,\r\n    dd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"narrow\" }),\r\n    ddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"short\" }),\r\n    dddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"long\" }),\r\n    A: () => meridiem(hours, minutes),\r\n    AA: () => meridiem(hours, minutes, false, true),\r\n    a: () => meridiem(hours, minutes, true),\r\n    aa: () => meridiem(hours, minutes, true, true),\r\n    z: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\r\n    zz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\r\n    zzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\r\n    zzzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"longOffset\" }))\r\n  };\r\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\r\n    var _a2, _b;\r\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\r\n  });\r\n}\r\nfunction normalizeDate(date) {\r\n  if (date === null)\r\n    return new Date(Number.NaN);\r\n  if (date === void 0)\r\n    return /* @__PURE__ */ new Date();\r\n  if (date instanceof Date)\r\n    return new Date(date);\r\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\r\n    const d = date.match(REGEX_PARSE);\r\n    if (d) {\r\n      const m = d[2] - 1 || 0;\r\n      const ms = (d[7] || \"0\").substring(0, 3);\r\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\r\n    }\r\n  }\r\n  return new Date(date);\r\n}\r\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\r\n  return computed(() => formatDate(normalizeDate(toValue$1(date)), toValue$1(formatStr), options));\r\n}\r\n\r\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    immediateCallback = false\r\n  } = options;\r\n  let timer = null;\r\n  const isActive = shallowRef(false);\r\n  function clean() {\r\n    if (timer) {\r\n      clearInterval(timer);\r\n      timer = null;\r\n    }\r\n  }\r\n  function pause() {\r\n    isActive.value = false;\r\n    clean();\r\n  }\r\n  function resume() {\r\n    const intervalValue = toValue$1(interval);\r\n    if (intervalValue <= 0)\r\n      return;\r\n    isActive.value = true;\r\n    if (immediateCallback)\r\n      cb();\r\n    clean();\r\n    if (isActive.value)\r\n      timer = setInterval(cb, intervalValue);\r\n  }\r\n  if (immediate && isClient)\r\n    resume();\r\n  if (isRef(interval) || typeof interval === \"function\") {\r\n    const stopWatch = watch(interval, () => {\r\n      if (isActive.value && isClient)\r\n        resume();\r\n    });\r\n    tryOnScopeDispose(stopWatch);\r\n  }\r\n  tryOnScopeDispose(pause);\r\n  return {\r\n    isActive,\r\n    pause,\r\n    resume\r\n  };\r\n}\r\n\r\nfunction useInterval(interval = 1e3, options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    immediate = true,\r\n    callback\r\n  } = options;\r\n  const counter = shallowRef(0);\r\n  const update = () => counter.value += 1;\r\n  const reset = () => {\r\n    counter.value = 0;\r\n  };\r\n  const controls = useIntervalFn(\r\n    callback ? () => {\r\n      update();\r\n      callback(counter.value);\r\n    } : update,\r\n    interval,\r\n    { immediate }\r\n  );\r\n  if (exposeControls) {\r\n    return {\r\n      counter,\r\n      reset,\r\n      ...controls\r\n    };\r\n  } else {\r\n    return counter;\r\n  }\r\n}\r\n\r\nfunction useLastChanged(source, options = {}) {\r\n  var _a;\r\n  const ms = shallowRef((_a = options.initialValue) != null ? _a : null);\r\n  watch(\r\n    source,\r\n    () => ms.value = timestamp(),\r\n    options\r\n  );\r\n  return ms;\r\n}\r\n\r\nfunction useTimeoutFn(cb, interval, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    immediateCallback = false\r\n  } = options;\r\n  const isPending = shallowRef(false);\r\n  let timer = null;\r\n  function clear() {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = null;\r\n    }\r\n  }\r\n  function stop() {\r\n    isPending.value = false;\r\n    clear();\r\n  }\r\n  function start(...args) {\r\n    if (immediateCallback)\r\n      cb();\r\n    clear();\r\n    isPending.value = true;\r\n    timer = setTimeout(() => {\r\n      isPending.value = false;\r\n      timer = null;\r\n      cb(...args);\r\n    }, toValue$1(interval));\r\n  }\r\n  if (immediate) {\r\n    isPending.value = true;\r\n    if (isClient)\r\n      start();\r\n  }\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isPending: readonly(isPending),\r\n    start,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useTimeout(interval = 1e3, options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    callback\r\n  } = options;\r\n  const controls = useTimeoutFn(\r\n    callback != null ? callback : noop,\r\n    interval,\r\n    options\r\n  );\r\n  const ready = computed(() => !controls.isPending.value);\r\n  if (exposeControls) {\r\n    return {\r\n      ready,\r\n      ...controls\r\n    };\r\n  } else {\r\n    return ready;\r\n  }\r\n}\r\n\r\nfunction useToNumber(value, options = {}) {\r\n  const {\r\n    method = \"parseFloat\",\r\n    radix,\r\n    nanToZero\r\n  } = options;\r\n  return computed(() => {\r\n    let resolved = toValue$1(value);\r\n    if (typeof method === \"function\")\r\n      resolved = method(resolved);\r\n    else if (typeof resolved === \"string\")\r\n      resolved = Number[method](resolved, radix);\r\n    if (nanToZero && Number.isNaN(resolved))\r\n      resolved = 0;\r\n    return resolved;\r\n  });\r\n}\r\n\r\nfunction useToString(value) {\r\n  return computed(() => `${toValue$1(value)}`);\r\n}\r\n\r\nfunction useToggle(initialValue = false, options = {}) {\r\n  const {\r\n    truthyValue = true,\r\n    falsyValue = false\r\n  } = options;\r\n  const valueIsRef = isRef(initialValue);\r\n  const _value = shallowRef(initialValue);\r\n  function toggle(value) {\r\n    if (arguments.length) {\r\n      _value.value = value;\r\n      return _value.value;\r\n    } else {\r\n      const truthy = toValue$1(truthyValue);\r\n      _value.value = _value.value === truthy ? toValue$1(falsyValue) : truthy;\r\n      return _value.value;\r\n    }\r\n  }\r\n  if (valueIsRef)\r\n    return toggle;\r\n  else\r\n    return [_value, toggle];\r\n}\r\n\r\nfunction watchArray(source, cb, options) {\r\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...typeof source === \"function\" ? source() : Array.isArray(source) ? source : toValue$1(source)];\r\n  return watch(source, (newList, _, onCleanup) => {\r\n    const oldListRemains = Array.from({ length: oldList.length });\r\n    const added = [];\r\n    for (const obj of newList) {\r\n      let found = false;\r\n      for (let i = 0; i < oldList.length; i++) {\r\n        if (!oldListRemains[i] && obj === oldList[i]) {\r\n          oldListRemains[i] = true;\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found)\r\n        added.push(obj);\r\n    }\r\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\r\n    cb(newList, oldList, added, removed, onCleanup);\r\n    oldList = [...newList];\r\n  }, options);\r\n}\r\n\r\nfunction watchAtMost(source, cb, options) {\r\n  const {\r\n    count,\r\n    ...watchOptions\r\n  } = options;\r\n  const current = shallowRef(0);\r\n  const stop = watchWithFilter(\r\n    source,\r\n    (...args) => {\r\n      current.value += 1;\r\n      if (current.value >= toValue$1(count))\r\n        nextTick(() => stop());\r\n      cb(...args);\r\n    },\r\n    watchOptions\r\n  );\r\n  return { count: current, stop };\r\n}\r\n\r\nfunction watchDebounced(source, cb, options = {}) {\r\n  const {\r\n    debounce = 0,\r\n    maxWait = void 0,\r\n    ...watchOptions\r\n  } = options;\r\n  return watchWithFilter(\r\n    source,\r\n    cb,\r\n    {\r\n      ...watchOptions,\r\n      eventFilter: debounceFilter(debounce, { maxWait })\r\n    }\r\n  );\r\n}\r\n\r\nfunction watchDeep(source, cb, options) {\r\n  return watch(\r\n    source,\r\n    cb,\r\n    {\r\n      ...options,\r\n      deep: true\r\n    }\r\n  );\r\n}\r\n\r\nfunction watchIgnorable(source, cb, options = {}) {\r\n  const {\r\n    eventFilter = bypassFilter,\r\n    ...watchOptions\r\n  } = options;\r\n  const filteredCb = createFilterWrapper(\r\n    eventFilter,\r\n    cb\r\n  );\r\n  let ignoreUpdates;\r\n  let ignorePrevAsyncUpdates;\r\n  let stop;\r\n  if (watchOptions.flush === \"sync\") {\r\n    const ignore = shallowRef(false);\r\n    ignorePrevAsyncUpdates = () => {\r\n    };\r\n    ignoreUpdates = (updater) => {\r\n      ignore.value = true;\r\n      updater();\r\n      ignore.value = false;\r\n    };\r\n    stop = watch(\r\n      source,\r\n      (...args) => {\r\n        if (!ignore.value)\r\n          filteredCb(...args);\r\n      },\r\n      watchOptions\r\n    );\r\n  } else {\r\n    const disposables = [];\r\n    const ignoreCounter = shallowRef(0);\r\n    const syncCounter = shallowRef(0);\r\n    ignorePrevAsyncUpdates = () => {\r\n      ignoreCounter.value = syncCounter.value;\r\n    };\r\n    disposables.push(\r\n      watch(\r\n        source,\r\n        () => {\r\n          syncCounter.value++;\r\n        },\r\n        { ...watchOptions, flush: \"sync\" }\r\n      )\r\n    );\r\n    ignoreUpdates = (updater) => {\r\n      const syncCounterPrev = syncCounter.value;\r\n      updater();\r\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\r\n    };\r\n    disposables.push(\r\n      watch(\r\n        source,\r\n        (...args) => {\r\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\r\n          ignoreCounter.value = 0;\r\n          syncCounter.value = 0;\r\n          if (ignore)\r\n            return;\r\n          filteredCb(...args);\r\n        },\r\n        watchOptions\r\n      )\r\n    );\r\n    stop = () => {\r\n      disposables.forEach((fn) => fn());\r\n    };\r\n  }\r\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\r\n}\r\n\r\nfunction watchImmediate(source, cb, options) {\r\n  return watch(\r\n    source,\r\n    cb,\r\n    {\r\n      ...options,\r\n      immediate: true\r\n    }\r\n  );\r\n}\r\n\r\nfunction watchOnce(source, cb, options) {\r\n  const stop = watch(source, (...args) => {\r\n    nextTick(() => stop());\r\n    return cb(...args);\r\n  }, options);\r\n  return stop;\r\n}\r\n\r\nfunction watchThrottled(source, cb, options = {}) {\r\n  const {\r\n    throttle = 0,\r\n    trailing = true,\r\n    leading = true,\r\n    ...watchOptions\r\n  } = options;\r\n  return watchWithFilter(\r\n    source,\r\n    cb,\r\n    {\r\n      ...watchOptions,\r\n      eventFilter: throttleFilter(throttle, trailing, leading)\r\n    }\r\n  );\r\n}\r\n\r\nfunction watchTriggerable(source, cb, options = {}) {\r\n  let cleanupFn;\r\n  function onEffect() {\r\n    if (!cleanupFn)\r\n      return;\r\n    const fn = cleanupFn;\r\n    cleanupFn = void 0;\r\n    fn();\r\n  }\r\n  function onCleanup(callback) {\r\n    cleanupFn = callback;\r\n  }\r\n  const _cb = (value, oldValue) => {\r\n    onEffect();\r\n    return cb(value, oldValue, onCleanup);\r\n  };\r\n  const res = watchIgnorable(source, _cb, options);\r\n  const { ignoreUpdates } = res;\r\n  const trigger = () => {\r\n    let res2;\r\n    ignoreUpdates(() => {\r\n      res2 = _cb(getWatchSources(source), getOldValue(source));\r\n    });\r\n    return res2;\r\n  };\r\n  return {\r\n    ...res,\r\n    trigger\r\n  };\r\n}\r\nfunction getWatchSources(sources) {\r\n  if (isReactive(sources))\r\n    return sources;\r\n  if (Array.isArray(sources))\r\n    return sources.map((item) => toValue$1(item));\r\n  return toValue$1(sources);\r\n}\r\nfunction getOldValue(source) {\r\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\r\n}\r\n\r\nfunction whenever(source, cb, options) {\r\n  const stop = watch(\r\n    source,\r\n    (v, ov, onInvalidate) => {\r\n      if (v) {\r\n        if (options == null ? void 0 : options.once)\r\n          nextTick(() => stop());\r\n        cb(v, ov, onInvalidate);\r\n      }\r\n    },\r\n    {\r\n      ...options,\r\n      once: false\r\n    }\r\n  );\r\n  return stop;\r\n}\r\n\r\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createRef, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, pxValue, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toArray, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\r\n", "import { noop, makeDestructurable, camelize, isClient, toArray, watchImmediate, isObject, tryOnScopeDispose, isIOS, notNullish, tryOnMounted, objectOmit, promiseTimeout, until, injectLocal, provideLocal, pxValue, increaseWithUnit, objectEntries, createRef, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, useIntervalFn, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, bypassFilter, createFilterWrapper, toRefs, watchOnce, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, tryOnUnmounted, clamp, syncRef, objectPick, watchWithFilter, identity, isDef, whenever, isWorker } from '@vueuse/shared';\r\nexport * from '@vueuse/shared';\r\nimport { isRef, shallowRef, ref, watchEffect, computed, inject, defineComponent, h, TransitionGroup, shallowReactive, Fragment, toValue, unref, getCurrentInstance, onMounted, watch, customRef, onUpdated, readonly, reactive, hasInjectionContext, toRaw, nextTick, markRaw, getCurrentScope, isReadonly, onBeforeUpdate } from 'vue';\r\n\r\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\r\n  let options;\r\n  if (isRef(optionsOrRef)) {\r\n    options = {\r\n      evaluating: optionsOrRef\r\n    };\r\n  } else {\r\n    options = optionsOrRef || {};\r\n  }\r\n  const {\r\n    lazy = false,\r\n    evaluating = void 0,\r\n    shallow = true,\r\n    onError = noop\r\n  } = options;\r\n  const started = shallowRef(!lazy);\r\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\r\n  let counter = 0;\r\n  watchEffect(async (onInvalidate) => {\r\n    if (!started.value)\r\n      return;\r\n    counter++;\r\n    const counterAtBeginning = counter;\r\n    let hasFinished = false;\r\n    if (evaluating) {\r\n      Promise.resolve().then(() => {\r\n        evaluating.value = true;\r\n      });\r\n    }\r\n    try {\r\n      const result = await evaluationCallback((cancelCallback) => {\r\n        onInvalidate(() => {\r\n          if (evaluating)\r\n            evaluating.value = false;\r\n          if (!hasFinished)\r\n            cancelCallback();\r\n        });\r\n      });\r\n      if (counterAtBeginning === counter)\r\n        current.value = result;\r\n    } catch (e) {\r\n      onError(e);\r\n    } finally {\r\n      if (evaluating && counterAtBeginning === counter)\r\n        evaluating.value = false;\r\n      hasFinished = true;\r\n    }\r\n  });\r\n  if (lazy) {\r\n    return computed(() => {\r\n      started.value = true;\r\n      return current.value;\r\n    });\r\n  } else {\r\n    return current;\r\n  }\r\n}\r\n\r\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\r\n  let source = inject(key);\r\n  if (defaultSource)\r\n    source = inject(key, defaultSource);\r\n  if (treatDefaultAsFactory)\r\n    source = inject(key, defaultSource, treatDefaultAsFactory);\r\n  if (typeof options === \"function\") {\r\n    return computed((ctx) => options(source, ctx));\r\n  } else {\r\n    return computed({\r\n      get: (ctx) => options.get(source, ctx),\r\n      set: options.set\r\n    });\r\n  }\r\n}\r\n\r\nfunction createReusableTemplate(options = {}) {\r\n  const {\r\n    inheritAttrs = true\r\n  } = options;\r\n  const render = shallowRef();\r\n  const define = /*@__PURE__*/ defineComponent({\r\n    setup(_, { slots }) {\r\n      return () => {\r\n        render.value = slots.default;\r\n      };\r\n    }\r\n  });\r\n  const reuse = /*@__PURE__*/ defineComponent({\r\n    inheritAttrs,\r\n    props: options.props,\r\n    setup(props, { attrs, slots }) {\r\n      return () => {\r\n        var _a;\r\n        if (!render.value && process.env.NODE_ENV !== \"production\")\r\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\r\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, {\r\n          ...options.props == null ? keysToCamelKebabCase(attrs) : props,\r\n          $slots: slots\r\n        });\r\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\r\n      };\r\n    }\r\n  });\r\n  return makeDestructurable(\r\n    { define, reuse },\r\n    [define, reuse]\r\n  );\r\n}\r\nfunction keysToCamelKebabCase(obj) {\r\n  const newObj = {};\r\n  for (const key in obj)\r\n    newObj[camelize(key)] = obj[key];\r\n  return newObj;\r\n}\r\n\r\nfunction createTemplatePromise(options = {}) {\r\n  let index = 0;\r\n  const instances = ref([]);\r\n  function create(...args) {\r\n    const props = shallowReactive({\r\n      key: index++,\r\n      args,\r\n      promise: void 0,\r\n      resolve: () => {\r\n      },\r\n      reject: () => {\r\n      },\r\n      isResolving: false,\r\n      options\r\n    });\r\n    instances.value.push(props);\r\n    props.promise = new Promise((_resolve, _reject) => {\r\n      props.resolve = (v) => {\r\n        props.isResolving = true;\r\n        return _resolve(v);\r\n      };\r\n      props.reject = _reject;\r\n    }).finally(() => {\r\n      props.promise = void 0;\r\n      const index2 = instances.value.indexOf(props);\r\n      if (index2 !== -1)\r\n        instances.value.splice(index2, 1);\r\n    });\r\n    return props.promise;\r\n  }\r\n  function start(...args) {\r\n    if (options.singleton && instances.value.length > 0)\r\n      return instances.value[0].promise;\r\n    return create(...args);\r\n  }\r\n  const component = /*@__PURE__*/ defineComponent((_, { slots }) => {\r\n    const renderList = () => instances.value.map((props) => {\r\n      var _a;\r\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\r\n    });\r\n    if (options.transition)\r\n      return () => h(TransitionGroup, options.transition, renderList);\r\n    return renderList;\r\n  });\r\n  component.start = start;\r\n  return component;\r\n}\r\n\r\nfunction createUnrefFn(fn) {\r\n  return function(...args) {\r\n    return fn.apply(this, args.map((i) => toValue(i)));\r\n  };\r\n}\r\n\r\nconst defaultWindow = isClient ? window : void 0;\r\nconst defaultDocument = isClient ? window.document : void 0;\r\nconst defaultNavigator = isClient ? window.navigator : void 0;\r\nconst defaultLocation = isClient ? window.location : void 0;\r\n\r\nfunction unrefElement(elRef) {\r\n  var _a;\r\n  const plain = toValue(elRef);\r\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\r\n}\r\n\r\nfunction useEventListener(...args) {\r\n  const cleanups = [];\r\n  const cleanup = () => {\r\n    cleanups.forEach((fn) => fn());\r\n    cleanups.length = 0;\r\n  };\r\n  const register = (el, event, listener, options) => {\r\n    el.addEventListener(event, listener, options);\r\n    return () => el.removeEventListener(event, listener, options);\r\n  };\r\n  const firstParamTargets = computed(() => {\r\n    const test = toArray(toValue(args[0])).filter((e) => e != null);\r\n    return test.every((e) => typeof e !== \"string\") ? test : void 0;\r\n  });\r\n  const stopWatch = watchImmediate(\r\n    () => {\r\n      var _a, _b;\r\n      return [\r\n        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),\r\n        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),\r\n        toArray(unref(firstParamTargets.value ? args[2] : args[1])),\r\n        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains\r\n        toValue(firstParamTargets.value ? args[3] : args[2])\r\n      ];\r\n    },\r\n    ([raw_targets, raw_events, raw_listeners, raw_options]) => {\r\n      cleanup();\r\n      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))\r\n        return;\r\n      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;\r\n      cleanups.push(\r\n        ...raw_targets.flatMap(\r\n          (el) => raw_events.flatMap(\r\n            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))\r\n          )\r\n        )\r\n      );\r\n    },\r\n    { flush: \"post\" }\r\n  );\r\n  const stop = () => {\r\n    stopWatch();\r\n    cleanup();\r\n  };\r\n  tryOnScopeDispose(cleanup);\r\n  return stop;\r\n}\r\n\r\nlet _iOSWorkaround = false;\r\nfunction onClickOutside(target, handler, options = {}) {\r\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;\r\n  if (!window) {\r\n    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;\r\n  }\r\n  if (isIOS && !_iOSWorkaround) {\r\n    _iOSWorkaround = true;\r\n    const listenerOptions = { passive: true };\r\n    Array.from(window.document.body.children).forEach((el) => useEventListener(el, \"click\", noop, listenerOptions));\r\n    useEventListener(window.document.documentElement, \"click\", noop, listenerOptions);\r\n  }\r\n  let shouldListen = true;\r\n  const shouldIgnore = (event) => {\r\n    return toValue(ignore).some((target2) => {\r\n      if (typeof target2 === \"string\") {\r\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\r\n      } else {\r\n        const el = unrefElement(target2);\r\n        return el && (event.target === el || event.composedPath().includes(el));\r\n      }\r\n    });\r\n  };\r\n  function hasMultipleRoots(target2) {\r\n    const vm = toValue(target2);\r\n    return vm && vm.$.subTree.shapeFlag === 16;\r\n  }\r\n  function checkMultipleRoots(target2, event) {\r\n    const vm = toValue(target2);\r\n    const children = vm.$.subTree && vm.$.subTree.children;\r\n    if (children == null || !Array.isArray(children))\r\n      return false;\r\n    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));\r\n  }\r\n  const listener = (event) => {\r\n    const el = unrefElement(target);\r\n    if (event.target == null)\r\n      return;\r\n    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))\r\n      return;\r\n    if (!el || el === event.target || event.composedPath().includes(el))\r\n      return;\r\n    if (\"detail\" in event && event.detail === 0)\r\n      shouldListen = !shouldIgnore(event);\r\n    if (!shouldListen) {\r\n      shouldListen = true;\r\n      return;\r\n    }\r\n    handler(event);\r\n  };\r\n  let isProcessingClick = false;\r\n  const cleanup = [\r\n    useEventListener(window, \"click\", (event) => {\r\n      if (!isProcessingClick) {\r\n        isProcessingClick = true;\r\n        setTimeout(() => {\r\n          isProcessingClick = false;\r\n        }, 0);\r\n        listener(event);\r\n      }\r\n    }, { passive: true, capture }),\r\n    useEventListener(window, \"pointerdown\", (e) => {\r\n      const el = unrefElement(target);\r\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\r\n    }, { passive: true }),\r\n    detectIframe && useEventListener(window, \"blur\", (event) => {\r\n      setTimeout(() => {\r\n        var _a;\r\n        const el = unrefElement(target);\r\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\r\n          handler(event);\r\n        }\r\n      }, 0);\r\n    }, { passive: true })\r\n  ].filter(Boolean);\r\n  const stop = () => cleanup.forEach((fn) => fn());\r\n  if (controls) {\r\n    return {\r\n      stop,\r\n      cancel: () => {\r\n        shouldListen = false;\r\n      },\r\n      trigger: (event) => {\r\n        shouldListen = true;\r\n        listener(event);\r\n        shouldListen = false;\r\n      }\r\n    };\r\n  }\r\n  return stop;\r\n}\r\n\r\nfunction useMounted() {\r\n  const isMounted = shallowRef(false);\r\n  const instance = getCurrentInstance();\r\n  if (instance) {\r\n    onMounted(() => {\r\n      isMounted.value = true;\r\n    }, instance);\r\n  }\r\n  return isMounted;\r\n}\r\n\r\nfunction useSupported(callback) {\r\n  const isMounted = useMounted();\r\n  return computed(() => {\r\n    isMounted.value;\r\n    return Boolean(callback());\r\n  });\r\n}\r\n\r\nfunction useMutationObserver(target, callback, options = {}) {\r\n  const { window = defaultWindow, ...mutationOptions } = options;\r\n  let observer;\r\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\r\n  const cleanup = () => {\r\n    if (observer) {\r\n      observer.disconnect();\r\n      observer = void 0;\r\n    }\r\n  };\r\n  const targets = computed(() => {\r\n    const value = toValue(target);\r\n    const items = toArray(value).map(unrefElement).filter(notNullish);\r\n    return new Set(items);\r\n  });\r\n  const stopWatch = watch(\r\n    () => targets.value,\r\n    (targets2) => {\r\n      cleanup();\r\n      if (isSupported.value && targets2.size) {\r\n        observer = new MutationObserver(callback);\r\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\r\n      }\r\n    },\r\n    { immediate: true, flush: \"post\" }\r\n  );\r\n  const takeRecords = () => {\r\n    return observer == null ? void 0 : observer.takeRecords();\r\n  };\r\n  const stop = () => {\r\n    stopWatch();\r\n    cleanup();\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isSupported,\r\n    stop,\r\n    takeRecords\r\n  };\r\n}\r\n\r\nfunction onElementRemoval(target, callback, options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    document = window == null ? void 0 : window.document,\r\n    flush = \"sync\"\r\n  } = options;\r\n  if (!window || !document)\r\n    return noop;\r\n  let stopFn;\r\n  const cleanupAndUpdate = (fn) => {\r\n    stopFn == null ? void 0 : stopFn();\r\n    stopFn = fn;\r\n  };\r\n  const stopWatch = watchEffect(() => {\r\n    const el = unrefElement(target);\r\n    if (el) {\r\n      const { stop } = useMutationObserver(\r\n        document,\r\n        (mutationsList) => {\r\n          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));\r\n          if (targetRemoved) {\r\n            callback(mutationsList);\r\n          }\r\n        },\r\n        {\r\n          window,\r\n          childList: true,\r\n          subtree: true\r\n        }\r\n      );\r\n      cleanupAndUpdate(stop);\r\n    }\r\n  }, { flush });\r\n  const stopHandle = () => {\r\n    stopWatch();\r\n    cleanupAndUpdate();\r\n  };\r\n  tryOnScopeDispose(stopHandle);\r\n  return stopHandle;\r\n}\r\n\r\nfunction createKeyPredicate(keyFilter) {\r\n  if (typeof keyFilter === \"function\")\r\n    return keyFilter;\r\n  else if (typeof keyFilter === \"string\")\r\n    return (event) => event.key === keyFilter;\r\n  else if (Array.isArray(keyFilter))\r\n    return (event) => keyFilter.includes(event.key);\r\n  return () => true;\r\n}\r\nfunction onKeyStroke(...args) {\r\n  let key;\r\n  let handler;\r\n  let options = {};\r\n  if (args.length === 3) {\r\n    key = args[0];\r\n    handler = args[1];\r\n    options = args[2];\r\n  } else if (args.length === 2) {\r\n    if (typeof args[1] === \"object\") {\r\n      key = true;\r\n      handler = args[0];\r\n      options = args[1];\r\n    } else {\r\n      key = args[0];\r\n      handler = args[1];\r\n    }\r\n  } else {\r\n    key = true;\r\n    handler = args[0];\r\n  }\r\n  const {\r\n    target = defaultWindow,\r\n    eventName = \"keydown\",\r\n    passive = false,\r\n    dedupe = false\r\n  } = options;\r\n  const predicate = createKeyPredicate(key);\r\n  const listener = (e) => {\r\n    if (e.repeat && toValue(dedupe))\r\n      return;\r\n    if (predicate(e))\r\n      handler(e);\r\n  };\r\n  return useEventListener(target, eventName, listener, passive);\r\n}\r\nfunction onKeyDown(key, handler, options = {}) {\r\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\r\n}\r\nfunction onKeyPressed(key, handler, options = {}) {\r\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\r\n}\r\nfunction onKeyUp(key, handler, options = {}) {\r\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\r\n}\r\n\r\nconst DEFAULT_DELAY = 500;\r\nconst DEFAULT_THRESHOLD = 10;\r\nfunction onLongPress(target, handler, options) {\r\n  var _a, _b;\r\n  const elementRef = computed(() => unrefElement(target));\r\n  let timeout;\r\n  let posStart;\r\n  let startTimestamp;\r\n  let hasLongPressed = false;\r\n  function clear() {\r\n    if (timeout) {\r\n      clearTimeout(timeout);\r\n      timeout = void 0;\r\n    }\r\n    posStart = void 0;\r\n    startTimestamp = void 0;\r\n    hasLongPressed = false;\r\n  }\r\n  function onRelease(ev) {\r\n    var _a2, _b2, _c;\r\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\r\n    clear();\r\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\r\n      return;\r\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\r\n      return;\r\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\r\n      ev.preventDefault();\r\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\r\n      ev.stopPropagation();\r\n    const dx = ev.x - _posStart.x;\r\n    const dy = ev.y - _posStart.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\r\n  }\r\n  function onDown(ev) {\r\n    var _a2, _b2, _c, _d;\r\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\r\n      return;\r\n    clear();\r\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\r\n      ev.preventDefault();\r\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\r\n      ev.stopPropagation();\r\n    posStart = {\r\n      x: ev.x,\r\n      y: ev.y\r\n    };\r\n    startTimestamp = ev.timeStamp;\r\n    timeout = setTimeout(\r\n      () => {\r\n        hasLongPressed = true;\r\n        handler(ev);\r\n      },\r\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\r\n    );\r\n  }\r\n  function onMove(ev) {\r\n    var _a2, _b2, _c, _d;\r\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\r\n      return;\r\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\r\n      return;\r\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\r\n      ev.preventDefault();\r\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\r\n      ev.stopPropagation();\r\n    const dx = ev.x - posStart.x;\r\n    const dy = ev.y - posStart.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\r\n      clear();\r\n  }\r\n  const listenerOptions = {\r\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\r\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\r\n  };\r\n  const cleanup = [\r\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\r\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\r\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\r\n  ];\r\n  const stop = () => cleanup.forEach((fn) => fn());\r\n  return stop;\r\n}\r\n\r\nfunction isFocusedElementEditable() {\r\n  const { activeElement, body } = document;\r\n  if (!activeElement)\r\n    return false;\r\n  if (activeElement === body)\r\n    return false;\r\n  switch (activeElement.tagName) {\r\n    case \"INPUT\":\r\n    case \"TEXTAREA\":\r\n      return true;\r\n  }\r\n  return activeElement.hasAttribute(\"contenteditable\");\r\n}\r\nfunction isTypedCharValid({\r\n  keyCode,\r\n  metaKey,\r\n  ctrlKey,\r\n  altKey\r\n}) {\r\n  if (metaKey || ctrlKey || altKey)\r\n    return false;\r\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\r\n    return true;\r\n  if (keyCode >= 65 && keyCode <= 90)\r\n    return true;\r\n  return false;\r\n}\r\nfunction onStartTyping(callback, options = {}) {\r\n  const { document: document2 = defaultDocument } = options;\r\n  const keydown = (event) => {\r\n    if (!isFocusedElementEditable() && isTypedCharValid(event)) {\r\n      callback(event);\r\n    }\r\n  };\r\n  if (document2)\r\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\r\n}\r\n\r\nfunction templateRef(key, initialValue = null) {\r\n  const instance = getCurrentInstance();\r\n  let _trigger = () => {\r\n  };\r\n  const element = customRef((track, trigger) => {\r\n    _trigger = trigger;\r\n    return {\r\n      get() {\r\n        var _a, _b;\r\n        track();\r\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\r\n      },\r\n      set() {\r\n      }\r\n    };\r\n  });\r\n  tryOnMounted(_trigger);\r\n  onUpdated(_trigger);\r\n  return element;\r\n}\r\n\r\nfunction useActiveElement(options = {}) {\r\n  var _a;\r\n  const {\r\n    window = defaultWindow,\r\n    deep = true,\r\n    triggerOnRemoval = false\r\n  } = options;\r\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\r\n  const getDeepActiveElement = () => {\r\n    var _a2;\r\n    let element = document == null ? void 0 : document.activeElement;\r\n    if (deep) {\r\n      while (element == null ? void 0 : element.shadowRoot)\r\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\r\n    }\r\n    return element;\r\n  };\r\n  const activeElement = shallowRef();\r\n  const trigger = () => {\r\n    activeElement.value = getDeepActiveElement();\r\n  };\r\n  if (window) {\r\n    const listenerOptions = {\r\n      capture: true,\r\n      passive: true\r\n    };\r\n    useEventListener(\r\n      window,\r\n      \"blur\",\r\n      (event) => {\r\n        if (event.relatedTarget !== null)\r\n          return;\r\n        trigger();\r\n      },\r\n      listenerOptions\r\n    );\r\n    useEventListener(\r\n      window,\r\n      \"focus\",\r\n      trigger,\r\n      listenerOptions\r\n    );\r\n  }\r\n  if (triggerOnRemoval) {\r\n    onElementRemoval(activeElement, trigger, { document });\r\n  }\r\n  trigger();\r\n  return activeElement;\r\n}\r\n\r\nfunction useRafFn(fn, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    fpsLimit = void 0,\r\n    window = defaultWindow,\r\n    once = false\r\n  } = options;\r\n  const isActive = shallowRef(false);\r\n  const intervalLimit = computed(() => {\r\n    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;\r\n  });\r\n  let previousFrameTimestamp = 0;\r\n  let rafId = null;\r\n  function loop(timestamp) {\r\n    if (!isActive.value || !window)\r\n      return;\r\n    if (!previousFrameTimestamp)\r\n      previousFrameTimestamp = timestamp;\r\n    const delta = timestamp - previousFrameTimestamp;\r\n    if (intervalLimit.value && delta < intervalLimit.value) {\r\n      rafId = window.requestAnimationFrame(loop);\r\n      return;\r\n    }\r\n    previousFrameTimestamp = timestamp;\r\n    fn({ delta, timestamp });\r\n    if (once) {\r\n      isActive.value = false;\r\n      rafId = null;\r\n      return;\r\n    }\r\n    rafId = window.requestAnimationFrame(loop);\r\n  }\r\n  function resume() {\r\n    if (!isActive.value && window) {\r\n      isActive.value = true;\r\n      previousFrameTimestamp = 0;\r\n      rafId = window.requestAnimationFrame(loop);\r\n    }\r\n  }\r\n  function pause() {\r\n    isActive.value = false;\r\n    if (rafId != null && window) {\r\n      window.cancelAnimationFrame(rafId);\r\n      rafId = null;\r\n    }\r\n  }\r\n  if (immediate)\r\n    resume();\r\n  tryOnScopeDispose(pause);\r\n  return {\r\n    isActive: readonly(isActive),\r\n    pause,\r\n    resume\r\n  };\r\n}\r\n\r\nfunction useAnimate(target, keyframes, options) {\r\n  let config;\r\n  let animateOptions;\r\n  if (isObject(options)) {\r\n    config = options;\r\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\r\n  } else {\r\n    config = { duration: options };\r\n    animateOptions = options;\r\n  }\r\n  const {\r\n    window = defaultWindow,\r\n    immediate = true,\r\n    commitStyles,\r\n    persist,\r\n    playbackRate: _playbackRate = 1,\r\n    onReady,\r\n    onError = (e) => {\r\n      console.error(e);\r\n    }\r\n  } = config;\r\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\r\n  const animate = shallowRef(void 0);\r\n  const store = shallowReactive({\r\n    startTime: null,\r\n    currentTime: null,\r\n    timeline: null,\r\n    playbackRate: _playbackRate,\r\n    pending: false,\r\n    playState: immediate ? \"idle\" : \"paused\",\r\n    replaceState: \"active\"\r\n  });\r\n  const pending = computed(() => store.pending);\r\n  const playState = computed(() => store.playState);\r\n  const replaceState = computed(() => store.replaceState);\r\n  const startTime = computed({\r\n    get() {\r\n      return store.startTime;\r\n    },\r\n    set(value) {\r\n      store.startTime = value;\r\n      if (animate.value)\r\n        animate.value.startTime = value;\r\n    }\r\n  });\r\n  const currentTime = computed({\r\n    get() {\r\n      return store.currentTime;\r\n    },\r\n    set(value) {\r\n      store.currentTime = value;\r\n      if (animate.value) {\r\n        animate.value.currentTime = value;\r\n        syncResume();\r\n      }\r\n    }\r\n  });\r\n  const timeline = computed({\r\n    get() {\r\n      return store.timeline;\r\n    },\r\n    set(value) {\r\n      store.timeline = value;\r\n      if (animate.value)\r\n        animate.value.timeline = value;\r\n    }\r\n  });\r\n  const playbackRate = computed({\r\n    get() {\r\n      return store.playbackRate;\r\n    },\r\n    set(value) {\r\n      store.playbackRate = value;\r\n      if (animate.value)\r\n        animate.value.playbackRate = value;\r\n    }\r\n  });\r\n  const play = () => {\r\n    if (animate.value) {\r\n      try {\r\n        animate.value.play();\r\n        syncResume();\r\n      } catch (e) {\r\n        syncPause();\r\n        onError(e);\r\n      }\r\n    } else {\r\n      update();\r\n    }\r\n  };\r\n  const pause = () => {\r\n    var _a;\r\n    try {\r\n      (_a = animate.value) == null ? void 0 : _a.pause();\r\n      syncPause();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  };\r\n  const reverse = () => {\r\n    var _a;\r\n    if (!animate.value)\r\n      update();\r\n    try {\r\n      (_a = animate.value) == null ? void 0 : _a.reverse();\r\n      syncResume();\r\n    } catch (e) {\r\n      syncPause();\r\n      onError(e);\r\n    }\r\n  };\r\n  const finish = () => {\r\n    var _a;\r\n    try {\r\n      (_a = animate.value) == null ? void 0 : _a.finish();\r\n      syncPause();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  };\r\n  const cancel = () => {\r\n    var _a;\r\n    try {\r\n      (_a = animate.value) == null ? void 0 : _a.cancel();\r\n      syncPause();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  };\r\n  watch(() => unrefElement(target), (el) => {\r\n    if (el) {\r\n      update();\r\n    } else {\r\n      animate.value = void 0;\r\n    }\r\n  });\r\n  watch(() => keyframes, (value) => {\r\n    if (animate.value) {\r\n      update();\r\n      const targetEl = unrefElement(target);\r\n      if (targetEl) {\r\n        animate.value.effect = new KeyframeEffect(\r\n          targetEl,\r\n          toValue(value),\r\n          animateOptions\r\n        );\r\n      }\r\n    }\r\n  }, { deep: true });\r\n  tryOnMounted(() => update(true), false);\r\n  tryOnScopeDispose(cancel);\r\n  function update(init) {\r\n    const el = unrefElement(target);\r\n    if (!isSupported.value || !el)\r\n      return;\r\n    if (!animate.value)\r\n      animate.value = el.animate(toValue(keyframes), animateOptions);\r\n    if (persist)\r\n      animate.value.persist();\r\n    if (_playbackRate !== 1)\r\n      animate.value.playbackRate = _playbackRate;\r\n    if (init && !immediate)\r\n      animate.value.pause();\r\n    else\r\n      syncResume();\r\n    onReady == null ? void 0 : onReady(animate.value);\r\n  }\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause, listenerOptions);\r\n  useEventListener(animate, \"finish\", () => {\r\n    var _a;\r\n    if (commitStyles)\r\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\r\n  }, listenerOptions);\r\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\r\n    if (!animate.value)\r\n      return;\r\n    store.pending = animate.value.pending;\r\n    store.playState = animate.value.playState;\r\n    store.replaceState = animate.value.replaceState;\r\n    store.startTime = animate.value.startTime;\r\n    store.currentTime = animate.value.currentTime;\r\n    store.timeline = animate.value.timeline;\r\n    store.playbackRate = animate.value.playbackRate;\r\n  }, { immediate: false });\r\n  function syncResume() {\r\n    if (isSupported.value)\r\n      resumeRef();\r\n  }\r\n  function syncPause() {\r\n    if (isSupported.value && window)\r\n      window.requestAnimationFrame(pauseRef);\r\n  }\r\n  return {\r\n    isSupported,\r\n    animate,\r\n    // actions\r\n    play,\r\n    pause,\r\n    reverse,\r\n    finish,\r\n    cancel,\r\n    // state\r\n    pending,\r\n    playState,\r\n    replaceState,\r\n    startTime,\r\n    currentTime,\r\n    timeline,\r\n    playbackRate\r\n  };\r\n}\r\n\r\nfunction useAsyncQueue(tasks, options) {\r\n  const {\r\n    interrupt = true,\r\n    onError = noop,\r\n    onFinished = noop,\r\n    signal\r\n  } = options || {};\r\n  const promiseState = {\r\n    aborted: \"aborted\",\r\n    fulfilled: \"fulfilled\",\r\n    pending: \"pending\",\r\n    rejected: \"rejected\"\r\n  };\r\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\r\n  const result = reactive(initialResult);\r\n  const activeIndex = shallowRef(-1);\r\n  if (!tasks || tasks.length === 0) {\r\n    onFinished();\r\n    return {\r\n      activeIndex,\r\n      result\r\n    };\r\n  }\r\n  function updateResult(state, res) {\r\n    activeIndex.value++;\r\n    result[activeIndex.value].data = res;\r\n    result[activeIndex.value].state = state;\r\n  }\r\n  tasks.reduce((prev, curr) => {\r\n    return prev.then((prevRes) => {\r\n      var _a;\r\n      if (signal == null ? void 0 : signal.aborted) {\r\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\r\n        return;\r\n      }\r\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\r\n        onFinished();\r\n        return;\r\n      }\r\n      const done = curr(prevRes).then((currentRes) => {\r\n        updateResult(promiseState.fulfilled, currentRes);\r\n        if (activeIndex.value === tasks.length - 1)\r\n          onFinished();\r\n        return currentRes;\r\n      });\r\n      if (!signal)\r\n        return done;\r\n      return Promise.race([done, whenAborted(signal)]);\r\n    }).catch((e) => {\r\n      if (signal == null ? void 0 : signal.aborted) {\r\n        updateResult(promiseState.aborted, e);\r\n        return e;\r\n      }\r\n      updateResult(promiseState.rejected, e);\r\n      onError();\r\n      return e;\r\n    });\r\n  }, Promise.resolve());\r\n  return {\r\n    activeIndex,\r\n    result\r\n  };\r\n}\r\nfunction whenAborted(signal) {\r\n  return new Promise((resolve, reject) => {\r\n    const error = new Error(\"aborted\");\r\n    if (signal.aborted)\r\n      reject(error);\r\n    else\r\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\r\n  });\r\n}\r\n\r\nfunction useAsyncState(promise, initialState, options) {\r\n  const {\r\n    immediate = true,\r\n    delay = 0,\r\n    onError = noop,\r\n    onSuccess = noop,\r\n    resetOnExecute = true,\r\n    shallow = true,\r\n    throwError\r\n  } = options != null ? options : {};\r\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\r\n  const isReady = shallowRef(false);\r\n  const isLoading = shallowRef(false);\r\n  const error = shallowRef(void 0);\r\n  async function execute(delay2 = 0, ...args) {\r\n    if (resetOnExecute)\r\n      state.value = initialState;\r\n    error.value = void 0;\r\n    isReady.value = false;\r\n    isLoading.value = true;\r\n    if (delay2 > 0)\r\n      await promiseTimeout(delay2);\r\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\r\n    try {\r\n      const data = await _promise;\r\n      state.value = data;\r\n      isReady.value = true;\r\n      onSuccess(data);\r\n    } catch (e) {\r\n      error.value = e;\r\n      onError(e);\r\n      if (throwError)\r\n        throw e;\r\n    } finally {\r\n      isLoading.value = false;\r\n    }\r\n    return state.value;\r\n  }\r\n  if (immediate) {\r\n    execute(delay);\r\n  }\r\n  const shell = {\r\n    state,\r\n    isReady,\r\n    isLoading,\r\n    error,\r\n    execute\r\n  };\r\n  function waitUntilIsLoaded() {\r\n    return new Promise((resolve, reject) => {\r\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\r\n    });\r\n  }\r\n  return {\r\n    ...shell,\r\n    then(onFulfilled, onRejected) {\r\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\r\n    }\r\n  };\r\n}\r\n\r\nconst defaults = {\r\n  array: (v) => JSON.stringify(v),\r\n  object: (v) => JSON.stringify(v),\r\n  set: (v) => JSON.stringify(Array.from(v)),\r\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\r\n  null: () => \"\"\r\n};\r\nfunction getDefaultSerialization(target) {\r\n  if (!target)\r\n    return defaults.null;\r\n  if (target instanceof Map)\r\n    return defaults.map;\r\n  else if (target instanceof Set)\r\n    return defaults.set;\r\n  else if (Array.isArray(target))\r\n    return defaults.array;\r\n  else\r\n    return defaults.object;\r\n}\r\n\r\nfunction useBase64(target, options) {\r\n  const base64 = shallowRef(\"\");\r\n  const promise = shallowRef();\r\n  function execute() {\r\n    if (!isClient)\r\n      return;\r\n    promise.value = new Promise((resolve, reject) => {\r\n      try {\r\n        const _target = toValue(target);\r\n        if (_target == null) {\r\n          resolve(\"\");\r\n        } else if (typeof _target === \"string\") {\r\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\r\n        } else if (_target instanceof Blob) {\r\n          resolve(blobToBase64(_target));\r\n        } else if (_target instanceof ArrayBuffer) {\r\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\r\n        } else if (_target instanceof HTMLCanvasElement) {\r\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\r\n        } else if (_target instanceof HTMLImageElement) {\r\n          const img = _target.cloneNode(false);\r\n          img.crossOrigin = \"Anonymous\";\r\n          imgLoaded(img).then(() => {\r\n            const canvas = document.createElement(\"canvas\");\r\n            const ctx = canvas.getContext(\"2d\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\r\n          }).catch(reject);\r\n        } else if (typeof _target === \"object\") {\r\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\r\n          const serialized = _serializeFn(_target);\r\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\r\n        } else {\r\n          reject(new Error(\"target is unsupported types\"));\r\n        }\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n    promise.value.then((res) => {\r\n      base64.value = (options == null ? void 0 : options.dataUrl) === false ? res.replace(/^data:.*?;base64,/, \"\") : res;\r\n    });\r\n    return promise.value;\r\n  }\r\n  if (isRef(target) || typeof target === \"function\")\r\n    watch(target, execute, { immediate: true });\r\n  else\r\n    execute();\r\n  return {\r\n    base64,\r\n    promise,\r\n    execute\r\n  };\r\n}\r\nfunction imgLoaded(img) {\r\n  return new Promise((resolve, reject) => {\r\n    if (!img.complete) {\r\n      img.onload = () => {\r\n        resolve();\r\n      };\r\n      img.onerror = reject;\r\n    } else {\r\n      resolve();\r\n    }\r\n  });\r\n}\r\nfunction blobToBase64(blob) {\r\n  return new Promise((resolve, reject) => {\r\n    const fr = new FileReader();\r\n    fr.onload = (e) => {\r\n      resolve(e.target.result);\r\n    };\r\n    fr.onerror = reject;\r\n    fr.readAsDataURL(blob);\r\n  });\r\n}\r\n\r\nfunction useBattery(options = {}) {\r\n  const { navigator = defaultNavigator } = options;\r\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\r\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\r\n  const charging = shallowRef(false);\r\n  const chargingTime = shallowRef(0);\r\n  const dischargingTime = shallowRef(0);\r\n  const level = shallowRef(1);\r\n  let battery;\r\n  function updateBatteryInfo() {\r\n    charging.value = this.charging;\r\n    chargingTime.value = this.chargingTime || 0;\r\n    dischargingTime.value = this.dischargingTime || 0;\r\n    level.value = this.level;\r\n  }\r\n  if (isSupported.value) {\r\n    navigator.getBattery().then((_battery) => {\r\n      battery = _battery;\r\n      updateBatteryInfo.call(battery);\r\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\r\n    });\r\n  }\r\n  return {\r\n    isSupported,\r\n    charging,\r\n    chargingTime,\r\n    dischargingTime,\r\n    level\r\n  };\r\n}\r\n\r\nfunction useBluetooth(options) {\r\n  let {\r\n    acceptAllDevices = false\r\n  } = options || {};\r\n  const {\r\n    filters = void 0,\r\n    optionalServices = void 0,\r\n    navigator = defaultNavigator\r\n  } = options || {};\r\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\r\n  const device = shallowRef();\r\n  const error = shallowRef(null);\r\n  watch(device, () => {\r\n    connectToBluetoothGATTServer();\r\n  });\r\n  async function requestDevice() {\r\n    if (!isSupported.value)\r\n      return;\r\n    error.value = null;\r\n    if (filters && filters.length > 0)\r\n      acceptAllDevices = false;\r\n    try {\r\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\r\n        acceptAllDevices,\r\n        filters,\r\n        optionalServices\r\n      }));\r\n    } catch (err) {\r\n      error.value = err;\r\n    }\r\n  }\r\n  const server = shallowRef();\r\n  const isConnected = shallowRef(false);\r\n  function reset() {\r\n    isConnected.value = false;\r\n    device.value = void 0;\r\n    server.value = void 0;\r\n  }\r\n  async function connectToBluetoothGATTServer() {\r\n    error.value = null;\r\n    if (device.value && device.value.gatt) {\r\n      useEventListener(device, \"gattserverdisconnected\", reset, { passive: true });\r\n      try {\r\n        server.value = await device.value.gatt.connect();\r\n        isConnected.value = server.value.connected;\r\n      } catch (err) {\r\n        error.value = err;\r\n      }\r\n    }\r\n  }\r\n  tryOnMounted(() => {\r\n    var _a;\r\n    if (device.value)\r\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\r\n  });\r\n  tryOnScopeDispose(() => {\r\n    var _a;\r\n    if (device.value)\r\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\r\n  });\r\n  return {\r\n    isSupported,\r\n    isConnected: readonly(isConnected),\r\n    // Device:\r\n    device,\r\n    requestDevice,\r\n    // Server:\r\n    server,\r\n    // Errors:\r\n    error\r\n  };\r\n}\r\n\r\nconst ssrWidthSymbol = Symbol(\"vueuse-ssr-width\");\r\nfunction useSSRWidth() {\r\n  const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;\r\n  return typeof ssrWidth === \"number\" ? ssrWidth : void 0;\r\n}\r\nfunction provideSSRWidth(width, app) {\r\n  if (app !== void 0) {\r\n    app.provide(ssrWidthSymbol, width);\r\n  } else {\r\n    provideLocal(ssrWidthSymbol, width);\r\n  }\r\n}\r\n\r\nfunction useMediaQuery(query, options = {}) {\r\n  const { window = defaultWindow, ssrWidth = useSSRWidth() } = options;\r\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\r\n  const ssrSupport = shallowRef(typeof ssrWidth === \"number\");\r\n  const mediaQuery = shallowRef();\r\n  const matches = shallowRef(false);\r\n  const handler = (event) => {\r\n    matches.value = event.matches;\r\n  };\r\n  watchEffect(() => {\r\n    if (ssrSupport.value) {\r\n      ssrSupport.value = !isSupported.value;\r\n      const queryStrings = toValue(query).split(\",\");\r\n      matches.value = queryStrings.some((queryString) => {\r\n        const not = queryString.includes(\"not all\");\r\n        const minWidth = queryString.match(/\\(\\s*min-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\r\n        const maxWidth = queryString.match(/\\(\\s*max-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\r\n        let res = Boolean(minWidth || maxWidth);\r\n        if (minWidth && res) {\r\n          res = ssrWidth >= pxValue(minWidth[1]);\r\n        }\r\n        if (maxWidth && res) {\r\n          res = ssrWidth <= pxValue(maxWidth[1]);\r\n        }\r\n        return not ? !res : res;\r\n      });\r\n      return;\r\n    }\r\n    if (!isSupported.value)\r\n      return;\r\n    mediaQuery.value = window.matchMedia(toValue(query));\r\n    matches.value = mediaQuery.value.matches;\r\n  });\r\n  useEventListener(mediaQuery, \"change\", handler, { passive: true });\r\n  return computed(() => matches.value);\r\n}\r\n\r\nconst breakpointsTailwind = {\r\n  \"sm\": 640,\r\n  \"md\": 768,\r\n  \"lg\": 1024,\r\n  \"xl\": 1280,\r\n  \"2xl\": 1536\r\n};\r\nconst breakpointsBootstrapV5 = {\r\n  xs: 0,\r\n  sm: 576,\r\n  md: 768,\r\n  lg: 992,\r\n  xl: 1200,\r\n  xxl: 1400\r\n};\r\nconst breakpointsVuetifyV2 = {\r\n  xs: 0,\r\n  sm: 600,\r\n  md: 960,\r\n  lg: 1264,\r\n  xl: 1904\r\n};\r\nconst breakpointsVuetifyV3 = {\r\n  xs: 0,\r\n  sm: 600,\r\n  md: 960,\r\n  lg: 1280,\r\n  xl: 1920,\r\n  xxl: 2560\r\n};\r\nconst breakpointsVuetify = breakpointsVuetifyV2;\r\nconst breakpointsAntDesign = {\r\n  xs: 480,\r\n  sm: 576,\r\n  md: 768,\r\n  lg: 992,\r\n  xl: 1200,\r\n  xxl: 1600\r\n};\r\nconst breakpointsQuasar = {\r\n  xs: 0,\r\n  sm: 600,\r\n  md: 1024,\r\n  lg: 1440,\r\n  xl: 1920\r\n};\r\nconst breakpointsSematic = {\r\n  mobileS: 320,\r\n  mobileM: 375,\r\n  mobileL: 425,\r\n  tablet: 768,\r\n  laptop: 1024,\r\n  laptopL: 1440,\r\n  desktop4K: 2560\r\n};\r\nconst breakpointsMasterCss = {\r\n  \"3xs\": 360,\r\n  \"2xs\": 480,\r\n  \"xs\": 600,\r\n  \"sm\": 768,\r\n  \"md\": 1024,\r\n  \"lg\": 1280,\r\n  \"xl\": 1440,\r\n  \"2xl\": 1600,\r\n  \"3xl\": 1920,\r\n  \"4xl\": 2560\r\n};\r\nconst breakpointsPrimeFlex = {\r\n  sm: 576,\r\n  md: 768,\r\n  lg: 992,\r\n  xl: 1200\r\n};\r\nconst breakpointsElement = {\r\n  xs: 0,\r\n  sm: 768,\r\n  md: 992,\r\n  lg: 1200,\r\n  xl: 1920\r\n};\r\n\r\nfunction useBreakpoints(breakpoints, options = {}) {\r\n  function getValue(k, delta) {\r\n    let v = toValue(breakpoints[toValue(k)]);\r\n    if (delta != null)\r\n      v = increaseWithUnit(v, delta);\r\n    if (typeof v === \"number\")\r\n      v = `${v}px`;\r\n    return v;\r\n  }\r\n  const { window = defaultWindow, strategy = \"min-width\", ssrWidth = useSSRWidth() } = options;\r\n  const ssrSupport = typeof ssrWidth === \"number\";\r\n  const mounted = ssrSupport ? shallowRef(false) : { value: true };\r\n  if (ssrSupport) {\r\n    tryOnMounted(() => mounted.value = !!window);\r\n  }\r\n  function match(query, size) {\r\n    if (!mounted.value && ssrSupport) {\r\n      return query === \"min\" ? ssrWidth >= pxValue(size) : ssrWidth <= pxValue(size);\r\n    }\r\n    if (!window)\r\n      return false;\r\n    return window.matchMedia(`(${query}-width: ${size})`).matches;\r\n  }\r\n  const greaterOrEqual = (k) => {\r\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\r\n  };\r\n  const smallerOrEqual = (k) => {\r\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\r\n  };\r\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\r\n    Object.defineProperty(shortcuts, k, {\r\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    return shortcuts;\r\n  }, {});\r\n  function current() {\r\n    const points = Object.keys(breakpoints).map((k) => [k, shortcutMethods[k], pxValue(getValue(k))]).sort((a, b) => a[2] - b[2]);\r\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\r\n  }\r\n  return Object.assign(shortcutMethods, {\r\n    greaterOrEqual,\r\n    smallerOrEqual,\r\n    greater(k) {\r\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\r\n    },\r\n    smaller(k) {\r\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\r\n    },\r\n    between(a, b) {\r\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\r\n    },\r\n    isGreater(k) {\r\n      return match(\"min\", getValue(k, 0.1));\r\n    },\r\n    isGreaterOrEqual(k) {\r\n      return match(\"min\", getValue(k));\r\n    },\r\n    isSmaller(k) {\r\n      return match(\"max\", getValue(k, -0.1));\r\n    },\r\n    isSmallerOrEqual(k) {\r\n      return match(\"max\", getValue(k));\r\n    },\r\n    isInBetween(a, b) {\r\n      return match(\"min\", getValue(a)) && match(\"max\", getValue(b, -0.1));\r\n    },\r\n    current,\r\n    active() {\r\n      const bps = current();\r\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(strategy === \"min-width\" ? -1 : 0));\r\n    }\r\n  });\r\n}\r\n\r\nfunction useBroadcastChannel(options) {\r\n  const {\r\n    name,\r\n    window = defaultWindow\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\r\n  const isClosed = shallowRef(false);\r\n  const channel = ref();\r\n  const data = ref();\r\n  const error = shallowRef(null);\r\n  const post = (data2) => {\r\n    if (channel.value)\r\n      channel.value.postMessage(data2);\r\n  };\r\n  const close = () => {\r\n    if (channel.value)\r\n      channel.value.close();\r\n    isClosed.value = true;\r\n  };\r\n  if (isSupported.value) {\r\n    tryOnMounted(() => {\r\n      error.value = null;\r\n      channel.value = new BroadcastChannel(name);\r\n      const listenerOptions = {\r\n        passive: true\r\n      };\r\n      useEventListener(channel, \"message\", (e) => {\r\n        data.value = e.data;\r\n      }, listenerOptions);\r\n      useEventListener(channel, \"messageerror\", (e) => {\r\n        error.value = e;\r\n      }, listenerOptions);\r\n      useEventListener(channel, \"close\", () => {\r\n        isClosed.value = true;\r\n      }, listenerOptions);\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    close();\r\n  });\r\n  return {\r\n    isSupported,\r\n    channel,\r\n    data,\r\n    post,\r\n    close,\r\n    error,\r\n    isClosed\r\n  };\r\n}\r\n\r\nconst WRITABLE_PROPERTIES = [\r\n  \"hash\",\r\n  \"host\",\r\n  \"hostname\",\r\n  \"href\",\r\n  \"pathname\",\r\n  \"port\",\r\n  \"protocol\",\r\n  \"search\"\r\n];\r\nfunction useBrowserLocation(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const refs = Object.fromEntries(\r\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\r\n  );\r\n  for (const [key, ref] of objectEntries(refs)) {\r\n    watch(ref, (value) => {\r\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\r\n        return;\r\n      window.location[key] = value;\r\n    });\r\n  }\r\n  const buildState = (trigger) => {\r\n    var _a;\r\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\r\n    const { origin } = (window == null ? void 0 : window.location) || {};\r\n    for (const key of WRITABLE_PROPERTIES)\r\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\r\n    return reactive({\r\n      trigger,\r\n      state: state2,\r\n      length,\r\n      origin,\r\n      ...refs\r\n    });\r\n  };\r\n  const state = ref(buildState(\"load\"));\r\n  if (window) {\r\n    const listenerOptions = { passive: true };\r\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), listenerOptions);\r\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), listenerOptions);\r\n  }\r\n  return state;\r\n}\r\n\r\nfunction useCached(refValue, comparator = (a, b) => a === b, options) {\r\n  const { deepRefs = true, ...watchOptions } = options || {};\r\n  const cachedValue = createRef(refValue.value, deepRefs);\r\n  watch(() => refValue.value, (value) => {\r\n    if (!comparator(value, cachedValue.value))\r\n      cachedValue.value = value;\r\n  }, watchOptions);\r\n  return cachedValue;\r\n}\r\n\r\nfunction usePermission(permissionDesc, options = {}) {\r\n  const {\r\n    controls = false,\r\n    navigator = defaultNavigator\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\r\n  const permissionStatus = shallowRef();\r\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\r\n  const state = shallowRef();\r\n  const update = () => {\r\n    var _a, _b;\r\n    state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : \"prompt\";\r\n  };\r\n  useEventListener(permissionStatus, \"change\", update, { passive: true });\r\n  const query = createSingletonPromise(async () => {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (!permissionStatus.value) {\r\n      try {\r\n        permissionStatus.value = await navigator.permissions.query(desc);\r\n      } catch (e) {\r\n        permissionStatus.value = void 0;\r\n      } finally {\r\n        update();\r\n      }\r\n    }\r\n    if (controls)\r\n      return toRaw(permissionStatus.value);\r\n  });\r\n  query();\r\n  if (controls) {\r\n    return {\r\n      state,\r\n      isSupported,\r\n      query\r\n    };\r\n  } else {\r\n    return state;\r\n  }\r\n}\r\n\r\nfunction useClipboard(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    read = false,\r\n    source,\r\n    copiedDuring = 1500,\r\n    legacy = false\r\n  } = options;\r\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\r\n  const permissionRead = usePermission(\"clipboard-read\");\r\n  const permissionWrite = usePermission(\"clipboard-write\");\r\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\r\n  const text = shallowRef(\"\");\r\n  const copied = shallowRef(false);\r\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\r\n  async function updateText() {\r\n    let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));\r\n    if (!useLegacy) {\r\n      try {\r\n        text.value = await navigator.clipboard.readText();\r\n      } catch (e) {\r\n        useLegacy = true;\r\n      }\r\n    }\r\n    if (useLegacy) {\r\n      text.value = legacyRead();\r\n    }\r\n  }\r\n  if (isSupported.value && read)\r\n    useEventListener([\"copy\", \"cut\"], updateText, { passive: true });\r\n  async function copy(value = toValue(source)) {\r\n    if (isSupported.value && value != null) {\r\n      let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));\r\n      if (!useLegacy) {\r\n        try {\r\n          await navigator.clipboard.writeText(value);\r\n        } catch (e) {\r\n          useLegacy = true;\r\n        }\r\n      }\r\n      if (useLegacy)\r\n        legacyCopy(value);\r\n      text.value = value;\r\n      copied.value = true;\r\n      timeout.start();\r\n    }\r\n  }\r\n  function legacyCopy(value) {\r\n    const ta = document.createElement(\"textarea\");\r\n    ta.value = value != null ? value : \"\";\r\n    ta.style.position = \"absolute\";\r\n    ta.style.opacity = \"0\";\r\n    document.body.appendChild(ta);\r\n    ta.select();\r\n    document.execCommand(\"copy\");\r\n    ta.remove();\r\n  }\r\n  function legacyRead() {\r\n    var _a, _b, _c;\r\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\r\n  }\r\n  function isAllowed(status) {\r\n    return status === \"granted\" || status === \"prompt\";\r\n  }\r\n  return {\r\n    isSupported,\r\n    text,\r\n    copied,\r\n    copy\r\n  };\r\n}\r\n\r\nfunction useClipboardItems(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    read = false,\r\n    source,\r\n    copiedDuring = 1500\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\r\n  const content = ref([]);\r\n  const copied = shallowRef(false);\r\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\r\n  function updateContent() {\r\n    if (isSupported.value) {\r\n      navigator.clipboard.read().then((items) => {\r\n        content.value = items;\r\n      });\r\n    }\r\n  }\r\n  if (isSupported.value && read)\r\n    useEventListener([\"copy\", \"cut\"], updateContent, { passive: true });\r\n  async function copy(value = toValue(source)) {\r\n    if (isSupported.value && value != null) {\r\n      await navigator.clipboard.write(value);\r\n      content.value = value;\r\n      copied.value = true;\r\n      timeout.start();\r\n    }\r\n  }\r\n  return {\r\n    isSupported,\r\n    content,\r\n    copied,\r\n    copy\r\n  };\r\n}\r\n\r\nfunction cloneFnJSON(source) {\r\n  return JSON.parse(JSON.stringify(source));\r\n}\r\nfunction useCloned(source, options = {}) {\r\n  const cloned = ref({});\r\n  const isModified = shallowRef(false);\r\n  let _lastSync = false;\r\n  const {\r\n    manual,\r\n    clone = cloneFnJSON,\r\n    // watch options\r\n    deep = true,\r\n    immediate = true\r\n  } = options;\r\n  watch(cloned, () => {\r\n    if (_lastSync) {\r\n      _lastSync = false;\r\n      return;\r\n    }\r\n    isModified.value = true;\r\n  }, {\r\n    deep: true,\r\n    flush: \"sync\"\r\n  });\r\n  function sync() {\r\n    _lastSync = true;\r\n    isModified.value = false;\r\n    cloned.value = clone(toValue(source));\r\n  }\r\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\r\n    watch(source, sync, {\r\n      ...options,\r\n      deep,\r\n      immediate\r\n    });\r\n  } else {\r\n    sync();\r\n  }\r\n  return { cloned, isModified, sync };\r\n}\r\n\r\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\r\nconst globalKey = \"__vueuse_ssr_handlers__\";\r\nconst handlers = /* @__PURE__ */ getHandlers();\r\nfunction getHandlers() {\r\n  if (!(globalKey in _global))\r\n    _global[globalKey] = _global[globalKey] || {};\r\n  return _global[globalKey];\r\n}\r\nfunction getSSRHandler(key, fallback) {\r\n  return handlers[key] || fallback;\r\n}\r\nfunction setSSRHandler(key, fn) {\r\n  handlers[key] = fn;\r\n}\r\n\r\nfunction usePreferredDark(options) {\r\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\r\n}\r\n\r\nfunction guessSerializerType(rawInit) {\r\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\r\n}\r\n\r\nconst StorageSerializers = {\r\n  boolean: {\r\n    read: (v) => v === \"true\",\r\n    write: (v) => String(v)\r\n  },\r\n  object: {\r\n    read: (v) => JSON.parse(v),\r\n    write: (v) => JSON.stringify(v)\r\n  },\r\n  number: {\r\n    read: (v) => Number.parseFloat(v),\r\n    write: (v) => String(v)\r\n  },\r\n  any: {\r\n    read: (v) => v,\r\n    write: (v) => String(v)\r\n  },\r\n  string: {\r\n    read: (v) => v,\r\n    write: (v) => String(v)\r\n  },\r\n  map: {\r\n    read: (v) => new Map(JSON.parse(v)),\r\n    write: (v) => JSON.stringify(Array.from(v.entries()))\r\n  },\r\n  set: {\r\n    read: (v) => new Set(JSON.parse(v)),\r\n    write: (v) => JSON.stringify(Array.from(v))\r\n  },\r\n  date: {\r\n    read: (v) => new Date(v),\r\n    write: (v) => v.toISOString()\r\n  }\r\n};\r\nconst customStorageEventName = \"vueuse-storage\";\r\nfunction useStorage(key, defaults, storage, options = {}) {\r\n  var _a;\r\n  const {\r\n    flush = \"pre\",\r\n    deep = true,\r\n    listenToStorageChanges = true,\r\n    writeDefaults = true,\r\n    mergeDefaults = false,\r\n    shallow,\r\n    window = defaultWindow,\r\n    eventFilter,\r\n    onError = (e) => {\r\n      console.error(e);\r\n    },\r\n    initOnMounted\r\n  } = options;\r\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\r\n  const keyComputed = computed(() => toValue(key));\r\n  if (!storage) {\r\n    try {\r\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\r\n        var _a2;\r\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\r\n      })();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  if (!storage)\r\n    return data;\r\n  const rawInit = toValue(defaults);\r\n  const type = guessSerializerType(rawInit);\r\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\r\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\r\n    data,\r\n    () => write(data.value),\r\n    { flush, deep, eventFilter }\r\n  );\r\n  watch(keyComputed, () => update(), { flush });\r\n  if (window && listenToStorageChanges) {\r\n    tryOnMounted(() => {\r\n      if (storage instanceof Storage)\r\n        useEventListener(window, \"storage\", update, { passive: true });\r\n      else\r\n        useEventListener(window, customStorageEventName, updateFromCustomEvent);\r\n      if (initOnMounted)\r\n        update();\r\n    });\r\n  }\r\n  if (!initOnMounted)\r\n    update();\r\n  function dispatchWriteEvent(oldValue, newValue) {\r\n    if (window) {\r\n      const payload = {\r\n        key: keyComputed.value,\r\n        oldValue,\r\n        newValue,\r\n        storageArea: storage\r\n      };\r\n      window.dispatchEvent(storage instanceof Storage ? new StorageEvent(\"storage\", payload) : new CustomEvent(customStorageEventName, {\r\n        detail: payload\r\n      }));\r\n    }\r\n  }\r\n  function write(v) {\r\n    try {\r\n      const oldValue = storage.getItem(keyComputed.value);\r\n      if (v == null) {\r\n        dispatchWriteEvent(oldValue, null);\r\n        storage.removeItem(keyComputed.value);\r\n      } else {\r\n        const serialized = serializer.write(v);\r\n        if (oldValue !== serialized) {\r\n          storage.setItem(keyComputed.value, serialized);\r\n          dispatchWriteEvent(oldValue, serialized);\r\n        }\r\n      }\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  function read(event) {\r\n    const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);\r\n    if (rawValue == null) {\r\n      if (writeDefaults && rawInit != null)\r\n        storage.setItem(keyComputed.value, serializer.write(rawInit));\r\n      return rawInit;\r\n    } else if (!event && mergeDefaults) {\r\n      const value = serializer.read(rawValue);\r\n      if (typeof mergeDefaults === \"function\")\r\n        return mergeDefaults(value, rawInit);\r\n      else if (type === \"object\" && !Array.isArray(value))\r\n        return { ...rawInit, ...value };\r\n      return value;\r\n    } else if (typeof rawValue !== \"string\") {\r\n      return rawValue;\r\n    } else {\r\n      return serializer.read(rawValue);\r\n    }\r\n  }\r\n  function update(event) {\r\n    if (event && event.storageArea !== storage)\r\n      return;\r\n    if (event && event.key == null) {\r\n      data.value = rawInit;\r\n      return;\r\n    }\r\n    if (event && event.key !== keyComputed.value)\r\n      return;\r\n    pauseWatch();\r\n    try {\r\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\r\n        data.value = read(event);\r\n    } catch (e) {\r\n      onError(e);\r\n    } finally {\r\n      if (event)\r\n        nextTick(resumeWatch);\r\n      else\r\n        resumeWatch();\r\n    }\r\n  }\r\n  function updateFromCustomEvent(event) {\r\n    update(event.detail);\r\n  }\r\n  return data;\r\n}\r\n\r\nconst CSS_DISABLE_TRANS = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\r\nfunction useColorMode(options = {}) {\r\n  const {\r\n    selector = \"html\",\r\n    attribute = \"class\",\r\n    initialValue = \"auto\",\r\n    window = defaultWindow,\r\n    storage,\r\n    storageKey = \"vueuse-color-scheme\",\r\n    listenToStorageChanges = true,\r\n    storageRef,\r\n    emitAuto,\r\n    disableTransition = true\r\n  } = options;\r\n  const modes = {\r\n    auto: \"\",\r\n    light: \"light\",\r\n    dark: \"dark\",\r\n    ...options.modes || {}\r\n  };\r\n  const preferredDark = usePreferredDark({ window });\r\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\r\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\r\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\r\n  const updateHTMLAttrs = getSSRHandler(\r\n    \"updateHTMLAttrs\",\r\n    (selector2, attribute2, value) => {\r\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\r\n      if (!el)\r\n        return;\r\n      const classesToAdd = /* @__PURE__ */ new Set();\r\n      const classesToRemove = /* @__PURE__ */ new Set();\r\n      let attributeToChange = null;\r\n      if (attribute2 === \"class\") {\r\n        const current = value.split(/\\s/g);\r\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\r\n          if (current.includes(v))\r\n            classesToAdd.add(v);\r\n          else\r\n            classesToRemove.add(v);\r\n        });\r\n      } else {\r\n        attributeToChange = { key: attribute2, value };\r\n      }\r\n      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)\r\n        return;\r\n      let style;\r\n      if (disableTransition) {\r\n        style = window.document.createElement(\"style\");\r\n        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));\r\n        window.document.head.appendChild(style);\r\n      }\r\n      for (const c of classesToAdd) {\r\n        el.classList.add(c);\r\n      }\r\n      for (const c of classesToRemove) {\r\n        el.classList.remove(c);\r\n      }\r\n      if (attributeToChange) {\r\n        el.setAttribute(attributeToChange.key, attributeToChange.value);\r\n      }\r\n      if (disableTransition) {\r\n        window.getComputedStyle(style).opacity;\r\n        document.head.removeChild(style);\r\n      }\r\n    }\r\n  );\r\n  function defaultOnChanged(mode) {\r\n    var _a;\r\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\r\n  }\r\n  function onChanged(mode) {\r\n    if (options.onChanged)\r\n      options.onChanged(mode, defaultOnChanged);\r\n    else\r\n      defaultOnChanged(mode);\r\n  }\r\n  watch(state, onChanged, { flush: \"post\", immediate: true });\r\n  tryOnMounted(() => onChanged(state.value));\r\n  const auto = computed({\r\n    get() {\r\n      return emitAuto ? store.value : state.value;\r\n    },\r\n    set(v) {\r\n      store.value = v;\r\n    }\r\n  });\r\n  return Object.assign(auto, { store, system, state });\r\n}\r\n\r\nfunction useConfirmDialog(revealed = shallowRef(false)) {\r\n  const confirmHook = createEventHook();\r\n  const cancelHook = createEventHook();\r\n  const revealHook = createEventHook();\r\n  let _resolve = noop;\r\n  const reveal = (data) => {\r\n    revealHook.trigger(data);\r\n    revealed.value = true;\r\n    return new Promise((resolve) => {\r\n      _resolve = resolve;\r\n    });\r\n  };\r\n  const confirm = (data) => {\r\n    revealed.value = false;\r\n    confirmHook.trigger(data);\r\n    _resolve({ data, isCanceled: false });\r\n  };\r\n  const cancel = (data) => {\r\n    revealed.value = false;\r\n    cancelHook.trigger(data);\r\n    _resolve({ data, isCanceled: true });\r\n  };\r\n  return {\r\n    isRevealed: computed(() => revealed.value),\r\n    reveal,\r\n    confirm,\r\n    cancel,\r\n    onReveal: revealHook.on,\r\n    onConfirm: confirmHook.on,\r\n    onCancel: cancelHook.on\r\n  };\r\n}\r\n\r\nfunction useCountdown(initialCountdown, options) {\r\n  var _a, _b;\r\n  const remaining = shallowRef(toValue(initialCountdown));\r\n  const intervalController = useIntervalFn(() => {\r\n    var _a2, _b2;\r\n    const value = remaining.value - 1;\r\n    remaining.value = value < 0 ? 0 : value;\r\n    (_a2 = options == null ? void 0 : options.onTick) == null ? void 0 : _a2.call(options);\r\n    if (remaining.value <= 0) {\r\n      intervalController.pause();\r\n      (_b2 = options == null ? void 0 : options.onComplete) == null ? void 0 : _b2.call(options);\r\n    }\r\n  }, (_a = options == null ? void 0 : options.interval) != null ? _a : 1e3, { immediate: (_b = options == null ? void 0 : options.immediate) != null ? _b : false });\r\n  const reset = (countdown) => {\r\n    var _a2;\r\n    remaining.value = (_a2 = toValue(countdown)) != null ? _a2 : toValue(initialCountdown);\r\n  };\r\n  const stop = () => {\r\n    intervalController.pause();\r\n    reset();\r\n  };\r\n  const resume = () => {\r\n    if (!intervalController.isActive.value) {\r\n      if (remaining.value > 0) {\r\n        intervalController.resume();\r\n      }\r\n    }\r\n  };\r\n  const start = (countdown) => {\r\n    reset(countdown);\r\n    intervalController.resume();\r\n  };\r\n  return {\r\n    remaining,\r\n    reset,\r\n    stop,\r\n    start,\r\n    pause: intervalController.pause,\r\n    resume,\r\n    isActive: intervalController.isActive\r\n  };\r\n}\r\n\r\nfunction useCssVar(prop, target, options = {}) {\r\n  const { window = defaultWindow, initialValue, observe = false } = options;\r\n  const variable = shallowRef(initialValue);\r\n  const elRef = computed(() => {\r\n    var _a;\r\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\r\n  });\r\n  function updateCssVar() {\r\n    var _a;\r\n    const key = toValue(prop);\r\n    const el = toValue(elRef);\r\n    if (el && window && key) {\r\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\r\n      variable.value = value || variable.value || initialValue;\r\n    }\r\n  }\r\n  if (observe) {\r\n    useMutationObserver(elRef, updateCssVar, {\r\n      attributeFilter: [\"style\", \"class\"],\r\n      window\r\n    });\r\n  }\r\n  watch(\r\n    [elRef, () => toValue(prop)],\r\n    (_, old) => {\r\n      if (old[0] && old[1])\r\n        old[0].style.removeProperty(old[1]);\r\n      updateCssVar();\r\n    },\r\n    { immediate: true }\r\n  );\r\n  watch(\r\n    [variable, elRef],\r\n    ([val, el]) => {\r\n      const raw_prop = toValue(prop);\r\n      if ((el == null ? void 0 : el.style) && raw_prop) {\r\n        if (val == null)\r\n          el.style.removeProperty(raw_prop);\r\n        else\r\n          el.style.setProperty(raw_prop, val);\r\n      }\r\n    },\r\n    { immediate: true }\r\n  );\r\n  return variable;\r\n}\r\n\r\nfunction useCurrentElement(rootComponent) {\r\n  const vm = getCurrentInstance();\r\n  const currentElement = computedWithControl(\r\n    () => null,\r\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\r\n  );\r\n  onUpdated(currentElement.trigger);\r\n  onMounted(currentElement.trigger);\r\n  return currentElement;\r\n}\r\n\r\nfunction useCycleList(list, options) {\r\n  const state = shallowRef(getInitialValue());\r\n  const listRef = toRef(list);\r\n  const index = computed({\r\n    get() {\r\n      var _a;\r\n      const targetList = listRef.value;\r\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\r\n      if (index2 < 0)\r\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\r\n      return index2;\r\n    },\r\n    set(v) {\r\n      set(v);\r\n    }\r\n  });\r\n  function set(i) {\r\n    const targetList = listRef.value;\r\n    const length = targetList.length;\r\n    const index2 = (i % length + length) % length;\r\n    const value = targetList[index2];\r\n    state.value = value;\r\n    return value;\r\n  }\r\n  function shift(delta = 1) {\r\n    return set(index.value + delta);\r\n  }\r\n  function next(n = 1) {\r\n    return shift(n);\r\n  }\r\n  function prev(n = 1) {\r\n    return shift(-n);\r\n  }\r\n  function getInitialValue() {\r\n    var _a, _b;\r\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\r\n  }\r\n  watch(listRef, () => set(index.value));\r\n  return {\r\n    state,\r\n    index,\r\n    next,\r\n    prev,\r\n    go: set\r\n  };\r\n}\r\n\r\nfunction useDark(options = {}) {\r\n  const {\r\n    valueDark = \"dark\",\r\n    valueLight = \"\"\r\n  } = options;\r\n  const mode = useColorMode({\r\n    ...options,\r\n    onChanged: (mode2, defaultHandler) => {\r\n      var _a;\r\n      if (options.onChanged)\r\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\r\n      else\r\n        defaultHandler(mode2);\r\n    },\r\n    modes: {\r\n      dark: valueDark,\r\n      light: valueLight\r\n    }\r\n  });\r\n  const system = computed(() => mode.system.value);\r\n  const isDark = computed({\r\n    get() {\r\n      return mode.value === \"dark\";\r\n    },\r\n    set(v) {\r\n      const modeVal = v ? \"dark\" : \"light\";\r\n      if (system.value === modeVal)\r\n        mode.value = \"auto\";\r\n      else\r\n        mode.value = modeVal;\r\n    }\r\n  });\r\n  return isDark;\r\n}\r\n\r\nfunction fnBypass(v) {\r\n  return v;\r\n}\r\nfunction fnSetSource(source, value) {\r\n  return source.value = value;\r\n}\r\nfunction defaultDump(clone) {\r\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\r\n}\r\nfunction defaultParse(clone) {\r\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\r\n}\r\nfunction useManualRefHistory(source, options = {}) {\r\n  const {\r\n    clone = false,\r\n    dump = defaultDump(clone),\r\n    parse = defaultParse(clone),\r\n    setSource = fnSetSource\r\n  } = options;\r\n  function _createHistoryRecord() {\r\n    return markRaw({\r\n      snapshot: dump(source.value),\r\n      timestamp: timestamp()\r\n    });\r\n  }\r\n  const last = ref(_createHistoryRecord());\r\n  const undoStack = ref([]);\r\n  const redoStack = ref([]);\r\n  const _setSource = (record) => {\r\n    setSource(source, parse(record.snapshot));\r\n    last.value = record;\r\n  };\r\n  const commit = () => {\r\n    undoStack.value.unshift(last.value);\r\n    last.value = _createHistoryRecord();\r\n    if (options.capacity && undoStack.value.length > options.capacity)\r\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\r\n    if (redoStack.value.length)\r\n      redoStack.value.splice(0, redoStack.value.length);\r\n  };\r\n  const clear = () => {\r\n    undoStack.value.splice(0, undoStack.value.length);\r\n    redoStack.value.splice(0, redoStack.value.length);\r\n  };\r\n  const undo = () => {\r\n    const state = undoStack.value.shift();\r\n    if (state) {\r\n      redoStack.value.unshift(last.value);\r\n      _setSource(state);\r\n    }\r\n  };\r\n  const redo = () => {\r\n    const state = redoStack.value.shift();\r\n    if (state) {\r\n      undoStack.value.unshift(last.value);\r\n      _setSource(state);\r\n    }\r\n  };\r\n  const reset = () => {\r\n    _setSource(last.value);\r\n  };\r\n  const history = computed(() => [last.value, ...undoStack.value]);\r\n  const canUndo = computed(() => undoStack.value.length > 0);\r\n  const canRedo = computed(() => redoStack.value.length > 0);\r\n  return {\r\n    source,\r\n    undoStack,\r\n    redoStack,\r\n    last,\r\n    history,\r\n    canUndo,\r\n    canRedo,\r\n    clear,\r\n    commit,\r\n    reset,\r\n    undo,\r\n    redo\r\n  };\r\n}\r\n\r\nfunction useRefHistory(source, options = {}) {\r\n  const {\r\n    deep = false,\r\n    flush = \"pre\",\r\n    eventFilter\r\n  } = options;\r\n  const {\r\n    eventFilter: composedFilter,\r\n    pause,\r\n    resume: resumeTracking,\r\n    isActive: isTracking\r\n  } = pausableFilter(eventFilter);\r\n  const {\r\n    ignoreUpdates,\r\n    ignorePrevAsyncUpdates,\r\n    stop\r\n  } = watchIgnorable(\r\n    source,\r\n    commit,\r\n    { deep, flush, eventFilter: composedFilter }\r\n  );\r\n  function setSource(source2, value) {\r\n    ignorePrevAsyncUpdates();\r\n    ignoreUpdates(() => {\r\n      source2.value = value;\r\n    });\r\n  }\r\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\r\n  const { clear, commit: manualCommit } = manualHistory;\r\n  function commit() {\r\n    ignorePrevAsyncUpdates();\r\n    manualCommit();\r\n  }\r\n  function resume(commitNow) {\r\n    resumeTracking();\r\n    if (commitNow)\r\n      commit();\r\n  }\r\n  function batch(fn) {\r\n    let canceled = false;\r\n    const cancel = () => canceled = true;\r\n    ignoreUpdates(() => {\r\n      fn(cancel);\r\n    });\r\n    if (!canceled)\r\n      commit();\r\n  }\r\n  function dispose() {\r\n    stop();\r\n    clear();\r\n  }\r\n  return {\r\n    ...manualHistory,\r\n    isTracking,\r\n    pause,\r\n    resume,\r\n    commit,\r\n    batch,\r\n    dispose\r\n  };\r\n}\r\n\r\nfunction useDebouncedRefHistory(source, options = {}) {\r\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\r\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\r\n  return {\r\n    ...history\r\n  };\r\n}\r\n\r\nfunction useDeviceMotion(options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    requestPermissions = false,\r\n    eventFilter = bypassFilter\r\n  } = options;\r\n  const isSupported = useSupported(() => typeof DeviceMotionEvent !== \"undefined\");\r\n  const requirePermissions = useSupported(() => isSupported.value && \"requestPermission\" in DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === \"function\");\r\n  const permissionGranted = shallowRef(false);\r\n  const acceleration = ref({ x: null, y: null, z: null });\r\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\r\n  const interval = shallowRef(0);\r\n  const accelerationIncludingGravity = ref({\r\n    x: null,\r\n    y: null,\r\n    z: null\r\n  });\r\n  function init() {\r\n    if (window) {\r\n      const onDeviceMotion = createFilterWrapper(\r\n        eventFilter,\r\n        (event) => {\r\n          var _a, _b, _c, _d, _e, _f, _g, _h, _i;\r\n          acceleration.value = {\r\n            x: ((_a = event.acceleration) == null ? void 0 : _a.x) || null,\r\n            y: ((_b = event.acceleration) == null ? void 0 : _b.y) || null,\r\n            z: ((_c = event.acceleration) == null ? void 0 : _c.z) || null\r\n          };\r\n          accelerationIncludingGravity.value = {\r\n            x: ((_d = event.accelerationIncludingGravity) == null ? void 0 : _d.x) || null,\r\n            y: ((_e = event.accelerationIncludingGravity) == null ? void 0 : _e.y) || null,\r\n            z: ((_f = event.accelerationIncludingGravity) == null ? void 0 : _f.z) || null\r\n          };\r\n          rotationRate.value = {\r\n            alpha: ((_g = event.rotationRate) == null ? void 0 : _g.alpha) || null,\r\n            beta: ((_h = event.rotationRate) == null ? void 0 : _h.beta) || null,\r\n            gamma: ((_i = event.rotationRate) == null ? void 0 : _i.gamma) || null\r\n          };\r\n          interval.value = event.interval;\r\n        }\r\n      );\r\n      useEventListener(window, \"devicemotion\", onDeviceMotion, { passive: true });\r\n    }\r\n  }\r\n  const ensurePermissions = async () => {\r\n    if (!requirePermissions.value)\r\n      permissionGranted.value = true;\r\n    if (permissionGranted.value)\r\n      return;\r\n    if (requirePermissions.value) {\r\n      const requestPermission = DeviceMotionEvent.requestPermission;\r\n      try {\r\n        const response = await requestPermission();\r\n        if (response === \"granted\") {\r\n          permissionGranted.value = true;\r\n          init();\r\n        }\r\n      } catch (error) {\r\n        console.error(error);\r\n      }\r\n    }\r\n  };\r\n  if (isSupported.value) {\r\n    if (requestPermissions && requirePermissions.value) {\r\n      ensurePermissions().then(() => init());\r\n    } else {\r\n      init();\r\n    }\r\n  }\r\n  return {\r\n    acceleration,\r\n    accelerationIncludingGravity,\r\n    rotationRate,\r\n    interval,\r\n    isSupported,\r\n    requirePermissions,\r\n    ensurePermissions,\r\n    permissionGranted\r\n  };\r\n}\r\n\r\nfunction useDeviceOrientation(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\r\n  const isAbsolute = shallowRef(false);\r\n  const alpha = shallowRef(null);\r\n  const beta = shallowRef(null);\r\n  const gamma = shallowRef(null);\r\n  if (window && isSupported.value) {\r\n    useEventListener(window, \"deviceorientation\", (event) => {\r\n      isAbsolute.value = event.absolute;\r\n      alpha.value = event.alpha;\r\n      beta.value = event.beta;\r\n      gamma.value = event.gamma;\r\n    }, { passive: true });\r\n  }\r\n  return {\r\n    isSupported,\r\n    isAbsolute,\r\n    alpha,\r\n    beta,\r\n    gamma\r\n  };\r\n}\r\n\r\nfunction useDevicePixelRatio(options = {}) {\r\n  const {\r\n    window = defaultWindow\r\n  } = options;\r\n  const pixelRatio = shallowRef(1);\r\n  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);\r\n  let stop = noop;\r\n  if (window) {\r\n    stop = watchImmediate(query, () => pixelRatio.value = window.devicePixelRatio);\r\n  }\r\n  return {\r\n    pixelRatio: readonly(pixelRatio),\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useDevicesList(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    requestPermissions = false,\r\n    constraints = { audio: true, video: true },\r\n    onUpdated\r\n  } = options;\r\n  const devices = ref([]);\r\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\r\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\r\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\r\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\r\n  const permissionGranted = shallowRef(false);\r\n  let stream;\r\n  async function update() {\r\n    if (!isSupported.value)\r\n      return;\r\n    devices.value = await navigator.mediaDevices.enumerateDevices();\r\n    onUpdated == null ? void 0 : onUpdated(devices.value);\r\n    if (stream) {\r\n      stream.getTracks().forEach((t) => t.stop());\r\n      stream = null;\r\n    }\r\n  }\r\n  async function ensurePermissions() {\r\n    const deviceName = constraints.video ? \"camera\" : \"microphone\";\r\n    if (!isSupported.value)\r\n      return false;\r\n    if (permissionGranted.value)\r\n      return true;\r\n    const { state, query } = usePermission(deviceName, { controls: true });\r\n    await query();\r\n    if (state.value !== \"granted\") {\r\n      let granted = true;\r\n      try {\r\n        stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n      } catch (e) {\r\n        stream = null;\r\n        granted = false;\r\n      }\r\n      update();\r\n      permissionGranted.value = granted;\r\n    } else {\r\n      permissionGranted.value = true;\r\n    }\r\n    return permissionGranted.value;\r\n  }\r\n  if (isSupported.value) {\r\n    if (requestPermissions)\r\n      ensurePermissions();\r\n    useEventListener(navigator.mediaDevices, \"devicechange\", update, { passive: true });\r\n    update();\r\n  }\r\n  return {\r\n    devices,\r\n    ensurePermissions,\r\n    permissionGranted,\r\n    videoInputs,\r\n    audioInputs,\r\n    audioOutputs,\r\n    isSupported\r\n  };\r\n}\r\n\r\nfunction useDisplayMedia(options = {}) {\r\n  var _a;\r\n  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);\r\n  const video = options.video;\r\n  const audio = options.audio;\r\n  const { navigator = defaultNavigator } = options;\r\n  const isSupported = useSupported(() => {\r\n    var _a2;\r\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\r\n  });\r\n  const constraint = { audio, video };\r\n  const stream = shallowRef();\r\n  async function _start() {\r\n    var _a2;\r\n    if (!isSupported.value || stream.value)\r\n      return;\r\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\r\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => useEventListener(t, \"ended\", stop, { passive: true }));\r\n    return stream.value;\r\n  }\r\n  async function _stop() {\r\n    var _a2;\r\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\r\n    stream.value = void 0;\r\n  }\r\n  function stop() {\r\n    _stop();\r\n    enabled.value = false;\r\n  }\r\n  async function start() {\r\n    await _start();\r\n    if (stream.value)\r\n      enabled.value = true;\r\n    return stream.value;\r\n  }\r\n  watch(\r\n    enabled,\r\n    (v) => {\r\n      if (v)\r\n        _start();\r\n      else\r\n        _stop();\r\n    },\r\n    { immediate: true }\r\n  );\r\n  return {\r\n    isSupported,\r\n    stream,\r\n    start,\r\n    stop,\r\n    enabled\r\n  };\r\n}\r\n\r\nfunction useDocumentVisibility(options = {}) {\r\n  const { document = defaultDocument } = options;\r\n  if (!document)\r\n    return shallowRef(\"visible\");\r\n  const visibility = shallowRef(document.visibilityState);\r\n  useEventListener(document, \"visibilitychange\", () => {\r\n    visibility.value = document.visibilityState;\r\n  }, { passive: true });\r\n  return visibility;\r\n}\r\n\r\nfunction useDraggable(target, options = {}) {\r\n  var _a;\r\n  const {\r\n    pointerTypes,\r\n    preventDefault,\r\n    stopPropagation,\r\n    exact,\r\n    onMove,\r\n    onEnd,\r\n    onStart,\r\n    initialValue,\r\n    axis = \"both\",\r\n    draggingElement = defaultWindow,\r\n    containerElement,\r\n    handle: draggingHandle = target,\r\n    buttons = [0]\r\n  } = options;\r\n  const position = ref(\r\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\r\n  );\r\n  const pressedDelta = ref();\r\n  const filterEvent = (e) => {\r\n    if (pointerTypes)\r\n      return pointerTypes.includes(e.pointerType);\r\n    return true;\r\n  };\r\n  const handleEvent = (e) => {\r\n    if (toValue(preventDefault))\r\n      e.preventDefault();\r\n    if (toValue(stopPropagation))\r\n      e.stopPropagation();\r\n  };\r\n  const start = (e) => {\r\n    var _a2;\r\n    if (!toValue(buttons).includes(e.button))\r\n      return;\r\n    if (toValue(options.disabled) || !filterEvent(e))\r\n      return;\r\n    if (toValue(exact) && e.target !== toValue(target))\r\n      return;\r\n    const container = toValue(containerElement);\r\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\r\n    const targetRect = toValue(target).getBoundingClientRect();\r\n    const pos = {\r\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\r\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\r\n    };\r\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\r\n      return;\r\n    pressedDelta.value = pos;\r\n    handleEvent(e);\r\n  };\r\n  const move = (e) => {\r\n    if (toValue(options.disabled) || !filterEvent(e))\r\n      return;\r\n    if (!pressedDelta.value)\r\n      return;\r\n    const container = toValue(containerElement);\r\n    const targetRect = toValue(target).getBoundingClientRect();\r\n    let { x, y } = position.value;\r\n    if (axis === \"x\" || axis === \"both\") {\r\n      x = e.clientX - pressedDelta.value.x;\r\n      if (container)\r\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\r\n    }\r\n    if (axis === \"y\" || axis === \"both\") {\r\n      y = e.clientY - pressedDelta.value.y;\r\n      if (container)\r\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\r\n    }\r\n    position.value = {\r\n      x,\r\n      y\r\n    };\r\n    onMove == null ? void 0 : onMove(position.value, e);\r\n    handleEvent(e);\r\n  };\r\n  const end = (e) => {\r\n    if (toValue(options.disabled) || !filterEvent(e))\r\n      return;\r\n    if (!pressedDelta.value)\r\n      return;\r\n    pressedDelta.value = void 0;\r\n    onEnd == null ? void 0 : onEnd(position.value, e);\r\n    handleEvent(e);\r\n  };\r\n  if (isClient) {\r\n    const config = () => {\r\n      var _a2;\r\n      return {\r\n        capture: (_a2 = options.capture) != null ? _a2 : true,\r\n        passive: !toValue(preventDefault)\r\n      };\r\n    };\r\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\r\n    useEventListener(draggingElement, \"pointermove\", move, config);\r\n    useEventListener(draggingElement, \"pointerup\", end, config);\r\n  }\r\n  return {\r\n    ...toRefs(position),\r\n    position,\r\n    isDragging: computed(() => !!pressedDelta.value),\r\n    style: computed(\r\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\r\n    )\r\n  };\r\n}\r\n\r\nfunction useDropZone(target, options = {}) {\r\n  var _a, _b;\r\n  const isOverDropZone = shallowRef(false);\r\n  const files = shallowRef(null);\r\n  let counter = 0;\r\n  let isValid = true;\r\n  if (isClient) {\r\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\r\n    const multiple = (_a = _options.multiple) != null ? _a : true;\r\n    const preventDefaultForUnhandled = (_b = _options.preventDefaultForUnhandled) != null ? _b : false;\r\n    const getFiles = (event) => {\r\n      var _a2, _b2;\r\n      const list = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b2 : []);\r\n      return list.length === 0 ? null : multiple ? list : [list[0]];\r\n    };\r\n    const checkDataTypes = (types) => {\r\n      const dataTypes = unref(_options.dataTypes);\r\n      if (typeof dataTypes === \"function\")\r\n        return dataTypes(types);\r\n      if (!(dataTypes == null ? void 0 : dataTypes.length))\r\n        return true;\r\n      if (types.length === 0)\r\n        return false;\r\n      return types.every(\r\n        (type) => dataTypes.some((allowedType) => type.includes(allowedType))\r\n      );\r\n    };\r\n    const checkValidity = (items) => {\r\n      const types = Array.from(items != null ? items : []).map((item) => item.type);\r\n      const dataTypesValid = checkDataTypes(types);\r\n      const multipleFilesValid = multiple || items.length <= 1;\r\n      return dataTypesValid && multipleFilesValid;\r\n    };\r\n    const isSafari = () => /^(?:(?!chrome|android).)*safari/i.test(navigator.userAgent) && !(\"chrome\" in window);\r\n    const handleDragEvent = (event, eventType) => {\r\n      var _a2, _b2, _c, _d, _e, _f;\r\n      const dataTransferItemList = (_a2 = event.dataTransfer) == null ? void 0 : _a2.items;\r\n      isValid = (_b2 = dataTransferItemList && checkValidity(dataTransferItemList)) != null ? _b2 : false;\r\n      if (preventDefaultForUnhandled) {\r\n        event.preventDefault();\r\n      }\r\n      if (!isSafari() && !isValid) {\r\n        if (event.dataTransfer) {\r\n          event.dataTransfer.dropEffect = \"none\";\r\n        }\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      if (event.dataTransfer) {\r\n        event.dataTransfer.dropEffect = \"copy\";\r\n      }\r\n      const currentFiles = getFiles(event);\r\n      switch (eventType) {\r\n        case \"enter\":\r\n          counter += 1;\r\n          isOverDropZone.value = true;\r\n          (_c = _options.onEnter) == null ? void 0 : _c.call(_options, null, event);\r\n          break;\r\n        case \"over\":\r\n          (_d = _options.onOver) == null ? void 0 : _d.call(_options, null, event);\r\n          break;\r\n        case \"leave\":\r\n          counter -= 1;\r\n          if (counter === 0)\r\n            isOverDropZone.value = false;\r\n          (_e = _options.onLeave) == null ? void 0 : _e.call(_options, null, event);\r\n          break;\r\n        case \"drop\":\r\n          counter = 0;\r\n          isOverDropZone.value = false;\r\n          if (isValid) {\r\n            files.value = currentFiles;\r\n            (_f = _options.onDrop) == null ? void 0 : _f.call(_options, currentFiles, event);\r\n          }\r\n          break;\r\n      }\r\n    };\r\n    useEventListener(target, \"dragenter\", (event) => handleDragEvent(event, \"enter\"));\r\n    useEventListener(target, \"dragover\", (event) => handleDragEvent(event, \"over\"));\r\n    useEventListener(target, \"dragleave\", (event) => handleDragEvent(event, \"leave\"));\r\n    useEventListener(target, \"drop\", (event) => handleDragEvent(event, \"drop\"));\r\n  }\r\n  return {\r\n    files,\r\n    isOverDropZone\r\n  };\r\n}\r\n\r\nfunction useResizeObserver(target, callback, options = {}) {\r\n  const { window = defaultWindow, ...observerOptions } = options;\r\n  let observer;\r\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\r\n  const cleanup = () => {\r\n    if (observer) {\r\n      observer.disconnect();\r\n      observer = void 0;\r\n    }\r\n  };\r\n  const targets = computed(() => {\r\n    const _targets = toValue(target);\r\n    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];\r\n  });\r\n  const stopWatch = watch(\r\n    targets,\r\n    (els) => {\r\n      cleanup();\r\n      if (isSupported.value && window) {\r\n        observer = new ResizeObserver(callback);\r\n        for (const _el of els) {\r\n          if (_el)\r\n            observer.observe(_el, observerOptions);\r\n        }\r\n      }\r\n    },\r\n    { immediate: true, flush: \"post\" }\r\n  );\r\n  const stop = () => {\r\n    cleanup();\r\n    stopWatch();\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isSupported,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useElementBounding(target, options = {}) {\r\n  const {\r\n    reset = true,\r\n    windowResize = true,\r\n    windowScroll = true,\r\n    immediate = true,\r\n    updateTiming = \"sync\"\r\n  } = options;\r\n  const height = shallowRef(0);\r\n  const bottom = shallowRef(0);\r\n  const left = shallowRef(0);\r\n  const right = shallowRef(0);\r\n  const top = shallowRef(0);\r\n  const width = shallowRef(0);\r\n  const x = shallowRef(0);\r\n  const y = shallowRef(0);\r\n  function recalculate() {\r\n    const el = unrefElement(target);\r\n    if (!el) {\r\n      if (reset) {\r\n        height.value = 0;\r\n        bottom.value = 0;\r\n        left.value = 0;\r\n        right.value = 0;\r\n        top.value = 0;\r\n        width.value = 0;\r\n        x.value = 0;\r\n        y.value = 0;\r\n      }\r\n      return;\r\n    }\r\n    const rect = el.getBoundingClientRect();\r\n    height.value = rect.height;\r\n    bottom.value = rect.bottom;\r\n    left.value = rect.left;\r\n    right.value = rect.right;\r\n    top.value = rect.top;\r\n    width.value = rect.width;\r\n    x.value = rect.x;\r\n    y.value = rect.y;\r\n  }\r\n  function update() {\r\n    if (updateTiming === \"sync\")\r\n      recalculate();\r\n    else if (updateTiming === \"next-frame\")\r\n      requestAnimationFrame(() => recalculate());\r\n  }\r\n  useResizeObserver(target, update);\r\n  watch(() => unrefElement(target), (ele) => !ele && update());\r\n  useMutationObserver(target, update, {\r\n    attributeFilter: [\"style\", \"class\"]\r\n  });\r\n  if (windowScroll)\r\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\r\n  if (windowResize)\r\n    useEventListener(\"resize\", update, { passive: true });\r\n  tryOnMounted(() => {\r\n    if (immediate)\r\n      update();\r\n  });\r\n  return {\r\n    height,\r\n    bottom,\r\n    left,\r\n    right,\r\n    top,\r\n    width,\r\n    x,\r\n    y,\r\n    update\r\n  };\r\n}\r\n\r\nfunction useElementByPoint(options) {\r\n  const {\r\n    x,\r\n    y,\r\n    document = defaultDocument,\r\n    multiple,\r\n    interval = \"requestAnimationFrame\",\r\n    immediate = true\r\n  } = options;\r\n  const isSupported = useSupported(() => {\r\n    if (toValue(multiple))\r\n      return document && \"elementsFromPoint\" in document;\r\n    return document && \"elementFromPoint\" in document;\r\n  });\r\n  const element = shallowRef(null);\r\n  const cb = () => {\r\n    var _a, _b;\r\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\r\n  };\r\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\r\n  return {\r\n    isSupported,\r\n    element,\r\n    ...controls\r\n  };\r\n}\r\n\r\nfunction useElementHover(el, options = {}) {\r\n  const {\r\n    delayEnter = 0,\r\n    delayLeave = 0,\r\n    triggerOnRemoval = false,\r\n    window = defaultWindow\r\n  } = options;\r\n  const isHovered = shallowRef(false);\r\n  let timer;\r\n  const toggle = (entering) => {\r\n    const delay = entering ? delayEnter : delayLeave;\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = void 0;\r\n    }\r\n    if (delay)\r\n      timer = setTimeout(() => isHovered.value = entering, delay);\r\n    else\r\n      isHovered.value = entering;\r\n  };\r\n  if (!window)\r\n    return isHovered;\r\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\r\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\r\n  if (triggerOnRemoval) {\r\n    onElementRemoval(\r\n      computed(() => unrefElement(el)),\r\n      () => toggle(false)\r\n    );\r\n  }\r\n  return isHovered;\r\n}\r\n\r\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\r\n  const { window = defaultWindow, box = \"content-box\" } = options;\r\n  const isSVG = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\r\n  });\r\n  const width = shallowRef(initialSize.width);\r\n  const height = shallowRef(initialSize.height);\r\n  const { stop: stop1 } = useResizeObserver(\r\n    target,\r\n    ([entry]) => {\r\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\r\n      if (window && isSVG.value) {\r\n        const $elem = unrefElement(target);\r\n        if ($elem) {\r\n          const rect = $elem.getBoundingClientRect();\r\n          width.value = rect.width;\r\n          height.value = rect.height;\r\n        }\r\n      } else {\r\n        if (boxSize) {\r\n          const formatBoxSize = toArray(boxSize);\r\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\r\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\r\n        } else {\r\n          width.value = entry.contentRect.width;\r\n          height.value = entry.contentRect.height;\r\n        }\r\n      }\r\n    },\r\n    options\r\n  );\r\n  tryOnMounted(() => {\r\n    const ele = unrefElement(target);\r\n    if (ele) {\r\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\r\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\r\n    }\r\n  });\r\n  const stop2 = watch(\r\n    () => unrefElement(target),\r\n    (ele) => {\r\n      width.value = ele ? initialSize.width : 0;\r\n      height.value = ele ? initialSize.height : 0;\r\n    }\r\n  );\r\n  function stop() {\r\n    stop1();\r\n    stop2();\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useIntersectionObserver(target, callback, options = {}) {\r\n  const {\r\n    root,\r\n    rootMargin = \"0px\",\r\n    threshold = 0,\r\n    window = defaultWindow,\r\n    immediate = true\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\r\n  const targets = computed(() => {\r\n    const _target = toValue(target);\r\n    return toArray(_target).map(unrefElement).filter(notNullish);\r\n  });\r\n  let cleanup = noop;\r\n  const isActive = shallowRef(immediate);\r\n  const stopWatch = isSupported.value ? watch(\r\n    () => [targets.value, unrefElement(root), isActive.value],\r\n    ([targets2, root2]) => {\r\n      cleanup();\r\n      if (!isActive.value)\r\n        return;\r\n      if (!targets2.length)\r\n        return;\r\n      const observer = new IntersectionObserver(\r\n        callback,\r\n        {\r\n          root: unrefElement(root2),\r\n          rootMargin,\r\n          threshold\r\n        }\r\n      );\r\n      targets2.forEach((el) => el && observer.observe(el));\r\n      cleanup = () => {\r\n        observer.disconnect();\r\n        cleanup = noop;\r\n      };\r\n    },\r\n    { immediate, flush: \"post\" }\r\n  ) : noop;\r\n  const stop = () => {\r\n    cleanup();\r\n    stopWatch();\r\n    isActive.value = false;\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isSupported,\r\n    isActive,\r\n    pause() {\r\n      cleanup();\r\n      isActive.value = false;\r\n    },\r\n    resume() {\r\n      isActive.value = true;\r\n    },\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useElementVisibility(element, options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    scrollTarget,\r\n    threshold = 0,\r\n    rootMargin,\r\n    once = false\r\n  } = options;\r\n  const elementIsVisible = shallowRef(false);\r\n  const { stop } = useIntersectionObserver(\r\n    element,\r\n    (intersectionObserverEntries) => {\r\n      let isIntersecting = elementIsVisible.value;\r\n      let latestTime = 0;\r\n      for (const entry of intersectionObserverEntries) {\r\n        if (entry.time >= latestTime) {\r\n          latestTime = entry.time;\r\n          isIntersecting = entry.isIntersecting;\r\n        }\r\n      }\r\n      elementIsVisible.value = isIntersecting;\r\n      if (once) {\r\n        watchOnce(elementIsVisible, () => {\r\n          stop();\r\n        });\r\n      }\r\n    },\r\n    {\r\n      root: scrollTarget,\r\n      window,\r\n      threshold,\r\n      rootMargin: toValue(rootMargin)\r\n    }\r\n  );\r\n  return elementIsVisible;\r\n}\r\n\r\nconst events = /* @__PURE__ */ new Map();\r\n\r\nfunction useEventBus(key) {\r\n  const scope = getCurrentScope();\r\n  function on(listener) {\r\n    var _a;\r\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\r\n    listeners.add(listener);\r\n    events.set(key, listeners);\r\n    const _off = () => off(listener);\r\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\r\n    return _off;\r\n  }\r\n  function once(listener) {\r\n    function _listener(...args) {\r\n      off(_listener);\r\n      listener(...args);\r\n    }\r\n    return on(_listener);\r\n  }\r\n  function off(listener) {\r\n    const listeners = events.get(key);\r\n    if (!listeners)\r\n      return;\r\n    listeners.delete(listener);\r\n    if (!listeners.size)\r\n      reset();\r\n  }\r\n  function reset() {\r\n    events.delete(key);\r\n  }\r\n  function emit(event, payload) {\r\n    var _a;\r\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\r\n  }\r\n  return { on, once, off, emit, reset };\r\n}\r\n\r\nfunction resolveNestedOptions$1(options) {\r\n  if (options === true)\r\n    return {};\r\n  return options;\r\n}\r\nfunction useEventSource(url, events = [], options = {}) {\r\n  const event = shallowRef(null);\r\n  const data = shallowRef(null);\r\n  const status = shallowRef(\"CONNECTING\");\r\n  const eventSource = ref(null);\r\n  const error = shallowRef(null);\r\n  const urlRef = toRef(url);\r\n  const lastEventId = shallowRef(null);\r\n  let explicitlyClosed = false;\r\n  let retried = 0;\r\n  const {\r\n    withCredentials = false,\r\n    immediate = true,\r\n    autoConnect = true,\r\n    autoReconnect\r\n  } = options;\r\n  const close = () => {\r\n    if (isClient && eventSource.value) {\r\n      eventSource.value.close();\r\n      eventSource.value = null;\r\n      status.value = \"CLOSED\";\r\n      explicitlyClosed = true;\r\n    }\r\n  };\r\n  const _init = () => {\r\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\r\n      return;\r\n    const es = new EventSource(urlRef.value, { withCredentials });\r\n    status.value = \"CONNECTING\";\r\n    eventSource.value = es;\r\n    es.onopen = () => {\r\n      status.value = \"OPEN\";\r\n      error.value = null;\r\n    };\r\n    es.onerror = (e) => {\r\n      status.value = \"CLOSED\";\r\n      error.value = e;\r\n      if (es.readyState === 2 && !explicitlyClosed && autoReconnect) {\r\n        es.close();\r\n        const {\r\n          retries = -1,\r\n          delay = 1e3,\r\n          onFailed\r\n        } = resolveNestedOptions$1(autoReconnect);\r\n        retried += 1;\r\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\r\n          setTimeout(_init, delay);\r\n        else if (typeof retries === \"function\" && retries())\r\n          setTimeout(_init, delay);\r\n        else\r\n          onFailed == null ? void 0 : onFailed();\r\n      }\r\n    };\r\n    es.onmessage = (e) => {\r\n      event.value = null;\r\n      data.value = e.data;\r\n      lastEventId.value = e.lastEventId;\r\n    };\r\n    for (const event_name of events) {\r\n      useEventListener(es, event_name, (e) => {\r\n        event.value = event_name;\r\n        data.value = e.data || null;\r\n      }, { passive: true });\r\n    }\r\n  };\r\n  const open = () => {\r\n    if (!isClient)\r\n      return;\r\n    close();\r\n    explicitlyClosed = false;\r\n    retried = 0;\r\n    _init();\r\n  };\r\n  if (immediate)\r\n    open();\r\n  if (autoConnect)\r\n    watch(urlRef, open);\r\n  tryOnScopeDispose(close);\r\n  return {\r\n    eventSource,\r\n    event,\r\n    data,\r\n    status,\r\n    error,\r\n    open,\r\n    close,\r\n    lastEventId\r\n  };\r\n}\r\n\r\nfunction useEyeDropper(options = {}) {\r\n  const { initialValue = \"\" } = options;\r\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\r\n  const sRGBHex = shallowRef(initialValue);\r\n  async function open(openOptions) {\r\n    if (!isSupported.value)\r\n      return;\r\n    const eyeDropper = new window.EyeDropper();\r\n    const result = await eyeDropper.open(openOptions);\r\n    sRGBHex.value = result.sRGBHex;\r\n    return result;\r\n  }\r\n  return { isSupported, sRGBHex, open };\r\n}\r\n\r\nfunction useFavicon(newIcon = null, options = {}) {\r\n  const {\r\n    baseUrl = \"\",\r\n    rel = \"icon\",\r\n    document = defaultDocument\r\n  } = options;\r\n  const favicon = toRef(newIcon);\r\n  const applyIcon = (icon) => {\r\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\r\n    if (!elements || elements.length === 0) {\r\n      const link = document == null ? void 0 : document.createElement(\"link\");\r\n      if (link) {\r\n        link.rel = rel;\r\n        link.href = `${baseUrl}${icon}`;\r\n        link.type = `image/${icon.split(\".\").pop()}`;\r\n        document == null ? void 0 : document.head.append(link);\r\n      }\r\n      return;\r\n    }\r\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\r\n  };\r\n  watch(\r\n    favicon,\r\n    (i, o) => {\r\n      if (typeof i === \"string\" && i !== o)\r\n        applyIcon(i);\r\n    },\r\n    { immediate: true }\r\n  );\r\n  return favicon;\r\n}\r\n\r\nconst payloadMapping = {\r\n  json: \"application/json\",\r\n  text: \"text/plain\"\r\n};\r\nfunction isFetchOptions(obj) {\r\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\r\n}\r\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\r\nfunction isAbsoluteURL(url) {\r\n  return reAbsolute.test(url);\r\n}\r\nfunction headersToObject(headers) {\r\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\r\n    return Object.fromEntries(headers.entries());\r\n  return headers;\r\n}\r\nfunction combineCallbacks(combination, ...callbacks) {\r\n  if (combination === \"overwrite\") {\r\n    return async (ctx) => {\r\n      let callback;\r\n      for (let i = callbacks.length - 1; i >= 0; i--) {\r\n        if (callbacks[i] != null) {\r\n          callback = callbacks[i];\r\n          break;\r\n        }\r\n      }\r\n      if (callback)\r\n        return { ...ctx, ...await callback(ctx) };\r\n      return ctx;\r\n    };\r\n  } else {\r\n    return async (ctx) => {\r\n      for (const callback of callbacks) {\r\n        if (callback)\r\n          ctx = { ...ctx, ...await callback(ctx) };\r\n      }\r\n      return ctx;\r\n    };\r\n  }\r\n}\r\nfunction createFetch(config = {}) {\r\n  const _combination = config.combination || \"chain\";\r\n  const _options = config.options || {};\r\n  const _fetchOptions = config.fetchOptions || {};\r\n  function useFactoryFetch(url, ...args) {\r\n    const computedUrl = computed(() => {\r\n      const baseUrl = toValue(config.baseUrl);\r\n      const targetUrl = toValue(url);\r\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\r\n    });\r\n    let options = _options;\r\n    let fetchOptions = _fetchOptions;\r\n    if (args.length > 0) {\r\n      if (isFetchOptions(args[0])) {\r\n        options = {\r\n          ...options,\r\n          ...args[0],\r\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\r\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\r\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\r\n        };\r\n      } else {\r\n        fetchOptions = {\r\n          ...fetchOptions,\r\n          ...args[0],\r\n          headers: {\r\n            ...headersToObject(fetchOptions.headers) || {},\r\n            ...headersToObject(args[0].headers) || {}\r\n          }\r\n        };\r\n      }\r\n    }\r\n    if (args.length > 1 && isFetchOptions(args[1])) {\r\n      options = {\r\n        ...options,\r\n        ...args[1],\r\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\r\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\r\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\r\n      };\r\n    }\r\n    return useFetch(computedUrl, fetchOptions, options);\r\n  }\r\n  return useFactoryFetch;\r\n}\r\nfunction useFetch(url, ...args) {\r\n  var _a;\r\n  const supportsAbort = typeof AbortController === \"function\";\r\n  let fetchOptions = {};\r\n  let options = {\r\n    immediate: true,\r\n    refetch: false,\r\n    timeout: 0,\r\n    updateDataOnError: false\r\n  };\r\n  const config = {\r\n    method: \"GET\",\r\n    type: \"text\",\r\n    payload: void 0\r\n  };\r\n  if (args.length > 0) {\r\n    if (isFetchOptions(args[0]))\r\n      options = { ...options, ...args[0] };\r\n    else\r\n      fetchOptions = args[0];\r\n  }\r\n  if (args.length > 1) {\r\n    if (isFetchOptions(args[1]))\r\n      options = { ...options, ...args[1] };\r\n  }\r\n  const {\r\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\r\n    initialData,\r\n    timeout\r\n  } = options;\r\n  const responseEvent = createEventHook();\r\n  const errorEvent = createEventHook();\r\n  const finallyEvent = createEventHook();\r\n  const isFinished = shallowRef(false);\r\n  const isFetching = shallowRef(false);\r\n  const aborted = shallowRef(false);\r\n  const statusCode = shallowRef(null);\r\n  const response = shallowRef(null);\r\n  const error = shallowRef(null);\r\n  const data = shallowRef(initialData || null);\r\n  const canAbort = computed(() => supportsAbort && isFetching.value);\r\n  let controller;\r\n  let timer;\r\n  const abort = () => {\r\n    if (supportsAbort) {\r\n      controller == null ? void 0 : controller.abort();\r\n      controller = new AbortController();\r\n      controller.signal.onabort = () => aborted.value = true;\r\n      fetchOptions = {\r\n        ...fetchOptions,\r\n        signal: controller.signal\r\n      };\r\n    }\r\n  };\r\n  const loading = (isLoading) => {\r\n    isFetching.value = isLoading;\r\n    isFinished.value = !isLoading;\r\n  };\r\n  if (timeout)\r\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\r\n  let executeCounter = 0;\r\n  const execute = async (throwOnFailed = false) => {\r\n    var _a2, _b;\r\n    abort();\r\n    loading(true);\r\n    error.value = null;\r\n    statusCode.value = null;\r\n    aborted.value = false;\r\n    executeCounter += 1;\r\n    const currentExecuteCounter = executeCounter;\r\n    const defaultFetchOptions = {\r\n      method: config.method,\r\n      headers: {}\r\n    };\r\n    const payload = toValue(config.payload);\r\n    if (payload) {\r\n      const headers = headersToObject(defaultFetchOptions.headers);\r\n      const proto = Object.getPrototypeOf(payload);\r\n      if (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData))\r\n        config.payloadType = \"json\";\r\n      if (config.payloadType)\r\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\r\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\r\n    }\r\n    let isCanceled = false;\r\n    const context = {\r\n      url: toValue(url),\r\n      options: {\r\n        ...defaultFetchOptions,\r\n        ...fetchOptions\r\n      },\r\n      cancel: () => {\r\n        isCanceled = true;\r\n      }\r\n    };\r\n    if (options.beforeFetch)\r\n      Object.assign(context, await options.beforeFetch(context));\r\n    if (isCanceled || !fetch) {\r\n      loading(false);\r\n      return Promise.resolve(null);\r\n    }\r\n    let responseData = null;\r\n    if (timer)\r\n      timer.start();\r\n    return fetch(\r\n      context.url,\r\n      {\r\n        ...defaultFetchOptions,\r\n        ...context.options,\r\n        headers: {\r\n          ...headersToObject(defaultFetchOptions.headers),\r\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\r\n        }\r\n      }\r\n    ).then(async (fetchResponse) => {\r\n      response.value = fetchResponse;\r\n      statusCode.value = fetchResponse.status;\r\n      responseData = await fetchResponse.clone()[config.type]();\r\n      if (!fetchResponse.ok) {\r\n        data.value = initialData || null;\r\n        throw new Error(fetchResponse.statusText);\r\n      }\r\n      if (options.afterFetch) {\r\n        ({ data: responseData } = await options.afterFetch({\r\n          data: responseData,\r\n          response: fetchResponse,\r\n          context,\r\n          execute\r\n        }));\r\n      }\r\n      data.value = responseData;\r\n      responseEvent.trigger(fetchResponse);\r\n      return fetchResponse;\r\n    }).catch(async (fetchError) => {\r\n      let errorData = fetchError.message || fetchError.name;\r\n      if (options.onFetchError) {\r\n        ({ error: errorData, data: responseData } = await options.onFetchError({\r\n          data: responseData,\r\n          error: fetchError,\r\n          response: response.value,\r\n          context,\r\n          execute\r\n        }));\r\n      }\r\n      error.value = errorData;\r\n      if (options.updateDataOnError)\r\n        data.value = responseData;\r\n      errorEvent.trigger(fetchError);\r\n      if (throwOnFailed)\r\n        throw fetchError;\r\n      return null;\r\n    }).finally(() => {\r\n      if (currentExecuteCounter === executeCounter)\r\n        loading(false);\r\n      if (timer)\r\n        timer.stop();\r\n      finallyEvent.trigger(null);\r\n    });\r\n  };\r\n  const refetch = toRef(options.refetch);\r\n  watch(\r\n    [\r\n      refetch,\r\n      toRef(url)\r\n    ],\r\n    ([refetch2]) => refetch2 && execute(),\r\n    { deep: true }\r\n  );\r\n  const shell = {\r\n    isFinished: readonly(isFinished),\r\n    isFetching: readonly(isFetching),\r\n    statusCode,\r\n    response,\r\n    error,\r\n    data,\r\n    canAbort,\r\n    aborted,\r\n    abort,\r\n    execute,\r\n    onFetchResponse: responseEvent.on,\r\n    onFetchError: errorEvent.on,\r\n    onFetchFinally: finallyEvent.on,\r\n    // method\r\n    get: setMethod(\"GET\"),\r\n    put: setMethod(\"PUT\"),\r\n    post: setMethod(\"POST\"),\r\n    delete: setMethod(\"DELETE\"),\r\n    patch: setMethod(\"PATCH\"),\r\n    head: setMethod(\"HEAD\"),\r\n    options: setMethod(\"OPTIONS\"),\r\n    // type\r\n    json: setType(\"json\"),\r\n    text: setType(\"text\"),\r\n    blob: setType(\"blob\"),\r\n    arrayBuffer: setType(\"arrayBuffer\"),\r\n    formData: setType(\"formData\")\r\n  };\r\n  function setMethod(method) {\r\n    return (payload, payloadType) => {\r\n      if (!isFetching.value) {\r\n        config.method = method;\r\n        config.payload = payload;\r\n        config.payloadType = payloadType;\r\n        if (isRef(config.payload)) {\r\n          watch(\r\n            [\r\n              refetch,\r\n              toRef(config.payload)\r\n            ],\r\n            ([refetch2]) => refetch2 && execute(),\r\n            { deep: true }\r\n          );\r\n        }\r\n        return {\r\n          ...shell,\r\n          then(onFulfilled, onRejected) {\r\n            return waitUntilFinished().then(onFulfilled, onRejected);\r\n          }\r\n        };\r\n      }\r\n      return void 0;\r\n    };\r\n  }\r\n  function waitUntilFinished() {\r\n    return new Promise((resolve, reject) => {\r\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);\r\n    });\r\n  }\r\n  function setType(type) {\r\n    return () => {\r\n      if (!isFetching.value) {\r\n        config.type = type;\r\n        return {\r\n          ...shell,\r\n          then(onFulfilled, onRejected) {\r\n            return waitUntilFinished().then(onFulfilled, onRejected);\r\n          }\r\n        };\r\n      }\r\n      return void 0;\r\n    };\r\n  }\r\n  if (options.immediate)\r\n    Promise.resolve().then(() => execute());\r\n  return {\r\n    ...shell,\r\n    then(onFulfilled, onRejected) {\r\n      return waitUntilFinished().then(onFulfilled, onRejected);\r\n    }\r\n  };\r\n}\r\nfunction joinPaths(start, end) {\r\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\")) {\r\n    return `${start}/${end}`;\r\n  }\r\n  if (start.endsWith(\"/\") && end.startsWith(\"/\")) {\r\n    return `${start.slice(0, -1)}${end}`;\r\n  }\r\n  return `${start}${end}`;\r\n}\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  multiple: true,\r\n  accept: \"*\",\r\n  reset: false,\r\n  directory: false\r\n};\r\nfunction prepareInitialFiles(files) {\r\n  if (!files)\r\n    return null;\r\n  if (files instanceof FileList)\r\n    return files;\r\n  const dt = new DataTransfer();\r\n  for (const file of files) {\r\n    dt.items.add(file);\r\n  }\r\n  return dt.files;\r\n}\r\nfunction useFileDialog(options = {}) {\r\n  const {\r\n    document = defaultDocument\r\n  } = options;\r\n  const files = ref(prepareInitialFiles(options.initialFiles));\r\n  const { on: onChange, trigger: changeTrigger } = createEventHook();\r\n  const { on: onCancel, trigger: cancelTrigger } = createEventHook();\r\n  let input;\r\n  if (document) {\r\n    input = document.createElement(\"input\");\r\n    input.type = \"file\";\r\n    input.onchange = (event) => {\r\n      const result = event.target;\r\n      files.value = result.files;\r\n      changeTrigger(files.value);\r\n    };\r\n    input.oncancel = () => {\r\n      cancelTrigger();\r\n    };\r\n  }\r\n  const reset = () => {\r\n    files.value = null;\r\n    if (input && input.value) {\r\n      input.value = \"\";\r\n      changeTrigger(null);\r\n    }\r\n  };\r\n  const open = (localOptions) => {\r\n    if (!input)\r\n      return;\r\n    const _options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options,\r\n      ...localOptions\r\n    };\r\n    input.multiple = _options.multiple;\r\n    input.accept = _options.accept;\r\n    input.webkitdirectory = _options.directory;\r\n    if (hasOwn(_options, \"capture\"))\r\n      input.capture = _options.capture;\r\n    if (_options.reset)\r\n      reset();\r\n    input.click();\r\n  };\r\n  return {\r\n    files: readonly(files),\r\n    open,\r\n    reset,\r\n    onCancel,\r\n    onChange\r\n  };\r\n}\r\n\r\nfunction useFileSystemAccess(options = {}) {\r\n  const {\r\n    window: _window = defaultWindow,\r\n    dataType = \"Text\"\r\n  } = options;\r\n  const window = _window;\r\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\r\n  const fileHandle = shallowRef();\r\n  const data = shallowRef();\r\n  const file = shallowRef();\r\n  const fileName = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\r\n  });\r\n  const fileMIME = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\r\n  });\r\n  const fileSize = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\r\n  });\r\n  const fileLastModified = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\r\n  });\r\n  async function open(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\r\n    fileHandle.value = handle;\r\n    await updateData();\r\n  }\r\n  async function create(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\r\n    data.value = void 0;\r\n    await updateData();\r\n  }\r\n  async function save(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (!fileHandle.value)\r\n      return saveAs(_options);\r\n    if (data.value) {\r\n      const writableStream = await fileHandle.value.createWritable();\r\n      await writableStream.write(data.value);\r\n      await writableStream.close();\r\n    }\r\n    await updateFile();\r\n  }\r\n  async function saveAs(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\r\n    if (data.value) {\r\n      const writableStream = await fileHandle.value.createWritable();\r\n      await writableStream.write(data.value);\r\n      await writableStream.close();\r\n    }\r\n    await updateFile();\r\n  }\r\n  async function updateFile() {\r\n    var _a;\r\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\r\n  }\r\n  async function updateData() {\r\n    var _a, _b;\r\n    await updateFile();\r\n    const type = toValue(dataType);\r\n    if (type === \"Text\")\r\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\r\n    else if (type === \"ArrayBuffer\")\r\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\r\n    else if (type === \"Blob\")\r\n      data.value = file.value;\r\n  }\r\n  watch(() => toValue(dataType), updateData);\r\n  return {\r\n    isSupported,\r\n    data,\r\n    file,\r\n    fileName,\r\n    fileMIME,\r\n    fileSize,\r\n    fileLastModified,\r\n    open,\r\n    create,\r\n    save,\r\n    saveAs,\r\n    updateData\r\n  };\r\n}\r\n\r\nfunction useFocus(target, options = {}) {\r\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\r\n  const innerFocused = shallowRef(false);\r\n  const targetElement = computed(() => unrefElement(target));\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(targetElement, \"focus\", (event) => {\r\n    var _a, _b;\r\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\r\n      innerFocused.value = true;\r\n  }, listenerOptions);\r\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false, listenerOptions);\r\n  const focused = computed({\r\n    get: () => innerFocused.value,\r\n    set(value) {\r\n      var _a, _b;\r\n      if (!value && innerFocused.value)\r\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\r\n      else if (value && !innerFocused.value)\r\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\r\n    }\r\n  });\r\n  watch(\r\n    targetElement,\r\n    () => {\r\n      focused.value = initialValue;\r\n    },\r\n    { immediate: true, flush: \"post\" }\r\n  );\r\n  return { focused };\r\n}\r\n\r\nconst EVENT_FOCUS_IN = \"focusin\";\r\nconst EVENT_FOCUS_OUT = \"focusout\";\r\nconst PSEUDO_CLASS_FOCUS_WITHIN = \":focus-within\";\r\nfunction useFocusWithin(target, options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const targetElement = computed(() => unrefElement(target));\r\n  const _focused = shallowRef(false);\r\n  const focused = computed(() => _focused.value);\r\n  const activeElement = useActiveElement(options);\r\n  if (!window || !activeElement.value) {\r\n    return { focused };\r\n  }\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);\r\n  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {\r\n    var _a, _b, _c;\r\n    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;\r\n  }, listenerOptions);\r\n  return { focused };\r\n}\r\n\r\nfunction useFps(options) {\r\n  var _a;\r\n  const fps = shallowRef(0);\r\n  if (typeof performance === \"undefined\")\r\n    return fps;\r\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\r\n  let last = performance.now();\r\n  let ticks = 0;\r\n  useRafFn(() => {\r\n    ticks += 1;\r\n    if (ticks >= every) {\r\n      const now = performance.now();\r\n      const diff = now - last;\r\n      fps.value = Math.round(1e3 / (diff / ticks));\r\n      last = now;\r\n      ticks = 0;\r\n    }\r\n  });\r\n  return fps;\r\n}\r\n\r\nconst eventHandlers = [\r\n  \"fullscreenchange\",\r\n  \"webkitfullscreenchange\",\r\n  \"webkitendfullscreen\",\r\n  \"mozfullscreenchange\",\r\n  \"MSFullscreenChange\"\r\n];\r\nfunction useFullscreen(target, options = {}) {\r\n  const {\r\n    document = defaultDocument,\r\n    autoExit = false\r\n  } = options;\r\n  const targetRef = computed(() => {\r\n    var _a;\r\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.documentElement;\r\n  });\r\n  const isFullscreen = shallowRef(false);\r\n  const requestMethod = computed(() => {\r\n    return [\r\n      \"requestFullscreen\",\r\n      \"webkitRequestFullscreen\",\r\n      \"webkitEnterFullscreen\",\r\n      \"webkitEnterFullScreen\",\r\n      \"webkitRequestFullScreen\",\r\n      \"mozRequestFullScreen\",\r\n      \"msRequestFullscreen\"\r\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\r\n  });\r\n  const exitMethod = computed(() => {\r\n    return [\r\n      \"exitFullscreen\",\r\n      \"webkitExitFullscreen\",\r\n      \"webkitExitFullScreen\",\r\n      \"webkitCancelFullScreen\",\r\n      \"mozCancelFullScreen\",\r\n      \"msExitFullscreen\"\r\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\r\n  });\r\n  const fullscreenEnabled = computed(() => {\r\n    return [\r\n      \"fullScreen\",\r\n      \"webkitIsFullScreen\",\r\n      \"webkitDisplayingFullscreen\",\r\n      \"mozFullScreen\",\r\n      \"msFullscreenElement\"\r\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\r\n  });\r\n  const fullscreenElementMethod = [\r\n    \"fullscreenElement\",\r\n    \"webkitFullscreenElement\",\r\n    \"mozFullScreenElement\",\r\n    \"msFullscreenElement\"\r\n  ].find((m) => document && m in document);\r\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\r\n  const isCurrentElementFullScreen = () => {\r\n    if (fullscreenElementMethod)\r\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\r\n    return false;\r\n  };\r\n  const isElementFullScreen = () => {\r\n    if (fullscreenEnabled.value) {\r\n      if (document && document[fullscreenEnabled.value] != null) {\r\n        return document[fullscreenEnabled.value];\r\n      } else {\r\n        const target2 = targetRef.value;\r\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\r\n          return Boolean(target2[fullscreenEnabled.value]);\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n  async function exit() {\r\n    if (!isSupported.value || !isFullscreen.value)\r\n      return;\r\n    if (exitMethod.value) {\r\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\r\n        await document[exitMethod.value]();\r\n      } else {\r\n        const target2 = targetRef.value;\r\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\r\n          await target2[exitMethod.value]();\r\n      }\r\n    }\r\n    isFullscreen.value = false;\r\n  }\r\n  async function enter() {\r\n    if (!isSupported.value || isFullscreen.value)\r\n      return;\r\n    if (isElementFullScreen())\r\n      await exit();\r\n    const target2 = targetRef.value;\r\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\r\n      await target2[requestMethod.value]();\r\n      isFullscreen.value = true;\r\n    }\r\n  }\r\n  async function toggle() {\r\n    await (isFullscreen.value ? exit() : enter());\r\n  }\r\n  const handlerCallback = () => {\r\n    const isElementFullScreenValue = isElementFullScreen();\r\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\r\n      isFullscreen.value = isElementFullScreenValue;\r\n  };\r\n  const listenerOptions = { capture: false, passive: true };\r\n  useEventListener(document, eventHandlers, handlerCallback, listenerOptions);\r\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, listenerOptions);\r\n  if (autoExit)\r\n    tryOnScopeDispose(exit);\r\n  return {\r\n    isSupported,\r\n    isFullscreen,\r\n    enter,\r\n    exit,\r\n    toggle\r\n  };\r\n}\r\n\r\nfunction mapGamepadToXbox360Controller(gamepad) {\r\n  return computed(() => {\r\n    if (gamepad.value) {\r\n      return {\r\n        buttons: {\r\n          a: gamepad.value.buttons[0],\r\n          b: gamepad.value.buttons[1],\r\n          x: gamepad.value.buttons[2],\r\n          y: gamepad.value.buttons[3]\r\n        },\r\n        bumper: {\r\n          left: gamepad.value.buttons[4],\r\n          right: gamepad.value.buttons[5]\r\n        },\r\n        triggers: {\r\n          left: gamepad.value.buttons[6],\r\n          right: gamepad.value.buttons[7]\r\n        },\r\n        stick: {\r\n          left: {\r\n            horizontal: gamepad.value.axes[0],\r\n            vertical: gamepad.value.axes[1],\r\n            button: gamepad.value.buttons[10]\r\n          },\r\n          right: {\r\n            horizontal: gamepad.value.axes[2],\r\n            vertical: gamepad.value.axes[3],\r\n            button: gamepad.value.buttons[11]\r\n          }\r\n        },\r\n        dpad: {\r\n          up: gamepad.value.buttons[12],\r\n          down: gamepad.value.buttons[13],\r\n          left: gamepad.value.buttons[14],\r\n          right: gamepad.value.buttons[15]\r\n        },\r\n        back: gamepad.value.buttons[8],\r\n        start: gamepad.value.buttons[9]\r\n      };\r\n    }\r\n    return null;\r\n  });\r\n}\r\nfunction useGamepad(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\r\n  const gamepads = ref([]);\r\n  const onConnectedHook = createEventHook();\r\n  const onDisconnectedHook = createEventHook();\r\n  const stateFromGamepad = (gamepad) => {\r\n    const hapticActuators = [];\r\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\r\n    if (vibrationActuator)\r\n      hapticActuators.push(vibrationActuator);\r\n    if (gamepad.hapticActuators)\r\n      hapticActuators.push(...gamepad.hapticActuators);\r\n    return {\r\n      id: gamepad.id,\r\n      index: gamepad.index,\r\n      connected: gamepad.connected,\r\n      mapping: gamepad.mapping,\r\n      timestamp: gamepad.timestamp,\r\n      vibrationActuator: gamepad.vibrationActuator,\r\n      hapticActuators,\r\n      axes: gamepad.axes.map((axes) => axes),\r\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\r\n    };\r\n  };\r\n  const updateGamepadState = () => {\r\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\r\n    for (const gamepad of _gamepads) {\r\n      if (gamepad && gamepads.value[gamepad.index])\r\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\r\n    }\r\n  };\r\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\r\n  const onGamepadConnected = (gamepad) => {\r\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\r\n      gamepads.value.push(stateFromGamepad(gamepad));\r\n      onConnectedHook.trigger(gamepad.index);\r\n    }\r\n    resume();\r\n  };\r\n  const onGamepadDisconnected = (gamepad) => {\r\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\r\n    onDisconnectedHook.trigger(gamepad.index);\r\n  };\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad), listenerOptions);\r\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad), listenerOptions);\r\n  tryOnMounted(() => {\r\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\r\n    for (const gamepad of _gamepads) {\r\n      if (gamepad && gamepads.value[gamepad.index])\r\n        onGamepadConnected(gamepad);\r\n    }\r\n  });\r\n  pause();\r\n  return {\r\n    isSupported,\r\n    onConnected: onConnectedHook.on,\r\n    onDisconnected: onDisconnectedHook.on,\r\n    gamepads,\r\n    pause,\r\n    resume,\r\n    isActive\r\n  };\r\n}\r\n\r\nfunction useGeolocation(options = {}) {\r\n  const {\r\n    enableHighAccuracy = true,\r\n    maximumAge = 3e4,\r\n    timeout = 27e3,\r\n    navigator = defaultNavigator,\r\n    immediate = true\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\r\n  const locatedAt = shallowRef(null);\r\n  const error = shallowRef(null);\r\n  const coords = ref({\r\n    accuracy: 0,\r\n    latitude: Number.POSITIVE_INFINITY,\r\n    longitude: Number.POSITIVE_INFINITY,\r\n    altitude: null,\r\n    altitudeAccuracy: null,\r\n    heading: null,\r\n    speed: null\r\n  });\r\n  function updatePosition(position) {\r\n    locatedAt.value = position.timestamp;\r\n    coords.value = position.coords;\r\n    error.value = null;\r\n  }\r\n  let watcher;\r\n  function resume() {\r\n    if (isSupported.value) {\r\n      watcher = navigator.geolocation.watchPosition(\r\n        updatePosition,\r\n        (err) => error.value = err,\r\n        {\r\n          enableHighAccuracy,\r\n          maximumAge,\r\n          timeout\r\n        }\r\n      );\r\n    }\r\n  }\r\n  if (immediate)\r\n    resume();\r\n  function pause() {\r\n    if (watcher && navigator)\r\n      navigator.geolocation.clearWatch(watcher);\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    pause();\r\n  });\r\n  return {\r\n    isSupported,\r\n    coords,\r\n    locatedAt,\r\n    error,\r\n    resume,\r\n    pause\r\n  };\r\n}\r\n\r\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\r\nconst oneMinute = 6e4;\r\nfunction useIdle(timeout = oneMinute, options = {}) {\r\n  const {\r\n    initialState = false,\r\n    listenForVisibilityChange = true,\r\n    events = defaultEvents$1,\r\n    window = defaultWindow,\r\n    eventFilter = throttleFilter(50)\r\n  } = options;\r\n  const idle = shallowRef(initialState);\r\n  const lastActive = shallowRef(timestamp());\r\n  let timer;\r\n  const reset = () => {\r\n    idle.value = false;\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => idle.value = true, timeout);\r\n  };\r\n  const onEvent = createFilterWrapper(\r\n    eventFilter,\r\n    () => {\r\n      lastActive.value = timestamp();\r\n      reset();\r\n    }\r\n  );\r\n  if (window) {\r\n    const document = window.document;\r\n    const listenerOptions = { passive: true };\r\n    for (const event of events)\r\n      useEventListener(window, event, onEvent, listenerOptions);\r\n    if (listenForVisibilityChange) {\r\n      useEventListener(document, \"visibilitychange\", () => {\r\n        if (!document.hidden)\r\n          onEvent();\r\n      }, listenerOptions);\r\n    }\r\n    reset();\r\n  }\r\n  return {\r\n    idle,\r\n    lastActive,\r\n    reset\r\n  };\r\n}\r\n\r\nasync function loadImage(options) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy, width, height, decoding, fetchPriority, ismap, usemap } = options;\r\n    img.src = src;\r\n    if (srcset != null)\r\n      img.srcset = srcset;\r\n    if (sizes != null)\r\n      img.sizes = sizes;\r\n    if (clazz != null)\r\n      img.className = clazz;\r\n    if (loading != null)\r\n      img.loading = loading;\r\n    if (crossorigin != null)\r\n      img.crossOrigin = crossorigin;\r\n    if (referrerPolicy != null)\r\n      img.referrerPolicy = referrerPolicy;\r\n    if (width != null)\r\n      img.width = width;\r\n    if (height != null)\r\n      img.height = height;\r\n    if (decoding != null)\r\n      img.decoding = decoding;\r\n    if (fetchPriority != null)\r\n      img.fetchPriority = fetchPriority;\r\n    if (ismap != null)\r\n      img.isMap = ismap;\r\n    if (usemap != null)\r\n      img.useMap = usemap;\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n  });\r\n}\r\nfunction useImage(options, asyncStateOptions = {}) {\r\n  const state = useAsyncState(\r\n    () => loadImage(toValue(options)),\r\n    void 0,\r\n    {\r\n      resetOnExecute: true,\r\n      ...asyncStateOptions\r\n    }\r\n  );\r\n  watch(\r\n    () => toValue(options),\r\n    () => state.execute(asyncStateOptions.delay),\r\n    { deep: true }\r\n  );\r\n  return state;\r\n}\r\n\r\nfunction resolveElement(el) {\r\n  if (typeof Window !== \"undefined\" && el instanceof Window)\r\n    return el.document.documentElement;\r\n  if (typeof Document !== \"undefined\" && el instanceof Document)\r\n    return el.documentElement;\r\n  return el;\r\n}\r\n\r\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\r\nfunction useScroll(element, options = {}) {\r\n  const {\r\n    throttle = 0,\r\n    idle = 200,\r\n    onStop = noop,\r\n    onScroll = noop,\r\n    offset = {\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    },\r\n    eventListenerOptions = {\r\n      capture: false,\r\n      passive: true\r\n    },\r\n    behavior = \"auto\",\r\n    window = defaultWindow,\r\n    onError = (e) => {\r\n      console.error(e);\r\n    }\r\n  } = options;\r\n  const internalX = shallowRef(0);\r\n  const internalY = shallowRef(0);\r\n  const x = computed({\r\n    get() {\r\n      return internalX.value;\r\n    },\r\n    set(x2) {\r\n      scrollTo(x2, void 0);\r\n    }\r\n  });\r\n  const y = computed({\r\n    get() {\r\n      return internalY.value;\r\n    },\r\n    set(y2) {\r\n      scrollTo(void 0, y2);\r\n    }\r\n  });\r\n  function scrollTo(_x, _y) {\r\n    var _a, _b, _c, _d;\r\n    if (!window)\r\n      return;\r\n    const _element = toValue(element);\r\n    if (!_element)\r\n      return;\r\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\r\n      top: (_a = toValue(_y)) != null ? _a : y.value,\r\n      left: (_b = toValue(_x)) != null ? _b : x.value,\r\n      behavior: toValue(behavior)\r\n    });\r\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\r\n    if (x != null)\r\n      internalX.value = scrollContainer.scrollLeft;\r\n    if (y != null)\r\n      internalY.value = scrollContainer.scrollTop;\r\n  }\r\n  const isScrolling = shallowRef(false);\r\n  const arrivedState = reactive({\r\n    left: true,\r\n    right: false,\r\n    top: true,\r\n    bottom: false\r\n  });\r\n  const directions = reactive({\r\n    left: false,\r\n    right: false,\r\n    top: false,\r\n    bottom: false\r\n  });\r\n  const onScrollEnd = (e) => {\r\n    if (!isScrolling.value)\r\n      return;\r\n    isScrolling.value = false;\r\n    directions.left = false;\r\n    directions.right = false;\r\n    directions.top = false;\r\n    directions.bottom = false;\r\n    onStop(e);\r\n  };\r\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\r\n  const setArrivedState = (target) => {\r\n    var _a;\r\n    if (!window)\r\n      return;\r\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\r\n    const { display, flexDirection, direction } = getComputedStyle(el);\r\n    const directionMultipler = direction === \"rtl\" ? -1 : 1;\r\n    const scrollLeft = el.scrollLeft;\r\n    directions.left = scrollLeft < internalX.value;\r\n    directions.right = scrollLeft > internalX.value;\r\n    const left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);\r\n    const right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\r\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\r\n      arrivedState.left = right;\r\n      arrivedState.right = left;\r\n    } else {\r\n      arrivedState.left = left;\r\n      arrivedState.right = right;\r\n    }\r\n    internalX.value = scrollLeft;\r\n    let scrollTop = el.scrollTop;\r\n    if (target === window.document && !scrollTop)\r\n      scrollTop = window.document.body.scrollTop;\r\n    directions.top = scrollTop < internalY.value;\r\n    directions.bottom = scrollTop > internalY.value;\r\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\r\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\r\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\r\n      arrivedState.top = bottom;\r\n      arrivedState.bottom = top;\r\n    } else {\r\n      arrivedState.top = top;\r\n      arrivedState.bottom = bottom;\r\n    }\r\n    internalY.value = scrollTop;\r\n  };\r\n  const onScrollHandler = (e) => {\r\n    var _a;\r\n    if (!window)\r\n      return;\r\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\r\n    setArrivedState(eventTarget);\r\n    isScrolling.value = true;\r\n    onScrollEndDebounced(e);\r\n    onScroll(e);\r\n  };\r\n  useEventListener(\r\n    element,\r\n    \"scroll\",\r\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\r\n    eventListenerOptions\r\n  );\r\n  tryOnMounted(() => {\r\n    try {\r\n      const _element = toValue(element);\r\n      if (!_element)\r\n        return;\r\n      setArrivedState(_element);\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  });\r\n  useEventListener(\r\n    element,\r\n    \"scrollend\",\r\n    onScrollEnd,\r\n    eventListenerOptions\r\n  );\r\n  return {\r\n    x,\r\n    y,\r\n    isScrolling,\r\n    arrivedState,\r\n    directions,\r\n    measure() {\r\n      const _element = toValue(element);\r\n      if (window && _element)\r\n        setArrivedState(_element);\r\n    }\r\n  };\r\n}\r\n\r\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\r\n  var _a;\r\n  const {\r\n    direction = \"bottom\",\r\n    interval = 100,\r\n    canLoadMore = () => true\r\n  } = options;\r\n  const state = reactive(useScroll(\r\n    element,\r\n    {\r\n      ...options,\r\n      offset: {\r\n        [direction]: (_a = options.distance) != null ? _a : 0,\r\n        ...options.offset\r\n      }\r\n    }\r\n  ));\r\n  const promise = ref();\r\n  const isLoading = computed(() => !!promise.value);\r\n  const observedElement = computed(() => {\r\n    return resolveElement(toValue(element));\r\n  });\r\n  const isElementVisible = useElementVisibility(observedElement);\r\n  function checkAndLoad() {\r\n    state.measure();\r\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\r\n      return;\r\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\r\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\r\n    if (state.arrivedState[direction] || isNarrower) {\r\n      if (!promise.value) {\r\n        promise.value = Promise.all([\r\n          onLoadMore(state),\r\n          new Promise((resolve) => setTimeout(resolve, interval))\r\n        ]).finally(() => {\r\n          promise.value = null;\r\n          nextTick(() => checkAndLoad());\r\n        });\r\n      }\r\n    }\r\n  }\r\n  const stop = watch(\r\n    () => [state.arrivedState[direction], isElementVisible.value],\r\n    checkAndLoad,\r\n    { immediate: true }\r\n  );\r\n  tryOnUnmounted(stop);\r\n  return {\r\n    isLoading,\r\n    reset() {\r\n      nextTick(() => checkAndLoad());\r\n    }\r\n  };\r\n}\r\n\r\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\r\nfunction useKeyModifier(modifier, options = {}) {\r\n  const {\r\n    events = defaultEvents,\r\n    document = defaultDocument,\r\n    initial = null\r\n  } = options;\r\n  const state = shallowRef(initial);\r\n  if (document) {\r\n    events.forEach((listenerEvent) => {\r\n      useEventListener(document, listenerEvent, (evt) => {\r\n        if (typeof evt.getModifierState === \"function\")\r\n          state.value = evt.getModifierState(modifier);\r\n      }, { passive: true });\r\n    });\r\n  }\r\n  return state;\r\n}\r\n\r\nfunction useLocalStorage(key, initialValue, options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\r\n}\r\n\r\nconst DefaultMagicKeysAliasMap = {\r\n  ctrl: \"control\",\r\n  command: \"meta\",\r\n  cmd: \"meta\",\r\n  option: \"alt\",\r\n  up: \"arrowup\",\r\n  down: \"arrowdown\",\r\n  left: \"arrowleft\",\r\n  right: \"arrowright\"\r\n};\r\n\r\nfunction useMagicKeys(options = {}) {\r\n  const {\r\n    reactive: useReactive = false,\r\n    target = defaultWindow,\r\n    aliasMap = DefaultMagicKeysAliasMap,\r\n    passive = true,\r\n    onEventFired = noop\r\n  } = options;\r\n  const current = reactive(/* @__PURE__ */ new Set());\r\n  const obj = {\r\n    toJSON() {\r\n      return {};\r\n    },\r\n    current\r\n  };\r\n  const refs = useReactive ? reactive(obj) : obj;\r\n  const metaDeps = /* @__PURE__ */ new Set();\r\n  const usedKeys = /* @__PURE__ */ new Set();\r\n  function setRefs(key, value) {\r\n    if (key in refs) {\r\n      if (useReactive)\r\n        refs[key] = value;\r\n      else\r\n        refs[key].value = value;\r\n    }\r\n  }\r\n  function reset() {\r\n    current.clear();\r\n    for (const key of usedKeys)\r\n      setRefs(key, false);\r\n  }\r\n  function updateRefs(e, value) {\r\n    var _a, _b;\r\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\r\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\r\n    const values = [code, key].filter(Boolean);\r\n    if (key) {\r\n      if (value)\r\n        current.add(key);\r\n      else\r\n        current.delete(key);\r\n    }\r\n    for (const key2 of values) {\r\n      usedKeys.add(key2);\r\n      setRefs(key2, value);\r\n    }\r\n    if (key === \"meta\" && !value) {\r\n      metaDeps.forEach((key2) => {\r\n        current.delete(key2);\r\n        setRefs(key2, false);\r\n      });\r\n      metaDeps.clear();\r\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\r\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\r\n    }\r\n  }\r\n  useEventListener(target, \"keydown\", (e) => {\r\n    updateRefs(e, true);\r\n    return onEventFired(e);\r\n  }, { passive });\r\n  useEventListener(target, \"keyup\", (e) => {\r\n    updateRefs(e, false);\r\n    return onEventFired(e);\r\n  }, { passive });\r\n  useEventListener(\"blur\", reset, { passive });\r\n  useEventListener(\"focus\", reset, { passive });\r\n  const proxy = new Proxy(\r\n    refs,\r\n    {\r\n      get(target2, prop, rec) {\r\n        if (typeof prop !== \"string\")\r\n          return Reflect.get(target2, prop, rec);\r\n        prop = prop.toLowerCase();\r\n        if (prop in aliasMap)\r\n          prop = aliasMap[prop];\r\n        if (!(prop in refs)) {\r\n          if (/[+_-]/.test(prop)) {\r\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\r\n            refs[prop] = computed(() => keys.map((key) => toValue(proxy[key])).every(Boolean));\r\n          } else {\r\n            refs[prop] = shallowRef(false);\r\n          }\r\n        }\r\n        const r = Reflect.get(target2, prop, rec);\r\n        return useReactive ? toValue(r) : r;\r\n      }\r\n    }\r\n  );\r\n  return proxy;\r\n}\r\n\r\nfunction usingElRef(source, cb) {\r\n  if (toValue(source))\r\n    cb(toValue(source));\r\n}\r\nfunction timeRangeToArray(timeRanges) {\r\n  let ranges = [];\r\n  for (let i = 0; i < timeRanges.length; ++i)\r\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\r\n  return ranges;\r\n}\r\nfunction tracksToArray(tracks) {\r\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\r\n}\r\nconst defaultOptions = {\r\n  src: \"\",\r\n  tracks: []\r\n};\r\nfunction useMediaControls(target, options = {}) {\r\n  target = toRef(target);\r\n  options = {\r\n    ...defaultOptions,\r\n    ...options\r\n  };\r\n  const {\r\n    document = defaultDocument\r\n  } = options;\r\n  const listenerOptions = { passive: true };\r\n  const currentTime = shallowRef(0);\r\n  const duration = shallowRef(0);\r\n  const seeking = shallowRef(false);\r\n  const volume = shallowRef(1);\r\n  const waiting = shallowRef(false);\r\n  const ended = shallowRef(false);\r\n  const playing = shallowRef(false);\r\n  const rate = shallowRef(1);\r\n  const stalled = shallowRef(false);\r\n  const buffered = ref([]);\r\n  const tracks = ref([]);\r\n  const selectedTrack = shallowRef(-1);\r\n  const isPictureInPicture = shallowRef(false);\r\n  const muted = shallowRef(false);\r\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\r\n  const sourceErrorEvent = createEventHook();\r\n  const playbackErrorEvent = createEventHook();\r\n  const disableTrack = (track) => {\r\n    usingElRef(target, (el) => {\r\n      if (track) {\r\n        const id = typeof track === \"number\" ? track : track.id;\r\n        el.textTracks[id].mode = \"disabled\";\r\n      } else {\r\n        for (let i = 0; i < el.textTracks.length; ++i)\r\n          el.textTracks[i].mode = \"disabled\";\r\n      }\r\n      selectedTrack.value = -1;\r\n    });\r\n  };\r\n  const enableTrack = (track, disableTracks = true) => {\r\n    usingElRef(target, (el) => {\r\n      const id = typeof track === \"number\" ? track : track.id;\r\n      if (disableTracks)\r\n        disableTrack();\r\n      el.textTracks[id].mode = \"showing\";\r\n      selectedTrack.value = id;\r\n    });\r\n  };\r\n  const togglePictureInPicture = () => {\r\n    return new Promise((resolve, reject) => {\r\n      usingElRef(target, async (el) => {\r\n        if (supportsPictureInPicture) {\r\n          if (!isPictureInPicture.value) {\r\n            el.requestPictureInPicture().then(resolve).catch(reject);\r\n          } else {\r\n            document.exitPictureInPicture().then(resolve).catch(reject);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  };\r\n  watchEffect(() => {\r\n    if (!document)\r\n      return;\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    const src = toValue(options.src);\r\n    let sources = [];\r\n    if (!src)\r\n      return;\r\n    if (typeof src === \"string\")\r\n      sources = [{ src }];\r\n    else if (Array.isArray(src))\r\n      sources = src;\r\n    else if (isObject(src))\r\n      sources = [src];\r\n    el.querySelectorAll(\"source\").forEach((e) => {\r\n      e.remove();\r\n    });\r\n    sources.forEach(({ src: src2, type, media }) => {\r\n      const source = document.createElement(\"source\");\r\n      source.setAttribute(\"src\", src2);\r\n      source.setAttribute(\"type\", type || \"\");\r\n      source.setAttribute(\"media\", media || \"\");\r\n      useEventListener(source, \"error\", sourceErrorEvent.trigger, listenerOptions);\r\n      el.appendChild(source);\r\n    });\r\n    el.load();\r\n  });\r\n  watch([target, volume], () => {\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    el.volume = volume.value;\r\n  });\r\n  watch([target, muted], () => {\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    el.muted = muted.value;\r\n  });\r\n  watch([target, rate], () => {\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    el.playbackRate = rate.value;\r\n  });\r\n  watchEffect(() => {\r\n    if (!document)\r\n      return;\r\n    const textTracks = toValue(options.tracks);\r\n    const el = toValue(target);\r\n    if (!textTracks || !textTracks.length || !el)\r\n      return;\r\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\r\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\r\n      const track = document.createElement(\"track\");\r\n      track.default = isDefault || false;\r\n      track.kind = kind;\r\n      track.label = label;\r\n      track.src = src;\r\n      track.srclang = srcLang;\r\n      if (track.default)\r\n        selectedTrack.value = i;\r\n      el.appendChild(track);\r\n    });\r\n  });\r\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    el.currentTime = time;\r\n  });\r\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    if (isPlaying) {\r\n      el.play().catch((e) => {\r\n        playbackErrorEvent.trigger(e);\r\n        throw e;\r\n      });\r\n    } else {\r\n      el.pause();\r\n    }\r\n  });\r\n  useEventListener(\r\n    target,\r\n    \"timeupdate\",\r\n    () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime),\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"durationchange\",\r\n    () => duration.value = toValue(target).duration,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"progress\",\r\n    () => buffered.value = timeRangeToArray(toValue(target).buffered),\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"seeking\",\r\n    () => seeking.value = true,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"seeked\",\r\n    () => seeking.value = false,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    [\"waiting\", \"loadstart\"],\r\n    () => {\r\n      waiting.value = true;\r\n      ignorePlayingUpdates(() => playing.value = false);\r\n    },\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"loadeddata\",\r\n    () => waiting.value = false,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"playing\",\r\n    () => {\r\n      waiting.value = false;\r\n      ended.value = false;\r\n      ignorePlayingUpdates(() => playing.value = true);\r\n    },\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"ratechange\",\r\n    () => rate.value = toValue(target).playbackRate,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"stalled\",\r\n    () => stalled.value = true,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"ended\",\r\n    () => ended.value = true,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"pause\",\r\n    () => ignorePlayingUpdates(() => playing.value = false),\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"play\",\r\n    () => ignorePlayingUpdates(() => playing.value = true),\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"enterpictureinpicture\",\r\n    () => isPictureInPicture.value = true,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"leavepictureinpicture\",\r\n    () => isPictureInPicture.value = false,\r\n    listenerOptions\r\n  );\r\n  useEventListener(\r\n    target,\r\n    \"volumechange\",\r\n    () => {\r\n      const el = toValue(target);\r\n      if (!el)\r\n        return;\r\n      volume.value = el.volume;\r\n      muted.value = el.muted;\r\n    },\r\n    listenerOptions\r\n  );\r\n  const listeners = [];\r\n  const stop = watch([target], () => {\r\n    const el = toValue(target);\r\n    if (!el)\r\n      return;\r\n    stop();\r\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\r\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\r\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\r\n  });\r\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\r\n  return {\r\n    currentTime,\r\n    duration,\r\n    waiting,\r\n    seeking,\r\n    ended,\r\n    stalled,\r\n    buffered,\r\n    playing,\r\n    rate,\r\n    // Volume\r\n    volume,\r\n    muted,\r\n    // Tracks\r\n    tracks,\r\n    selectedTrack,\r\n    enableTrack,\r\n    disableTrack,\r\n    // Picture in Picture\r\n    supportsPictureInPicture,\r\n    togglePictureInPicture,\r\n    isPictureInPicture,\r\n    // Events\r\n    onSourceError: sourceErrorEvent.on,\r\n    onPlaybackError: playbackErrorEvent.on\r\n  };\r\n}\r\n\r\nfunction useMemoize(resolver, options) {\r\n  const initCache = () => {\r\n    if (options == null ? void 0 : options.cache)\r\n      return shallowReactive(options.cache);\r\n    return shallowReactive(/* @__PURE__ */ new Map());\r\n  };\r\n  const cache = initCache();\r\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\r\n  const _loadData = (key, ...args) => {\r\n    cache.set(key, resolver(...args));\r\n    return cache.get(key);\r\n  };\r\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\r\n  const deleteData = (...args) => {\r\n    cache.delete(generateKey(...args));\r\n  };\r\n  const clearData = () => {\r\n    cache.clear();\r\n  };\r\n  const memoized = (...args) => {\r\n    const key = generateKey(...args);\r\n    if (cache.has(key))\r\n      return cache.get(key);\r\n    return _loadData(key, ...args);\r\n  };\r\n  memoized.load = loadData;\r\n  memoized.delete = deleteData;\r\n  memoized.clear = clearData;\r\n  memoized.generateKey = generateKey;\r\n  memoized.cache = cache;\r\n  return memoized;\r\n}\r\n\r\nfunction useMemory(options = {}) {\r\n  const memory = ref();\r\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\r\n  if (isSupported.value) {\r\n    const { interval = 1e3 } = options;\r\n    useIntervalFn(() => {\r\n      memory.value = performance.memory;\r\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\r\n  }\r\n  return { isSupported, memory };\r\n}\r\n\r\nconst UseMouseBuiltinExtractors = {\r\n  page: (event) => [event.pageX, event.pageY],\r\n  client: (event) => [event.clientX, event.clientY],\r\n  screen: (event) => [event.screenX, event.screenY],\r\n  movement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null\r\n};\r\nfunction useMouse(options = {}) {\r\n  const {\r\n    type = \"page\",\r\n    touch = true,\r\n    resetOnTouchEnds = false,\r\n    initialValue = { x: 0, y: 0 },\r\n    window = defaultWindow,\r\n    target = window,\r\n    scroll = true,\r\n    eventFilter\r\n  } = options;\r\n  let _prevMouseEvent = null;\r\n  let _prevScrollX = 0;\r\n  let _prevScrollY = 0;\r\n  const x = shallowRef(initialValue.x);\r\n  const y = shallowRef(initialValue.y);\r\n  const sourceType = shallowRef(null);\r\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\r\n  const mouseHandler = (event) => {\r\n    const result = extractor(event);\r\n    _prevMouseEvent = event;\r\n    if (result) {\r\n      [x.value, y.value] = result;\r\n      sourceType.value = \"mouse\";\r\n    }\r\n    if (window) {\r\n      _prevScrollX = window.scrollX;\r\n      _prevScrollY = window.scrollY;\r\n    }\r\n  };\r\n  const touchHandler = (event) => {\r\n    if (event.touches.length > 0) {\r\n      const result = extractor(event.touches[0]);\r\n      if (result) {\r\n        [x.value, y.value] = result;\r\n        sourceType.value = \"touch\";\r\n      }\r\n    }\r\n  };\r\n  const scrollHandler = () => {\r\n    if (!_prevMouseEvent || !window)\r\n      return;\r\n    const pos = extractor(_prevMouseEvent);\r\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\r\n      x.value = pos[0] + window.scrollX - _prevScrollX;\r\n      y.value = pos[1] + window.scrollY - _prevScrollY;\r\n    }\r\n  };\r\n  const reset = () => {\r\n    x.value = initialValue.x;\r\n    y.value = initialValue.y;\r\n  };\r\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\r\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\r\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\r\n  if (target) {\r\n    const listenerOptions = { passive: true };\r\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\r\n    if (touch && type !== \"movement\") {\r\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\r\n      if (resetOnTouchEnds)\r\n        useEventListener(target, \"touchend\", reset, listenerOptions);\r\n    }\r\n    if (scroll && type === \"page\")\r\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, listenerOptions);\r\n  }\r\n  return {\r\n    x,\r\n    y,\r\n    sourceType\r\n  };\r\n}\r\n\r\nfunction useMouseInElement(target, options = {}) {\r\n  const {\r\n    handleOutside = true,\r\n    window = defaultWindow\r\n  } = options;\r\n  const type = options.type || \"page\";\r\n  const { x, y, sourceType } = useMouse(options);\r\n  const targetRef = shallowRef(target != null ? target : window == null ? void 0 : window.document.body);\r\n  const elementX = shallowRef(0);\r\n  const elementY = shallowRef(0);\r\n  const elementPositionX = shallowRef(0);\r\n  const elementPositionY = shallowRef(0);\r\n  const elementHeight = shallowRef(0);\r\n  const elementWidth = shallowRef(0);\r\n  const isOutside = shallowRef(true);\r\n  let stop = () => {\r\n  };\r\n  if (window) {\r\n    stop = watch(\r\n      [targetRef, x, y],\r\n      () => {\r\n        const el = unrefElement(targetRef);\r\n        if (!el || !(el instanceof Element))\r\n          return;\r\n        const {\r\n          left,\r\n          top,\r\n          width,\r\n          height\r\n        } = el.getBoundingClientRect();\r\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\r\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\r\n        elementHeight.value = height;\r\n        elementWidth.value = width;\r\n        const elX = x.value - elementPositionX.value;\r\n        const elY = y.value - elementPositionY.value;\r\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\r\n        if (handleOutside || !isOutside.value) {\r\n          elementX.value = elX;\r\n          elementY.value = elY;\r\n        }\r\n      },\r\n      { immediate: true }\r\n    );\r\n    useEventListener(\r\n      document,\r\n      \"mouseleave\",\r\n      () => isOutside.value = true,\r\n      { passive: true }\r\n    );\r\n  }\r\n  return {\r\n    x,\r\n    y,\r\n    sourceType,\r\n    elementX,\r\n    elementY,\r\n    elementPositionX,\r\n    elementPositionY,\r\n    elementHeight,\r\n    elementWidth,\r\n    isOutside,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useMousePressed(options = {}) {\r\n  const {\r\n    touch = true,\r\n    drag = true,\r\n    capture = false,\r\n    initialValue = false,\r\n    window = defaultWindow\r\n  } = options;\r\n  const pressed = shallowRef(initialValue);\r\n  const sourceType = shallowRef(null);\r\n  if (!window) {\r\n    return {\r\n      pressed,\r\n      sourceType\r\n    };\r\n  }\r\n  const onPressed = (srcType) => (event) => {\r\n    var _a;\r\n    pressed.value = true;\r\n    sourceType.value = srcType;\r\n    (_a = options.onPressed) == null ? void 0 : _a.call(options, event);\r\n  };\r\n  const onReleased = (event) => {\r\n    var _a;\r\n    pressed.value = false;\r\n    sourceType.value = null;\r\n    (_a = options.onReleased) == null ? void 0 : _a.call(options, event);\r\n  };\r\n  const target = computed(() => unrefElement(options.target) || window);\r\n  const listenerOptions = { passive: true, capture };\r\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), listenerOptions);\r\n  useEventListener(window, \"mouseleave\", onReleased, listenerOptions);\r\n  useEventListener(window, \"mouseup\", onReleased, listenerOptions);\r\n  if (drag) {\r\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), listenerOptions);\r\n    useEventListener(window, \"drop\", onReleased, listenerOptions);\r\n    useEventListener(window, \"dragend\", onReleased, listenerOptions);\r\n  }\r\n  if (touch) {\r\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), listenerOptions);\r\n    useEventListener(window, \"touchend\", onReleased, listenerOptions);\r\n    useEventListener(window, \"touchcancel\", onReleased, listenerOptions);\r\n  }\r\n  return {\r\n    pressed,\r\n    sourceType\r\n  };\r\n}\r\n\r\nfunction useNavigatorLanguage(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const navigator = window == null ? void 0 : window.navigator;\r\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\r\n  const language = shallowRef(navigator == null ? void 0 : navigator.language);\r\n  useEventListener(window, \"languagechange\", () => {\r\n    if (navigator)\r\n      language.value = navigator.language;\r\n  }, { passive: true });\r\n  return {\r\n    isSupported,\r\n    language\r\n  };\r\n}\r\n\r\nfunction useNetwork(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const navigator = window == null ? void 0 : window.navigator;\r\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\r\n  const isOnline = shallowRef(true);\r\n  const saveData = shallowRef(false);\r\n  const offlineAt = shallowRef(void 0);\r\n  const onlineAt = shallowRef(void 0);\r\n  const downlink = shallowRef(void 0);\r\n  const downlinkMax = shallowRef(void 0);\r\n  const rtt = shallowRef(void 0);\r\n  const effectiveType = shallowRef(void 0);\r\n  const type = shallowRef(\"unknown\");\r\n  const connection = isSupported.value && navigator.connection;\r\n  function updateNetworkInformation() {\r\n    if (!navigator)\r\n      return;\r\n    isOnline.value = navigator.onLine;\r\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\r\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\r\n    if (connection) {\r\n      downlink.value = connection.downlink;\r\n      downlinkMax.value = connection.downlinkMax;\r\n      effectiveType.value = connection.effectiveType;\r\n      rtt.value = connection.rtt;\r\n      saveData.value = connection.saveData;\r\n      type.value = connection.type;\r\n    }\r\n  }\r\n  const listenerOptions = { passive: true };\r\n  if (window) {\r\n    useEventListener(window, \"offline\", () => {\r\n      isOnline.value = false;\r\n      offlineAt.value = Date.now();\r\n    }, listenerOptions);\r\n    useEventListener(window, \"online\", () => {\r\n      isOnline.value = true;\r\n      onlineAt.value = Date.now();\r\n    }, listenerOptions);\r\n  }\r\n  if (connection)\r\n    useEventListener(connection, \"change\", updateNetworkInformation, listenerOptions);\r\n  updateNetworkInformation();\r\n  return {\r\n    isSupported,\r\n    isOnline: readonly(isOnline),\r\n    saveData: readonly(saveData),\r\n    offlineAt: readonly(offlineAt),\r\n    onlineAt: readonly(onlineAt),\r\n    downlink: readonly(downlink),\r\n    downlinkMax: readonly(downlinkMax),\r\n    effectiveType: readonly(effectiveType),\r\n    rtt: readonly(rtt),\r\n    type: readonly(type)\r\n  };\r\n}\r\n\r\nfunction useNow(options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    interval = \"requestAnimationFrame\"\r\n  } = options;\r\n  const now = ref(/* @__PURE__ */ new Date());\r\n  const update = () => now.value = /* @__PURE__ */ new Date();\r\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\r\n  if (exposeControls) {\r\n    return {\r\n      now,\r\n      ...controls\r\n    };\r\n  } else {\r\n    return now;\r\n  }\r\n}\r\n\r\nfunction useObjectUrl(object) {\r\n  const url = shallowRef();\r\n  const release = () => {\r\n    if (url.value)\r\n      URL.revokeObjectURL(url.value);\r\n    url.value = void 0;\r\n  };\r\n  watch(\r\n    () => toValue(object),\r\n    (newObject) => {\r\n      release();\r\n      if (newObject)\r\n        url.value = URL.createObjectURL(newObject);\r\n    },\r\n    { immediate: true }\r\n  );\r\n  tryOnScopeDispose(release);\r\n  return readonly(url);\r\n}\r\n\r\nfunction useClamp(value, min, max) {\r\n  if (typeof value === \"function\" || isReadonly(value))\r\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\r\n  const _value = ref(value);\r\n  return computed({\r\n    get() {\r\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\r\n    },\r\n    set(value2) {\r\n      _value.value = clamp(value2, toValue(min), toValue(max));\r\n    }\r\n  });\r\n}\r\n\r\nfunction useOffsetPagination(options) {\r\n  const {\r\n    total = Number.POSITIVE_INFINITY,\r\n    pageSize = 10,\r\n    page = 1,\r\n    onPageChange = noop,\r\n    onPageSizeChange = noop,\r\n    onPageCountChange = noop\r\n  } = options;\r\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\r\n  const pageCount = computed(() => Math.max(\r\n    1,\r\n    Math.ceil(toValue(total) / toValue(currentPageSize))\r\n  ));\r\n  const currentPage = useClamp(page, 1, pageCount);\r\n  const isFirstPage = computed(() => currentPage.value === 1);\r\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\r\n  if (isRef(page)) {\r\n    syncRef(page, currentPage, {\r\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\r\n    });\r\n  }\r\n  if (isRef(pageSize)) {\r\n    syncRef(pageSize, currentPageSize, {\r\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\r\n    });\r\n  }\r\n  function prev() {\r\n    currentPage.value--;\r\n  }\r\n  function next() {\r\n    currentPage.value++;\r\n  }\r\n  const returnValue = {\r\n    currentPage,\r\n    currentPageSize,\r\n    pageCount,\r\n    isFirstPage,\r\n    isLastPage,\r\n    prev,\r\n    next\r\n  };\r\n  watch(currentPage, () => {\r\n    onPageChange(reactive(returnValue));\r\n  });\r\n  watch(currentPageSize, () => {\r\n    onPageSizeChange(reactive(returnValue));\r\n  });\r\n  watch(pageCount, () => {\r\n    onPageCountChange(reactive(returnValue));\r\n  });\r\n  return returnValue;\r\n}\r\n\r\nfunction useOnline(options = {}) {\r\n  const { isOnline } = useNetwork(options);\r\n  return isOnline;\r\n}\r\n\r\nfunction usePageLeave(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const isLeft = shallowRef(false);\r\n  const handler = (event) => {\r\n    if (!window)\r\n      return;\r\n    event = event || window.event;\r\n    const from = event.relatedTarget || event.toElement;\r\n    isLeft.value = !from;\r\n  };\r\n  if (window) {\r\n    const listenerOptions = { passive: true };\r\n    useEventListener(window, \"mouseout\", handler, listenerOptions);\r\n    useEventListener(window.document, \"mouseleave\", handler, listenerOptions);\r\n    useEventListener(window.document, \"mouseenter\", handler, listenerOptions);\r\n  }\r\n  return isLeft;\r\n}\r\n\r\nfunction useScreenOrientation(options = {}) {\r\n  const {\r\n    window = defaultWindow\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\r\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\r\n  const orientation = ref(screenOrientation.type);\r\n  const angle = shallowRef(screenOrientation.angle || 0);\r\n  if (isSupported.value) {\r\n    useEventListener(window, \"orientationchange\", () => {\r\n      orientation.value = screenOrientation.type;\r\n      angle.value = screenOrientation.angle;\r\n    }, { passive: true });\r\n  }\r\n  const lockOrientation = (type) => {\r\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\r\n      return screenOrientation.lock(type);\r\n    return Promise.reject(new Error(\"Not supported\"));\r\n  };\r\n  const unlockOrientation = () => {\r\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\r\n      screenOrientation.unlock();\r\n  };\r\n  return {\r\n    isSupported,\r\n    orientation,\r\n    angle,\r\n    lockOrientation,\r\n    unlockOrientation\r\n  };\r\n}\r\n\r\nfunction useParallax(target, options = {}) {\r\n  const {\r\n    deviceOrientationTiltAdjust = (i) => i,\r\n    deviceOrientationRollAdjust = (i) => i,\r\n    mouseTiltAdjust = (i) => i,\r\n    mouseRollAdjust = (i) => i,\r\n    window = defaultWindow\r\n  } = options;\r\n  const orientation = reactive(useDeviceOrientation({ window }));\r\n  const screenOrientation = reactive(useScreenOrientation({ window }));\r\n  const {\r\n    elementX: x,\r\n    elementY: y,\r\n    elementWidth: width,\r\n    elementHeight: height\r\n  } = useMouseInElement(target, { handleOutside: false, window });\r\n  const source = computed(() => {\r\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\r\n      return \"deviceOrientation\";\r\n    }\r\n    return \"mouse\";\r\n  });\r\n  const roll = computed(() => {\r\n    if (source.value === \"deviceOrientation\") {\r\n      let value;\r\n      switch (screenOrientation.orientation) {\r\n        case \"landscape-primary\":\r\n          value = orientation.gamma / 90;\r\n          break;\r\n        case \"landscape-secondary\":\r\n          value = -orientation.gamma / 90;\r\n          break;\r\n        case \"portrait-primary\":\r\n          value = -orientation.beta / 90;\r\n          break;\r\n        case \"portrait-secondary\":\r\n          value = orientation.beta / 90;\r\n          break;\r\n        default:\r\n          value = -orientation.beta / 90;\r\n      }\r\n      return deviceOrientationRollAdjust(value);\r\n    } else {\r\n      const value = -(y.value - height.value / 2) / height.value;\r\n      return mouseRollAdjust(value);\r\n    }\r\n  });\r\n  const tilt = computed(() => {\r\n    if (source.value === \"deviceOrientation\") {\r\n      let value;\r\n      switch (screenOrientation.orientation) {\r\n        case \"landscape-primary\":\r\n          value = orientation.beta / 90;\r\n          break;\r\n        case \"landscape-secondary\":\r\n          value = -orientation.beta / 90;\r\n          break;\r\n        case \"portrait-primary\":\r\n          value = orientation.gamma / 90;\r\n          break;\r\n        case \"portrait-secondary\":\r\n          value = -orientation.gamma / 90;\r\n          break;\r\n        default:\r\n          value = orientation.gamma / 90;\r\n      }\r\n      return deviceOrientationTiltAdjust(value);\r\n    } else {\r\n      const value = (x.value - width.value / 2) / width.value;\r\n      return mouseTiltAdjust(value);\r\n    }\r\n  });\r\n  return { roll, tilt, source };\r\n}\r\n\r\nfunction useParentElement(element = useCurrentElement()) {\r\n  const parentElement = shallowRef();\r\n  const update = () => {\r\n    const el = unrefElement(element);\r\n    if (el)\r\n      parentElement.value = el.parentElement;\r\n  };\r\n  tryOnMounted(update);\r\n  watch(() => toValue(element), update);\r\n  return parentElement;\r\n}\r\n\r\nfunction usePerformanceObserver(options, callback) {\r\n  const {\r\n    window = defaultWindow,\r\n    immediate = true,\r\n    ...performanceOptions\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\r\n  let observer;\r\n  const stop = () => {\r\n    observer == null ? void 0 : observer.disconnect();\r\n  };\r\n  const start = () => {\r\n    if (isSupported.value) {\r\n      stop();\r\n      observer = new PerformanceObserver(callback);\r\n      observer.observe(performanceOptions);\r\n    }\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  if (immediate)\r\n    start();\r\n  return {\r\n    isSupported,\r\n    start,\r\n    stop\r\n  };\r\n}\r\n\r\nconst defaultState = {\r\n  x: 0,\r\n  y: 0,\r\n  pointerId: 0,\r\n  pressure: 0,\r\n  tiltX: 0,\r\n  tiltY: 0,\r\n  width: 0,\r\n  height: 0,\r\n  twist: 0,\r\n  pointerType: null\r\n};\r\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\r\nfunction usePointer(options = {}) {\r\n  const {\r\n    target = defaultWindow\r\n  } = options;\r\n  const isInside = shallowRef(false);\r\n  const state = ref(options.initialValue || {});\r\n  Object.assign(state.value, defaultState, state.value);\r\n  const handler = (event) => {\r\n    isInside.value = true;\r\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\r\n      return;\r\n    state.value = objectPick(event, keys, false);\r\n  };\r\n  if (target) {\r\n    const listenerOptions = { passive: true };\r\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\r\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\r\n  }\r\n  return {\r\n    ...toRefs(state),\r\n    isInside\r\n  };\r\n}\r\n\r\nfunction usePointerLock(target, options = {}) {\r\n  const { document = defaultDocument } = options;\r\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\r\n  const element = shallowRef();\r\n  const triggerElement = shallowRef();\r\n  let targetElement;\r\n  if (isSupported.value) {\r\n    const listenerOptions = { passive: true };\r\n    useEventListener(document, \"pointerlockchange\", () => {\r\n      var _a;\r\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\r\n      if (targetElement && currentElement === targetElement) {\r\n        element.value = document.pointerLockElement;\r\n        if (!element.value)\r\n          targetElement = triggerElement.value = null;\r\n      }\r\n    }, listenerOptions);\r\n    useEventListener(document, \"pointerlockerror\", () => {\r\n      var _a;\r\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\r\n      if (targetElement && currentElement === targetElement) {\r\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\r\n        throw new Error(`Failed to ${action} pointer lock.`);\r\n      }\r\n    }, listenerOptions);\r\n  }\r\n  async function lock(e) {\r\n    var _a;\r\n    if (!isSupported.value)\r\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\r\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\r\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\r\n    if (!targetElement)\r\n      throw new Error(\"Target element undefined.\");\r\n    targetElement.requestPointerLock();\r\n    return await until(element).toBe(targetElement);\r\n  }\r\n  async function unlock() {\r\n    if (!element.value)\r\n      return false;\r\n    document.exitPointerLock();\r\n    await until(element).toBeNull();\r\n    return true;\r\n  }\r\n  return {\r\n    isSupported,\r\n    element,\r\n    triggerElement,\r\n    lock,\r\n    unlock\r\n  };\r\n}\r\n\r\nfunction usePointerSwipe(target, options = {}) {\r\n  const targetRef = toRef(target);\r\n  const {\r\n    threshold = 50,\r\n    onSwipe,\r\n    onSwipeEnd,\r\n    onSwipeStart,\r\n    disableTextSelect = false\r\n  } = options;\r\n  const posStart = reactive({ x: 0, y: 0 });\r\n  const updatePosStart = (x, y) => {\r\n    posStart.x = x;\r\n    posStart.y = y;\r\n  };\r\n  const posEnd = reactive({ x: 0, y: 0 });\r\n  const updatePosEnd = (x, y) => {\r\n    posEnd.x = x;\r\n    posEnd.y = y;\r\n  };\r\n  const distanceX = computed(() => posStart.x - posEnd.x);\r\n  const distanceY = computed(() => posStart.y - posEnd.y);\r\n  const { max, abs } = Math;\r\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\r\n  const isSwiping = shallowRef(false);\r\n  const isPointerDown = shallowRef(false);\r\n  const direction = computed(() => {\r\n    if (!isThresholdExceeded.value)\r\n      return \"none\";\r\n    if (abs(distanceX.value) > abs(distanceY.value)) {\r\n      return distanceX.value > 0 ? \"left\" : \"right\";\r\n    } else {\r\n      return distanceY.value > 0 ? \"up\" : \"down\";\r\n    }\r\n  });\r\n  const eventIsAllowed = (e) => {\r\n    var _a, _b, _c;\r\n    const isReleasingButton = e.buttons === 0;\r\n    const isPrimaryButton = e.buttons === 1;\r\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\r\n  };\r\n  const listenerOptions = { passive: true };\r\n  const stops = [\r\n    useEventListener(target, \"pointerdown\", (e) => {\r\n      if (!eventIsAllowed(e))\r\n        return;\r\n      isPointerDown.value = true;\r\n      const eventTarget = e.target;\r\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\r\n      const { clientX: x, clientY: y } = e;\r\n      updatePosStart(x, y);\r\n      updatePosEnd(x, y);\r\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\r\n    }, listenerOptions),\r\n    useEventListener(target, \"pointermove\", (e) => {\r\n      if (!eventIsAllowed(e))\r\n        return;\r\n      if (!isPointerDown.value)\r\n        return;\r\n      const { clientX: x, clientY: y } = e;\r\n      updatePosEnd(x, y);\r\n      if (!isSwiping.value && isThresholdExceeded.value)\r\n        isSwiping.value = true;\r\n      if (isSwiping.value)\r\n        onSwipe == null ? void 0 : onSwipe(e);\r\n    }, listenerOptions),\r\n    useEventListener(target, \"pointerup\", (e) => {\r\n      if (!eventIsAllowed(e))\r\n        return;\r\n      if (isSwiping.value)\r\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\r\n      isPointerDown.value = false;\r\n      isSwiping.value = false;\r\n    }, listenerOptions)\r\n  ];\r\n  tryOnMounted(() => {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h;\r\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\r\n    if (disableTextSelect) {\r\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\r\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\r\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\r\n    }\r\n  });\r\n  const stop = () => stops.forEach((s) => s());\r\n  return {\r\n    isSwiping: readonly(isSwiping),\r\n    direction: readonly(direction),\r\n    posStart: readonly(posStart),\r\n    posEnd: readonly(posEnd),\r\n    distanceX,\r\n    distanceY,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction usePreferredColorScheme(options) {\r\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\r\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\r\n  return computed(() => {\r\n    if (isDark.value)\r\n      return \"dark\";\r\n    if (isLight.value)\r\n      return \"light\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePreferredContrast(options) {\r\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\r\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\r\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\r\n  return computed(() => {\r\n    if (isMore.value)\r\n      return \"more\";\r\n    if (isLess.value)\r\n      return \"less\";\r\n    if (isCustom.value)\r\n      return \"custom\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePreferredLanguages(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  if (!window)\r\n    return ref([\"en\"]);\r\n  const navigator = window.navigator;\r\n  const value = ref(navigator.languages);\r\n  useEventListener(window, \"languagechange\", () => {\r\n    value.value = navigator.languages;\r\n  }, { passive: true });\r\n  return value;\r\n}\r\n\r\nfunction usePreferredReducedMotion(options) {\r\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\r\n  return computed(() => {\r\n    if (isReduced.value)\r\n      return \"reduce\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePreferredReducedTransparency(options) {\r\n  const isReduced = useMediaQuery(\"(prefers-reduced-transparency: reduce)\", options);\r\n  return computed(() => {\r\n    if (isReduced.value)\r\n      return \"reduce\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePrevious(value, initialValue) {\r\n  const previous = shallowRef(initialValue);\r\n  watch(\r\n    toRef(value),\r\n    (_, oldValue) => {\r\n      previous.value = oldValue;\r\n    },\r\n    { flush: \"sync\" }\r\n  );\r\n  return readonly(previous);\r\n}\r\n\r\nconst topVarName = \"--vueuse-safe-area-top\";\r\nconst rightVarName = \"--vueuse-safe-area-right\";\r\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\r\nconst leftVarName = \"--vueuse-safe-area-left\";\r\nfunction useScreenSafeArea() {\r\n  const top = shallowRef(\"\");\r\n  const right = shallowRef(\"\");\r\n  const bottom = shallowRef(\"\");\r\n  const left = shallowRef(\"\");\r\n  if (isClient) {\r\n    const topCssVar = useCssVar(topVarName);\r\n    const rightCssVar = useCssVar(rightVarName);\r\n    const bottomCssVar = useCssVar(bottomVarName);\r\n    const leftCssVar = useCssVar(leftVarName);\r\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\r\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\r\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\r\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\r\n    update();\r\n    useEventListener(\"resize\", useDebounceFn(update), { passive: true });\r\n  }\r\n  function update() {\r\n    top.value = getValue(topVarName);\r\n    right.value = getValue(rightVarName);\r\n    bottom.value = getValue(bottomVarName);\r\n    left.value = getValue(leftVarName);\r\n  }\r\n  return {\r\n    top,\r\n    right,\r\n    bottom,\r\n    left,\r\n    update\r\n  };\r\n}\r\nfunction getValue(position) {\r\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\r\n}\r\n\r\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    manual = false,\r\n    type = \"text/javascript\",\r\n    async = true,\r\n    crossOrigin,\r\n    referrerPolicy,\r\n    noModule,\r\n    defer,\r\n    document = defaultDocument,\r\n    attrs = {}\r\n  } = options;\r\n  const scriptTag = shallowRef(null);\r\n  let _promise = null;\r\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\r\n    const resolveWithElement = (el2) => {\r\n      scriptTag.value = el2;\r\n      resolve(el2);\r\n      return el2;\r\n    };\r\n    if (!document) {\r\n      resolve(false);\r\n      return;\r\n    }\r\n    let shouldAppend = false;\r\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\r\n    if (!el) {\r\n      el = document.createElement(\"script\");\r\n      el.type = type;\r\n      el.async = async;\r\n      el.src = toValue(src);\r\n      if (defer)\r\n        el.defer = defer;\r\n      if (crossOrigin)\r\n        el.crossOrigin = crossOrigin;\r\n      if (noModule)\r\n        el.noModule = noModule;\r\n      if (referrerPolicy)\r\n        el.referrerPolicy = referrerPolicy;\r\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\r\n      shouldAppend = true;\r\n    } else if (el.hasAttribute(\"data-loaded\")) {\r\n      resolveWithElement(el);\r\n    }\r\n    const listenerOptions = {\r\n      passive: true\r\n    };\r\n    useEventListener(el, \"error\", (event) => reject(event), listenerOptions);\r\n    useEventListener(el, \"abort\", (event) => reject(event), listenerOptions);\r\n    useEventListener(el, \"load\", () => {\r\n      el.setAttribute(\"data-loaded\", \"true\");\r\n      onLoaded(el);\r\n      resolveWithElement(el);\r\n    }, listenerOptions);\r\n    if (shouldAppend)\r\n      el = document.head.appendChild(el);\r\n    if (!waitForScriptLoad)\r\n      resolveWithElement(el);\r\n  });\r\n  const load = (waitForScriptLoad = true) => {\r\n    if (!_promise)\r\n      _promise = loadScript(waitForScriptLoad);\r\n    return _promise;\r\n  };\r\n  const unload = () => {\r\n    if (!document)\r\n      return;\r\n    _promise = null;\r\n    if (scriptTag.value)\r\n      scriptTag.value = null;\r\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\r\n    if (el)\r\n      document.head.removeChild(el);\r\n  };\r\n  if (immediate && !manual)\r\n    tryOnMounted(load);\r\n  if (!manual)\r\n    tryOnUnmounted(unload);\r\n  return { scriptTag, load, unload };\r\n}\r\n\r\nfunction checkOverflowScroll(ele) {\r\n  const style = window.getComputedStyle(ele);\r\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\r\n    return true;\r\n  } else {\r\n    const parent = ele.parentNode;\r\n    if (!parent || parent.tagName === \"BODY\")\r\n      return false;\r\n    return checkOverflowScroll(parent);\r\n  }\r\n}\r\nfunction preventDefault(rawEvent) {\r\n  const e = rawEvent || window.event;\r\n  const _target = e.target;\r\n  if (checkOverflowScroll(_target))\r\n    return false;\r\n  if (e.touches.length > 1)\r\n    return true;\r\n  if (e.preventDefault)\r\n    e.preventDefault();\r\n  return false;\r\n}\r\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\r\nfunction useScrollLock(element, initialState = false) {\r\n  const isLocked = shallowRef(initialState);\r\n  let stopTouchMoveListener = null;\r\n  let initialOverflow = \"\";\r\n  watch(toRef(element), (el) => {\r\n    const target = resolveElement(toValue(el));\r\n    if (target) {\r\n      const ele = target;\r\n      if (!elInitialOverflow.get(ele))\r\n        elInitialOverflow.set(ele, ele.style.overflow);\r\n      if (ele.style.overflow !== \"hidden\")\r\n        initialOverflow = ele.style.overflow;\r\n      if (ele.style.overflow === \"hidden\")\r\n        return isLocked.value = true;\r\n      if (isLocked.value)\r\n        return ele.style.overflow = \"hidden\";\r\n    }\r\n  }, {\r\n    immediate: true\r\n  });\r\n  const lock = () => {\r\n    const el = resolveElement(toValue(element));\r\n    if (!el || isLocked.value)\r\n      return;\r\n    if (isIOS) {\r\n      stopTouchMoveListener = useEventListener(\r\n        el,\r\n        \"touchmove\",\r\n        (e) => {\r\n          preventDefault(e);\r\n        },\r\n        { passive: false }\r\n      );\r\n    }\r\n    el.style.overflow = \"hidden\";\r\n    isLocked.value = true;\r\n  };\r\n  const unlock = () => {\r\n    const el = resolveElement(toValue(element));\r\n    if (!el || !isLocked.value)\r\n      return;\r\n    if (isIOS)\r\n      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();\r\n    el.style.overflow = initialOverflow;\r\n    elInitialOverflow.delete(el);\r\n    isLocked.value = false;\r\n  };\r\n  tryOnScopeDispose(unlock);\r\n  return computed({\r\n    get() {\r\n      return isLocked.value;\r\n    },\r\n    set(v) {\r\n      if (v)\r\n        lock();\r\n      else unlock();\r\n    }\r\n  });\r\n}\r\n\r\nfunction useSessionStorage(key, initialValue, options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\r\n}\r\n\r\nfunction useShare(shareOptions = {}, options = {}) {\r\n  const { navigator = defaultNavigator } = options;\r\n  const _navigator = navigator;\r\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\r\n  const share = async (overrideOptions = {}) => {\r\n    if (isSupported.value) {\r\n      const data = {\r\n        ...toValue(shareOptions),\r\n        ...toValue(overrideOptions)\r\n      };\r\n      let granted = true;\r\n      if (data.files && _navigator.canShare)\r\n        granted = _navigator.canShare({ files: data.files });\r\n      if (granted)\r\n        return _navigator.share(data);\r\n    }\r\n  };\r\n  return {\r\n    isSupported,\r\n    share\r\n  };\r\n}\r\n\r\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\r\nconst defaultCompare = (a, b) => a - b;\r\nfunction useSorted(...args) {\r\n  var _a, _b, _c, _d;\r\n  const [source] = args;\r\n  let compareFn = defaultCompare;\r\n  let options = {};\r\n  if (args.length === 2) {\r\n    if (typeof args[1] === \"object\") {\r\n      options = args[1];\r\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\r\n    } else {\r\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\r\n    }\r\n  } else if (args.length > 2) {\r\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\r\n    options = (_d = args[2]) != null ? _d : {};\r\n  }\r\n  const {\r\n    dirty = false,\r\n    sortFn = defaultSortFn\r\n  } = options;\r\n  if (!dirty)\r\n    return computed(() => sortFn([...toValue(source)], compareFn));\r\n  watchEffect(() => {\r\n    const result = sortFn(toValue(source), compareFn);\r\n    if (isRef(source))\r\n      source.value = result;\r\n    else\r\n      source.splice(0, source.length, ...result);\r\n  });\r\n  return source;\r\n}\r\n\r\nfunction useSpeechRecognition(options = {}) {\r\n  const {\r\n    interimResults = true,\r\n    continuous = true,\r\n    maxAlternatives = 1,\r\n    window = defaultWindow\r\n  } = options;\r\n  const lang = toRef(options.lang || \"en-US\");\r\n  const isListening = shallowRef(false);\r\n  const isFinal = shallowRef(false);\r\n  const result = shallowRef(\"\");\r\n  const error = shallowRef(void 0);\r\n  let recognition;\r\n  const start = () => {\r\n    isListening.value = true;\r\n  };\r\n  const stop = () => {\r\n    isListening.value = false;\r\n  };\r\n  const toggle = (value = !isListening.value) => {\r\n    if (value) {\r\n      start();\r\n    } else {\r\n      stop();\r\n    }\r\n  };\r\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\r\n  const isSupported = useSupported(() => SpeechRecognition);\r\n  if (isSupported.value) {\r\n    recognition = new SpeechRecognition();\r\n    recognition.continuous = continuous;\r\n    recognition.interimResults = interimResults;\r\n    recognition.lang = toValue(lang);\r\n    recognition.maxAlternatives = maxAlternatives;\r\n    recognition.onstart = () => {\r\n      isListening.value = true;\r\n      isFinal.value = false;\r\n    };\r\n    watch(lang, (lang2) => {\r\n      if (recognition && !isListening.value)\r\n        recognition.lang = lang2;\r\n    });\r\n    recognition.onresult = (event) => {\r\n      const currentResult = event.results[event.resultIndex];\r\n      const { transcript } = currentResult[0];\r\n      isFinal.value = currentResult.isFinal;\r\n      result.value = transcript;\r\n      error.value = void 0;\r\n    };\r\n    recognition.onerror = (event) => {\r\n      error.value = event;\r\n    };\r\n    recognition.onend = () => {\r\n      isListening.value = false;\r\n      recognition.lang = toValue(lang);\r\n    };\r\n    watch(isListening, (newValue, oldValue) => {\r\n      if (newValue === oldValue)\r\n        return;\r\n      if (newValue)\r\n        recognition.start();\r\n      else\r\n        recognition.stop();\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    stop();\r\n  });\r\n  return {\r\n    isSupported,\r\n    isListening,\r\n    isFinal,\r\n    recognition,\r\n    result,\r\n    error,\r\n    toggle,\r\n    start,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useSpeechSynthesis(text, options = {}) {\r\n  const {\r\n    pitch = 1,\r\n    rate = 1,\r\n    volume = 1,\r\n    window = defaultWindow\r\n  } = options;\r\n  const synth = window && window.speechSynthesis;\r\n  const isSupported = useSupported(() => synth);\r\n  const isPlaying = shallowRef(false);\r\n  const status = shallowRef(\"init\");\r\n  const spokenText = toRef(text || \"\");\r\n  const lang = toRef(options.lang || \"en-US\");\r\n  const error = shallowRef(void 0);\r\n  const toggle = (value = !isPlaying.value) => {\r\n    isPlaying.value = value;\r\n  };\r\n  const bindEventsForUtterance = (utterance2) => {\r\n    utterance2.lang = toValue(lang);\r\n    utterance2.voice = toValue(options.voice) || null;\r\n    utterance2.pitch = toValue(pitch);\r\n    utterance2.rate = toValue(rate);\r\n    utterance2.volume = volume;\r\n    utterance2.onstart = () => {\r\n      isPlaying.value = true;\r\n      status.value = \"play\";\r\n    };\r\n    utterance2.onpause = () => {\r\n      isPlaying.value = false;\r\n      status.value = \"pause\";\r\n    };\r\n    utterance2.onresume = () => {\r\n      isPlaying.value = true;\r\n      status.value = \"play\";\r\n    };\r\n    utterance2.onend = () => {\r\n      isPlaying.value = false;\r\n      status.value = \"end\";\r\n    };\r\n    utterance2.onerror = (event) => {\r\n      error.value = event;\r\n    };\r\n  };\r\n  const utterance = computed(() => {\r\n    isPlaying.value = false;\r\n    status.value = \"init\";\r\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\r\n    bindEventsForUtterance(newUtterance);\r\n    return newUtterance;\r\n  });\r\n  const speak = () => {\r\n    synth.cancel();\r\n    if (utterance)\r\n      synth.speak(utterance.value);\r\n  };\r\n  const stop = () => {\r\n    synth.cancel();\r\n    isPlaying.value = false;\r\n  };\r\n  if (isSupported.value) {\r\n    bindEventsForUtterance(utterance.value);\r\n    watch(lang, (lang2) => {\r\n      if (utterance.value && !isPlaying.value)\r\n        utterance.value.lang = lang2;\r\n    });\r\n    if (options.voice) {\r\n      watch(options.voice, () => {\r\n        synth.cancel();\r\n      });\r\n    }\r\n    watch(isPlaying, () => {\r\n      if (isPlaying.value)\r\n        synth.resume();\r\n      else\r\n        synth.pause();\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    isPlaying.value = false;\r\n  });\r\n  return {\r\n    isSupported,\r\n    isPlaying,\r\n    status,\r\n    utterance,\r\n    error,\r\n    stop,\r\n    toggle,\r\n    speak\r\n  };\r\n}\r\n\r\nfunction useStepper(steps, initialStep) {\r\n  const stepsRef = ref(steps);\r\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\r\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\r\n  const current = computed(() => at(index.value));\r\n  const isFirst = computed(() => index.value === 0);\r\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\r\n  const next = computed(() => stepNames.value[index.value + 1]);\r\n  const previous = computed(() => stepNames.value[index.value - 1]);\r\n  function at(index2) {\r\n    if (Array.isArray(stepsRef.value))\r\n      return stepsRef.value[index2];\r\n    return stepsRef.value[stepNames.value[index2]];\r\n  }\r\n  function get(step) {\r\n    if (!stepNames.value.includes(step))\r\n      return;\r\n    return at(stepNames.value.indexOf(step));\r\n  }\r\n  function goTo(step) {\r\n    if (stepNames.value.includes(step))\r\n      index.value = stepNames.value.indexOf(step);\r\n  }\r\n  function goToNext() {\r\n    if (isLast.value)\r\n      return;\r\n    index.value++;\r\n  }\r\n  function goToPrevious() {\r\n    if (isFirst.value)\r\n      return;\r\n    index.value--;\r\n  }\r\n  function goBackTo(step) {\r\n    if (isAfter(step))\r\n      goTo(step);\r\n  }\r\n  function isNext(step) {\r\n    return stepNames.value.indexOf(step) === index.value + 1;\r\n  }\r\n  function isPrevious(step) {\r\n    return stepNames.value.indexOf(step) === index.value - 1;\r\n  }\r\n  function isCurrent(step) {\r\n    return stepNames.value.indexOf(step) === index.value;\r\n  }\r\n  function isBefore(step) {\r\n    return index.value < stepNames.value.indexOf(step);\r\n  }\r\n  function isAfter(step) {\r\n    return index.value > stepNames.value.indexOf(step);\r\n  }\r\n  return {\r\n    steps: stepsRef,\r\n    stepNames,\r\n    index,\r\n    current,\r\n    next,\r\n    previous,\r\n    isFirst,\r\n    isLast,\r\n    at,\r\n    get,\r\n    goTo,\r\n    goToNext,\r\n    goToPrevious,\r\n    goBackTo,\r\n    isNext,\r\n    isPrevious,\r\n    isCurrent,\r\n    isBefore,\r\n    isAfter\r\n  };\r\n}\r\n\r\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\r\n  var _a;\r\n  const {\r\n    flush = \"pre\",\r\n    deep = true,\r\n    listenToStorageChanges = true,\r\n    writeDefaults = true,\r\n    mergeDefaults = false,\r\n    shallow,\r\n    window = defaultWindow,\r\n    eventFilter,\r\n    onError = (e) => {\r\n      console.error(e);\r\n    }\r\n  } = options;\r\n  const rawInit = toValue(initialValue);\r\n  const type = guessSerializerType(rawInit);\r\n  const data = (shallow ? shallowRef : ref)(toValue(initialValue));\r\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\r\n  if (!storage) {\r\n    try {\r\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\r\n        var _a2;\r\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\r\n      })();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  async function read(event) {\r\n    if (!storage || event && event.key !== key)\r\n      return;\r\n    try {\r\n      const rawValue = event ? event.newValue : await storage.getItem(key);\r\n      if (rawValue == null) {\r\n        data.value = rawInit;\r\n        if (writeDefaults && rawInit !== null)\r\n          await storage.setItem(key, await serializer.write(rawInit));\r\n      } else if (mergeDefaults) {\r\n        const value = await serializer.read(rawValue);\r\n        if (typeof mergeDefaults === \"function\")\r\n          data.value = mergeDefaults(value, rawInit);\r\n        else if (type === \"object\" && !Array.isArray(value))\r\n          data.value = { ...rawInit, ...value };\r\n        else data.value = value;\r\n      } else {\r\n        data.value = await serializer.read(rawValue);\r\n      }\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  read();\r\n  if (window && listenToStorageChanges)\r\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)), { passive: true });\r\n  if (storage) {\r\n    watchWithFilter(\r\n      data,\r\n      async () => {\r\n        try {\r\n          if (data.value == null)\r\n            await storage.removeItem(key);\r\n          else\r\n            await storage.setItem(key, await serializer.write(data.value));\r\n        } catch (e) {\r\n          onError(e);\r\n        }\r\n      },\r\n      {\r\n        flush,\r\n        deep,\r\n        eventFilter\r\n      }\r\n    );\r\n  }\r\n  return data;\r\n}\r\n\r\nlet _id = 0;\r\nfunction useStyleTag(css, options = {}) {\r\n  const isLoaded = shallowRef(false);\r\n  const {\r\n    document = defaultDocument,\r\n    immediate = true,\r\n    manual = false,\r\n    id = `vueuse_styletag_${++_id}`\r\n  } = options;\r\n  const cssRef = shallowRef(css);\r\n  let stop = () => {\r\n  };\r\n  const load = () => {\r\n    if (!document)\r\n      return;\r\n    const el = document.getElementById(id) || document.createElement(\"style\");\r\n    if (!el.isConnected) {\r\n      el.id = id;\r\n      if (options.media)\r\n        el.media = options.media;\r\n      document.head.appendChild(el);\r\n    }\r\n    if (isLoaded.value)\r\n      return;\r\n    stop = watch(\r\n      cssRef,\r\n      (value) => {\r\n        el.textContent = value;\r\n      },\r\n      { immediate: true }\r\n    );\r\n    isLoaded.value = true;\r\n  };\r\n  const unload = () => {\r\n    if (!document || !isLoaded.value)\r\n      return;\r\n    stop();\r\n    document.head.removeChild(document.getElementById(id));\r\n    isLoaded.value = false;\r\n  };\r\n  if (immediate && !manual)\r\n    tryOnMounted(load);\r\n  if (!manual)\r\n    tryOnScopeDispose(unload);\r\n  return {\r\n    id,\r\n    css: cssRef,\r\n    unload,\r\n    load,\r\n    isLoaded: readonly(isLoaded)\r\n  };\r\n}\r\n\r\nfunction useSwipe(target, options = {}) {\r\n  const {\r\n    threshold = 50,\r\n    onSwipe,\r\n    onSwipeEnd,\r\n    onSwipeStart,\r\n    passive = true\r\n  } = options;\r\n  const coordsStart = reactive({ x: 0, y: 0 });\r\n  const coordsEnd = reactive({ x: 0, y: 0 });\r\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\r\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\r\n  const { max, abs } = Math;\r\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\r\n  const isSwiping = shallowRef(false);\r\n  const direction = computed(() => {\r\n    if (!isThresholdExceeded.value)\r\n      return \"none\";\r\n    if (abs(diffX.value) > abs(diffY.value)) {\r\n      return diffX.value > 0 ? \"left\" : \"right\";\r\n    } else {\r\n      return diffY.value > 0 ? \"up\" : \"down\";\r\n    }\r\n  });\r\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\r\n  const updateCoordsStart = (x, y) => {\r\n    coordsStart.x = x;\r\n    coordsStart.y = y;\r\n  };\r\n  const updateCoordsEnd = (x, y) => {\r\n    coordsEnd.x = x;\r\n    coordsEnd.y = y;\r\n  };\r\n  const listenerOptions = { passive, capture: !passive };\r\n  const onTouchEnd = (e) => {\r\n    if (isSwiping.value)\r\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\r\n    isSwiping.value = false;\r\n  };\r\n  const stops = [\r\n    useEventListener(target, \"touchstart\", (e) => {\r\n      if (e.touches.length !== 1)\r\n        return;\r\n      const [x, y] = getTouchEventCoords(e);\r\n      updateCoordsStart(x, y);\r\n      updateCoordsEnd(x, y);\r\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\r\n    }, listenerOptions),\r\n    useEventListener(target, \"touchmove\", (e) => {\r\n      if (e.touches.length !== 1)\r\n        return;\r\n      const [x, y] = getTouchEventCoords(e);\r\n      updateCoordsEnd(x, y);\r\n      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))\r\n        e.preventDefault();\r\n      if (!isSwiping.value && isThresholdExceeded.value)\r\n        isSwiping.value = true;\r\n      if (isSwiping.value)\r\n        onSwipe == null ? void 0 : onSwipe(e);\r\n    }, listenerOptions),\r\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\r\n  ];\r\n  const stop = () => stops.forEach((s) => s());\r\n  return {\r\n    isSwiping,\r\n    direction,\r\n    coordsStart,\r\n    coordsEnd,\r\n    lengthX: diffX,\r\n    lengthY: diffY,\r\n    stop,\r\n    // TODO: Remove in the next major version\r\n    isPassiveEventSupported: true\r\n  };\r\n}\r\n\r\nfunction useTemplateRefsList() {\r\n  const refs = ref([]);\r\n  refs.value.set = (el) => {\r\n    if (el)\r\n      refs.value.push(el);\r\n  };\r\n  onBeforeUpdate(() => {\r\n    refs.value.length = 0;\r\n  });\r\n  return refs;\r\n}\r\n\r\nfunction useTextDirection(options = {}) {\r\n  const {\r\n    document = defaultDocument,\r\n    selector = \"html\",\r\n    observe = false,\r\n    initialValue = \"ltr\"\r\n  } = options;\r\n  function getValue() {\r\n    var _a, _b;\r\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\r\n  }\r\n  const dir = ref(getValue());\r\n  tryOnMounted(() => dir.value = getValue());\r\n  if (observe && document) {\r\n    useMutationObserver(\r\n      document.querySelector(selector),\r\n      () => dir.value = getValue(),\r\n      { attributes: true }\r\n    );\r\n  }\r\n  return computed({\r\n    get() {\r\n      return dir.value;\r\n    },\r\n    set(v) {\r\n      var _a, _b;\r\n      dir.value = v;\r\n      if (!document)\r\n        return;\r\n      if (dir.value)\r\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\r\n      else\r\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\r\n    }\r\n  });\r\n}\r\n\r\nfunction getRangesFromSelection(selection) {\r\n  var _a;\r\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\r\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\r\n}\r\nfunction useTextSelection(options = {}) {\r\n  const {\r\n    window = defaultWindow\r\n  } = options;\r\n  const selection = ref(null);\r\n  const text = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\r\n  });\r\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\r\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\r\n  function onSelectionChange() {\r\n    selection.value = null;\r\n    if (window)\r\n      selection.value = window.getSelection();\r\n  }\r\n  if (window)\r\n    useEventListener(window.document, \"selectionchange\", onSelectionChange, { passive: true });\r\n  return {\r\n    text,\r\n    rects,\r\n    ranges,\r\n    selection\r\n  };\r\n}\r\n\r\nfunction tryRequestAnimationFrame(window = defaultWindow, fn) {\r\n  if (window && typeof window.requestAnimationFrame === \"function\") {\r\n    window.requestAnimationFrame(fn);\r\n  } else {\r\n    fn();\r\n  }\r\n}\r\nfunction useTextareaAutosize(options = {}) {\r\n  var _a, _b;\r\n  const { window = defaultWindow } = options;\r\n  const textarea = toRef(options == null ? void 0 : options.element);\r\n  const input = toRef((_a = options == null ? void 0 : options.input) != null ? _a : \"\");\r\n  const styleProp = (_b = options == null ? void 0 : options.styleProp) != null ? _b : \"height\";\r\n  const textareaScrollHeight = shallowRef(1);\r\n  const textareaOldWidth = shallowRef(0);\r\n  function triggerResize() {\r\n    var _a2;\r\n    if (!textarea.value)\r\n      return;\r\n    let height = \"\";\r\n    textarea.value.style[styleProp] = \"1px\";\r\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\r\n    const _styleTarget = toValue(options == null ? void 0 : options.styleTarget);\r\n    if (_styleTarget)\r\n      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;\r\n    else\r\n      height = `${textareaScrollHeight.value}px`;\r\n    textarea.value.style[styleProp] = height;\r\n  }\r\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\r\n  watch(textareaScrollHeight, () => {\r\n    var _a2;\r\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\r\n  });\r\n  useResizeObserver(textarea, ([{ contentRect }]) => {\r\n    if (textareaOldWidth.value === contentRect.width)\r\n      return;\r\n    tryRequestAnimationFrame(window, () => {\r\n      textareaOldWidth.value = contentRect.width;\r\n      triggerResize();\r\n    });\r\n  });\r\n  if (options == null ? void 0 : options.watch)\r\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\r\n  return {\r\n    textarea,\r\n    input,\r\n    triggerResize\r\n  };\r\n}\r\n\r\nfunction useThrottledRefHistory(source, options = {}) {\r\n  const { throttle = 200, trailing = true } = options;\r\n  const filter = throttleFilter(throttle, trailing);\r\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\r\n  return {\r\n    ...history\r\n  };\r\n}\r\n\r\nconst DEFAULT_UNITS = [\r\n  { max: 6e4, value: 1e3, name: \"second\" },\r\n  { max: 276e4, value: 6e4, name: \"minute\" },\r\n  { max: 72e6, value: 36e5, name: \"hour\" },\r\n  { max: 5184e5, value: 864e5, name: \"day\" },\r\n  { max: 24192e5, value: 6048e5, name: \"week\" },\r\n  { max: 28512e6, value: 2592e6, name: \"month\" },\r\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\r\n];\r\nconst DEFAULT_MESSAGES = {\r\n  justNow: \"just now\",\r\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\r\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\r\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\r\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\r\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\r\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\r\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\r\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\r\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\r\n  invalid: \"\"\r\n};\r\nfunction DEFAULT_FORMATTER(date) {\r\n  return date.toISOString().slice(0, 10);\r\n}\r\nfunction useTimeAgo(time, options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    updateInterval = 3e4\r\n  } = options;\r\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\r\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\r\n  if (exposeControls) {\r\n    return {\r\n      timeAgo,\r\n      ...controls\r\n    };\r\n  } else {\r\n    return timeAgo;\r\n  }\r\n}\r\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\r\n  var _a;\r\n  const {\r\n    max,\r\n    messages = DEFAULT_MESSAGES,\r\n    fullDateFormatter = DEFAULT_FORMATTER,\r\n    units = DEFAULT_UNITS,\r\n    showSecond = false,\r\n    rounding = \"round\"\r\n  } = options;\r\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\r\n  const diff = +now - +from;\r\n  const absDiff = Math.abs(diff);\r\n  function getValue(diff2, unit) {\r\n    return roundFn(Math.abs(diff2) / unit.value);\r\n  }\r\n  function format(diff2, unit) {\r\n    const val = getValue(diff2, unit);\r\n    const past = diff2 > 0;\r\n    const str = applyFormat(unit.name, val, past);\r\n    return applyFormat(past ? \"past\" : \"future\", str, past);\r\n  }\r\n  function applyFormat(name, val, isPast) {\r\n    const formatter = messages[name];\r\n    if (typeof formatter === \"function\")\r\n      return formatter(val, isPast);\r\n    return formatter.replace(\"{0}\", val.toString());\r\n  }\r\n  if (absDiff < 6e4 && !showSecond)\r\n    return messages.justNow;\r\n  if (typeof max === \"number\" && absDiff > max)\r\n    return fullDateFormatter(new Date(from));\r\n  if (typeof max === \"string\") {\r\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\r\n    if (unitMax && absDiff > unitMax)\r\n      return fullDateFormatter(new Date(from));\r\n  }\r\n  for (const [idx, unit] of units.entries()) {\r\n    const val = getValue(diff, unit);\r\n    if (val <= 0 && units[idx - 1])\r\n      return format(diff, units[idx - 1]);\r\n    if (absDiff < unit.max)\r\n      return format(diff, unit);\r\n  }\r\n  return messages.invalid;\r\n}\r\n\r\nfunction useTimeoutPoll(fn, interval, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    immediateCallback = false\r\n  } = options;\r\n  const { start } = useTimeoutFn(loop, interval, { immediate });\r\n  const isActive = shallowRef(false);\r\n  async function loop() {\r\n    if (!isActive.value)\r\n      return;\r\n    await fn();\r\n    start();\r\n  }\r\n  function resume() {\r\n    if (!isActive.value) {\r\n      isActive.value = true;\r\n      if (immediateCallback)\r\n        fn();\r\n      start();\r\n    }\r\n  }\r\n  function pause() {\r\n    isActive.value = false;\r\n  }\r\n  if (immediate && isClient)\r\n    resume();\r\n  tryOnScopeDispose(pause);\r\n  return {\r\n    isActive,\r\n    pause,\r\n    resume\r\n  };\r\n}\r\n\r\nfunction useTimestamp(options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    offset = 0,\r\n    immediate = true,\r\n    interval = \"requestAnimationFrame\",\r\n    callback\r\n  } = options;\r\n  const ts = shallowRef(timestamp() + offset);\r\n  const update = () => ts.value = timestamp() + offset;\r\n  const cb = callback ? () => {\r\n    update();\r\n    callback(ts.value);\r\n  } : update;\r\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\r\n  if (exposeControls) {\r\n    return {\r\n      timestamp: ts,\r\n      ...controls\r\n    };\r\n  } else {\r\n    return ts;\r\n  }\r\n}\r\n\r\nfunction useTitle(newTitle = null, options = {}) {\r\n  var _a, _b, _c;\r\n  const {\r\n    document = defaultDocument,\r\n    restoreOnUnmount = (t) => t\r\n  } = options;\r\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\r\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\r\n  const isReadonly = !!(newTitle && typeof newTitle === \"function\");\r\n  function format(t) {\r\n    if (!(\"titleTemplate\" in options))\r\n      return t;\r\n    const template = options.titleTemplate || \"%s\";\r\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\r\n  }\r\n  watch(\r\n    title,\r\n    (newValue, oldValue) => {\r\n      if (newValue !== oldValue && document)\r\n        document.title = format(newValue != null ? newValue : \"\");\r\n    },\r\n    { immediate: true }\r\n  );\r\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\r\n    useMutationObserver(\r\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\r\n      () => {\r\n        if (document && document.title !== title.value)\r\n          title.value = format(document.title);\r\n      },\r\n      { childList: true }\r\n    );\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    if (restoreOnUnmount) {\r\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\r\n      if (restoredTitle != null && document)\r\n        document.title = restoredTitle;\r\n    }\r\n  });\r\n  return title;\r\n}\r\n\r\nconst _TransitionPresets = {\r\n  easeInSine: [0.12, 0, 0.39, 0],\r\n  easeOutSine: [0.61, 1, 0.88, 1],\r\n  easeInOutSine: [0.37, 0, 0.63, 1],\r\n  easeInQuad: [0.11, 0, 0.5, 0],\r\n  easeOutQuad: [0.5, 1, 0.89, 1],\r\n  easeInOutQuad: [0.45, 0, 0.55, 1],\r\n  easeInCubic: [0.32, 0, 0.67, 0],\r\n  easeOutCubic: [0.33, 1, 0.68, 1],\r\n  easeInOutCubic: [0.65, 0, 0.35, 1],\r\n  easeInQuart: [0.5, 0, 0.75, 0],\r\n  easeOutQuart: [0.25, 1, 0.5, 1],\r\n  easeInOutQuart: [0.76, 0, 0.24, 1],\r\n  easeInQuint: [0.64, 0, 0.78, 0],\r\n  easeOutQuint: [0.22, 1, 0.36, 1],\r\n  easeInOutQuint: [0.83, 0, 0.17, 1],\r\n  easeInExpo: [0.7, 0, 0.84, 0],\r\n  easeOutExpo: [0.16, 1, 0.3, 1],\r\n  easeInOutExpo: [0.87, 0, 0.13, 1],\r\n  easeInCirc: [0.55, 0, 1, 0.45],\r\n  easeOutCirc: [0, 0.55, 0.45, 1],\r\n  easeInOutCirc: [0.85, 0, 0.15, 1],\r\n  easeInBack: [0.36, 0, 0.66, -0.56],\r\n  easeOutBack: [0.34, 1.56, 0.64, 1],\r\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\r\n};\r\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\r\nfunction createEasingFunction([p0, p1, p2, p3]) {\r\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\r\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\r\n  const c = (a1) => 3 * a1;\r\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\r\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\r\n  const getTforX = (x) => {\r\n    let aGuessT = x;\r\n    for (let i = 0; i < 4; ++i) {\r\n      const currentSlope = getSlope(aGuessT, p0, p2);\r\n      if (currentSlope === 0)\r\n        return aGuessT;\r\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\r\n      aGuessT -= currentX / currentSlope;\r\n    }\r\n    return aGuessT;\r\n  };\r\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\r\n}\r\nfunction lerp(a, b, alpha) {\r\n  return a + alpha * (b - a);\r\n}\r\nfunction toVec(t) {\r\n  return (typeof t === \"number\" ? [t] : t) || [];\r\n}\r\nfunction executeTransition(source, from, to, options = {}) {\r\n  var _a, _b;\r\n  const fromVal = toValue(from);\r\n  const toVal = toValue(to);\r\n  const v1 = toVec(fromVal);\r\n  const v2 = toVec(toVal);\r\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\r\n  const startedAt = Date.now();\r\n  const endAt = Date.now() + duration;\r\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\r\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\r\n  return new Promise((resolve) => {\r\n    source.value = fromVal;\r\n    const tick = () => {\r\n      var _a2;\r\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\r\n        resolve();\r\n        return;\r\n      }\r\n      const now = Date.now();\r\n      const alpha = ease((now - startedAt) / duration);\r\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\r\n      if (Array.isArray(source.value))\r\n        source.value = arr.map((n, i) => {\r\n          var _a3, _b2;\r\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\r\n        });\r\n      else if (typeof source.value === \"number\")\r\n        source.value = arr[0];\r\n      if (now < endAt) {\r\n        requestAnimationFrame(tick);\r\n      } else {\r\n        source.value = toVal;\r\n        resolve();\r\n      }\r\n    };\r\n    tick();\r\n  });\r\n}\r\nfunction useTransition(source, options = {}) {\r\n  let currentId = 0;\r\n  const sourceVal = () => {\r\n    const v = toValue(source);\r\n    return typeof v === \"number\" ? v : v.map(toValue);\r\n  };\r\n  const outputRef = ref(sourceVal());\r\n  watch(sourceVal, async (to) => {\r\n    var _a, _b;\r\n    if (toValue(options.disabled))\r\n      return;\r\n    const id = ++currentId;\r\n    if (options.delay)\r\n      await promiseTimeout(toValue(options.delay));\r\n    if (id !== currentId)\r\n      return;\r\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\r\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\r\n    await executeTransition(outputRef, outputRef.value, toVal, {\r\n      ...options,\r\n      abort: () => {\r\n        var _a2;\r\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\r\n      }\r\n    });\r\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\r\n  }, { deep: true });\r\n  watch(() => toValue(options.disabled), (disabled) => {\r\n    if (disabled) {\r\n      currentId++;\r\n      outputRef.value = sourceVal();\r\n    }\r\n  });\r\n  tryOnScopeDispose(() => {\r\n    currentId++;\r\n  });\r\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\r\n}\r\n\r\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\r\n  const {\r\n    initialValue = {},\r\n    removeNullishValues = true,\r\n    removeFalsyValues = false,\r\n    write: enableWrite = true,\r\n    writeMode = \"replace\",\r\n    window = defaultWindow\r\n  } = options;\r\n  if (!window)\r\n    return reactive(initialValue);\r\n  const state = reactive({});\r\n  function getRawParams() {\r\n    if (mode === \"history\") {\r\n      return window.location.search || \"\";\r\n    } else if (mode === \"hash\") {\r\n      const hash = window.location.hash || \"\";\r\n      const index = hash.indexOf(\"?\");\r\n      return index > 0 ? hash.slice(index) : \"\";\r\n    } else {\r\n      return (window.location.hash || \"\").replace(/^#/, \"\");\r\n    }\r\n  }\r\n  function constructQuery(params) {\r\n    const stringified = params.toString();\r\n    if (mode === \"history\")\r\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\r\n    if (mode === \"hash-params\")\r\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\r\n    const hash = window.location.hash || \"#\";\r\n    const index = hash.indexOf(\"?\");\r\n    if (index > 0)\r\n      return `${window.location.search || \"\"}${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\r\n    return `${window.location.search || \"\"}${hash}${stringified ? `?${stringified}` : \"\"}`;\r\n  }\r\n  function read() {\r\n    return new URLSearchParams(getRawParams());\r\n  }\r\n  function updateState(params) {\r\n    const unusedKeys = new Set(Object.keys(state));\r\n    for (const key of params.keys()) {\r\n      const paramsForKey = params.getAll(key);\r\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\r\n      unusedKeys.delete(key);\r\n    }\r\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\r\n  }\r\n  const { pause, resume } = pausableWatch(\r\n    state,\r\n    () => {\r\n      const params = new URLSearchParams(\"\");\r\n      Object.keys(state).forEach((key) => {\r\n        const mapEntry = state[key];\r\n        if (Array.isArray(mapEntry))\r\n          mapEntry.forEach((value) => params.append(key, value));\r\n        else if (removeNullishValues && mapEntry == null)\r\n          params.delete(key);\r\n        else if (removeFalsyValues && !mapEntry)\r\n          params.delete(key);\r\n        else\r\n          params.set(key, mapEntry);\r\n      });\r\n      write(params, false);\r\n    },\r\n    { deep: true }\r\n  );\r\n  function write(params, shouldUpdate) {\r\n    pause();\r\n    if (shouldUpdate)\r\n      updateState(params);\r\n    if (writeMode === \"replace\") {\r\n      window.history.replaceState(\r\n        window.history.state,\r\n        window.document.title,\r\n        window.location.pathname + constructQuery(params)\r\n      );\r\n    } else {\r\n      window.history.pushState(\r\n        window.history.state,\r\n        window.document.title,\r\n        window.location.pathname + constructQuery(params)\r\n      );\r\n    }\r\n    resume();\r\n  }\r\n  function onChanged() {\r\n    if (!enableWrite)\r\n      return;\r\n    write(read(), true);\r\n  }\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(window, \"popstate\", onChanged, listenerOptions);\r\n  if (mode !== \"history\")\r\n    useEventListener(window, \"hashchange\", onChanged, listenerOptions);\r\n  const initial = read();\r\n  if (initial.keys().next().value)\r\n    updateState(initial);\r\n  else\r\n    Object.assign(state, initialValue);\r\n  return state;\r\n}\r\n\r\nfunction useUserMedia(options = {}) {\r\n  var _a, _b;\r\n  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);\r\n  const autoSwitch = shallowRef((_b = options.autoSwitch) != null ? _b : true);\r\n  const constraints = ref(options.constraints);\r\n  const { navigator = defaultNavigator } = options;\r\n  const isSupported = useSupported(() => {\r\n    var _a2;\r\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\r\n  });\r\n  const stream = shallowRef();\r\n  function getDeviceOptions(type) {\r\n    switch (type) {\r\n      case \"video\": {\r\n        if (constraints.value)\r\n          return constraints.value.video || false;\r\n        break;\r\n      }\r\n      case \"audio\": {\r\n        if (constraints.value)\r\n          return constraints.value.audio || false;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  async function _start() {\r\n    if (!isSupported.value || stream.value)\r\n      return;\r\n    stream.value = await navigator.mediaDevices.getUserMedia({\r\n      video: getDeviceOptions(\"video\"),\r\n      audio: getDeviceOptions(\"audio\")\r\n    });\r\n    return stream.value;\r\n  }\r\n  function _stop() {\r\n    var _a2;\r\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\r\n    stream.value = void 0;\r\n  }\r\n  function stop() {\r\n    _stop();\r\n    enabled.value = false;\r\n  }\r\n  async function start() {\r\n    await _start();\r\n    if (stream.value)\r\n      enabled.value = true;\r\n    return stream.value;\r\n  }\r\n  async function restart() {\r\n    _stop();\r\n    return await start();\r\n  }\r\n  watch(\r\n    enabled,\r\n    (v) => {\r\n      if (v)\r\n        _start();\r\n      else _stop();\r\n    },\r\n    { immediate: true }\r\n  );\r\n  watch(\r\n    constraints,\r\n    () => {\r\n      if (autoSwitch.value && stream.value)\r\n        restart();\r\n    },\r\n    { immediate: true }\r\n  );\r\n  tryOnScopeDispose(() => {\r\n    stop();\r\n  });\r\n  return {\r\n    isSupported,\r\n    stream,\r\n    start,\r\n    stop,\r\n    restart,\r\n    constraints,\r\n    enabled,\r\n    autoSwitch\r\n  };\r\n}\r\n\r\nfunction useVModel(props, key, emit, options = {}) {\r\n  var _a, _b, _c;\r\n  const {\r\n    clone = false,\r\n    passive = false,\r\n    eventName,\r\n    deep = false,\r\n    defaultValue,\r\n    shouldEmit\r\n  } = options;\r\n  const vm = getCurrentInstance();\r\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\r\n  let event = eventName;\r\n  if (!key) {\r\n    key = \"modelValue\";\r\n  }\r\n  event = event || `update:${key.toString()}`;\r\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\r\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\r\n  const triggerEmit = (value) => {\r\n    if (shouldEmit) {\r\n      if (shouldEmit(value))\r\n        _emit(event, value);\r\n    } else {\r\n      _emit(event, value);\r\n    }\r\n  };\r\n  if (passive) {\r\n    const initialValue = getValue();\r\n    const proxy = ref(initialValue);\r\n    let isUpdating = false;\r\n    watch(\r\n      () => props[key],\r\n      (v) => {\r\n        if (!isUpdating) {\r\n          isUpdating = true;\r\n          proxy.value = cloneFn(v);\r\n          nextTick(() => isUpdating = false);\r\n        }\r\n      }\r\n    );\r\n    watch(\r\n      proxy,\r\n      (v) => {\r\n        if (!isUpdating && (v !== props[key] || deep))\r\n          triggerEmit(v);\r\n      },\r\n      { deep }\r\n    );\r\n    return proxy;\r\n  } else {\r\n    return computed({\r\n      get() {\r\n        return getValue();\r\n      },\r\n      set(value) {\r\n        triggerEmit(value);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction useVModels(props, emit, options = {}) {\r\n  const ret = {};\r\n  for (const key in props) {\r\n    ret[key] = useVModel(\r\n      props,\r\n      key,\r\n      emit,\r\n      options\r\n    );\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction useVibrate(options) {\r\n  const {\r\n    pattern = [],\r\n    interval = 0,\r\n    navigator = defaultNavigator\r\n  } = options || {};\r\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\r\n  const patternRef = toRef(pattern);\r\n  let intervalControls;\r\n  const vibrate = (pattern2 = patternRef.value) => {\r\n    if (isSupported.value)\r\n      navigator.vibrate(pattern2);\r\n  };\r\n  const stop = () => {\r\n    if (isSupported.value)\r\n      navigator.vibrate(0);\r\n    intervalControls == null ? void 0 : intervalControls.pause();\r\n  };\r\n  if (interval > 0) {\r\n    intervalControls = useIntervalFn(\r\n      vibrate,\r\n      interval,\r\n      {\r\n        immediate: false,\r\n        immediateCallback: false\r\n      }\r\n    );\r\n  }\r\n  return {\r\n    isSupported,\r\n    pattern,\r\n    intervalControls,\r\n    vibrate,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useVirtualList(list, options) {\r\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\r\n  return {\r\n    list: currentList,\r\n    scrollTo,\r\n    containerProps: {\r\n      ref: containerRef,\r\n      onScroll: () => {\r\n        calculateRange();\r\n      },\r\n      style: containerStyle\r\n    },\r\n    wrapperProps\r\n  };\r\n}\r\nfunction useVirtualListResources(list) {\r\n  const containerRef = shallowRef(null);\r\n  const size = useElementSize(containerRef);\r\n  const currentList = ref([]);\r\n  const source = shallowRef(list);\r\n  const state = ref({ start: 0, end: 10 });\r\n  return { state, source, currentList, size, containerRef };\r\n}\r\nfunction createGetViewCapacity(state, source, itemSize) {\r\n  return (containerSize) => {\r\n    if (typeof itemSize === \"number\")\r\n      return Math.ceil(containerSize / itemSize);\r\n    const { start = 0 } = state.value;\r\n    let sum = 0;\r\n    let capacity = 0;\r\n    for (let i = start; i < source.value.length; i++) {\r\n      const size = itemSize(i);\r\n      sum += size;\r\n      capacity = i;\r\n      if (sum > containerSize)\r\n        break;\r\n    }\r\n    return capacity - start;\r\n  };\r\n}\r\nfunction createGetOffset(source, itemSize) {\r\n  return (scrollDirection) => {\r\n    if (typeof itemSize === \"number\")\r\n      return Math.floor(scrollDirection / itemSize) + 1;\r\n    let sum = 0;\r\n    let offset = 0;\r\n    for (let i = 0; i < source.value.length; i++) {\r\n      const size = itemSize(i);\r\n      sum += size;\r\n      if (sum >= scrollDirection) {\r\n        offset = i;\r\n        break;\r\n      }\r\n    }\r\n    return offset + 1;\r\n  };\r\n}\r\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\r\n  return () => {\r\n    const element = containerRef.value;\r\n    if (element) {\r\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\r\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\r\n      const from = offset - overscan;\r\n      const to = offset + viewCapacity + overscan;\r\n      state.value = {\r\n        start: from < 0 ? 0 : from,\r\n        end: to > source.value.length ? source.value.length : to\r\n      };\r\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\r\n        data: ele,\r\n        index: index + state.value.start\r\n      }));\r\n    }\r\n  };\r\n}\r\nfunction createGetDistance(itemSize, source) {\r\n  return (index) => {\r\n    if (typeof itemSize === \"number\") {\r\n      const size2 = index * itemSize;\r\n      return size2;\r\n    }\r\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\r\n    return size;\r\n  };\r\n}\r\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\r\n  watch([size.width, size.height, list, containerRef], () => {\r\n    calculateRange();\r\n  });\r\n}\r\nfunction createComputedTotalSize(itemSize, source) {\r\n  return computed(() => {\r\n    if (typeof itemSize === \"number\")\r\n      return source.value.length * itemSize;\r\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\r\n  });\r\n}\r\nconst scrollToDictionaryForElementScrollKey = {\r\n  horizontal: \"scrollLeft\",\r\n  vertical: \"scrollTop\"\r\n};\r\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\r\n  return (index) => {\r\n    if (containerRef.value) {\r\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\r\n      calculateRange();\r\n    }\r\n  };\r\n}\r\nfunction useHorizontalVirtualList(options, list) {\r\n  const resources = useVirtualListResources(list);\r\n  const { state, source, currentList, size, containerRef } = resources;\r\n  const containerStyle = { overflowX: \"auto\" };\r\n  const { itemWidth, overscan = 5 } = options;\r\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\r\n  const getOffset = createGetOffset(source, itemWidth);\r\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\r\n  const getDistanceLeft = createGetDistance(itemWidth, source);\r\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\r\n  const totalWidth = createComputedTotalSize(itemWidth, source);\r\n  useWatchForSizes(size, list, containerRef, calculateRange);\r\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\r\n  const wrapperProps = computed(() => {\r\n    return {\r\n      style: {\r\n        height: \"100%\",\r\n        width: `${totalWidth.value - offsetLeft.value}px`,\r\n        marginLeft: `${offsetLeft.value}px`,\r\n        display: \"flex\"\r\n      }\r\n    };\r\n  });\r\n  return {\r\n    scrollTo,\r\n    calculateRange,\r\n    wrapperProps,\r\n    containerStyle,\r\n    currentList,\r\n    containerRef\r\n  };\r\n}\r\nfunction useVerticalVirtualList(options, list) {\r\n  const resources = useVirtualListResources(list);\r\n  const { state, source, currentList, size, containerRef } = resources;\r\n  const containerStyle = { overflowY: \"auto\" };\r\n  const { itemHeight, overscan = 5 } = options;\r\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\r\n  const getOffset = createGetOffset(source, itemHeight);\r\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\r\n  const getDistanceTop = createGetDistance(itemHeight, source);\r\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\r\n  const totalHeight = createComputedTotalSize(itemHeight, source);\r\n  useWatchForSizes(size, list, containerRef, calculateRange);\r\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\r\n  const wrapperProps = computed(() => {\r\n    return {\r\n      style: {\r\n        width: \"100%\",\r\n        height: `${totalHeight.value - offsetTop.value}px`,\r\n        marginTop: `${offsetTop.value}px`\r\n      }\r\n    };\r\n  });\r\n  return {\r\n    calculateRange,\r\n    scrollTo,\r\n    containerStyle,\r\n    wrapperProps,\r\n    currentList,\r\n    containerRef\r\n  };\r\n}\r\n\r\nfunction useWakeLock(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    document = defaultDocument\r\n  } = options;\r\n  const requestedType = shallowRef(false);\r\n  const sentinel = shallowRef(null);\r\n  const documentVisibility = useDocumentVisibility({ document });\r\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\r\n  const isActive = computed(() => !!sentinel.value && documentVisibility.value === \"visible\");\r\n  if (isSupported.value) {\r\n    useEventListener(sentinel, \"release\", () => {\r\n      var _a, _b;\r\n      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;\r\n    }, { passive: true });\r\n    whenever(\r\n      () => documentVisibility.value === \"visible\" && (document == null ? void 0 : document.visibilityState) === \"visible\" && requestedType.value,\r\n      (type) => {\r\n        requestedType.value = false;\r\n        forceRequest(type);\r\n      }\r\n    );\r\n  }\r\n  async function forceRequest(type) {\r\n    var _a;\r\n    await ((_a = sentinel.value) == null ? void 0 : _a.release());\r\n    sentinel.value = isSupported.value ? await navigator.wakeLock.request(type) : null;\r\n  }\r\n  async function request(type) {\r\n    if (documentVisibility.value === \"visible\")\r\n      await forceRequest(type);\r\n    else\r\n      requestedType.value = type;\r\n  }\r\n  async function release() {\r\n    requestedType.value = false;\r\n    const s = sentinel.value;\r\n    sentinel.value = null;\r\n    await (s == null ? void 0 : s.release());\r\n  }\r\n  return {\r\n    sentinel,\r\n    isSupported,\r\n    isActive,\r\n    request,\r\n    forceRequest,\r\n    release\r\n  };\r\n}\r\n\r\nfunction useWebNotification(options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    requestPermissions: _requestForPermissions = true\r\n  } = options;\r\n  const defaultWebNotificationOptions = options;\r\n  const isSupported = useSupported(() => {\r\n    if (!window || !(\"Notification\" in window))\r\n      return false;\r\n    if (Notification.permission === \"granted\")\r\n      return true;\r\n    try {\r\n      const notification2 = new Notification(\"\");\r\n      notification2.onshow = () => {\r\n        notification2.close();\r\n      };\r\n    } catch (e) {\r\n      if (e.name === \"TypeError\")\r\n        return false;\r\n    }\r\n    return true;\r\n  });\r\n  const permissionGranted = shallowRef(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\r\n  const notification = ref(null);\r\n  const ensurePermissions = async () => {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\r\n      const result = await Notification.requestPermission();\r\n      if (result === \"granted\")\r\n        permissionGranted.value = true;\r\n    }\r\n    return permissionGranted.value;\r\n  };\r\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\r\n  const { on: onShow, trigger: showTrigger } = createEventHook();\r\n  const { on: onError, trigger: errorTrigger } = createEventHook();\r\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\r\n  const show = async (overrides) => {\r\n    if (!isSupported.value || !permissionGranted.value)\r\n      return;\r\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\r\n    notification.value = new Notification(options2.title || \"\", options2);\r\n    notification.value.onclick = clickTrigger;\r\n    notification.value.onshow = showTrigger;\r\n    notification.value.onerror = errorTrigger;\r\n    notification.value.onclose = closeTrigger;\r\n    return notification.value;\r\n  };\r\n  const close = () => {\r\n    if (notification.value)\r\n      notification.value.close();\r\n    notification.value = null;\r\n  };\r\n  if (_requestForPermissions)\r\n    tryOnMounted(ensurePermissions);\r\n  tryOnScopeDispose(close);\r\n  if (isSupported.value && window) {\r\n    const document = window.document;\r\n    useEventListener(document, \"visibilitychange\", (e) => {\r\n      e.preventDefault();\r\n      if (document.visibilityState === \"visible\") {\r\n        close();\r\n      }\r\n    });\r\n  }\r\n  return {\r\n    isSupported,\r\n    notification,\r\n    ensurePermissions,\r\n    permissionGranted,\r\n    show,\r\n    close,\r\n    onClick,\r\n    onShow,\r\n    onError,\r\n    onClose\r\n  };\r\n}\r\n\r\nconst DEFAULT_PING_MESSAGE = \"ping\";\r\nfunction resolveNestedOptions(options) {\r\n  if (options === true)\r\n    return {};\r\n  return options;\r\n}\r\nfunction useWebSocket(url, options = {}) {\r\n  const {\r\n    onConnected,\r\n    onDisconnected,\r\n    onError,\r\n    onMessage,\r\n    immediate = true,\r\n    autoConnect = true,\r\n    autoClose = true,\r\n    protocols = []\r\n  } = options;\r\n  const data = ref(null);\r\n  const status = shallowRef(\"CLOSED\");\r\n  const wsRef = ref();\r\n  const urlRef = toRef(url);\r\n  let heartbeatPause;\r\n  let heartbeatResume;\r\n  let explicitlyClosed = false;\r\n  let retried = 0;\r\n  let bufferedData = [];\r\n  let retryTimeout;\r\n  let pongTimeoutWait;\r\n  const _sendBuffer = () => {\r\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\r\n      for (const buffer of bufferedData)\r\n        wsRef.value.send(buffer);\r\n      bufferedData = [];\r\n    }\r\n  };\r\n  const resetRetry = () => {\r\n    if (retryTimeout != null) {\r\n      clearTimeout(retryTimeout);\r\n      retryTimeout = void 0;\r\n    }\r\n  };\r\n  const resetHeartbeat = () => {\r\n    clearTimeout(pongTimeoutWait);\r\n    pongTimeoutWait = void 0;\r\n  };\r\n  const close = (code = 1e3, reason) => {\r\n    resetRetry();\r\n    if (!isClient && !isWorker || !wsRef.value)\r\n      return;\r\n    explicitlyClosed = true;\r\n    resetHeartbeat();\r\n    heartbeatPause == null ? void 0 : heartbeatPause();\r\n    wsRef.value.close(code, reason);\r\n    wsRef.value = void 0;\r\n  };\r\n  const send = (data2, useBuffer = true) => {\r\n    if (!wsRef.value || status.value !== \"OPEN\") {\r\n      if (useBuffer)\r\n        bufferedData.push(data2);\r\n      return false;\r\n    }\r\n    _sendBuffer();\r\n    wsRef.value.send(data2);\r\n    return true;\r\n  };\r\n  const _init = () => {\r\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\r\n      return;\r\n    const ws = new WebSocket(urlRef.value, protocols);\r\n    wsRef.value = ws;\r\n    status.value = \"CONNECTING\";\r\n    ws.onopen = () => {\r\n      status.value = \"OPEN\";\r\n      retried = 0;\r\n      onConnected == null ? void 0 : onConnected(ws);\r\n      heartbeatResume == null ? void 0 : heartbeatResume();\r\n      _sendBuffer();\r\n    };\r\n    ws.onclose = (ev) => {\r\n      status.value = \"CLOSED\";\r\n      resetHeartbeat();\r\n      heartbeatPause == null ? void 0 : heartbeatPause();\r\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\r\n      if (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {\r\n        const {\r\n          retries = -1,\r\n          delay = 1e3,\r\n          onFailed\r\n        } = resolveNestedOptions(options.autoReconnect);\r\n        const checkRetires = typeof retries === \"function\" ? retries : () => typeof retries === \"number\" && (retries < 0 || retried < retries);\r\n        if (checkRetires(retried)) {\r\n          retried += 1;\r\n          retryTimeout = setTimeout(_init, delay);\r\n        } else {\r\n          onFailed == null ? void 0 : onFailed();\r\n        }\r\n      }\r\n    };\r\n    ws.onerror = (e) => {\r\n      onError == null ? void 0 : onError(ws, e);\r\n    };\r\n    ws.onmessage = (e) => {\r\n      if (options.heartbeat) {\r\n        resetHeartbeat();\r\n        const {\r\n          message = DEFAULT_PING_MESSAGE,\r\n          responseMessage = message\r\n        } = resolveNestedOptions(options.heartbeat);\r\n        if (e.data === toValue(responseMessage))\r\n          return;\r\n      }\r\n      data.value = e.data;\r\n      onMessage == null ? void 0 : onMessage(ws, e);\r\n    };\r\n  };\r\n  if (options.heartbeat) {\r\n    const {\r\n      message = DEFAULT_PING_MESSAGE,\r\n      interval = 1e3,\r\n      pongTimeout = 1e3\r\n    } = resolveNestedOptions(options.heartbeat);\r\n    const { pause, resume } = useIntervalFn(\r\n      () => {\r\n        send(toValue(message), false);\r\n        if (pongTimeoutWait != null)\r\n          return;\r\n        pongTimeoutWait = setTimeout(() => {\r\n          close();\r\n          explicitlyClosed = false;\r\n        }, pongTimeout);\r\n      },\r\n      interval,\r\n      { immediate: false }\r\n    );\r\n    heartbeatPause = pause;\r\n    heartbeatResume = resume;\r\n  }\r\n  if (autoClose) {\r\n    if (isClient)\r\n      useEventListener(\"beforeunload\", () => close(), { passive: true });\r\n    tryOnScopeDispose(close);\r\n  }\r\n  const open = () => {\r\n    if (!isClient && !isWorker)\r\n      return;\r\n    close();\r\n    explicitlyClosed = false;\r\n    retried = 0;\r\n    _init();\r\n  };\r\n  if (immediate)\r\n    open();\r\n  if (autoConnect)\r\n    watch(urlRef, open);\r\n  return {\r\n    data,\r\n    status,\r\n    close,\r\n    send,\r\n    open,\r\n    ws: wsRef\r\n  };\r\n}\r\n\r\nfunction useWebWorker(arg0, workerOptions, options) {\r\n  const {\r\n    window = defaultWindow\r\n  } = options != null ? options : {};\r\n  const data = ref(null);\r\n  const worker = shallowRef();\r\n  const post = (...args) => {\r\n    if (!worker.value)\r\n      return;\r\n    worker.value.postMessage(...args);\r\n  };\r\n  const terminate = function terminate2() {\r\n    if (!worker.value)\r\n      return;\r\n    worker.value.terminate();\r\n  };\r\n  if (window) {\r\n    if (typeof arg0 === \"string\")\r\n      worker.value = new Worker(arg0, workerOptions);\r\n    else if (typeof arg0 === \"function\")\r\n      worker.value = arg0();\r\n    else\r\n      worker.value = arg0;\r\n    worker.value.onmessage = (e) => {\r\n      data.value = e.data;\r\n    };\r\n    tryOnScopeDispose(() => {\r\n      if (worker.value)\r\n        worker.value.terminate();\r\n    });\r\n  }\r\n  return {\r\n    data,\r\n    post,\r\n    terminate,\r\n    worker\r\n  };\r\n}\r\n\r\nfunction depsParser(deps, localDeps) {\r\n  if (deps.length === 0 && localDeps.length === 0)\r\n    return \"\";\r\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\r\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\r\n    const str = fn.toString();\r\n    if (str.trim().startsWith(\"function\")) {\r\n      return str;\r\n    } else {\r\n      const name = fn.name;\r\n      return `const ${name} = ${str}`;\r\n    }\r\n  }).join(\";\");\r\n  const importString = `importScripts(${depsString});`;\r\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\r\n}\r\n\r\nfunction jobRunner(userFunc) {\r\n  return (e) => {\r\n    const userFuncArgs = e.data[0];\r\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\r\n      postMessage([\"SUCCESS\", result]);\r\n    }).catch((error) => {\r\n      postMessage([\"ERROR\", error]);\r\n    });\r\n  };\r\n}\r\n\r\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\r\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\r\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\r\n  const url = URL.createObjectURL(blob);\r\n  return url;\r\n}\r\n\r\nfunction useWebWorkerFn(fn, options = {}) {\r\n  const {\r\n    dependencies = [],\r\n    localDependencies = [],\r\n    timeout,\r\n    window = defaultWindow\r\n  } = options;\r\n  const worker = ref();\r\n  const workerStatus = shallowRef(\"PENDING\");\r\n  const promise = ref({});\r\n  const timeoutId = shallowRef();\r\n  const workerTerminate = (status = \"PENDING\") => {\r\n    if (worker.value && worker.value._url && window) {\r\n      worker.value.terminate();\r\n      URL.revokeObjectURL(worker.value._url);\r\n      promise.value = {};\r\n      worker.value = void 0;\r\n      window.clearTimeout(timeoutId.value);\r\n      workerStatus.value = status;\r\n    }\r\n  };\r\n  workerTerminate();\r\n  tryOnScopeDispose(workerTerminate);\r\n  const generateWorker = () => {\r\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\r\n    const newWorker = new Worker(blobUrl);\r\n    newWorker._url = blobUrl;\r\n    newWorker.onmessage = (e) => {\r\n      const { resolve = () => {\r\n      }, reject = () => {\r\n      } } = promise.value;\r\n      const [status, result] = e.data;\r\n      switch (status) {\r\n        case \"SUCCESS\":\r\n          resolve(result);\r\n          workerTerminate(status);\r\n          break;\r\n        default:\r\n          reject(result);\r\n          workerTerminate(\"ERROR\");\r\n          break;\r\n      }\r\n    };\r\n    newWorker.onerror = (e) => {\r\n      const { reject = () => {\r\n      } } = promise.value;\r\n      e.preventDefault();\r\n      reject(e);\r\n      workerTerminate(\"ERROR\");\r\n    };\r\n    if (timeout) {\r\n      timeoutId.value = setTimeout(\r\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\r\n        timeout\r\n      );\r\n    }\r\n    return newWorker;\r\n  };\r\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\r\n    var _a;\r\n    promise.value = {\r\n      resolve,\r\n      reject\r\n    };\r\n    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);\r\n    workerStatus.value = \"RUNNING\";\r\n  });\r\n  const workerFn = (...fnArgs) => {\r\n    if (workerStatus.value === \"RUNNING\") {\r\n      console.error(\r\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\r\n      );\r\n      return Promise.reject();\r\n    }\r\n    worker.value = generateWorker();\r\n    return callWorker(...fnArgs);\r\n  };\r\n  return {\r\n    workerFn,\r\n    workerStatus,\r\n    workerTerminate\r\n  };\r\n}\r\n\r\nfunction useWindowFocus(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  if (!window)\r\n    return shallowRef(false);\r\n  const focused = shallowRef(window.document.hasFocus());\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(window, \"blur\", () => {\r\n    focused.value = false;\r\n  }, listenerOptions);\r\n  useEventListener(window, \"focus\", () => {\r\n    focused.value = true;\r\n  }, listenerOptions);\r\n  return focused;\r\n}\r\n\r\nfunction useWindowScroll(options = {}) {\r\n  const { window = defaultWindow, ...rest } = options;\r\n  return useScroll(window, rest);\r\n}\r\n\r\nfunction useWindowSize(options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    initialWidth = Number.POSITIVE_INFINITY,\r\n    initialHeight = Number.POSITIVE_INFINITY,\r\n    listenOrientation = true,\r\n    includeScrollbar = true,\r\n    type = \"inner\"\r\n  } = options;\r\n  const width = shallowRef(initialWidth);\r\n  const height = shallowRef(initialHeight);\r\n  const update = () => {\r\n    if (window) {\r\n      if (type === \"outer\") {\r\n        width.value = window.outerWidth;\r\n        height.value = window.outerHeight;\r\n      } else if (type === \"visual\" && window.visualViewport) {\r\n        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window.visualViewport;\r\n        width.value = Math.round(visualViewportWidth * scale);\r\n        height.value = Math.round(visualViewportHeight * scale);\r\n      } else if (includeScrollbar) {\r\n        width.value = window.innerWidth;\r\n        height.value = window.innerHeight;\r\n      } else {\r\n        width.value = window.document.documentElement.clientWidth;\r\n        height.value = window.document.documentElement.clientHeight;\r\n      }\r\n    }\r\n  };\r\n  update();\r\n  tryOnMounted(update);\r\n  const listenerOptions = { passive: true };\r\n  useEventListener(\"resize\", update, listenerOptions);\r\n  if (window && type === \"visual\" && window.visualViewport) {\r\n    useEventListener(window.visualViewport, \"resize\", update, listenerOptions);\r\n  }\r\n  if (listenOrientation) {\r\n    const matches = useMediaQuery(\"(orientation: portrait)\");\r\n    watch(matches, () => update());\r\n  }\r\n  return { width, height };\r\n}\r\n\r\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onElementRemoval, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, provideSSRWidth, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCountdown, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePreferredReducedTransparency, usePrevious, useRafFn, useRefHistory, useResizeObserver, useSSRWidth, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\r\n", "import type { InjectionKey } from 'vue'\nimport { inject, provide } from 'vue'\n\n/**\n * @param providerComponentName - The name(s) of the component(s) providing the context.\n *\n * There are situations where context can come from multiple components. In such cases, you might need to give an array of component names to provide your context, instead of just a single string.\n *\n * @param contextName The description for injection key symbol.\n */\nexport function createContext<ContextValue>(\n  providerComponentName: string | string[],\n  contextName?: string,\n) {\n  const symbolDescription\n    = typeof providerComponentName === 'string' && !contextName\n      ? `${providerComponentName}Context`\n      : contextName\n\n  const injectionKey: InjectionKey<ContextValue | null> = Symbol(symbolDescription)\n\n  /**\n   * @param fallback The context value to return if the injection fails.\n   *\n   * @throws When context injection failed and no fallback is specified.\n   * This happens when the component injecting the context is not a child of the root component providing the context.\n   */\n  const injectContext = <\n    T extends ContextValue | null | undefined = ContextValue,\n  >(\n    fallback?: T,\n  ): T extends null ? ContextValue | null : ContextValue => {\n    const context = inject(injectionKey, fallback)\n    if (context)\n      return context\n\n    if (context === null)\n      return context as any\n\n    throw new Error(\n      `Injection \\`${injectionKey.toString()}\\` not found. Component must be used within ${\n        Array.isArray(providerComponentName)\n          ? `one of the following components: ${providerComponentName.join(\n            ', ',\n          )}`\n          : `\\`${providerComponentName}\\``\n      }`,\n    )\n  }\n\n  const provideContext = (contextValue: ContextValue) => {\n    provide(injectionKey, contextValue)\n    return contextValue\n  }\n\n  return [injectContext, provideContext] as const\n}\n", "function serialize(o){return typeof o==\"string\"?`'${o}'`:new c().serialize(o)}const c=/*@__PURE__*/function(){class o{#t=new Map;compare(t,r){const e=typeof t,n=typeof r;return e===\"string\"&&n===\"string\"?t.localeCompare(r):e===\"number\"&&n===\"number\"?t-r:String.prototype.localeCompare.call(this.serialize(t,true),this.serialize(r,true))}serialize(t,r){if(t===null)return \"null\";switch(typeof t){case \"string\":return r?t:`'${t}'`;case \"bigint\":return `${t}n`;case \"object\":return this.$object(t);case \"function\":return this.$function(t)}return String(t)}serializeObject(t){const r=Object.prototype.toString.call(t);if(r!==\"[object Object]\")return this.serializeBuiltInType(r.length<10?`unknown:${r}`:r.slice(8,-1),t);const e=t.constructor,n=e===Object||e===void 0?\"\":e.name;if(n!==\"\"&&globalThis[n]===e)return this.serializeBuiltInType(n,t);if(typeof t.toJSON==\"function\"){const i=t.toJSON();return n+(i!==null&&typeof i==\"object\"?this.$object(i):`(${this.serialize(i)})`)}return this.serializeObjectEntries(n,Object.entries(t))}serializeBuiltInType(t,r){const e=this[\"$\"+t];if(e)return e.call(this,r);if(typeof r?.entries==\"function\")return this.serializeObjectEntries(t,r.entries());throw new Error(`Cannot serialize ${t}`)}serializeObjectEntries(t,r){const e=Array.from(r).sort((i,a)=>this.compare(i[0],a[0]));let n=`${t}{`;for(let i=0;i<e.length;i++){const[a,l]=e[i];n+=`${this.serialize(a,true)}:${this.serialize(l)}`,i<e.length-1&&(n+=\",\");}return n+\"}\"}$object(t){let r=this.#t.get(t);return r===void 0&&(this.#t.set(t,`#${this.#t.size}`),r=this.serializeObject(t),this.#t.set(t,r)),r}$function(t){const r=Function.prototype.toString.call(t);return r.slice(-15)===\"[native code] }\"?`${t.name||\"\"}()[native]`:`${t.name}(${t.length})${r.replace(/\\s*\\n\\s*/g,\"\")}`}$Array(t){let r=\"[\";for(let e=0;e<t.length;e++)r+=this.serialize(t[e]),e<t.length-1&&(r+=\",\");return r+\"]\"}$Date(t){try{return `Date(${t.toISOString()})`}catch{return \"Date(null)\"}}$ArrayBuffer(t){return `ArrayBuffer[${new Uint8Array(t).join(\",\")}]`}$Set(t){return `Set${this.$Array(Array.from(t).sort((r,e)=>this.compare(r,e)))}`}$Map(t){return this.serializeObjectEntries(\"Map\",t.entries())}}for(const s of [\"Error\",\"RegExp\",\"URL\"])o.prototype[\"$\"+s]=function(t){return `${s}(${t})`};for(const s of [\"Int8Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"Int16Array\",\"Uint16Array\",\"Int32Array\",\"Uint32Array\",\"Float32Array\",\"Float64Array\"])o.prototype[\"$\"+s]=function(t){return `${s}[${t.join(\",\")}]`};for(const s of [\"BigInt64Array\",\"BigUint64Array\"])o.prototype[\"$\"+s]=function(t){return `${s}[${t.join(\"n,\")}${t.length>0?\"n\":\"\"}]`};return o}();\r\n\r\nfunction isEqual(object1, object2) {\r\n  if (object1 === object2) {\r\n    return true;\r\n  }\r\n  if (serialize(object1) === serialize(object2)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport { isEqual as i, serialize as s };\r\n", "export function isNullish(value: any): value is null | undefined {\n  return value === null || value === undefined\n}\n", "import { isEqual } from 'ohash'\nimport { isNullish } from './nullish'\n\n/**\n * The function `isValueEqualOrExist` checks if a value is equal to or exists in another value or\n * array.\n * @param {T | T[] | undefined} base - It represents the base value that you want to compare with the `current` value.\n * @param {T | T[] | undefined} current - The `current` parameter represents the current value that you want to compare with the `base` value or values.\n * @returns The `isValueEqualOrExist` function returns a boolean value. It checks if the `base` value\n * is equal to the `current` value or if the `current` value exists within the `base` value. The\n * function handles cases where `base` can be a single value, an array of values, or undefined.\n */\nexport function isValueEqualOrExist<T>(base: T | T[] | undefined, current: T | T[] | undefined) {\n  if (isNullish(base))\n    return false\n  if (Array.isArray(base)) {\n    return base.some(val => isEqual(val, current))\n  }\n  else {\n    return isEqual(base, current)\n  }\n}\n", "import type { Ref } from 'vue'\nimport type { AcceptableValue, SingleOrMultipleProps } from './types'\nimport { useVModel } from '@vueuse/core'\nimport { isEqual } from 'ohash'\nimport { computed } from 'vue'\nimport { isValueEqualOrExist } from './isValueEqualOrExist'\n\n/**\n * Validates the props and it makes sure that the types are coherent with each other\n *\n * 1. If type, defaultValue, and modelValue are all undefined, throw an error.\n * 2. If modelValue and defaultValue are defined and not of the same type, throw an error.\n * 3. If type is defined:\n *    a. If type is 'single' and either modelValue or defaultValue is an array, log an error and return 'multiple'.\n *    b. If type is 'multiple' and neither modelValue nor defaultValue is an array, log an error and return 'single'.\n * 4. Return 'multiple' if modelValue is an array, else return 'single'.\n */\nfunction validateProps({ type, defaultValue, modelValue }: SingleOrMultipleProps) {\n  const value = modelValue || defaultValue\n  const canTypeBeInferred = modelValue !== undefined || defaultValue !== undefined\n\n  if (canTypeBeInferred)\n    return Array.isArray(value) ? 'multiple' : 'single'\n  else\n    return type ?? 'single' // always fallback to `single`\n}\n\nfunction getDefaultType({ type, defaultValue, modelValue }: SingleOrMultipleProps) {\n  if (type)\n    return type\n\n  return validateProps({ type, defaultValue, modelValue })\n}\n\nfunction getDefaultValue({ type, defaultValue }: SingleOrMultipleProps) {\n  if (defaultValue !== undefined)\n    return defaultValue\n\n  return (type === 'single') ? undefined : []\n}\n\nexport function useSingleOrMultipleValue<P extends SingleOrMultipleProps, Name extends string>(\n  props: P,\n  emits: (name: Name, ...args: any[]) => void,\n) {\n  const type = computed(() => getDefaultType(props))\n  const modelValue = useVModel(props, 'modelValue', emits, {\n    defaultValue: getDefaultValue(props),\n    passive: (props.modelValue === undefined) as false,\n    deep: true,\n  }) as Ref<AcceptableValue | AcceptableValue[] | undefined>\n\n  function changeModelValue(value: AcceptableValue) {\n    if (type.value === 'single') {\n      modelValue.value = isEqual(value, modelValue.value) ? undefined : value\n    }\n    else {\n      const modelValueArray = Array.isArray(modelValue.value) ? [...(modelValue.value as AcceptableValue[] || [])] : [modelValue.value].filter(Boolean)\n      if (isValueEqualOrExist(modelValueArray, value)) {\n        const index = modelValueArray.findIndex(i => isEqual(i, value))\n        modelValueArray.splice(index, 1)\n      }\n      else {\n        modelValueArray.push(value)\n      }\n      modelValue.value = modelValueArray\n    }\n  }\n\n  const isSingle = computed(() => type.value === 'single')\n\n  return {\n    modelValue,\n    changeModelValue,\n    isSingle,\n  }\n}\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Direction, ScrollBodyOption } from '@/shared/types'\nimport { createContext } from '@/shared'\n\ninterface ConfigProviderContextValue {\n  dir?: Ref<Direction>\n  locale?: Ref<string>\n  scrollBody?: Ref<boolean | ScrollBodyOption>\n  nonce?: Ref<string | undefined>\n  useId?: () => string\n}\n\nexport const [injectConfigProviderContext, provideConfigProviderContext]\n  = createContext<ConfigProviderContextValue>('ConfigProvider')\n\nexport interface ConfigProviderProps {\n  /**\n   * The global reading direction of your application. This will be inherited by all primitives.\n   * @defaultValue 'ltr'\n   */\n  dir?: Direction\n  /**\n   * The global locale of your application. This will be inherited by all primitives.\n   * @defaultValue 'en'\n   */\n  locale?: string\n  /**\n   * The global scroll body behavior of your application. This will be inherited by the related primitives.\n   * @type boolean | ScrollBodyOption\n   */\n  scrollBody?: boolean | ScrollBodyOption\n  /**\n   * The global `nonce` value of your application. This will be inherited by the related primitives.\n   * @type string\n   */\n  nonce?: string\n  /**\n   * The global `useId` injection as a workaround for preventing hydration issue.\n   */\n  useId?: () => string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { toRefs } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ConfigProviderProps>(), {\n  dir: 'ltr',\n  locale: 'en',\n  scrollBody: true,\n  nonce: undefined,\n  useId: undefined,\n})\n\nconst { dir, locale, scrollBody, nonce } = toRefs(props)\n\nprovideConfigProviderContext({\n  dir,\n  locale,\n  scrollBody,\n  nonce,\n  useId: props.useId,\n})\n</script>\n\n<template>\n  <slot />\n</template>\n", "import type { Ref } from 'vue'\nimport type { Direction } from './types'\nimport { computed, ref } from 'vue'\nimport { injectConfigProviderContext } from '@/ConfigProvider/ConfigProvider.vue'\n\nexport function useDirection(dir?: Ref<Direction | undefined>) {\n  const context = injectConfigProviderContext({\n    dir: ref('ltr'),\n  })\n  return computed(() => dir?.value || context.dir?.value || 'ltr')\n}\n", "import type { ComponentPublicInstance } from 'vue'\n// reference: https://github.com/vuejs/rfcs/issues/258#issuecomment-1068697672\nimport { unrefElement } from '@vueuse/core'\nimport { computed, getCurrentInstance, ref } from 'vue'\n\nexport function useForwardExpose<T extends ComponentPublicInstance>() {\n  const instance = getCurrentInstance()!\n\n  const currentRef = ref<Element | T | null>()\n  const currentElement = computed<HTMLElement>(() => {\n    // $el could be text/comment for non-single root normal or text root, thus we retrieve the nextElementSibling\n    // @ts-expect-error ignore ts error\n    return ['#text', '#comment'].includes(currentRef.value?.$el.nodeName) ? currentRef.value?.$el.nextElementSibling : unrefElement(currentRef)\n  })\n\n  // Do give us credit if you reference our code :D\n  // localExpose should only be assigned once else will create infinite loop\n  const localExpose: Record<string, any> | null = Object.assign({}, instance.exposed)\n  const ret: Record<string, any> = {}\n\n  // retrieve props for current instance\n  for (const key in instance.props) {\n    Object.defineProperty(ret, key, {\n      enumerable: true,\n      configurable: true,\n      get: () => instance.props[key],\n    })\n  }\n\n  // retrieve default exposed value\n  if (Object.keys(localExpose).length > 0) {\n    for (const key in localExpose) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => localExpose![key],\n      })\n    }\n  }\n\n  // retrieve original first root element\n  Object.defineProperty(ret, '$el', {\n    enumerable: true,\n    configurable: true,\n    get: () => instance.vnode.el,\n  })\n  instance.exposed = ret\n\n  function forwardRef(ref: Element | T | null) {\n    currentRef.value = ref\n\n    if (!ref)\n      return\n\n    // retrieve the forwarded element\n    Object.defineProperty(ret, '$el', {\n      enumerable: true,\n      configurable: true,\n      get: () => (ref instanceof Element ? ref : ref.$el),\n    })\n\n    instance.exposed = ret\n  }\n\n  return { forwardRef, currentRef, currentElement }\n}\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue, DataOrientation, Direction, SingleOrMultipleProps, SingleOrMultipleType } from '@/shared/types'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\nexport interface AccordionRootProps<T = string | string[]>\n  extends PrimitiveProps, SingleOrMultipleProps<T> {\n  /**\n   * When type is \"single\", allows closing content when clicking trigger for an open item.\n   * When type is \"multiple\", this prop has no effect.\n   *\n   * @defaultValue false\n   */\n  collapsible?: boolean\n\n  /**\n   * When `true`, prevents the user from interacting with the accordion and all its items\n   *\n   * @defaultValue false\n   */\n  disabled?: boolean\n\n  /**\n   * The reading direction of the accordion when applicable. If omitted, assumes LTR (left-to-right) reading mode.\n   *\n   * @defaultValue \"ltr\"\n   */\n  dir?: Direction\n\n  /**\n   * The orientation of the accordion.\n   *\n   * @defaultValue \"vertical\"\n   */\n  orientation?: DataOrientation\n\n  /**\n   * When `true`, the element will be unmounted on closed state.\n   *\n   * @defaultValue `true`\n   */\n  unmountOnHide?: boolean\n}\n\nexport type AccordionRootEmits<T extends SingleOrMultipleType = SingleOrMultipleType> = {\n  /**\n   * Event handler called when the expanded state of an item changes\n   */\n  'update:modelValue': [value: (T extends 'single' ? string : string[]) | undefined]\n}\n\nexport type AccordionRootContext<P extends AccordionRootProps> = {\n  disabled: Ref<P['disabled']>\n  direction: Ref<P['dir']>\n  orientation: P['orientation']\n  parentElement: Ref<HTMLElement | undefined>\n  changeModelValue: (value: string) => void\n  isSingle: ComputedRef<boolean>\n  modelValue: Ref<AcceptableValue | AcceptableValue[] | undefined>\n  collapsible: boolean\n  unmountOnHide: Ref<boolean>\n}\n\nexport const [injectAccordionRootContext, provideAccordionRootContext]\n  = createContext<AccordionRootContext<AccordionRootProps>>('AccordionRoot')\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends (string | string[]), ExplicitType extends SingleOrMultipleType\">\nimport { toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useSingleOrMultipleValue } from '@/shared/useSingleOrMultipleValue'\n\nconst props = withDefaults(defineProps<AccordionRootProps<T>>(), {\n  disabled: false,\n  orientation: 'vertical',\n  collapsible: false,\n  unmountOnHide: true,\n})\n\nconst emits = defineEmits<AccordionRootEmits<ExplicitType>>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current active value */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { dir, disabled, unmountOnHide } = toRefs(props)\nconst direction = useDirection(dir)\n\nconst { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props, emits)\n\nconst { forwardRef, currentElement: parentElement } = useForwardExpose()\n\nprovideAccordionRootContext({\n  disabled,\n  direction,\n  orientation: props.orientation,\n  parentElement,\n  isSingle,\n  collapsible: props.collapsible,\n  modelValue,\n  changeModelValue,\n  unmountOnHide,\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n  >\n    <slot :model-value=\"modelValue\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { toRefs } from 'vue'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface CollapsibleRootProps extends PrimitiveProps {\n  /** The open state of the collapsible when it is initially rendered. <br> Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n  /** The controlled open state of the collapsible. Can be binded with `v-model`. */\n  open?: boolean\n  /** When `true`, prevents the user from interacting with the collapsible. */\n  disabled?: boolean\n  /** When `true`, the element will be unmounted on closed state. */\n  unmountOnHide?: boolean\n}\n\nexport type CollapsibleRootEmits = {\n  /** Event handler called when the open state of the collapsible changes. */\n  'update:open': [value: boolean]\n}\n\ninterface CollapsibleRootContext {\n  contentId: string\n  disabled?: Ref<boolean>\n  open: Ref<boolean>\n  unmountOnHide: Ref<boolean>\n  onOpenToggle: () => void\n}\n\nexport const [injectCollapsibleRootContext, provideCollapsibleRootContext]\n  = createContext<CollapsibleRootContext>('CollapsibleRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CollapsibleRootProps>(), {\n  open: undefined,\n  defaultOpen: false,\n  unmountOnHide: true,\n})\n\nconst emit = defineEmits<CollapsibleRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst { disabled, unmountOnHide } = toRefs(props)\n\nprovideCollapsibleRootContext({\n  contentId: '',\n  disabled,\n  open,\n  unmountOnHide,\n  onOpenToggle: () => {\n    if (disabled.value)\n      return\n\n    open.value = !open.value\n  },\n})\n\ndefineExpose({ open })\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"props.asChild\"\n    :data-state=\"open ? 'open' : 'closed'\"\n    :data-disabled=\"disabled ? '' : undefined\"\n  >\n    <slot :open=\"open\" />\n  </Primitive>\n</template>\n", "import type { Direction } from './types'\n\ntype ArrowKeyOptions = 'horizontal' | 'vertical' | 'both'\n\ninterface ArrowNavigationOptions {\n  /**\n   * The arrow key options to allow navigation\n   *\n   * @defaultValue \"both\"\n   */\n  arrowKeyOptions?: ArrowKeyOptions\n\n  /**\n   * The attribute name to find the collection items in the parent element.\n   *\n   * @defaultValue \"data-reka-collection-item\"\n   */\n  attributeName?: string\n\n  /**\n   * The parent element where contains all the collection items, this will collect every item to be used when nav\n   * It will be ignored if attributeName is provided\n   *\n   * @defaultValue []\n   */\n  itemsArray?: HTMLElement[]\n\n  /**\n   * Allow loop navigation. If false, it will stop at the first and last element\n   *\n   * @defaultValue true\n   */\n  loop?: boolean\n\n  /**\n   * The orientation of the collection\n   *\n   * @defaultValue \"ltr\"\n   */\n  dir?: Direction\n\n  /**\n   * Prevent the scroll when navigating. This happens when the direction of the\n   * key matches the scroll direction of any ancestor scrollable elements.\n   *\n   * @defaultValue true\n   */\n  preventScroll?: boolean\n\n  /**\n   * By default all currentElement would trigger navigation. If `true`, currentElement nodeName in the ignore list will return null\n   *\n   * @defaultValue false\n   */\n  enableIgnoredElement?: boolean\n\n  /**\n   * Focus the element after navigation\n   *\n   * @defaultValue false\n   */\n  focus?: boolean\n}\n\nconst ignoredElement = ['INPUT', 'TEXTAREA']\n\n/**\n * Allow arrow navigation for every html element with data-reka-collection-item tag\n *\n * @param e               Keyboard event\n * @param currentElement  Event initiator element or any element that wants to handle the navigation\n * @param parentElement   Parent element where contains all the collection items, this will collect every item to be used when nav\n * @param options         further options\n * @returns               the navigated html element or null if none\n */\nexport function useArrowNavigation(\n  e: KeyboardEvent,\n  currentElement: HTMLElement,\n  parentElement: HTMLElement | undefined,\n  options: ArrowNavigationOptions = {},\n): HTMLElement | null {\n  if (!currentElement || (options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)))\n    return null\n\n  const {\n    arrowKeyOptions = 'both',\n    attributeName = '[data-reka-collection-item]',\n    itemsArray = [],\n    loop = true,\n    dir = 'ltr',\n    preventScroll = true,\n    focus = false,\n  } = options\n\n  const [right, left, up, down, home, end] = [\n    e.key === 'ArrowRight',\n    e.key === 'ArrowLeft',\n    e.key === 'ArrowUp',\n    e.key === 'ArrowDown',\n    e.key === 'Home',\n    e.key === 'End',\n  ]\n  const goingVertical = up || down\n  const goingHorizontal = right || left\n  if (\n    !home\n    && !end\n    && ((!goingVertical && !goingHorizontal)\n      || (arrowKeyOptions === 'vertical' && goingHorizontal)\n      || (arrowKeyOptions === 'horizontal' && goingVertical))\n  ) {\n    return null\n  }\n\n  const allCollectionItems: HTMLElement[] = parentElement\n    ? Array.from(parentElement.querySelectorAll(attributeName))\n    : itemsArray\n\n  if (!allCollectionItems.length)\n    return null\n\n  if (preventScroll)\n    e.preventDefault()\n\n  let item: HTMLElement | null = null\n\n  if (goingHorizontal || goingVertical) {\n    const goForward = goingVertical ? down : dir === 'ltr' ? right : left\n    item = findNextFocusableElement(allCollectionItems, currentElement, {\n      goForward,\n      loop,\n    })\n  }\n  else if (home) {\n    item = allCollectionItems.at(0) || null\n  }\n  else if (end) {\n    item = allCollectionItems.at(-1) || null\n  }\n\n  if (focus)\n    item?.focus()\n\n  return item\n}\n\ninterface FindNextFocusableElementOptions {\n  /**\n   * Whether to search forwards or backwards.\n   */\n  goForward: boolean\n  /**\n   * Whether to allow looping the search. If false, it will stop at the first/last element.\n   *\n   * @default true\n   */\n  loop?: boolean\n}\n\n/**\n * Recursive function to find the next focusable element to avoid disabled elements\n *\n * @param elements Elements to navigate\n * @param currentElement Current active element\n * @param options\n * @returns next focusable element\n */\nfunction findNextFocusableElement(\n  elements: HTMLElement[],\n  currentElement: HTMLElement,\n  options: FindNextFocusableElementOptions,\n  iterations = elements.length,\n): HTMLElement | null {\n  if (--iterations === 0)\n    return null\n\n  const index = elements.indexOf(currentElement)\n  const newIndex = options.goForward ? index + 1 : index - 1\n\n  if (!options.loop && (newIndex < 0 || newIndex >= elements.length))\n    return null\n\n  const adjustedNewIndex = (newIndex + elements.length) % elements.length\n  const candidate = elements[adjustedNewIndex]\n  if (!candidate)\n    return null\n\n  const isDisabled\n    = candidate.hasAttribute('disabled')\n      && candidate.getAttribute('disabled') !== 'false'\n  if (isDisabled) {\n    return findNextFocusableElement(\n      elements,\n      candidate,\n      options,\n      iterations,\n    )\n  }\n  return candidate\n}\n", "<script lang=\"ts\">\nimport type { ComputedRef, VNodeRef } from 'vue'\nimport type { CollapsibleRootProps } from '../Collapsible'\nimport { createContext, useArrowNavigation, useForwardExpose } from '@/shared'\nimport { injectAccordionRootContext } from './AccordionRoot.vue'\n\nenum AccordionItemState {\n  Open = 'open',\n  Closed = 'closed',\n}\n\nexport interface AccordionItemProps\n  extends Omit<CollapsibleRootProps, 'open' | 'defaultOpen' | 'onOpenChange'> {\n  /**\n   * Whether or not an accordion item is disabled from user interaction.\n   * When `true`, prevents the user from interacting with the item.\n   *\n   * @defaultValue false\n   */\n  disabled?: boolean\n  /**\n   * A string value for the accordion item. All items within an accordion should use a unique value.\n   */\n  value: string\n}\n\ninterface AccordionItemContext {\n  open: ComputedRef<boolean>\n  dataState: ComputedRef<AccordionItemState>\n  disabled: ComputedRef<boolean>\n  dataDisabled: ComputedRef<'' | undefined>\n  triggerId: string\n  currentRef: VNodeRef\n  currentElement: ComputedRef<HTMLElement | undefined>\n  value: ComputedRef<string>\n}\n\nexport const [injectAccordionItemContext, provideAccordionItemContext]\n  = createContext<AccordionItemContext>('AccordionItem')\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { CollapsibleRoot } from '@/Collapsible'\n\nconst props = defineProps<AccordionItemProps>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nconst rootContext = injectAccordionRootContext()\n\nconst open = computed(() =>\n  rootContext.isSingle.value\n    ? props.value === rootContext.modelValue.value\n    : Array.isArray(rootContext.modelValue.value)\n      && rootContext.modelValue.value.includes(props.value),\n)\n\nconst disabled = computed(() => {\n  return (rootContext.disabled.value || props.disabled)\n})\n\nconst dataDisabled = computed(() => (disabled.value ? '' : undefined))\n\nconst dataState = computed(() =>\n  open.value ? AccordionItemState.Open : AccordionItemState.Closed,\n)\n\ndefineExpose({ open, dataDisabled })\nconst { currentRef, currentElement } = useForwardExpose()\n\nprovideAccordionItemContext({\n  open,\n  dataState,\n  disabled,\n  dataDisabled,\n  triggerId: '',\n  currentRef,\n  currentElement,\n  value: computed(() => props.value),\n})\n\nfunction handleArrowKey(e: KeyboardEvent) {\n  const target = e.target as HTMLElement\n  const allCollectionItems: HTMLElement[] = Array.from(rootContext.parentElement.value?.querySelectorAll('[data-reka-collection-item]') ?? [])\n\n  const collectionItemIndex = allCollectionItems.findIndex(item => item === target)\n  if (collectionItemIndex === -1)\n    return null\n\n  useArrowNavigation(\n    e,\n    target,\n    rootContext.parentElement.value!,\n    {\n      arrowKeyOptions: rootContext.orientation,\n      dir: rootContext.direction.value,\n      focus: true,\n    },\n  )\n}\n</script>\n\n<template>\n  <CollapsibleRoot\n    :data-orientation=\"rootContext.orientation\"\n    :data-disabled=\"dataDisabled\"\n    :data-state=\"dataState\"\n    :disabled=\"disabled\"\n    :open=\"open\"\n    :as=\"props.as\"\n    :as-child=\"props.asChild\"\n    :unmount-on-hide=\"rootContext.unmountOnHide.value\"\n    @keydown.up.down.left.right.home.end=\"handleArrowKey\"\n  >\n    <slot :open=\"open\" />\n  </CollapsibleRoot>\n</template>\n", "import * as vue from 'vue'\n// Inspired from https://github.com/tailwindlabs/headlessui/issues/2913\n// as the alternative, and a fallback for Vue version < 3.5\nimport { injectConfigProviderContext } from '@/ConfigProvider/ConfigProvider.vue'\n\nlet count = 0\n/**\n * The `useId` function generates a unique identifier using a provided deterministic ID or a default\n * one prefixed with \"reka-\", or the provided one via `useId` props from `<ConfigProvider>`.\n * @param {string | null | undefined} [deterministicId] - The `useId` function you provided takes an\n * optional parameter `deterministicId`, which can be a string, null, or undefined. If\n * `deterministicId` is provided, the function will return it. Otherwise, it will generate an id using\n * the `useId` function obtained\n */\nexport function useId(deterministicId?: string | null | undefined, prefix = 'reka') {\n  if (deterministicId)\n    return deterministicId\n\n  const configProviderContext = injectConfigProviderContext({ useId: undefined })\n\n  if (Object.hasOwn(vue, 'useId')) {\n    return `${prefix}-${vue.useId?.()}`\n  }\n  else if (configProviderContext.useId) {\n    return `${prefix}-${configProviderContext.useId()}`\n  }\n\n  return `${prefix}-${++count}`\n}\n", "import type { Ref } from 'vue'\nimport { ref } from 'vue'\n\ninterface Machine<S> {\n  [k: string]: { [k: string]: S }\n}\ntype MachineState<T> = keyof T\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>\n\n//  https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (\n  x: infer R\n) => any\n  ? R\n  : never\n\n/**\n * The `useStateMachine` function is a TypeScript function that creates a state machine and returns the\n * current state and a dispatch function to update the state based on events.\n * @param initialState - The `initialState` parameter is the initial state of the state machine. It\n * represents the starting point of the state machine's state.\n * @param machine - The `machine` parameter is an object that represents a state machine. It should\n * have keys that correspond to the possible states of the machine, and the values should be objects\n * that represent the possible events and their corresponding next states.\n * @returns The `useStateMachine` function returns an object with two properties: `state` and\n * `dispatch`.\n */\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>,\n) {\n  const state = ref(initialState) as Ref<MachineState<M>>\n\n  function reducer(event: MachineEvent<M>) {\n    // @ts-expect-error  state.value is keyof M\n    const nextState = machine[state.value][event]\n    return nextState ?? state.value\n  }\n\n  const dispatch = (event: MachineEvent<M>) => {\n    state.value = reducer(event)\n  }\n\n  return {\n    state,\n    dispatch,\n  }\n}\n", "import type { Ref } from 'vue'\nimport { defaultWindow } from '@vueuse/core'\nimport { isClient } from '@vueuse/shared'\nimport { computed, nextTick, onUnmounted, ref, watch } from 'vue'\nimport { useStateMachine } from '@/shared'\n\nexport function usePresence(\n  present: Ref<boolean>,\n  node: Ref<HTMLElement | undefined>,\n) {\n  const stylesRef = ref<CSSStyleDeclaration>({} as any)\n  const prevAnimationNameRef = ref<string>('none')\n  const prevPresentRef = ref(present)\n  const initialState = present.value ? 'mounted' : 'unmounted'\n  let timeoutId: number | undefined\n  const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow\n\n  const { state, dispatch } = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  })\n\n  const dispatchCustomEvent = (name: 'enter' | 'after-enter' | 'leave' | 'after-leave') => {\n    // We only dispatch this event because CustomEvent is not available in Node18\n    // https://github.com/unovue/reka-ui/issues/930\n    if (isClient) {\n      const customEvent = new CustomEvent(name, { bubbles: false, cancelable: false })\n      node.value?.dispatchEvent(customEvent)\n    }\n  }\n\n  watch(\n    present,\n    async (currentPresent, prevPresent) => {\n      const hasPresentChanged = prevPresent !== currentPresent\n      await nextTick()\n      if (hasPresentChanged) {\n        const prevAnimationName = prevAnimationNameRef.value\n        const currentAnimationName = getAnimationName(node.value)\n\n        if (currentPresent) {\n          dispatch('MOUNT')\n          dispatchCustomEvent('enter')\n          if (currentAnimationName === 'none')\n            dispatchCustomEvent('after-enter')\n        }\n        else if (\n          currentAnimationName === 'none' || currentAnimationName === 'undefined'\n          || stylesRef.value?.display === 'none'\n        ) {\n          // If there is no exit animation or the element is hidden, animations won't run\n          // so we unmount instantly rv\n          dispatch('UNMOUNT')\n          dispatchCustomEvent('leave')\n          dispatchCustomEvent('after-leave')\n        }\n        else {\n          /**\n           * When `present` changes to `false`, we check changes to animation-name to\n           * determine whether an animation has started. We chose this approach (reading\n           * computed styles) because there is no `animationrun` event and `animationstart`\n           * fires after `animation-delay` has expired which would be too late.\n           */\n          const isAnimating = prevAnimationName !== currentAnimationName\n          if (prevPresent && isAnimating) {\n            dispatch('ANIMATION_OUT')\n            dispatchCustomEvent('leave')\n          }\n          else {\n            dispatch('UNMOUNT')\n            dispatchCustomEvent('after-leave')\n          }\n        }\n      }\n    },\n    { immediate: true },\n  )\n\n  /**\n   * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n   * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n   * make sure we only trigger ANIMATION_END for the currently active animation.\n   */\n  const handleAnimationEnd = (event: AnimationEvent) => {\n    const currentAnimationName = getAnimationName(node.value)\n    const isCurrentAnimation = currentAnimationName.includes(\n      event.animationName,\n    )\n    const directionName = state.value === 'mounted' ? 'enter' : 'leave'\n    if (event.target === node.value && isCurrentAnimation) {\n      dispatchCustomEvent(`after-${directionName}`)\n      dispatch('ANIMATION_END')\n\n      if (!prevPresentRef.value) {\n        const currentFillMode = node.value.style.animationFillMode\n        node.value.style.animationFillMode = 'forwards'\n        // Reset the style after the node had time to unmount (for cases\n        // where the component chooses not to unmount). Doing this any\n        // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n        // still causes a flash.\n        timeoutId = ownerWindow?.setTimeout(() => {\n          if (node.value?.style.animationFillMode === 'forwards') {\n            node.value.style.animationFillMode = currentFillMode\n          }\n        })\n      }\n    }\n    // if no animation, immediately trigger 'ANIMATION_END'\n    if (event.target === node.value && currentAnimationName === 'none')\n      dispatch('ANIMATION_END')\n  }\n  const handleAnimationStart = (event: AnimationEvent) => {\n    if (event.target === node.value) {\n      // if animation occurred, store its name as the previous animation.\n      prevAnimationNameRef.value = getAnimationName(node.value)\n    }\n  }\n\n  const watcher = watch(\n    node,\n    (newNode, oldNode) => {\n      if (newNode) {\n        stylesRef.value = getComputedStyle(newNode)\n        newNode.addEventListener('animationstart', handleAnimationStart)\n        newNode.addEventListener('animationcancel', handleAnimationEnd)\n        newNode.addEventListener('animationend', handleAnimationEnd)\n      }\n      else {\n        // Transition to the unmounted state if the node is removed prematurely.\n        // We avoid doing so during cleanup as the node may change but still exist.\n        dispatch('ANIMATION_END')\n\n        if (timeoutId !== undefined)\n          ownerWindow?.clearTimeout(timeoutId)\n        oldNode?.removeEventListener('animationstart', handleAnimationStart)\n        oldNode?.removeEventListener('animationcancel', handleAnimationEnd)\n        oldNode?.removeEventListener('animationend', handleAnimationEnd)\n      }\n    },\n    { immediate: true },\n  )\n\n  const stateWatcher = watch(state, () => {\n    const currentAnimationName = getAnimationName(node.value)\n    prevAnimationNameRef.value\n      = state.value === 'mounted' ? currentAnimationName : 'none'\n  })\n\n  onUnmounted(() => {\n    watcher()\n    stateWatcher()\n  })\n\n  const isPresent = computed(() =>\n    ['mounted', 'unmountSuspended'].includes(state.value),\n  )\n\n  return {\n    isPresent,\n  }\n}\n\nfunction getAnimationName(node?: HTMLElement) {\n  return node ? getComputedStyle(node).animationName || 'none' : 'none'\n}\n", "import type {\n  SlotsType,\n  VNode,\n} from 'vue'\nimport { unrefElement } from '@vueuse/core'\nimport {\n  defineComponent,\n  getCurrentInstance,\n  h,\n  ref,\n  toRefs,\n} from 'vue'\nimport { renderSlotFragments } from '@/shared'\nimport { usePresence } from './usePresence'\n\nexport interface PresenceProps {\n  /**\n   * Conditional to mount or unmount the child element. Similar to `v-if`\n   *\n   * @required true\n   */\n  present: boolean\n  /**\n   * Force the element to render all the time.\n   *\n   * Useful for programmatically render grandchild component with the exposed `present`\n   *\n   * @defaultValue false\n   */\n  forceMount?: boolean\n}\n\nexport default defineComponent({\n  name: 'Presence',\n  props: {\n    present: {\n      type: Boolean,\n      required: true,\n    },\n    forceMount: {\n      type: Boolean,\n    },\n  },\n  slots: {} as SlotsType<{\n    default: (opts: { present: boolean }) => any\n  }>,\n  setup(props, { slots, expose }) {\n    const { present, forceMount } = toRefs(props)\n\n    const node = ref<HTMLElement>()\n    // Mount composables once to prevent duplicated eventListener\n    const { isPresent } = usePresence(present, node)\n    expose({ present: isPresent })\n\n    let children = slots.default({ present: isPresent.value })\n    children = renderSlotFragments(children || [])\n    const instance = getCurrentInstance()\n\n    if (children && children?.length > 1) {\n      const componentName = instance?.parent?.type.name\n        ? `<${instance.parent.type.name} />`\n        : 'component'\n\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${componentName}\\` for  \\`Presence\\` component.`,\n          '',\n          'Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.',\n          'You can apply a few solutions:',\n          [\n            'Provide a single child element so that `presence` directive attach correctly.',\n            'Ensure the first child is an actual element instead of a raw text node or comment node.',\n          ]\n            .map(line => `  - ${line}`)\n            .join('\\n'),\n        ].join('\\n'),\n      )\n    }\n\n    return () => {\n      if (forceMount.value || present.value || isPresent.value) {\n        return h(slots.default({ present: isPresent.value })[0] as VNode, {\n          ref: (v) => {\n            const el = unrefElement(v as HTMLElement)\n            if (typeof el?.hasAttribute === 'undefined')\n              return el\n\n            // special case to handle animation for PopperContent\n            if (el?.hasAttribute('data-reka-popper-content-wrapper'))\n              node.value = el.firstElementChild as HTMLElement\n            else\n              node.value = el\n\n            return el\n          },\n        })\n      }\n      else { return null }\n    }\n  },\n})\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CollapsibleContentProps extends PrimitiveProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n\nexport type CollapsibleContentEmits = {\n  contentFound: [void]\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useEventListener } from '@vueuse/core'\nimport { computed, nextTick, onMounted, ref, watch } from 'vue'\nimport { Presence } from '@/Presence'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { useForwardExpose, useId } from '@/shared'\nimport { injectCollapsibleRootContext } from './CollapsibleRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<CollapsibleContentProps>()\nconst emits = defineEmits<CollapsibleContentEmits>()\n\nconst rootContext = injectCollapsibleRootContext()\nrootContext.contentId ||= useId(undefined, 'reka-collapsible-content')\n\nconst presentRef = ref<InstanceType<typeof Presence>>()\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst width = ref(0)\nconst height = ref(0)\n\n// when opening we want it to immediately open to retrieve dimensions\n// when closing we delay `present` to retrieve dimensions before closing\nconst isOpen = computed(() => rootContext.open.value)\nconst isMountAnimationPrevented = ref(isOpen.value)\nconst currentStyle = ref<Record<string, string>>()\n\nwatch(\n  () => [isOpen.value, presentRef.value?.present],\n  async () => {\n    await nextTick()\n    const node = currentElement.value\n    if (!node)\n      return\n    currentStyle.value = currentStyle.value || {\n      transitionDuration: node.style.transitionDuration,\n      animationName: node.style.animationName,\n    }\n    // block any animations/transitions so the element renders at its full dimensions\n    node.style.transitionDuration = '0s'\n    node.style.animationName = 'none'\n\n    // get width and height from full dimensions\n    const rect = node.getBoundingClientRect()\n    height.value = rect.height\n    width.value = rect.width\n\n    // kick off any animations/transitions that were originally set up if it isn't the initial mount\n    if (!isMountAnimationPrevented.value) {\n      node.style.transitionDuration = currentStyle.value.transitionDuration\n      node.style.animationName = currentStyle.value.animationName\n    }\n  },\n  {\n    immediate: true,\n  },\n)\n\nconst skipAnimation = computed(() => isMountAnimationPrevented.value && rootContext.open.value)\n\nonMounted(() => {\n  requestAnimationFrame(() => {\n    isMountAnimationPrevented.value = false\n  })\n})\n\nuseEventListener(currentElement, 'beforematch', (ev) => {\n  requestAnimationFrame(() => {\n    rootContext.onOpenToggle()\n    emits('contentFound')\n  })\n})\n</script>\n\n<template>\n  <Presence\n    v-slot=\"{ present }\"\n    ref=\"presentRef\"\n    :present=\"forceMount || rootContext.open.value\"\n    :force-mount=\"true\"\n  >\n    <Primitive\n      v-bind=\"$attrs\"\n      :id=\"rootContext.contentId\"\n      :ref=\"forwardRef\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n      :hidden=\"!present ? rootContext.unmountOnHide.value ? '' : 'until-found' : undefined\"\n      :data-state=\"skipAnimation ? undefined : rootContext.open.value ? 'open' : 'closed'\"\n      :data-disabled=\"rootContext.disabled?.value ? '' : undefined\"\n      :style=\"{\n        [`--reka-collapsible-content-height`]: `${height}px`,\n        [`--reka-collapsible-content-width`]: `${width}px`,\n      }\"\n    >\n      <slot v-if=\"rootContext.unmountOnHide.value ? present : true\" />\n    </Primitive>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { CollapsibleContentProps } from '../Collapsible'\n\nexport interface AccordionContentProps extends CollapsibleContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { useForwardExpose } from '@/shared'\nimport { CollapsibleContent } from '../Collapsible'\nimport { injectAccordionItemContext } from './AccordionItem.vue'\nimport { injectAccordionRootContext } from './AccordionRoot.vue'\n\nconst props = defineProps<AccordionContentProps>()\n\nconst rootContext = injectAccordionRootContext()\nconst itemContext = injectAccordionItemContext()\n\nuseForwardExpose()\n</script>\n\n<template>\n  <CollapsibleContent\n    role=\"region\"\n    :as-child=\"props.asChild\"\n    :as=\"as\"\n    :force-mount=\"props.forceMount\"\n    :aria-labelledby=\"itemContext.triggerId\"\n    :data-state=\"itemContext.dataState.value\"\n    :data-disabled=\"itemContext.dataDisabled.value\"\n    :data-orientation=\"rootContext.orientation\"\n    style=\"\n      --reka-accordion-content-width: var(--reka-collapsible-content-width);\n      --reka-accordion-content-height: var(--reka-collapsible-content-height);\n    \"\n    @content-found=\"rootContext.changeModelValue(itemContext.value.value)\"\n  >\n    <slot />\n  </CollapsibleContent>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface AccordionHeaderProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectAccordionItemContext } from './AccordionItem.vue'\nimport { injectAccordionRootContext } from './AccordionRoot.vue'\n\nconst props = withDefaults(defineProps<AccordionHeaderProps>(), {\n  as: 'h3',\n})\n\nconst rootContext = injectAccordionRootContext()\nconst itemContext = injectAccordionItemContext()\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    :as=\"props.as\"\n    :as-child=\"props.asChild\"\n    :data-orientation=\"rootContext.orientation\"\n    :data-state=\"itemContext.dataState.value\"\n    :data-disabled=\"itemContext.dataDisabled.value\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface CollapsibleTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectCollapsibleRootContext } from './CollapsibleRoot.vue'\n\nconst props = withDefaults(defineProps<CollapsibleTriggerProps>(), {\n  as: 'button',\n})\n\nuseForwardExpose()\nconst rootContext = injectCollapsibleRootContext()\n</script>\n\n<template>\n  <Primitive\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :as=\"as\"\n    :as-child=\"props.asChild\"\n    :aria-controls=\"rootContext.contentId\"\n    :aria-expanded=\"rootContext.open.value\"\n    :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n    :data-disabled=\"rootContext.disabled?.value ? '' : undefined\"\n    :disabled=\"rootContext.disabled?.value\"\n    @click=\"rootContext.onOpenToggle\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface AccordionTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { CollapsibleTrigger } from '@/Collapsible'\nimport { useId } from '@/shared'\nimport { injectAccordionItemContext } from './AccordionItem.vue'\n\nimport { injectAccordionRootContext } from './AccordionRoot.vue'\n\nconst props = defineProps<AccordionTriggerProps>()\n\nconst rootContext = injectAccordionRootContext()\nconst itemContext = injectAccordionItemContext()\n\nitemContext.triggerId ||= useId(undefined, 'reka-accordion-trigger')\nfunction changeItem() {\n  const triggerDisabled = rootContext.isSingle.value && itemContext.open.value && !rootContext.collapsible\n  if (itemContext.disabled.value || triggerDisabled)\n    return\n\n  rootContext.changeModelValue(itemContext.value.value)\n}\n</script>\n\n<template>\n  <CollapsibleTrigger\n    :id=\"itemContext.triggerId\"\n    :ref=\"itemContext.currentRef\"\n    data-reka-collection-item\n    :as=\"props.as\"\n    :as-child=\"props.asChild\"\n    :aria-disabled=\"itemContext.disabled.value || undefined\"\n    :aria-expanded=\"itemContext.open.value || false\"\n    :data-disabled=\"itemContext.dataDisabled.value\"\n    :data-orientation=\"rootContext.orientation\"\n    :data-state=\"itemContext.dataState.value\"\n    :disabled=\"itemContext.disabled.value\"\n    @click=\"changeItem\"\n  >\n    <slot />\n  </CollapsibleTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { createContext } from '@/shared'\n\nexport interface DialogRootProps {\n  /** The controlled open state of the dialog. Can be binded as `v-model:open`. */\n  open?: boolean\n  /** The open state of the dialog when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n  /**\n   * The modality of the dialog When set to `true`, <br>\n   * interaction with outside elements will be disabled and only dialog content will be visible to screen readers.\n   */\n  modal?: boolean\n}\n\nexport type DialogRootEmits = {\n  /** Event handler called when the open state of the dialog changes. */\n  'update:open': [value: boolean]\n}\n\nexport interface DialogRootContext {\n  open: Readonly<Ref<boolean>>\n  modal: Ref<boolean>\n  openModal: () => void\n  onOpenChange: (value: boolean) => void\n  onOpenToggle: () => void\n  triggerElement: Ref<HTMLElement | undefined>\n  contentElement: Ref<HTMLElement | undefined>\n  contentId: string\n  titleId: string\n  descriptionId: string\n}\n\nexport const [injectDialogRootContext, provideDialogRootContext]\n  = createContext<DialogRootContext>('DialogRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<DialogRootProps>(), {\n  open: undefined,\n  defaultOpen: false,\n  modal: true,\n})\nconst emit = defineEmits<DialogRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n    /** Close the dialog */\n    close: () => void\n  }) => any\n}>()\n\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst triggerElement = ref<HTMLElement>()\nconst contentElement = ref<HTMLElement>()\nconst { modal } = toRefs(props)\n\nprovideDialogRootContext({\n  open,\n  modal,\n  openModal: () => {\n    open.value = true\n  },\n  onOpenChange: (value) => {\n    open.value = value\n  },\n  onOpenToggle: () => {\n    open.value = !open.value\n  },\n  contentId: '',\n  titleId: '',\n  descriptionId: '',\n  triggerElement,\n  contentElement,\n})\n</script>\n\n<template>\n  <slot\n    :open=\"open\"\n    :close=\"() => open = false\"\n  />\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface DialogCloseProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = withDefaults(defineProps<DialogCloseProps>(), {\n  as: 'button',\n})\n\nuseForwardExpose()\nconst rootContext = injectDialogRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    @click=\"rootContext.onOpenChange(false)\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogCloseProps } from '@/Dialog'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AlertDialogActionProps extends DialogCloseProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { DialogClose } from '@/Dialog'\n\nconst props = withDefaults(defineProps<AlertDialogActionProps>(), { as: 'button' })\nuseForwardExpose()\n</script>\n\n<template>\n  <DialogClose v-bind=\"props\">\n    <slot />\n  </DialogClose>\n</template>\n", "import { camelize, getCurrentInstance, toHandlerKey } from 'vue'\n\n// Vue doesn't have emits forwarding, in order to bind the emits we have to convert events into `onXXX` handlers\n// issue: https://github.com/vuejs/core/issues/5917\n/**\n * The `useEmitAsProps` function is a TypeScript utility that converts emitted events into props for a\n * Vue component.\n * @param emit - The `emit` parameter is a function that is used to emit events from a component. It\n * takes two parameters: `name` which is the name of the event to be emitted, and `...args` which are\n * the arguments to be passed along with the event.\n * @returns The function `useEmitAsProps` returns an object that maps event names to functions that\n * call the `emit` function with the corresponding event name and arguments.\n */\nexport function useEmitAsProps<Name extends string>(\n  emit: (name: Name, ...args: any[]) => void,\n) {\n  const vm = getCurrentInstance()\n\n  const events = vm?.type.emits as Name[]\n  const result: Record<string, any> = {}\n\n  if (!events?.length) {\n    console.warn(\n      `No emitted event found. Please check component: ${vm?.type.__name}`,\n    )\n  }\n\n  events?.forEach((ev) => {\n    result[toHandlerKey(camelize(ev))] = (...arg: any) => emit(ev, ...arg)\n  })\n  return result\n}\n", "export function getActiveElement(): Element | null {\r\n  let activeElement = document.activeElement\r\n  if (activeElement == null) {\r\n    return null\r\n  }\r\n\r\n  while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) {\r\n    activeElement = activeElement.shadowRoot.activeElement\r\n  }\r\n\r\n  return activeElement\r\n}\r\n", "import { getActiveElement } from '@/shared'\n\nexport type CheckedState = boolean | 'indeterminate'\nexport type Direction = 'ltr' | 'rtl'\n\nexport const ITEM_NAME = 'MenuItem'\nexport const ITEM_SELECT = 'menu.itemSelect'\nexport const SELECTION_KEYS = ['Enter', ' ']\nexport const FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home']\nexport const LAST_KEYS = ['ArrowUp', 'PageDown', 'End']\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS]\nexport const SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n}\nexport const SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n}\n\nexport function getOpenState(open: boolean) {\n  return open ? 'open' : 'closed'\n}\n\nexport function isIndeterminate(\n  checked?: CheckedState,\n): checked is 'indeterminate' {\n  return checked === 'indeterminate'\n}\n\nexport function getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked)\n    ? 'indeterminate'\n    : checked\n      ? 'checked'\n      : 'unchecked'\n}\n\nexport function focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement()\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return\n    candidate.focus()\n    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return\n  }\n}\n\nexport interface Point {\n  x: number\n  y: number\n}\nexport type Polygon = Point[]\nexport type Side = 'left' | 'right'\nexport interface GraceIntent {\n  area: Polygon\n  side: Side\n}\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nexport function isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point\n  let inside = false\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n    if (intersect)\n      inside = !inside\n  }\n\n  return inside\n}\n\nexport function isPointerInGraceArea(event: PointerEvent, area?: Polygon) {\n  if (!area)\n    return false\n  const cursorPos = { x: event.clientX, y: event.clientY }\n  return isPointInPolygon(cursorPos, area)\n}\n\nexport function isMouseEvent(event: PointerEvent) {\n  return event.pointerType === 'mouse'\n}\n", "import type { Ref } from 'vue'\nimport { onMounted } from 'vue'\n\nconst DEFAULT_TITLE_NAME = 'DialogTitle'\nconst DEFAULT_CONTENT_NAME = 'DialogContent'\n\nexport type WarningProps = {\n  titleName?: string\n  contentName?: string\n  componentLink?: string\n  titleId: string\n  descriptionId: string\n  contentElement: Ref<HTMLElement | undefined>\n}\n\nexport function useWarning({\n  titleName = DEFAULT_TITLE_NAME,\n  contentName = DEFAULT_CONTENT_NAME,\n  componentLink = 'dialog.html#title',\n  titleId,\n  descriptionId,\n  contentElement,\n}: WarningProps) {\n  const TITLE_MESSAGE = `Warning: \\`${contentName}\\` requires a \\`${titleName}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${titleName}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.reka-ui.com/docs/components/${componentLink}`\n\n  const DESCRIPTION_MESSAGE = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${contentName}.`\n\n  onMounted(() => {\n    const hasTitle = document.getElementById(titleId)\n    if (!hasTitle)\n      console.warn(TITLE_MESSAGE)\n\n    const describedById = contentElement.value?.getAttribute('aria-describedby')\n    // if we have an id and the user hasn't set aria-describedby=\"undefined\"\n    if (descriptionId && describedById) {\n      const hasDescription = document.getElementById(descriptionId)\n      if (!hasDescription)\n        console.warn(DESCRIPTION_MESSAGE)\n    }\n  })\n}\n", "import { createGlobalState } from '@vueuse/core'\nimport { ref } from 'vue'\n\ninterface FocusScopeAPI {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nconst useFocusStackState = createGlobalState(() => {\n  const stack = ref<FocusScopeAPI[]>([])\n  return stack\n})\n\nexport function createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  const stack = useFocusStackState()\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack.value[0]\n      if (focusScope !== activeFocusScope)\n        activeFocusScope?.pause()\n\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack.value = arrayRemove(stack.value, focusScope)\n      stack.value.unshift(focusScope)\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack.value = arrayRemove(stack.value, focusScope)\n      stack.value[0]?.resume()\n    },\n  }\n}\n\nexport function arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array]\n  const index = updatedArray.indexOf(item)\n  if (index !== -1)\n    updatedArray.splice(index, 1)\n\n  return updatedArray\n}\n\nexport function removeLinks(items: HTMLElement[]) {\n  return items.filter(item => item.tagName !== 'A')\n}\n", "import { getActiveElement } from '@/shared'\n\nexport const AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount'\nexport const AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount'\nexport const EVENT_OPTIONS = { bubbles: false, cancelable: true }\n\ntype FocusableTarget = HTMLElement | { focus: () => void }\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nexport function focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = getActiveElement()\n  for (const candidate of candidates) {\n    focus(candidate, { select })\n    if (getActiveElement() !== previouslyFocusedElement)\n      return true\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nexport function getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container)\n  const first = findVisible(candidates, container)\n  const last = findVisible(candidates.reverse(), container)\n  return [first, last] as const\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nexport function getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nexport function findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container }))\n      return element\n  }\n}\n\nexport function isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden')\n    return true\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo)\n      return false\n    if (getComputedStyle(node).display === 'none')\n      return true\n    node = node.parentElement as HTMLElement\n  }\n  return false\n}\n\nexport function isSelectableInput(\n  element: any,\n): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport function focus(\n  element?: FocusableTarget | null,\n  { select = false } = {},\n) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = getActiveElement()\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true })\n    // only select if its not the same element, it supports selection and we need to select\n    if (\n      element !== previouslyFocusedElement\n      && isSelectableInput(element)\n      && select\n    ) {\n      element.select()\n    }\n  }\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { getActiveElement, useForwardExpose } from '@/shared'\n\nexport type FocusScopeEmits = {\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  mountAutoFocus: [event: Event]\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  unmountAutoFocus: [event: Event]\n}\n\nexport interface FocusScopeProps extends PrimitiveProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { isClient } from '@vueuse/shared'\nimport { nextTick, reactive, ref, watchEffect } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { createFocusScopesStack, removeLinks } from './stack'\nimport {\n  AUTOFOCUS_ON_MOUNT,\n  AUTOFOCUS_ON_UNMOUNT,\n  EVENT_OPTIONS,\n  focus,\n  focusFirst,\n  getTabbableCandidates,\n  getTabbableEdges,\n} from './utils'\n\nconst props = withDefaults(defineProps<FocusScopeProps>(), {\n  loop: false,\n  trapped: false,\n})\nconst emits = defineEmits<FocusScopeEmits>()\n\nconst { currentRef, currentElement } = useForwardExpose()\nconst lastFocusedElementRef = ref<HTMLElement | null>(null)\nconst focusScopesStack = createFocusScopesStack()\n\nconst focusScope = reactive({\n  paused: false,\n  pause() {\n    this.paused = true\n  },\n  resume() {\n    this.paused = false\n  },\n})\n\nwatchEffect((cleanupFn) => {\n  if (!isClient)\n    return\n  const container = currentElement.value\n  if (!props.trapped)\n    return\n\n  function handleFocusIn(event: FocusEvent) {\n    if (focusScope.paused || !container)\n      return\n    const target = event.target as HTMLElement | null\n    if (container.contains(target))\n      lastFocusedElementRef.value = target\n    else focus(lastFocusedElementRef.value, { select: true })\n  }\n\n  function handleFocusOut(event: FocusEvent) {\n    if (focusScope.paused || !container)\n      return\n    const relatedTarget = event.relatedTarget as HTMLElement | null\n\n    // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n    //\n    // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n    // 2. In Google Chrome, when the focused element is removed from the DOM.\n    //\n    // We let the browser do its thing here because:\n    //\n    // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n    // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n    //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n    if (relatedTarget === null)\n      return\n\n    // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n    // that is outside the container, we move focus to the last valid focused element inside.\n    if (!container.contains(relatedTarget))\n      focus(lastFocusedElementRef.value, { select: true })\n  }\n\n  // When the focused element gets removed from the DOM, browsers move focus\n  // back to the document.body. In this case, we move focus to the container\n  // to keep focus trapped correctly.\n  // -- related: https://github.com/unovue/reka-ui/issues/518\n  // Reka UI tentative solution:\n  // instead of leaning on document.activeElement, we use lastFocusedElementRef.value to check\n  // if the element still exist inside the container,\n  // if not then we focus to the container\n  function handleMutations(mutations: MutationRecord[]) {\n    const isLastFocusedElementExist = container.contains(lastFocusedElementRef.value)\n    if (!isLastFocusedElementExist)\n      focus(container)\n  }\n\n  document.addEventListener('focusin', handleFocusIn)\n  document.addEventListener('focusout', handleFocusOut)\n  const mutationObserver = new MutationObserver(handleMutations)\n  if (container)\n    mutationObserver.observe(container, { childList: true, subtree: true })\n\n  cleanupFn(() => {\n    document.removeEventListener('focusin', handleFocusIn)\n    document.removeEventListener('focusout', handleFocusOut)\n    mutationObserver.disconnect()\n  })\n})\n\nwatchEffect(async (cleanupFn) => {\n  const container = currentElement.value\n\n  await nextTick()\n  if (!container)\n    return\n  focusScopesStack.add(focusScope)\n  const previouslyFocusedElement = getActiveElement() as HTMLElement | null\n  const hasFocusedCandidate = container.contains(previouslyFocusedElement)\n\n  if (!hasFocusedCandidate) {\n    const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS)\n    container.addEventListener(AUTOFOCUS_ON_MOUNT, (ev: Event) =>\n      emits('mountAutoFocus', ev))\n    container.dispatchEvent(mountEvent)\n\n    if (!mountEvent.defaultPrevented) {\n      focusFirst(removeLinks(getTabbableCandidates(container)), {\n        select: true,\n      })\n      if (getActiveElement() === previouslyFocusedElement)\n        focus(container)\n    }\n  }\n\n  cleanupFn(() => {\n    container.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev: Event) =>\n      emits('mountAutoFocus', ev))\n\n    const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS)\n    const unmountEventHandler = (ev: Event) => {\n      emits('unmountAutoFocus', ev)\n    }\n    container.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler)\n    container.dispatchEvent(unmountEvent)\n\n    setTimeout(() => {\n      if (!unmountEvent.defaultPrevented)\n        focus(previouslyFocusedElement ?? document.body, { select: true })\n\n      // we need to remove the listener after we `dispatchEvent`\n      container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler)\n\n      focusScopesStack.remove(focusScope)\n    }, 0)\n  })\n})\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  if (!props.loop && !props.trapped)\n    return\n  if (focusScope.paused)\n    return\n\n  const isTabKey\n    = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey\n  const focusedElement = getActiveElement() as HTMLElement | null\n\n  if (isTabKey && focusedElement) {\n    const container = event.currentTarget as HTMLElement\n    const [first, last] = getTabbableEdges(container)\n    const hasTabbableElementsInside = first && last\n\n    // we can only wrap focus if we have tabbable edges\n    if (!hasTabbableElementsInside) {\n      if (focusedElement === container)\n        event.preventDefault()\n    }\n    else {\n      if (!event.shiftKey && focusedElement === last) {\n        event.preventDefault()\n        if (props.loop)\n          focus(first, { select: true })\n      }\n      else if (event.shiftKey && focusedElement === first) {\n        event.preventDefault()\n        if (props.loop)\n          focus(last, { select: true })\n      }\n    }\n  }\n}\n</script>\n\n<template>\n  <Primitive\n    ref=\"currentRef\"\n    tabindex=\"-1\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n    @keydown=\"handleKeyDown\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "export function handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  OriginalEvent extends Event,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D>\n    ? D\n    : never),\n) {\n  const target = detail.originalEvent.target\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail,\n  })\n  if (handler)\n    target.addEventListener(name, handler as EventListener, { once: true })\n\n  target.dispatchEvent(event)\n}\n", "import type { MaybeRefOrGetter, Ref } from 'vue'\nimport { isClient } from '@vueuse/shared'\nimport { nextTick, ref, toValue, watchEffect } from 'vue'\nimport { handleAndDispatchCustomEvent } from '@/shared'\n\nexport type PointerDownOutsideEvent = CustomEvent<{\n  originalEvent: PointerEvent\n}>\nexport type FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>\n\nexport const DISMISSABLE_LAYER_NAME = 'DismissableLayer'\nexport const CONTEXT_UPDATE = 'dismissableLayer.update'\nexport const POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside'\nexport const FOCUS_OUTSIDE = 'dismissableLayer.focusOutside'\n\nfunction isLayerExist(layerElement: HTMLElement, targetElement: HTMLElement) {\n  const targetLayer = targetElement.closest(\n    '[data-dismissable-layer]',\n  )\n\n  const mainLayer = layerElement.dataset.dismissableLayer === ''\n    ? layerElement\n    : layerElement.querySelector(\n      '[data-dismissable-layer]',\n    ) as HTMLElement\n\n  const nodeList = Array.from(\n    layerElement.ownerDocument.querySelectorAll('[data-dismissable-layer]'),\n  )\n\n  if (targetLayer && (mainLayer === targetLayer || nodeList.indexOf(mainLayer) < nodeList.indexOf(targetLayer))\n  ) {\n    return true\n  }\n  else {\n    return false\n  }\n}\n\n/**\n * Listens for `pointerdown` outside a DOM subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nexport function usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  element?: Ref<HTMLElement | undefined>,\n  enabled: MaybeRefOrGetter<boolean> = true,\n) {\n  const ownerDocument: Document\n    = element?.value?.ownerDocument ?? globalThis?.document\n\n  const isPointerInsideDOMTree = ref(false)\n  const handleClickRef = ref(() => {})\n\n  watchEffect((cleanupFn) => {\n    if (!isClient || !toValue(enabled))\n      return\n    const handlePointerDown = async (event: PointerEvent) => {\n      const target = event.target as HTMLElement | undefined\n\n      if (!element?.value || !target)\n        return\n\n      if (isLayerExist(element.value, target)) {\n        isPointerInsideDOMTree.value = false\n        return\n      }\n\n      if (event.target && !isPointerInsideDOMTree.value) {\n        const eventDetail = { originalEvent: event }\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            onPointerDownOutside,\n            eventDetail,\n          )\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executes events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.value)\n          handleClickRef.value = handleAndDispatchPointerDownOutsideEvent\n          ownerDocument.addEventListener('click', handleClickRef.value, {\n            once: true,\n          })\n        }\n        else {\n          handleAndDispatchPointerDownOutsideEvent()\n        }\n      }\n      else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.value)\n      }\n      isPointerInsideDOMTree.value = false\n    }\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown)\n    }, 0)\n\n    cleanupFn(() => {\n      window.clearTimeout(timerId)\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown)\n      ownerDocument.removeEventListener('click', handleClickRef.value)\n    })\n  })\n\n  return {\n    onPointerDownCapture: () => {\n      if (!toValue(enabled))\n        return\n      isPointerInsideDOMTree.value = true\n    },\n  }\n}\n\n/**\n * Listens for when focus happens outside a DOM subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nexport function useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  element?: Ref<HTMLElement | undefined>,\n  enabled: MaybeRefOrGetter<boolean> = true,\n) {\n  const ownerDocument: Document\n    = element?.value?.ownerDocument ?? globalThis?.document\n\n  const isFocusInsideDOMTree = ref(false)\n  watchEffect((cleanupFn) => {\n    if (!isClient || !toValue(enabled))\n      return\n    const handleFocus = async (event: FocusEvent) => {\n      if (!element?.value)\n        return\n\n      await nextTick()\n      await nextTick()\n      const target = event.target as HTMLElement | undefined\n      if (!element.value || !target || isLayerExist(element.value, target))\n        return\n\n      if (event.target && !isFocusInsideDOMTree.value) {\n        const eventDetail = { originalEvent: event }\n        handleAndDispatchCustomEvent(\n          FOCUS_OUTSIDE,\n          onFocusOutside,\n          eventDetail,\n        )\n      }\n    }\n\n    ownerDocument.addEventListener('focusin', handleFocus)\n\n    cleanupFn(() => ownerDocument.removeEventListener('focusin', handleFocus))\n  })\n\n  return {\n    onFocusCapture: () => {\n      if (!toValue(enabled))\n        return\n\n      isFocusInsideDOMTree.value = true\n    },\n    onBlurCapture: () => {\n      if (!toValue(enabled))\n        return\n\n      isFocusInsideDOMTree.value = false\n    },\n  }\n}\n\nexport function dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE)\n  document.dispatchEvent(event)\n}\n", "<script lang=\"ts\">\nimport type {\n  FocusOutsideEvent,\n  PointerDownOutsideEvent,\n} from './utils'\n\nimport type { PrimitiveProps } from '@/Primitive'\nimport {\n  computed,\n  nextTick,\n  reactive,\n  watchEffect,\n} from 'vue'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DismissableLayerProps extends PrimitiveProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean\n}\n\nexport type DismissableLayerEmits = {\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  escapeKeyDown: [event: KeyboardEvent]\n  /**\n   * Event handler called when a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  pointerDownOutside: [event: PointerDownOutsideEvent]\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  focusOutside: [ event: FocusOutsideEvent]\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  interactOutside: [ event: PointerDownOutsideEvent | FocusOutsideEvent]\n}\n\nexport type DismissableLayerPrivateEmits = DismissableLayerEmits & {\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  dismiss: []\n}\n\nexport const context = reactive({\n  layersRoot: new Set<HTMLElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<HTMLElement>(),\n  branches: new Set<HTMLElement>(),\n})\n</script>\n\n<script setup lang=\"ts\">\nimport { onKeyStroke } from '@vueuse/core'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport {\n  useFocusOutside,\n  usePointerDownOutside,\n} from './utils'\n\nconst props = withDefaults(defineProps<DismissableLayerProps>(), {\n  disableOutsidePointerEvents: false,\n})\n\nconst emits = defineEmits<DismissableLayerPrivateEmits>()\n\nconst { forwardRef, currentElement: layerElement } = useForwardExpose()\nconst ownerDocument = computed(\n  () => layerElement.value?.ownerDocument ?? globalThis.document,\n)\n\nconst layers = computed(() => context.layersRoot)\n\nconst index = computed(() => {\n  return layerElement.value\n    ? Array.from(layers.value).indexOf(layerElement.value)\n    : -1\n})\n\nconst isBodyPointerEventsDisabled = computed(() => {\n  return context.layersWithOutsidePointerEventsDisabled.size > 0\n})\n\nconst isPointerEventsEnabled = computed(() => {\n  const localLayers = Array.from(layers.value)\n  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1)\n  const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled)\n\n  return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex\n})\n\nconst pointerDownOutside = usePointerDownOutside(async (event) => {\n  const isPointerDownOnBranch = [...context.branches].some(branch =>\n    branch?.contains(event.target as HTMLElement),\n  )\n\n  if (!isPointerEventsEnabled.value || isPointerDownOnBranch)\n    return\n  emits('pointerDownOutside', event)\n  emits('interactOutside', event)\n  await nextTick()\n  if (!event.defaultPrevented)\n    emits('dismiss')\n}, layerElement)\n\nconst focusOutside = useFocusOutside((event) => {\n  const isFocusInBranch = [...context.branches].some(branch =>\n    branch?.contains(event.target as HTMLElement),\n  )\n\n  if (isFocusInBranch)\n    return\n  emits('focusOutside', event)\n  emits('interactOutside', event)\n  if (!event.defaultPrevented)\n    emits('dismiss')\n}, layerElement)\n\nonKeyStroke('Escape', (event) => {\n  const isHighestLayer = index.value === layers.value.size - 1\n  if (!isHighestLayer)\n    return\n  emits('escapeKeyDown', event)\n  if (!event.defaultPrevented)\n    emits('dismiss')\n})\n\nlet originalBodyPointerEvents: string\nwatchEffect((cleanupFn) => {\n  if (!layerElement.value)\n    return\n  if (props.disableOutsidePointerEvents) {\n    if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n      originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents\n      ownerDocument.value.body.style.pointerEvents = 'none'\n    }\n    context.layersWithOutsidePointerEventsDisabled.add(layerElement.value)\n  }\n  layers.value.add(layerElement.value)\n\n  cleanupFn(() => {\n    if (\n      props.disableOutsidePointerEvents\n      && context.layersWithOutsidePointerEventsDisabled.size === 1\n    ) {\n      ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents\n    }\n  })\n})\n\nwatchEffect((cleanupFn) => {\n  cleanupFn(() => {\n    if (!layerElement.value)\n      return\n    layers.value.delete(layerElement.value)\n    context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value)\n  })\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n    data-dismissable-layer\n    :style=\"{\n      pointerEvents: isBodyPointerEventsDisabled\n        ? isPointerEventsEnabled\n          ? 'auto'\n          : 'none'\n        : undefined,\n    }\"\n    @focus.capture=\"focusOutside.onFocusCapture\"\n    @blur.capture=\"focusOutside.onBlurCapture\"\n    @pointerdown.capture=\"pointerDownOutside.onPointerDownCapture\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  DismissableLayerEmits,\n  DismissableLayerProps,\n} from '@/DismissableLayer'\nimport { getActiveElement, useForwardExpose, useId } from '@/shared'\n\nexport type DialogContentImplEmits = DismissableLayerEmits & {\n  /**\n   * Event handler called when auto-focusing on open.\n   * Can be prevented.\n   */\n  openAutoFocus: [event: Event]\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  closeAutoFocus: [event: Event]\n}\n\nexport interface DialogContentImplProps extends DismissableLayerProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling transntion with Vue native transition or other animation libraries.\n   */\n  forceMount?: boolean\n  /**\n   * When `true`, focus cannot escape the `Content` via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapFocus?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { FocusScope } from '@/FocusScope'\nimport { getOpenState } from '@/Menu/utils'\nimport { injectDialogRootContext } from './DialogRoot.vue'\nimport { useWarning } from './utils'\n\nconst props = defineProps<DialogContentImplProps>()\nconst emits = defineEmits<DialogContentImplEmits>()\n\nconst rootContext = injectDialogRootContext()\nconst { forwardRef, currentElement: contentElement } = useForwardExpose()\n\nrootContext.titleId ||= useId(undefined, 'reka-dialog-title')\nrootContext.descriptionId ||= useId(undefined, 'reka-dialog-description')\n\nonMounted(() => {\n  rootContext.contentElement = contentElement\n\n  // Preserve the `DialogTrigger` element in case it was triggered programmatically\n  if (getActiveElement() !== document.body)\n    rootContext.triggerElement.value = getActiveElement() as HTMLElement\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  useWarning({\n    titleName: 'DialogTitle',\n    contentName: 'DialogContent',\n    componentLink: 'dialog.html#title',\n    titleId: rootContext.titleId,\n    descriptionId: rootContext.descriptionId,\n    contentElement,\n  })\n}\n</script>\n\n<template>\n  <FocusScope\n    as-child\n    loop\n    :trapped=\"props.trapFocus\"\n    @mount-auto-focus=\"emits('openAutoFocus', $event)\"\n    @unmount-auto-focus=\"emits('closeAutoFocus', $event)\"\n  >\n    <DismissableLayer\n      :id=\"rootContext.contentId\"\n      :ref=\"forwardRef\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :disable-outside-pointer-events=\"disableOutsidePointerEvents\"\n      role=\"dialog\"\n      :aria-describedby=\"rootContext.descriptionId\"\n      :aria-labelledby=\"rootContext.titleId\"\n      :data-state=\"getOpenState(rootContext.open.value)\"\n      v-bind=\"$attrs\"\n      @dismiss=\"rootContext.onOpenChange(false)\"\n      @escape-key-down=\"emits('escapeKeyDown', $event)\"\n      @focus-outside=\"emits('focusOutside', $event)\"\n      @interact-outside=\"emits('interactOutside', $event)\"\n      @pointer-down-outside=\"emits('pointerDownOutside', $event)\"\n    >\n      <slot />\n    </DismissableLayer>\n  </FocusScope>\n</template>\n", "var getDefaultParent = function (originalTarget) {\r\n    if (typeof document === 'undefined') {\r\n        return null;\r\n    }\r\n    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\r\n    return sampleTarget.ownerDocument.body;\r\n};\r\nvar counterMap = new WeakMap();\r\nvar uncontrolledNodes = new WeakMap();\r\nvar markerMap = {};\r\nvar lockCount = 0;\r\nvar unwrapHost = function (node) {\r\n    return node && (node.host || unwrapHost(node.parentNode));\r\n};\r\nvar correctTargets = function (parent, targets) {\r\n    return targets\r\n        .map(function (target) {\r\n        if (parent.contains(target)) {\r\n            return target;\r\n        }\r\n        var correctedTarget = unwrapHost(target);\r\n        if (correctedTarget && parent.contains(correctedTarget)) {\r\n            return correctedTarget;\r\n        }\r\n        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');\r\n        return null;\r\n    })\r\n        .filter(function (x) { return Boolean(x); });\r\n};\r\n/**\r\n * Marks everything except given node(or nodes) as aria-hidden\r\n * @param {Element | Element[]} originalTarget - elements to keep on the page\r\n * @param [parentNode] - top element, defaults to document.body\r\n * @param {String} [markerName] - a special attribute to mark every node\r\n * @param {String} [controlAttribute] - html Attribute to control\r\n * @return {Undo} undo command\r\n */\r\nvar applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {\r\n    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\r\n    if (!markerMap[markerName]) {\r\n        markerMap[markerName] = new WeakMap();\r\n    }\r\n    var markerCounter = markerMap[markerName];\r\n    var hiddenNodes = [];\r\n    var elementsToKeep = new Set();\r\n    var elementsToStop = new Set(targets);\r\n    var keep = function (el) {\r\n        if (!el || elementsToKeep.has(el)) {\r\n            return;\r\n        }\r\n        elementsToKeep.add(el);\r\n        keep(el.parentNode);\r\n    };\r\n    targets.forEach(keep);\r\n    var deep = function (parent) {\r\n        if (!parent || elementsToStop.has(parent)) {\r\n            return;\r\n        }\r\n        Array.prototype.forEach.call(parent.children, function (node) {\r\n            if (elementsToKeep.has(node)) {\r\n                deep(node);\r\n            }\r\n            else {\r\n                try {\r\n                    var attr = node.getAttribute(controlAttribute);\r\n                    var alreadyHidden = attr !== null && attr !== 'false';\r\n                    var counterValue = (counterMap.get(node) || 0) + 1;\r\n                    var markerValue = (markerCounter.get(node) || 0) + 1;\r\n                    counterMap.set(node, counterValue);\r\n                    markerCounter.set(node, markerValue);\r\n                    hiddenNodes.push(node);\r\n                    if (counterValue === 1 && alreadyHidden) {\r\n                        uncontrolledNodes.set(node, true);\r\n                    }\r\n                    if (markerValue === 1) {\r\n                        node.setAttribute(markerName, 'true');\r\n                    }\r\n                    if (!alreadyHidden) {\r\n                        node.setAttribute(controlAttribute, 'true');\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    console.error('aria-hidden: cannot operate on ', node, e);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    deep(parentNode);\r\n    elementsToKeep.clear();\r\n    lockCount++;\r\n    return function () {\r\n        hiddenNodes.forEach(function (node) {\r\n            var counterValue = counterMap.get(node) - 1;\r\n            var markerValue = markerCounter.get(node) - 1;\r\n            counterMap.set(node, counterValue);\r\n            markerCounter.set(node, markerValue);\r\n            if (!counterValue) {\r\n                if (!uncontrolledNodes.has(node)) {\r\n                    node.removeAttribute(controlAttribute);\r\n                }\r\n                uncontrolledNodes.delete(node);\r\n            }\r\n            if (!markerValue) {\r\n                node.removeAttribute(markerName);\r\n            }\r\n        });\r\n        lockCount--;\r\n        if (!lockCount) {\r\n            // clear\r\n            counterMap = new WeakMap();\r\n            counterMap = new WeakMap();\r\n            uncontrolledNodes = new WeakMap();\r\n            markerMap = {};\r\n        }\r\n    };\r\n};\r\n/**\r\n * Marks everything except given node(or nodes) as aria-hidden\r\n * @param {Element | Element[]} originalTarget - elements to keep on the page\r\n * @param [parentNode] - top element, defaults to document.body\r\n * @param {String} [markerName] - a special attribute to mark every node\r\n * @return {Undo} undo command\r\n */\r\nexport var hideOthers = function (originalTarget, parentNode, markerName) {\r\n    if (markerName === void 0) { markerName = 'data-aria-hidden'; }\r\n    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\r\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\r\n    if (!activeParentNode) {\r\n        return function () { return null; };\r\n    }\r\n    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\r\n    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));\r\n    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');\r\n};\r\n/**\r\n * Marks everything except given node(or nodes) as inert\r\n * @param {Element | Element[]} originalTarget - elements to keep on the page\r\n * @param [parentNode] - top element, defaults to document.body\r\n * @param {String} [markerName] - a special attribute to mark every node\r\n * @return {Undo} undo command\r\n */\r\nexport var inertOthers = function (originalTarget, parentNode, markerName) {\r\n    if (markerName === void 0) { markerName = 'data-inert-ed'; }\r\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\r\n    if (!activeParentNode) {\r\n        return function () { return null; };\r\n    }\r\n    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');\r\n};\r\n/**\r\n * @returns if current browser supports inert\r\n */\r\nexport var supportsInert = function () {\r\n    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');\r\n};\r\n/**\r\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\r\n * @param {Element | Element[]} originalTarget - elements to keep on the page\r\n * @param [parentNode] - top element, defaults to document.body\r\n * @param {String} [markerName] - a special attribute to mark every node\r\n * @return {Undo} undo command\r\n */\r\nexport var suppressOthers = function (originalTarget, parentNode, markerName) {\r\n    if (markerName === void 0) { markerName = 'data-suppressed'; }\r\n    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\r\n};\r\n", "import type { MaybeElementRef } from '@vueuse/core'\nimport { unrefElement } from '@vueuse/core'\nimport { hideOthers } from 'aria-hidden'\nimport { onUnmounted, watch } from 'vue'\n\n/**\n * The `useHideOthers` function is a TypeScript function that takes a target element reference and\n * hides all other elements in ARIA when the target element is present, and restores the visibility of the\n * hidden elements when the target element is removed.\n * @param {MaybeElementRef} target - The `target` parameter is a reference to the element that you want\n * to hide other elements when it is clicked or focused.\n */\nexport function useHideOthers(target: MaybeElementRef) {\n  let undo: ReturnType<typeof hideOthers>\n  watch(() => unrefElement(target), (el) => {\n    // disable hideOthers on test mode\n    if (import.meta.env.MODE === 'test')\n      return\n    if (el)\n      undo = hideOthers(el)\n    else if (undo)\n      undo()\n  })\n\n  onUnmounted(() => {\n    if (undo)\n      undo()\n  })\n}\n", "<script setup lang=\"ts\">\nimport type { DialogContentImplEmits, DialogContentImplProps } from './DialogContentImpl.vue'\nimport { useEmitAsProps, useForwardExpose, useHideOthers } from '@/shared'\nimport DialogContentImpl from './DialogContentImpl.vue'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = defineProps<DialogContentImplProps>()\nconst emits = defineEmits<DialogContentImplEmits>()\n\nconst rootContext = injectDialogRootContext()\n\nconst emitsAsProps = useEmitAsProps(emits)\n\nconst { forwardRef, currentElement } = useForwardExpose()\nuseHideOthers(currentElement)\n</script>\n\n<template>\n  <DialogContentImpl\n    v-bind=\"{ ...props, ...emitsAsProps }\"\n    :ref=\"forwardRef\"\n    :trap-focus=\"rootContext.open.value\"\n    :disable-outside-pointer-events=\"true\"\n    @close-auto-focus=\"\n      (event) => {\n        if (!event.defaultPrevented) {\n          event.preventDefault();\n          rootContext.triggerElement.value?.focus();\n        }\n      }\n    \"\n    @pointer-down-outside=\"\n      (event) => {\n        const originalEvent = event.detail.originalEvent;\n        const ctrlLeftClick\n          = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n\n        // If the event is a right-click, we shouldn't close because\n        // it is effectively as if we right-clicked the `Overlay`.\n        if (isRightClick) event.preventDefault();\n      }\n    \"\n    @focus-outside=\"\n      (event) => {\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        event.preventDefault();\n      }\n    \"\n  >\n    <slot />\n  </DialogContentImpl>\n</template>\n", "<script setup lang=\"ts\">\nimport type { DialogContentImplEmits, DialogContentImplProps } from './DialogContentImpl.vue'\nimport { ref } from 'vue'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\nimport DialogContentImpl from './DialogContentImpl.vue'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = defineProps<DialogContentImplProps>()\nconst emits = defineEmits<DialogContentImplEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n\nconst rootContext = injectDialogRootContext()\nconst hasInteractedOutsideRef = ref(false)\nconst hasPointerDownOutsideRef = ref(false)\n</script>\n\n<template>\n  <DialogContentImpl\n    v-bind=\"{ ...props, ...emitsAsProps }\"\n    :trap-focus=\"false\"\n    :disable-outside-pointer-events=\"false\"\n    @close-auto-focus=\"\n      (event) => {\n        if (!event.defaultPrevented) {\n          if (!hasInteractedOutsideRef) rootContext.triggerElement.value?.focus();\n          // Always prevent auto focus because we either focus manually or want user agent focus\n          event.preventDefault();\n        }\n\n        hasInteractedOutsideRef = false;\n        hasPointerDownOutsideRef = false;\n      }\n    \"\n    @interact-outside=\"(event) => {\n      if (!event.defaultPrevented) {\n        hasInteractedOutsideRef = true;\n        if (event.detail.originalEvent.type === 'pointerdown') {\n          hasPointerDownOutsideRef = true;\n        }\n      }\n\n      // Prevent dismissing when clicking the trigger.\n      // As the trigger is already setup to close, without doing so would\n      // cause it to close and immediately open.\n      const target = event.target as HTMLElement;\n      const targetIsTrigger = rootContext.triggerElement.value?.contains(target);\n      if (targetIsTrigger) event.preventDefault();\n\n      // On Safari if the trigger is inside a container with tabIndex={0}, when clicked\n      // we will get the pointer down outside event on the trigger, but then a subsequent\n      // focus outside event on the container, we ignore any focus outside event when we've\n      // already had a pointer down outside event.\n      if (event.detail.originalEvent.type === 'focusin' && hasPointerDownOutsideRef) {\n        event.preventDefault();\n      }\n    }\"\n  >\n    <slot />\n  </DialogContentImpl>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  DialogContentImplEmits,\n  DialogContentImplProps,\n} from './DialogContentImpl.vue'\n\nexport type DialogContentEmits = DialogContentImplEmits\n\nexport interface DialogContentProps extends Omit<DialogContentImplProps, 'trapFocus'> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\nimport DialogContentModal from './DialogContentModal.vue'\nimport DialogContentNonModal from './DialogContentNonModal.vue'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = defineProps<DialogContentProps>()\nconst emits = defineEmits<DialogContentEmits>()\n\nconst rootContext = injectDialogRootContext()\n\nconst emitsAsProps = useEmitAsProps(emits)\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <Presence :present=\"forceMount || rootContext.open.value\">\n    <DialogContentModal\n      v-if=\"rootContext.modal.value\"\n      :ref=\"forwardRef\"\n      v-bind=\"{ ...props, ...emitsAsProps, ...$attrs }\"\n    >\n      <slot />\n    </DialogContentModal>\n    <DialogContentNonModal\n      v-else\n      :ref=\"forwardRef\"\n      v-bind=\"{ ...props, ...emitsAsProps, ...$attrs }\"\n    >\n      <slot />\n    </DialogContentNonModal>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  DialogContentEmits,\n  DialogContentProps,\n} from '@/Dialog'\nimport { createContext, useEmitAsProps, useForwardExpose } from '@/shared'\n\ninterface AlertDialogContentContext {\n  onCancelElementChange: (el: HTMLElement | undefined) => void\n}\n\nexport const [injectAlertDialogContentContext, provideAlertDialogContentContext]\n  = createContext<AlertDialogContentContext>('AlertDialogContent')\n\nexport type AlertDialogContentEmits = DialogContentEmits\nexport interface AlertDialogContentProps extends DialogContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, ref } from 'vue'\nimport { DialogContent } from '@/Dialog'\n\nconst props = defineProps<AlertDialogContentProps>()\nconst emits = defineEmits<AlertDialogContentEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n\nconst cancelElement = ref<HTMLElement | undefined>()\n\nprovideAlertDialogContentContext({\n  onCancelElementChange: (el) => {\n    cancelElement.value = el\n  },\n})\n</script>\n\n<template>\n  <DialogContent\n    v-bind=\"{ ...props, ...emitsAsProps }\"\n    role=\"alertdialog\"\n    @pointer-down-outside.prevent\n    @interact-outside.prevent\n    @open-auto-focus=\"\n      () => {\n        nextTick(() => {\n          cancelElement?.focus({\n            preventScroll: true,\n          });\n        });\n      }\n    \"\n  >\n    <slot />\n  </DialogContent>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogCloseProps } from '@/Dialog'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AlertDialogCancelProps extends DialogCloseProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport { DialogClose } from '@/Dialog'\nimport { injectAlertDialogContentContext } from './AlertDialogContent.vue'\n\nconst props = withDefaults(defineProps<AlertDialogCancelProps>(), { as: 'button' })\nconst contentContext = injectAlertDialogContentContext()\nconst { forwardRef, currentElement } = useForwardExpose()\n\nonMounted(() => {\n  contentContext.onCancelElementChange(currentElement.value)\n})\n</script>\n\n<template>\n  <DialogClose\n    v-bind=\"props\"\n    :ref=\"forwardRef\"\n  >\n    <slot />\n  </DialogClose>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DialogDescriptionProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = withDefaults(defineProps<DialogDescriptionProps>(), { as: 'p' })\n\nuseForwardExpose()\nconst rootContext = injectDialogRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"rootContext.descriptionId\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogDescriptionProps } from '@/Dialog'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AlertDialogDescriptionProps extends DialogDescriptionProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { DialogDescription } from '@/Dialog'\n\nconst props = withDefaults(defineProps<AlertDialogDescriptionProps>(), { as: 'p' })\nuseForwardExpose()\n</script>\n\n<template>\n  <DialogDescription v-bind=\"props\">\n    <slot />\n  </DialogDescription>\n</template>\n", "function isPlainObject(value) {\r\n  if (value === null || typeof value !== \"object\") {\r\n    return false;\r\n  }\r\n  const prototype = Object.getPrototypeOf(value);\r\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\r\n    return false;\r\n  }\r\n  if (Symbol.iterator in value) {\r\n    return false;\r\n  }\r\n  if (Symbol.toStringTag in value) {\r\n    return Object.prototype.toString.call(value) === \"[object Module]\";\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\r\n  if (!isPlainObject(defaults)) {\r\n    return _defu(baseObject, {}, namespace, merger);\r\n  }\r\n  const object = Object.assign({}, defaults);\r\n  for (const key in baseObject) {\r\n    if (key === \"__proto__\" || key === \"constructor\") {\r\n      continue;\r\n    }\r\n    const value = baseObject[key];\r\n    if (value === null || value === void 0) {\r\n      continue;\r\n    }\r\n    if (merger && merger(object, key, value, namespace)) {\r\n      continue;\r\n    }\r\n    if (Array.isArray(value) && Array.isArray(object[key])) {\r\n      object[key] = [...value, ...object[key]];\r\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\r\n      object[key] = _defu(\r\n        value,\r\n        object[key],\r\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\r\n        merger\r\n      );\r\n    } else {\r\n      object[key] = value;\r\n    }\r\n  }\r\n  return object;\r\n}\r\nfunction createDefu(merger) {\r\n  return (...arguments_) => (\r\n    // eslint-disable-next-line unicorn/no-array-reduce\r\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\r\n  );\r\n}\r\nconst defu = createDefu();\r\nconst defuFn = createDefu((object, key, currentValue) => {\r\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\r\n    object[key] = currentValue(object[key]);\r\n    return true;\r\n  }\r\n});\r\nconst defuArrayFn = createDefu((object, key, currentValue) => {\r\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\r\n    object[key] = currentValue(object[key]);\r\n    return true;\r\n  }\r\n});\r\n\r\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\r\n", "import type { Fn } from '@vueuse/shared'\nimport {\n  createSharedComposable,\n  useEventListener,\n} from '@vueuse/core'\nimport { isClient, isIOS, tryOnBeforeUnmount } from '@vueuse/shared'\nimport { defu } from 'defu'\nimport { computed, nextTick, ref, watch } from 'vue'\nimport { injectConfigProviderContext } from '@/ConfigProvider/ConfigProvider.vue'\n\nconst useBodyLockStackCount = createSharedComposable(() => {\n  const map = ref<Map<string, boolean>>(new Map())\n  const initialOverflow = ref<string | undefined>()\n\n  const locked = computed(() => {\n    for (const value of map.value.values()) {\n      if (value)\n        return true\n    }\n    return false\n  })\n\n  const context = injectConfigProviderContext({\n    scrollBody: ref(true),\n  })\n\n  let stopTouchMoveListener: Fn | null = null\n\n  const resetBodyStyle = () => {\n    document.body.style.paddingRight = ''\n    document.body.style.marginRight = ''\n    document.body.style.pointerEvents = ''\n    document.documentElement.style.removeProperty('--scrollbar-width')\n    document.body.style.overflow = initialOverflow.value ?? ''\n    isIOS && stopTouchMoveListener?.()\n\n    initialOverflow.value = undefined\n  }\n\n  watch(locked, (val, oldVal) => {\n    if (!isClient)\n      return\n\n    if (!val) {\n      if (oldVal)\n        resetBodyStyle()\n      return\n    }\n\n    if (initialOverflow.value === undefined)\n      initialOverflow.value = document.body.style.overflow\n\n    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth\n    const defaultConfig = { padding: verticalScrollbarWidth, margin: 0 }\n\n    const config = context.scrollBody?.value\n      ? typeof context.scrollBody.value === 'object'\n        ? defu({\n            padding: context.scrollBody.value.padding === true ? verticalScrollbarWidth : context.scrollBody.value.padding,\n            margin: context.scrollBody.value.margin === true ? verticalScrollbarWidth : context.scrollBody.value.margin,\n          }, defaultConfig)\n        : defaultConfig\n      : ({ padding: 0, margin: 0 })\n\n    if (verticalScrollbarWidth > 0) {\n      document.body.style.paddingRight = typeof config.padding === 'number' ? `${config.padding}px` : String(config.padding)\n      document.body.style.marginRight = typeof config.margin === 'number' ? `${config.margin}px` : String(config.margin)\n      document.documentElement.style.setProperty('--scrollbar-width', `${verticalScrollbarWidth}px`)\n      document.body.style.overflow = 'hidden'\n    }\n\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        document,\n        'touchmove',\n        (e: TouchEvent) => preventDefault(e),\n        { passive: false },\n      )\n    }\n\n    // let dismissibleLayer set previous pointerEvent first\n    nextTick(() => {\n      document.body.style.pointerEvents = 'none'\n      document.body.style.overflow = 'hidden'\n    })\n  }, { immediate: true, flush: 'sync' })\n\n  return map\n})\n\nexport function useBodyScrollLock(initialState?: boolean | undefined) {\n  const id = Math.random().toString(36).substring(2, 7) // just simple random id, need not to be cryptographically secure\n  const map = useBodyLockStackCount()\n\n  map.value.set(id, initialState ?? false)\n\n  const locked = computed({\n    get: () => map.value.get(id) ?? false,\n    set: value => map.value.set(id, value),\n  })\n\n  tryOnBeforeUnmount(() => {\n    map.value.delete(id)\n  })\n\n  return locked\n}\n\n// Adapt from https://github.com/vueuse/vueuse/blob/main/packages/core/useScrollLock/index.ts#L28C10-L28C24\nfunction checkOverflowScroll(ele: Element): boolean {\n  const style = window.getComputedStyle(ele)\n  if (\n    style.overflowX === 'scroll'\n    || style.overflowY === 'scroll'\n    || (style.overflowX === 'auto' && ele.clientWidth < ele.scrollWidth)\n    || (style.overflowY === 'auto' && ele.clientHeight < ele.scrollHeight)\n  ) {\n    return true\n  }\n  else {\n    const parent = ele.parentNode\n\n    if (!(parent instanceof Element) || parent.tagName === 'BODY')\n      return false\n\n    return checkOverflowScroll(parent)\n  }\n}\n\nfunction preventDefault(rawEvent: TouchEvent): boolean {\n  const e = rawEvent || window.event\n\n  const _target = e.target\n\n  // Do not prevent if element or parentNodes have overflow: scroll set.\n  if (_target instanceof Element && checkOverflowScroll(_target))\n    return false\n\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1)\n    return true\n\n  if (e.preventDefault && e.cancelable)\n    e.preventDefault()\n\n  return false\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface DialogOverlayImplProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { useBodyScrollLock } from '@/shared/useBodyScrollLock'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\ndefineProps<DialogOverlayImplProps>()\nconst rootContext = injectDialogRootContext()\n\nuseBodyScrollLock(true)\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n    style=\"pointer-events: auto\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogOverlayImplProps } from './DialogOverlayImpl.vue'\nimport { useForwardExpose } from '@/shared'\nimport DialogOverlayImpl from './DialogOverlayImpl.vue'\n\nexport interface DialogOverlayProps extends DialogOverlayImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\ndefineProps<DialogOverlayProps>()\nconst rootContext = injectDialogRootContext()\n\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <Presence\n    v-if=\"rootContext?.modal.value\"\n    :present=\"forceMount || rootContext.open.value\"\n  >\n    <DialogOverlayImpl\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n    >\n      <slot />\n    </DialogOverlayImpl>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogOverlayProps } from '@/Dialog'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AlertDialogOverlayProps extends DialogOverlayProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { DialogOverlay } from '@/Dialog'\n\nconst props = defineProps<AlertDialogOverlayProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <DialogOverlay v-bind=\"props\">\n    <slot />\n  </DialogOverlay>\n</template>\n", "<script lang=\"ts\">\nexport interface TeleportProps {\n  /**\n   * Vue native teleport component prop `:to`\n   *\n   * {@link https://vuejs.org/guide/built-ins/teleport.html#basic-usage}\n   */\n  to?: string | HTMLElement\n  /**\n   * Disable teleport and render the component inline\n   *\n   * {@link https://vuejs.org/guide/built-ins/teleport.html#disabling-teleport}\n   */\n  disabled?: boolean\n  /**\n   * Defer the resolving of a Teleport target until other parts of the\n   * application have mounted (requires Vue 3.5.0+)\n   *\n   * {@link https://vuejs.org/guide/built-ins/teleport.html#deferred-teleport}\n   */\n  defer?: boolean\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useMounted } from '@vueuse/core'\n\nwithDefaults(defineProps<TeleportProps>(), {\n  to: 'body',\n})\n\nconst isMounted = useMounted()\n</script>\n\n<template>\n  <Teleport\n    v-if=\"isMounted || forceMount\"\n    :to=\"to\"\n    :disabled=\"disabled\"\n    :defer=\"defer\"\n  >\n    <slot />\n  </Teleport>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface AlertDialogPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<AlertDialogPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "import type { MaybeRefOrGetter } from 'vue'\nimport { camelize, computed, getCurrentInstance, toRef } from 'vue'\n\ninterface PropOptions {\n  type?: any\n  required?: boolean\n  default?: any\n}\n\n/**\n * The `useForwardProps` function in TypeScript takes in a set of props and returns a computed value\n * that combines default props with assigned props from the current instance.\n * @param {T} props - The `props` parameter is an object that represents the props passed to a\n * component.\n * @returns computed value that combines the default props, preserved props, and assigned props.\n */\nexport function useForwardProps<T extends Record<string, any>>(props: MaybeRefOrGetter<T>) {\n  const vm = getCurrentInstance()\n  // Default value for declared props\n  const defaultProps = Object.keys(vm?.type.props ?? {}).reduce((prev, curr) => {\n    const defaultValue = (vm?.type.props[curr] as PropOptions).default\n    if (defaultValue !== undefined)\n      prev[curr as keyof T] = defaultValue\n    return prev\n  }, {} as T)\n\n  const refProps = toRef(props)\n  return computed(() => {\n    const preservedProps = {} as T\n    const assignedProps = vm?.vnode.props ?? {}\n\n    Object.keys(assignedProps).forEach((key) => {\n      preservedProps[camelize(key) as keyof T] = assignedProps[key]\n    })\n\n    // Only return value from the props parameter\n    return Object.keys({ ...defaultProps, ...preservedProps }).reduce((prev, curr) => {\n      if (refProps.value[curr] !== undefined)\n        prev[curr as keyof T] = refProps.value[curr]\n      return prev\n    }, {} as T)\n  })\n}\n", "import type { MaybeRefOrGetter } from 'vue'\nimport { computed } from 'vue'\nimport { useEmitAsProps } from './useEmitAsProps'\nimport { useForwardProps } from './useForwardProps'\n\n/**\n * The function `useForwardPropsEmits` takes in props and an optional emit function, and returns a\n * computed object that combines the parsed props and emits as props.\n * @param {T} props - The `props` parameter is of type `T`, which is a generic type that extends the\n * parameters of the `useForwardProps` function. It represents the props object that is passed to the\n * `useForwardProps` function.\n * @param [emit] - The `emit` parameter is a function that can be used to emit events. It takes two\n * arguments: `name`, which is the name of the event to be emitted, and `args`, which are the arguments\n * to be passed along with the event.\n * @returns a computed property that combines the parsed\n * props and emits as props.\n */\nexport function useForwardPropsEmits<T extends Record<string, any>, Name extends string>(props: MaybeRefOrGetter<T>, emit?: (name: Name, ...args: any[]) => void) {\n  const parsedProps = useForwardProps(props)\n  const emitsAsProps = emit ? useEmitAsProps(emit) : {}\n\n  return computed(() => ({\n    ...parsedProps.value,\n    ...emitsAsProps,\n  }))\n}\n", "<script lang=\"ts\">\nimport type {\n  DialogRootEmits,\n  DialogRootProps,\n} from '@/Dialog'\n\nexport type AlertDialogEmits = DialogRootEmits\nexport interface AlertDialogProps extends Omit<DialogRootProps, 'modal'> {}\n</script>\n\n<script setup lang=\"ts\">\nimport { DialogRoot } from '@/Dialog'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\n\nconst props = defineProps<AlertDialogProps>()\nconst emits = defineEmits<AlertDialogEmits>()\n\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <DialogRoot\n    v-slot=\"slotProps\"\n    v-bind=\"forwarded\"\n    :modal=\"true\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </DialogRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DialogTitleProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = withDefaults(defineProps<DialogTitleProps>(), { as: 'h2' })\nconst rootContext = injectDialogRootContext()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"rootContext.titleId\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogTitleProps } from '@/Dialog'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AlertDialogTitleProps extends DialogTitleProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { DialogTitle } from '@/Dialog'\n\nconst props = withDefaults(defineProps<AlertDialogTitleProps>(), { as: 'h2' })\nuseForwardExpose()\n</script>\n\n<template>\n  <DialogTitle v-bind=\"props\">\n    <slot />\n  </DialogTitle>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface DialogTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose, useId } from '@/shared'\nimport { injectDialogRootContext } from './DialogRoot.vue'\n\nconst props = withDefaults(defineProps<DialogTriggerProps>(), {\n  as: 'button',\n})\nconst rootContext = injectDialogRootContext()\nconst { forwardRef, currentElement } = useForwardExpose()\n\nrootContext.contentId ||= useId(undefined, 'reka-dialog-content')\nonMounted(() => {\n  rootContext.triggerElement.value = currentElement.value\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :ref=\"forwardRef\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    aria-haspopup=\"dialog\"\n    :aria-expanded=\"rootContext.open.value || false\"\n    :aria-controls=\"rootContext.open.value ? rootContext.contentId : undefined\"\n    :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n    @click=\"rootContext.onOpenToggle\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DialogTriggerProps } from '@/Dialog'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AlertDialogTriggerProps extends DialogTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { DialogTrigger } from '@/Dialog'\n\nconst props = withDefaults(defineProps<AlertDialogTriggerProps>(), { as: 'button' })\nuseForwardExpose()\n</script>\n\n<template>\n  <DialogTrigger v-bind=\"props\">\n    <slot />\n  </DialogTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AspectRatioProps extends PrimitiveProps {\n  /**\n   * The desired ratio. Eg: 16/9\n   * @defaultValue 1\n   */\n  ratio?: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<AspectRatioProps>(), {\n  ratio: 1,\n})\ndefineSlots<{\n  default?: (props: {\n    /** Current aspect ratio (in %) */\n    aspect: typeof aspect.value\n  }) => any\n}>()\n\nconst { forwardRef } = useForwardExpose()\n\nconst aspect = computed(() => {\n  return (1 / props.ratio) * 100\n})\n</script>\n\n<template>\n  <div\n    :style=\"`position: relative; width: 100%; padding-bottom: ${aspect}%`\"\n    data-reka-aspect-ratio-wrapper\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      style=\"position: absolute; inset: 0px\"\n      v-bind=\"$attrs\"\n    >\n      <slot :aspect=\"aspect\" />\n    </Primitive>\n  </div>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { ImageLoadingStatus } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface AvatarRootProps extends PrimitiveProps {}\n\nexport type AvatarRootContext = {\n  imageLoadingStatus: Ref<ImageLoadingStatus>\n}\n\nexport const [injectAvatarRootContext, provideAvatarRootContext]\n  = createContext<AvatarRootContext>('AvatarRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nwithDefaults(defineProps<AvatarRootProps>(), {\n  as: 'span',\n})\n\nuseForwardExpose()\n\nprovideAvatarRootContext({\n  imageLoadingStatus: ref<ImageLoadingStatus>('idle'),\n})\n</script>\n\n<template>\n  <Primitive\n    :as-child=\"asChild\"\n    :as=\"as\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { isClient } from '@vueuse/shared'\nimport { useForwardExpose } from '@/shared'\n\nexport interface AvatarFallbackProps extends PrimitiveProps {\n  /** Useful for delaying rendering so it only appears for those with slower connections. */\n  delayMs?: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref, watchEffect } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectAvatarRootContext } from './AvatarRoot.vue'\n\nconst props = withDefaults(defineProps<AvatarFallbackProps>(), {\n  as: 'span',\n})\n\nconst rootContext = injectAvatarRootContext()\nuseForwardExpose()\n\nconst canRender = ref(props.delayMs === undefined)\n\nwatchEffect((onCleanup) => {\n  if (props.delayMs && isClient) {\n    const timerId = window.setTimeout(() => {\n      canRender.value = true\n    }, props.delayMs)\n\n    onCleanup(() => {\n      window.clearTimeout(timerId)\n    })\n  }\n})\n</script>\n\n<template>\n  <Primitive\n    v-if=\"canRender && rootContext.imageLoadingStatus.value !== 'loaded'\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import type { ImgHTMLAttributes, Ref } from 'vue'\nimport { isClient } from '@vueuse/shared'\nimport { computed, onMounted, onUnmounted, ref, watchEffect } from 'vue'\n\nexport type ImageLoadingStatus = 'idle' | 'loading' | 'loaded' | 'error'\n\nfunction resolveLoadingStatus(image: HTMLImageElement | null, src?: string): ImageLoadingStatus {\n  if (!image) {\n    return 'idle'\n  }\n  if (!src) {\n    return 'error'\n  }\n  if (image.src !== src) {\n    image.src = src\n  }\n  return image.complete && image.naturalWidth > 0 ? 'loaded' : 'loading'\n}\n\nexport function useImageLoadingStatus(src: Ref<string>, { referrerPolicy, crossOrigin }: { referrerPolicy?: Ref<ImgHTMLAttributes['referrerpolicy']>, crossOrigin?: Ref<ImgHTMLAttributes['crossorigin']> } = {}) {\n  const isMounted = ref(false)\n  const imageRef = ref<HTMLImageElement | null>(null)\n  const image = computed(() => {\n    if (!isMounted.value) {\n      return null\n    }\n    if (!imageRef.value && isClient) {\n      imageRef.value = new window.Image()\n    }\n    return imageRef.value\n  })\n\n  const loadingStatus = ref<ImageLoadingStatus>(resolveLoadingStatus(image.value, src.value))\n\n  const updateStatus = (status: ImageLoadingStatus) => () => {\n    if (isMounted.value)\n      loadingStatus.value = status\n  }\n\n  onMounted(() => {\n    isMounted.value = true\n\n    watchEffect((onCleanup) => {\n      const img = image.value\n      if (!img)\n        return\n\n      loadingStatus.value = resolveLoadingStatus(img, src.value)\n\n      const handleLoad = updateStatus('loaded')\n      const handleError = updateStatus('error')\n\n      img.addEventListener('load', handleLoad)\n      img.addEventListener('error', handleError)\n\n      if (referrerPolicy?.value)\n        img.referrerPolicy = referrerPolicy.value\n      if (typeof crossOrigin?.value === 'string')\n        img.crossOrigin = crossOrigin.value\n\n      onCleanup(() => {\n        img.removeEventListener('load', handleLoad)\n        img.removeEventListener('error', handleError)\n      })\n    })\n  })\n\n  onUnmounted(() => {\n    isMounted.value = false\n  })\n\n  return loadingStatus\n}\n", "<script lang=\"ts\">\nimport type { ImageLoadingStatus } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport type AvatarImageEmits = {\n  /**\n   * A callback providing information about the loading status of the image. <br>\n   * This is useful in case you want to control more precisely what to render as the image is loading.\n   */\n  loadingStatusChange: [value: ImageLoadingStatus]\n}\nexport interface AvatarImageProps extends PrimitiveProps {\n  src: string\n  referrerPolicy?: ImgHTMLAttributes['referrerpolicy']\n  crossOrigin?: ImgHTMLAttributes['crossorigin']\n}\n</script>\n\n<script setup lang=\"ts\">\nimport type { ImgHTMLAttributes } from 'vue'\nimport { toRefs, watch } from 'vue'\nimport { Primitive } from '../Primitive'\nimport { injectAvatarRootContext } from './AvatarRoot.vue'\nimport { useImageLoadingStatus } from './utils'\n\nconst props = withDefaults(defineProps<AvatarImageProps>(), { as: 'img' })\nconst emits = defineEmits<AvatarImageEmits>()\n\nconst { src, referrerPolicy, crossOrigin } = toRefs(props)\nuseForwardExpose()\nconst rootContext = injectAvatarRootContext()\n\nconst imageLoadingStatus = useImageLoadingStatus(src, { referrerPolicy, crossOrigin })\n\nwatch(\n  imageLoadingStatus,\n  (newValue) => {\n    emits('loadingStatusChange', newValue)\n    if (newValue !== 'idle')\n      rootContext.imageLoadingStatus.value = newValue\n  },\n  { immediate: true },\n)\n</script>\n\n<template>\n  <Primitive\n    v-show=\"imageLoadingStatus === 'loaded'\"\n    role=\"img\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n    :src=\"src\"\n    :referrer-policy=\"referrerPolicy\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "/*\n  * Implementation ported from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/internal/helpers/date/utils.ts\n*/\n\nimport type { DateValue, ZonedDateTime } from '@internationalized/date'\nimport { CalendarDate, CalendarDateTime, createCalendar, DateFormatter, Time, toCalendar } from '@internationalized/date'\n\nexport type TimeValue = Time | CalendarDateTime | ZonedDateTime\n\nexport type Granularity = 'day' | 'hour' | 'minute' | 'second'\nexport type TimeGranularity = 'hour' | 'minute' | 'second'\n\ntype GetDefaultDateProps = {\n  defaultValue?: DateValue | DateValue[] | undefined\n  defaultPlaceholder?: DateValue | undefined\n  granularity?: Granularity\n  locale?: string\n}\n\n/**\n * A helper function used throughout the various date builders\n * to generate a default `DateValue` using the `defaultValue`,\n * `defaultPlaceholder`, and `granularity` props.\n *\n * It's important to match the `DateValue` type being used\n * elsewhere in the builder, so they behave according to the\n * behavior the user expects based on the props they've provided.\n *\n */\nexport function getDefaultDate(props: GetDefaultDateProps): DateValue {\n  const { defaultValue, defaultPlaceholder, granularity = 'day', locale = 'en' } = props\n\n  if (Array.isArray(defaultValue) && defaultValue.length)\n    return defaultValue.at(-1)!.copy()\n\n  if (defaultValue && !Array.isArray(defaultValue))\n    return defaultValue.copy()\n\n  if (defaultPlaceholder)\n    return defaultPlaceholder.copy()\n\n  const date = new Date()\n  const year = date.getFullYear()\n  const month = date.getMonth() + 1\n  const day = date.getDate()\n  const calendarDateTimeGranularities = ['hour', 'minute', 'second']\n\n  const defaultFormatter = new DateFormatter(locale)\n  const calendar = createCalendar(defaultFormatter.resolvedOptions().calendar)\n\n  if (calendarDateTimeGranularities.includes(granularity ?? 'day'))\n    return toCalendar(new CalendarDateTime(year, month, day, 0, 0, 0), calendar)\n\n  return toCalendar(new CalendarDate(year, month, day), calendar)\n}\n\ntype GetDefaultTimeProps = {\n  defaultValue?: TimeValue | undefined\n  defaultPlaceholder?: TimeValue | undefined\n}\n\nexport function getDefaultTime(props: GetDefaultTimeProps): TimeValue {\n  const { defaultValue, defaultPlaceholder } = props\n\n  if (defaultValue) {\n    return defaultValue.copy()\n  }\n\n  if (defaultPlaceholder) {\n    return defaultPlaceholder.copy()\n  }\n\n  return new Time(0, 0, 0)\n}\n", "import type { DateValue } from '@internationalized/date'\nimport type { Matcher } from './types'\nimport { CalendarDateTime, getDayOfWeek, getLocalTimeZone, parseDate, parseDateTime, parseZonedDateTime, toCalendar, ZonedDateTime } from '@internationalized/date'\n\n/**\n * Given a date string and a reference `DateValue` object, parse the\n * string to the same type as the reference object.\n *\n * Useful for parsing strings from data attributes, which are always\n * strings, to the same type being used by the date component.\n */\nexport function parseStringToDateValue(dateStr: string, referenceVal: DateValue): DateValue {\n  let dateValue: DateValue\n  if (isZonedDateTime(referenceVal))\n    dateValue = parseZonedDateTime(dateStr)\n\n  else if (isCalendarDateTime(referenceVal))\n    dateValue = parseDateTime(dateStr)\n\n  else\n    dateValue = parseDate(dateStr)\n\n  return dateValue.calendar !== referenceVal.calendar ? toCalendar(dateValue, referenceVal.calendar) : dateValue\n}\n\n/**\n * Given a `DateValue` object, convert it to a native `Date` object.\n * If a timezone is provided, the date will be converted to that timezone.\n * If no timezone is provided, the date will be converted to the local timezone.\n */\nexport function toDate(dateValue: DateValue, tz: string = getLocalTimeZone()) {\n  if (isZonedDateTime(dateValue))\n    return dateValue.toDate()\n  else\n    return dateValue.toDate(tz)\n}\n\nexport function isCalendarDateTime(dateValue: DateValue): dateValue is CalendarDateTime {\n  return dateValue instanceof CalendarDateTime\n}\n\nexport function isZonedDateTime(dateValue: DateValue): dateValue is ZonedDateTime {\n  return dateValue instanceof ZonedDateTime\n}\n\nexport function hasTime(dateValue: DateValue) {\n  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue)\n}\n\n/**\n * Given a date, return the number of days in the month.\n */\nexport function getDaysInMonth(date: Date | DateValue) {\n  if (date instanceof Date) {\n    const year = date.getFullYear()\n    const month = date.getMonth() + 1\n    /**\n     * By using zero as the day, we get the\n     * last day of the previous month, which\n     * is the month we originally passed in.\n     */\n    return new Date(year, month, 0).getDate()\n  }\n  else {\n    return date.set({ day: 100 }).day\n  }\n}\n\n/**\n * Determine if a date is before the reference date.\n * @param dateToCompare - is this date before the `referenceDate`\n * @param referenceDate - is the `dateToCompare` before this date\n *\n * @see {@link isBeforeOrSame} for inclusive\n */\nexport function isBefore(dateToCompare: DateValue, referenceDate: DateValue) {\n  return dateToCompare.compare(referenceDate) < 0\n}\n\n/**\n * Determine if a date is after the reference date.\n * @param dateToCompare - is this date after the `referenceDate`\n * @param referenceDate - is the `dateToCompare` after this date\n *\n * @see {@link isAfterOrSame} for inclusive\n */\nexport function isAfter(dateToCompare: DateValue, referenceDate: DateValue) {\n  return dateToCompare.compare(referenceDate) > 0\n}\n\n/**\n * Determine if a date is before or the same as the reference date.\n *\n * @param dateToCompare - the date to compare\n * @param referenceDate - the reference date to make the comparison against\n *\n * @see {@link isBefore} for non-inclusive\n */\nexport function isBeforeOrSame(dateToCompare: DateValue, referenceDate: DateValue) {\n  return dateToCompare.compare(referenceDate) <= 0\n}\n\n/**\n * Determine if a date is after or the same as the reference date.\n *\n * @param dateToCompare - is this date after or the same as the `referenceDate`\n * @param referenceDate - is the `dateToCompare` after or the same as this date\n *\n * @see {@link isAfter} for non-inclusive\n */\nexport function isAfterOrSame(dateToCompare: DateValue, referenceDate: DateValue) {\n  return dateToCompare.compare(referenceDate) >= 0\n}\n\n/**\n * Determine if a date is inclusively between a start and end reference date.\n *\n * @param date - is this date inclusively between the `start` and `end` dates\n * @param start - the start reference date to make the comparison against\n * @param end - the end reference date to make the comparison against\n *\n * @see {@link isBetween} for non-inclusive\n */\nexport function isBetweenInclusive(date: DateValue, start: DateValue, end: DateValue) {\n  return isAfterOrSame(date, start) && isBeforeOrSame(date, end)\n}\n\n/**\n * Determine if a date is between a start and end reference date.\n *\n * @param date - is this date between the `start` and `end` dates\n * @param start - the start reference date to make the comparison against\n * @param end - the end reference date to make the comparison against\n *\n * @see {@link isBetweenInclusive} for inclusive\n */\nexport function isBetween(date: DateValue, start: DateValue, end: DateValue) {\n  return isAfter(date, start) && isBefore(date, end)\n}\n\nexport function getLastFirstDayOfWeek<T extends DateValue = DateValue>(\n  date: T,\n  firstDayOfWeek: number,\n  locale: string,\n): T {\n  const day = getDayOfWeek(date, locale)\n\n  if (firstDayOfWeek > day)\n    return date.subtract({ days: day + 7 - firstDayOfWeek }) as T\n\n  if (firstDayOfWeek === day)\n    return date as T\n\n  return date.subtract({ days: day - firstDayOfWeek }) as T\n}\n\nexport function getNextLastDayOfWeek<T extends DateValue = DateValue>(\n  date: T,\n  firstDayOfWeek: number,\n  locale: string,\n): T {\n  const day = getDayOfWeek(date, locale)\n  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1\n\n  if (day === lastDayOfWeek)\n    return date as T\n\n  if (day > lastDayOfWeek)\n    return date.add({ days: 7 - day + lastDayOfWeek }) as T\n\n  return date.add({ days: lastDayOfWeek - day }) as T\n}\n\nexport function areAllDaysBetweenValid(\n  start: DateValue,\n  end: DateValue,\n  isUnavailable: Matcher | undefined,\n  isDisabled: Matcher | undefined,\n  isHighlightable?: Matcher | undefined,\n) {\n  if (isUnavailable === undefined && isDisabled === undefined && isHighlightable === undefined)\n    return true\n\n  let dCurrent = start.add({ days: 1 })\n  if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent))\n    && !isHighlightable?.(dCurrent)) {\n    return false\n  }\n\n  const dEnd = end\n  while (dCurrent.compare(dEnd) < 0) {\n    dCurrent = dCurrent.add({ days: 1 })\n    if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent))\n      && !isHighlightable?.(dCurrent)) {\n      return false\n    }\n  }\n  return true\n}\n", "/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk<T>(arr: T[], size: number): T[][] {\n  const result = []\n  for (let i = 0; i < arr.length; i += size)\n    result.push(arr.slice(i, i + size))\n\n  return result\n}\n", "import type { Granularity } from './comparators'\nimport type { DateStep, HourCycle } from './types'\nimport { defu } from 'defu'\n\nexport function getOptsByGranularity(granularity: Granularity, hourCycle: HourCycle, isTimeValue: boolean = false) {\n  const opts: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    timeZoneName: 'short',\n    hourCycle: normalizeHourCycle(hourCycle),\n    hour12: normalizeHour12(hourCycle),\n  }\n  if (isTimeValue) {\n    delete opts.year\n    delete opts.month\n    delete opts.day\n  }\n\n  if (granularity === 'day') {\n    delete opts.second\n    delete opts.hour\n    delete opts.minute\n    delete opts.timeZoneName\n  }\n  if (granularity === 'hour') {\n    delete opts.minute\n    delete opts.second\n  }\n\n  if (granularity === 'minute')\n    delete opts.second\n\n  return opts\n}\n\ntype GetDefaultDateStepProps = {\n  step?: DateStep\n}\n\nexport function normalizeDateStep(props?: GetDefaultDateStepProps): DateStep {\n  return defu(props?.step, {\n    year: 1,\n    month: 1,\n    day: 1,\n    hour: 1,\n    minute: 1,\n    second: 1,\n    millisecond: 1,\n  } satisfies DateStep)\n}\n\nexport function handleCalendarInitialFocus(calendar: HTMLElement) {\n  const selectedDay = calendar.querySelector<HTMLElement>('[data-selected]')\n  if (selectedDay)\n    return selectedDay.focus()\n\n  const today = calendar.querySelector<HTMLElement>('[data-today]')\n  if (today)\n    return today.focus()\n\n  const firstDay = calendar.querySelector<HTMLElement>('[data-reka-calendar-day]')\n  if (firstDay)\n    return firstDay.focus()\n}\n\nexport function normalizeHourCycle(hourCycle: HourCycle) {\n  if (hourCycle === 24)\n    return 'h23'\n  if (hourCycle === 12)\n    return 'h11'\n  return undefined\n}\n\nexport function normalizeHour12(hourCycle: HourCycle) {\n  if (hourCycle === 24)\n    return false\n  if (hourCycle === 12)\n    return true\n  return undefined\n}\n", "/*\n * Implementation ported from from from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/builders/calendar/create.ts\n*/\n\nimport type { DateValue } from '@internationalized/date'\nimport type { Grid } from './types'\nimport type { DateRange } from '@/shared'\nimport { endOfMonth, endOfYear, startOfMonth, startOfYear } from '@internationalized/date'\nimport { getDaysInMonth, getLastFirstDayOfWeek, getNextLastDayOfWeek } from './comparators'\nimport { chunk } from './utils'\n\nexport type WeekDayFormat = 'narrow' | 'short' | 'long'\n\nexport type CreateSelectProps = {\n  /**\n   * The date object representing the date (usually the first day of the month/year).\n   */\n  dateObj: DateValue\n}\n\nexport type CreateMonthProps = {\n  /**\n   * The date object representing the month's date (usually the first day of the month).\n   */\n  dateObj: DateValue\n\n  /**\n   * The day of the week to start the calendar on (0 for Sunday, 1 for Monday, etc.).\n   */\n  weekStartsOn: number\n\n  /**\n   * Whether to always render 6 weeks in the calendar, even if the month doesn't\n   * span 6 weeks.\n   */\n  fixedWeeks: boolean\n\n  /**\n   * The locale to use when creating the calendar month.\n   */\n  locale: string\n}\n\n/**\n * Retrieves an array of date values representing the days between\n * the provided start and end dates.\n */\nexport function getDaysBetween(start: DateValue, end: DateValue) {\n  const days: DateValue[] = []\n  let dCurrent = start.add({ days: 1 })\n  const dEnd = end\n  while (dCurrent.compare(dEnd) < 0) {\n    days.push(dCurrent)\n    dCurrent = dCurrent.add({ days: 1 })\n  }\n  return days\n}\n\nexport function createMonth(props: CreateMonthProps): Grid<DateValue> {\n  const { dateObj, weekStartsOn, fixedWeeks, locale } = props\n  const daysInMonth = getDaysInMonth(dateObj)\n\n  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }))\n\n  const firstDayOfMonth = startOfMonth(dateObj)\n  const lastDayOfMonth = endOfMonth(dateObj)\n\n  const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale)\n  const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale)\n\n  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth)\n  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }))\n\n  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length\n\n  if (fixedWeeks && totalDays < 42) {\n    const extraDays = 42 - totalDays\n\n    let startFrom = nextMonthDays[nextMonthDays.length - 1]\n\n    if (!startFrom)\n      startFrom = endOfMonth(dateObj)\n\n    const extraDaysArray = Array.from({ length: extraDays }, (_, i) => {\n      const incr = i + 1\n      return startFrom.add({ days: incr })\n    })\n    nextMonthDays.push(...extraDaysArray)\n  }\n\n  const allDays = lastMonthDays.concat(datesArray, nextMonthDays)\n\n  const weeks = chunk(allDays, 7)\n\n  return {\n    value: dateObj,\n    cells: allDays,\n    rows: weeks,\n  }\n}\n\ntype SetMonthProps = CreateMonthProps & {\n  numberOfMonths: number | undefined\n  currentMonths?: Grid<DateValue>[]\n}\n\ntype SetYearProps = CreateSelectProps & {\n  numberOfMonths?: number\n  pagedNavigation?: boolean\n}\n\ntype SetDecadeProps = CreateSelectProps & {\n  startIndex?: number\n  endIndex: number\n}\n\nexport function startOfDecade(dateObj: DateValue) {\n  // round to the lowest nearest 10 when building the decade\n  return startOfYear(dateObj.subtract({ years: dateObj.year - Math.floor(dateObj.year / 10) * 10 }).set({ day: 1, month: 1 }))\n}\n\nexport function endOfDecade(dateObj: DateValue) {\n  // round to the lowest nearest 10 when building the decade\n  return endOfYear(dateObj.add({ years: Math.ceil((dateObj.year + 1) / 10) * 10 - dateObj.year - 1 }).set({ day: 35, month: 12 }))\n}\n\nexport function createDecade(props: SetDecadeProps): DateValue[] {\n  const { dateObj, startIndex, endIndex } = props\n\n  const decadeArray = Array.from({ length: Math.abs(startIndex ?? 0) + endIndex }, (_, i) =>\n    i <= Math.abs((startIndex ?? 0))\n      ? dateObj.subtract({ years: i }).set({ day: 1, month: 1 })\n      : dateObj.add({ years: i - endIndex }).set({ day: 1, month: 1 }))\n\n  decadeArray.sort((a: DateValue, b: DateValue) => a.year - b.year)\n\n  return decadeArray\n}\n\nexport function createYear(props: SetYearProps): DateValue[] {\n  const { dateObj, numberOfMonths = 1, pagedNavigation = false } = props\n\n  if (numberOfMonths && pagedNavigation) {\n    const monthsArray = Array.from({ length: Math.floor(12 / numberOfMonths) }, (_, i) => startOfMonth(dateObj.set({ month: i * numberOfMonths + 1 })))\n\n    return monthsArray\n  }\n\n  const monthsArray = Array.from({ length: 12 }, (_, i) => startOfMonth(dateObj.set({ month: i + 1 })))\n  return monthsArray\n}\n\nexport function createMonths(props: SetMonthProps) {\n  const { numberOfMonths, dateObj, ...monthProps } = props\n\n  const months: Grid<DateValue>[] = []\n\n  if (!numberOfMonths || numberOfMonths === 1) {\n    months.push(\n      createMonth({\n        ...monthProps,\n        dateObj,\n      }),\n    )\n    return months\n  }\n\n  months.push(\n    createMonth({\n      ...monthProps,\n      dateObj,\n    }),\n  )\n\n  // Create all the months, starting with the current month\n  for (let i = 1; i < numberOfMonths; i++) {\n    const nextMonth = dateObj.add({ months: i })\n    months.push(\n      createMonth({\n        ...monthProps,\n        dateObj: nextMonth,\n      }),\n    )\n  }\n\n  return months\n}\n\nexport function createYearRange({ start, end }: DateRange): DateValue[] {\n  const years: DateValue[] = []\n\n  if (!start || !end)\n    return years\n\n  let current = startOfYear(start)\n\n  while (current.compare(end) <= 0) {\n    years.push(current)\n    // Move to the first day of the next year\n    current = startOfYear(current.add({ years: 1 }))\n  }\n\n  return years\n}\n\nexport function createDateRange({ start, end }: DateRange): DateValue[] {\n  const dates: DateValue[] = []\n\n  if (!start || !end)\n    return dates\n\n  let current = start\n\n  while (current.compare(end) <= 0) {\n    dates.push(current)\n    current = current.add({ days: 1 })\n  }\n\n  return dates\n}\n", "/*\n  * Implementation ported from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/internal/helpers/date/formatter.ts\n*/\n\nimport type { DateValue, ZonedDateTime } from '@internationalized/date'\nimport { DateFormatter, getLocalTimeZone, today } from '@internationalized/date'\nimport { ref } from 'vue'\nimport { hasTime, isZonedDateTime, toDate } from '@/date'\n\nexport interface DateFormatterOptions extends Intl.DateTimeFormatOptions {\n  calendar?: string\n}\n\nexport type Formatter = {\n  getLocale: () => string\n  setLocale: (newLocale: string) => void\n  custom: (date: Date, options: DateFormatterOptions) => string\n  selectedDate: (date: DateValue, includeTime?: boolean) => string\n  dayOfWeek: (date: Date, length?: DateFormatterOptions['weekday']) => string\n  fullMonthAndYear: (date: Date, options?: DateFormatterOptions) => string\n  fullMonth: (date: Date, options?: DateFormatterOptions) => string\n  fullYear: (date: Date, options?: DateFormatterOptions) => string\n  dayPeriod: (date: Date) => string\n  part: (dateObj: DateValue, type: Intl.DateTimeFormatPartTypes, options?: DateFormatterOptions) => string\n  toParts: (date: DateValue, options?: DateFormatterOptions) => Intl.DateTimeFormatPart[]\n  getMonths: () => { label: string, value: number }[]\n}\n\n/**\n * Creates a wrapper around the `DateFormatter`, which is\n * an improved version of the {@link Intl.DateTimeFormat} API,\n * that is used internally by the various date builders to\n * easily format dates in a consistent way.\n *\n * @see [DateFormatter](https://react-spectrum.adobe.com/internationalized/date/DateFormatter.html)\n */\nexport function useDateFormatter(initialLocale: string, opts: DateFormatterOptions = {}): Formatter {\n  const locale = ref(initialLocale)\n\n  function getLocale() {\n    return locale.value\n  }\n\n  function setLocale(newLocale: string) {\n    locale.value = newLocale\n  }\n\n  function custom(date: Date, options: DateFormatterOptions) {\n    return new DateFormatter(locale.value, { ...opts, ...options }).format(date)\n  }\n\n  function selectedDate(date: DateValue, includeTime = true) {\n    if (hasTime(date) && includeTime) {\n      return custom(toDate(date), {\n        dateStyle: 'long',\n        timeStyle: 'long',\n      })\n    }\n    else {\n      return custom(toDate(date), {\n        dateStyle: 'long',\n      })\n    }\n  }\n\n  function fullMonthAndYear(date: Date, options: DateFormatterOptions = {}) {\n    return new DateFormatter(locale.value, { ...opts, month: 'long', year: 'numeric', ...options }).format(date)\n  }\n\n  function fullMonth(date: Date, options: DateFormatterOptions = {}) {\n    return new DateFormatter(locale.value, { ...opts, month: 'long', ...options }).format(date)\n  }\n\n  function getMonths() {\n    const defaultDate = today(getLocalTimeZone())\n    const months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    return months.map(item => ({ label: fullMonth(toDate(defaultDate.set({ month: item }))), value: item }))\n  }\n\n  function fullYear(date: Date, options: DateFormatterOptions = {}) {\n    return new DateFormatter(locale.value, { ...opts, year: 'numeric', ...options }).format(date)\n  }\n\n  function toParts(date: DateValue, options?: DateFormatterOptions) {\n    if (isZonedDateTime(date)) {\n      return new DateFormatter(locale.value, {\n        ...opts,\n        ...options,\n        timeZone: (date as ZonedDateTime).timeZone,\n      }).formatToParts(toDate(date))\n    }\n    else {\n      return new DateFormatter(locale.value, { ...opts, ...options }).formatToParts(toDate(date))\n    }\n  }\n\n  function dayOfWeek(date: Date, length: DateFormatterOptions['weekday'] = 'narrow') {\n    return new DateFormatter(locale.value, { ...opts, weekday: length }).format(date)\n  }\n\n  function dayPeriod(date: Date) {\n    const parts = new DateFormatter(locale.value, {\n      ...opts,\n      hour: 'numeric',\n      minute: 'numeric',\n    }).formatToParts(date)\n    const value = parts.find(p => p.type === 'dayPeriod')?.value\n    if (value === 'PM')\n      return 'PM'\n\n    return 'AM'\n  }\n\n  const defaultPartOptions: DateFormatterOptions = {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n    second: 'numeric',\n  }\n\n  function part(\n    dateObj: DateValue,\n    type: Intl.DateTimeFormatPartTypes,\n    options: DateFormatterOptions = {},\n  ) {\n    const opts = { ...defaultPartOptions, ...options }\n    const parts = toParts(dateObj, opts)\n    const part = parts.find(p => p.type === type)\n    return part ? part.value : ''\n  }\n\n  return {\n    setLocale,\n    getLocale,\n    fullMonth,\n    fullYear,\n    fullMonthAndYear,\n    toParts,\n    custom,\n    part,\n    dayPeriod,\n    selectedDate,\n    dayOfWeek,\n    getMonths,\n  }\n}\n", "/*\n  * Adapted from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/builders/calendar/create.ts\n*/\n\nimport type { DateFields, DateValue } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { Grid, Matcher, WeekDayFormat } from '@/date'\nimport type { DateFormatterOptions } from '@/shared/useDateFormatter'\nimport { isEqualMonth, isSameDay } from '@internationalized/date'\nimport { computed, ref, watch } from 'vue'\nimport { createMonths, getDaysInMonth, isAfter, isBefore, toDate } from '@/date'\nimport { useDateFormatter } from '@/shared'\n\nexport type UseCalendarProps = {\n  locale: Ref<string>\n  placeholder: Ref<DateValue>\n  weekStartsOn: Ref<0 | 1 | 2 | 3 | 4 | 5 | 6>\n  fixedWeeks: Ref<boolean>\n  numberOfMonths: Ref<number>\n  minValue: Ref<DateValue | undefined>\n  maxValue: Ref<DateValue | undefined>\n  disabled: Ref<boolean>\n  weekdayFormat: Ref<WeekDayFormat>\n  pagedNavigation: Ref<boolean>\n  isDateDisabled?: Matcher\n  isDateUnavailable?: Matcher\n  calendarLabel: Ref<string | undefined>\n  nextPage: Ref<((placeholder: DateValue) => DateValue) | undefined>\n  prevPage: Ref<((placeholder: DateValue) => DateValue) | undefined>\n}\n\nexport type UseCalendarStateProps = {\n  isDateDisabled: Matcher\n  isDateUnavailable: Matcher\n  date: Ref<DateValue | DateValue[] | undefined>\n}\n\nexport function useCalendarState(props: UseCalendarStateProps) {\n  function isDateSelected(dateObj: DateValue) {\n    if (Array.isArray(props.date.value))\n      return props.date.value.some(d => isSameDay(d, dateObj))\n\n    else if (!props.date.value)\n      return false\n\n    else\n      return isSameDay(props.date.value, dateObj)\n  }\n\n  const isInvalid = computed(\n    () => {\n      if (Array.isArray(props.date.value)) {\n        if (!props.date.value.length)\n          return false\n        for (const dateObj of props.date.value) {\n          if (props.isDateDisabled?.(dateObj))\n            return true\n          if (props.isDateUnavailable?.(dateObj))\n            return true\n        }\n      }\n      else {\n        if (!props.date.value)\n          return false\n        if (props.isDateDisabled?.(props.date.value))\n          return true\n        if (props.isDateUnavailable?.(props.date.value))\n          return true\n      }\n      return false\n    },\n  )\n\n  return {\n    isDateSelected,\n    isInvalid,\n  }\n}\n\nfunction handleNextDisabled(lastPeriodInView: DateValue, nextPageFunc: (date: DateValue) => DateValue): DateValue {\n  const firstPeriodOfNextPage = nextPageFunc(lastPeriodInView)\n  const diff = firstPeriodOfNextPage.compare(lastPeriodInView)\n  const duration: DateFields = {}\n  if (diff >= 7)\n    duration.day = 1\n  if (diff >= getDaysInMonth(lastPeriodInView))\n    duration.month = 1\n  return firstPeriodOfNextPage.set({ ...duration })\n}\nfunction handlePrevDisabled(firstPeriodInView: DateValue, prevPageFunc: (date: DateValue) => DateValue): DateValue {\n  const lastPeriodOfPrevPage = prevPageFunc(firstPeriodInView)\n  const diff = firstPeriodInView.compare(lastPeriodOfPrevPage)\n  const duration: DateFields = {}\n  if (diff >= 7)\n    duration.day = 35\n  if (diff >= getDaysInMonth(firstPeriodInView))\n    duration.month = 13\n  return lastPeriodOfPrevPage.set({ ...duration })\n}\nfunction handleNextPage(date: DateValue, nextPageFunc: (date: DateValue) => DateValue): DateValue {\n  return nextPageFunc(date)\n}\n\nfunction handlePrevPage(date: DateValue, prevPageFunc: (date: DateValue) => DateValue): DateValue {\n  return prevPageFunc(date)\n}\n\nexport function useCalendar(props: UseCalendarProps) {\n  const formatter = useDateFormatter(props.locale.value)\n\n  const headingFormatOptions = computed(() => {\n    const options: DateFormatterOptions = {\n      calendar: props.placeholder.value.calendar.identifier,\n    }\n\n    if (props.placeholder.value.calendar.identifier === 'gregory' && props.placeholder.value.era === 'BC')\n      options.era = 'short'\n\n    return options\n  })\n\n  const grid = ref<Grid<DateValue>[]>(createMonths({\n    dateObj: props.placeholder.value,\n    weekStartsOn: props.weekStartsOn.value,\n    locale: props.locale.value,\n    fixedWeeks: props.fixedWeeks.value,\n    numberOfMonths: props.numberOfMonths.value,\n  })) as Ref<Grid<DateValue>[]>\n\n  const visibleView = computed(() => {\n    return grid.value.map(month => month.value)\n  })\n\n  function isOutsideVisibleView(date: DateValue) {\n    return !visibleView.value.some(month => isEqualMonth(date, month))\n  }\n\n  const isNextButtonDisabled = (nextPageFunc?: (date: DateValue) => DateValue) => {\n    if (!props.maxValue.value || !grid.value.length)\n      return false\n    if (props.disabled.value)\n      return true\n\n    const lastPeriodInView = grid.value[grid.value.length - 1].value\n\n    if (!nextPageFunc && !props.nextPage.value) {\n      const firstPeriodOfNextPage = lastPeriodInView.add({ months: 1 }).set({ day: 1 })\n      return isAfter(firstPeriodOfNextPage, props.maxValue.value)\n    }\n\n    const firstPeriodOfNextPage = handleNextDisabled(lastPeriodInView, nextPageFunc || props.nextPage.value!)\n    return isAfter(firstPeriodOfNextPage, props.maxValue.value)\n  }\n\n  const isPrevButtonDisabled = (prevPageFunc?: (date: DateValue) => DateValue) => {\n    if (!props.minValue.value || !grid.value.length)\n      return false\n    if (props.disabled.value)\n      return true\n    const firstPeriodInView = grid.value[0].value\n\n    if (!prevPageFunc && !props.prevPage.value) {\n      const lastPeriodOfPrevPage = firstPeriodInView.subtract({ months: 1 }).set({ day: 35 })\n      return isBefore(lastPeriodOfPrevPage, props.minValue.value)\n    }\n\n    const lastPeriodOfPrevPage = handlePrevDisabled(firstPeriodInView, prevPageFunc || props.prevPage.value!)\n    return isBefore(lastPeriodOfPrevPage, props.minValue.value)\n  }\n\n  function isDateDisabled(dateObj: DateValue) {\n    if (props.isDateDisabled?.(dateObj) || props.disabled.value)\n      return true\n    if (props.maxValue.value && isAfter(dateObj, props.maxValue.value))\n      return true\n    if (props.minValue.value && isBefore(dateObj, props.minValue.value))\n      return true\n    return false\n  }\n\n  const isDateUnavailable = (date: DateValue) => {\n    if (props.isDateUnavailable?.(date))\n      return true\n    return false\n  }\n\n  const weekdays = computed(() => {\n    if (!grid.value.length)\n      return []\n    return grid.value[0].rows[0].map((date) => {\n      return formatter.dayOfWeek(toDate(date), props.weekdayFormat.value)\n    })\n  })\n\n  const nextPage = (nextPageFunc?: (date: DateValue) => DateValue) => {\n    const firstDate = grid.value[0].value\n\n    if (!nextPageFunc && !props.nextPage.value) {\n      const newDate = firstDate.add({ months: props.pagedNavigation.value ? props.numberOfMonths.value : 1 })\n\n      const newGrid = createMonths({\n        dateObj: newDate,\n        weekStartsOn: props.weekStartsOn.value,\n        locale: props.locale.value,\n        fixedWeeks: props.fixedWeeks.value,\n        numberOfMonths: props.numberOfMonths.value,\n      })\n\n      grid.value = newGrid\n\n      props.placeholder.value = newGrid[0].value.set({ day: 1 })\n      return\n    }\n\n    const newDate = handleNextPage(firstDate, nextPageFunc || props.nextPage.value!)\n    const newGrid = createMonths({\n      dateObj: newDate,\n      weekStartsOn: props.weekStartsOn.value,\n      locale: props.locale.value,\n      fixedWeeks: props.fixedWeeks.value,\n      numberOfMonths: props.numberOfMonths.value,\n    })\n\n    grid.value = newGrid\n\n    const duration: DateFields = {}\n\n    // Do not adjust the placeholder if the nextPageFunc is defined (overwrite)\n    if (!nextPageFunc) {\n      const diff = newGrid[0].value.compare(firstDate)\n      if (diff >= getDaysInMonth(firstDate))\n        duration.day = 1\n\n      if (diff >= 365)\n        duration.month = 1\n    }\n\n    props.placeholder.value = newGrid[0].value.set({ ...duration })\n  }\n\n  const prevPage = (prevPageFunc?: (date: DateValue) => DateValue) => {\n    const firstDate = grid.value[0].value\n\n    if (!prevPageFunc && !props.prevPage.value) {\n      const newDate = firstDate.subtract({ months: props.pagedNavigation.value ? props.numberOfMonths.value : 1 })\n\n      const newGrid = createMonths({\n        dateObj: newDate,\n        weekStartsOn: props.weekStartsOn.value,\n        locale: props.locale.value,\n        fixedWeeks: props.fixedWeeks.value,\n        numberOfMonths: props.numberOfMonths.value,\n      })\n\n      grid.value = newGrid\n\n      props.placeholder.value = newGrid[0].value.set({ day: 1 })\n      return\n    }\n\n    const newDate = handlePrevPage(firstDate, prevPageFunc || props.prevPage.value!)\n    const newGrid = createMonths({\n      dateObj: newDate,\n      weekStartsOn: props.weekStartsOn.value,\n      locale: props.locale.value,\n      fixedWeeks: props.fixedWeeks.value,\n      numberOfMonths: props.numberOfMonths.value,\n    })\n\n    grid.value = newGrid\n\n    const duration: DateFields = {}\n\n    // Do not adjust the placeholder if the prevPageFunc is defined (overwrite)\n    if (!prevPageFunc) {\n      const diff = firstDate.compare(newGrid[0].value)\n      if (diff >= getDaysInMonth(firstDate))\n        duration.day = 1\n\n      if (diff >= 365)\n        duration.month = 1\n    }\n\n    props.placeholder.value = newGrid[0].value.set({ ...duration })\n  }\n\n  watch(props.placeholder, (value) => {\n    if (visibleView.value.some(month => isEqualMonth(month, value)))\n      return\n    grid.value = createMonths({\n      dateObj: value,\n      weekStartsOn: props.weekStartsOn.value,\n      locale: props.locale.value,\n      fixedWeeks: props.fixedWeeks.value,\n      numberOfMonths: props.numberOfMonths.value,\n    })\n  })\n\n  watch([props.locale, props.weekStartsOn, props.fixedWeeks, props.numberOfMonths], () => {\n    grid.value = createMonths({\n      dateObj: props.placeholder.value,\n      weekStartsOn: props.weekStartsOn.value,\n      locale: props.locale.value,\n      fixedWeeks: props.fixedWeeks.value,\n      numberOfMonths: props.numberOfMonths.value,\n    })\n  })\n\n  const headingValue = computed(() => {\n    if (!grid.value.length)\n      return ''\n\n    if (props.locale.value !== formatter.getLocale())\n      formatter.setLocale(props.locale.value)\n\n    if (grid.value.length === 1) {\n      const month = grid.value[0].value\n      return `${formatter.fullMonthAndYear(toDate(month), headingFormatOptions.value)}`\n    }\n\n    const startMonth = toDate(grid.value[0].value)\n    const endMonth = toDate(grid.value[grid.value.length - 1].value)\n\n    const startMonthName = formatter.fullMonth(startMonth, headingFormatOptions.value)\n    const endMonthName = formatter.fullMonth(endMonth, headingFormatOptions.value)\n    const startMonthYear = formatter.fullYear(startMonth, headingFormatOptions.value)\n    const endMonthYear = formatter.fullYear(endMonth, headingFormatOptions.value)\n\n    const content\n    = startMonthYear === endMonthYear\n      ? `${startMonthName} - ${endMonthName} ${endMonthYear}`\n      : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`\n\n    return content\n  })\n\n  const fullCalendarLabel = computed(() => `${props.calendarLabel.value ?? 'Event Date'}, ${headingValue.value}`)\n\n  return {\n    isDateDisabled,\n    isDateUnavailable,\n    isNextButtonDisabled,\n    isPrevButtonDisabled,\n    grid,\n    weekdays,\n    visibleView,\n    isOutsideVisibleView,\n    formatter,\n    nextPage,\n    prevPage,\n    headingValue,\n    fullCalendarLabel,\n  }\n}\n", "import type { ComponentPublicInstance } from 'vue'\nimport { unrefElement } from '@vueuse/core'\nimport { computed, ref } from 'vue'\n\nexport function usePrimitiveElement<T extends ComponentPublicInstance>() {\n  const primitiveElement = ref<T>()\n  const currentElement = computed<HTMLElement>(() => ['#text', '#comment'].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement(primitiveElement))\n\n  return {\n    primitiveElement,\n    currentElement,\n  }\n}\n", "import type { Ref } from 'vue'\nimport { computed, ref } from 'vue'\nimport { injectConfigProviderContext } from '@/ConfigProvider/ConfigProvider.vue'\n\nexport function useLocale(locale?: Ref<string | undefined>) {\n  const context = injectConfigProviderContext({\n    locale: ref('en'),\n  })\n  return computed(() => locale?.value || context.locale?.value || 'en')\n}\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\n\nimport type { Ref } from 'vue'\nimport type { Grid, Matcher, WeekDayFormat } from '@/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nimport type { Formatter } from '@/shared'\nimport type { Direction } from '@/shared/types'\nimport { isEqualDay, isSameDay } from '@internationalized/date'\nimport { createContext, useDirection, useLocale } from '@/shared'\nimport { getDefaultDate, handleCalendarInitialFocus } from '@/shared/date'\nimport { useCalendar, useCalendarState } from './useCalendar'\n\ntype CalendarRootContext = {\n  locale: Ref<string>\n  modelValue: Ref<DateValue | DateValue[] | undefined>\n  placeholder: Ref<DateValue>\n  pagedNavigation: Ref<boolean>\n  preventDeselect: Ref<boolean>\n  grid: Ref<Grid<DateValue>[]>\n  weekDays: Ref<string[]>\n  weekStartsOn: Ref<0 | 1 | 2 | 3 | 4 | 5 | 6>\n  weekdayFormat: Ref<WeekDayFormat>\n  fixedWeeks: Ref<boolean>\n  multiple: Ref<boolean>\n  numberOfMonths: Ref<number>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  initialFocus: Ref<boolean>\n  onDateChange: (date: DateValue) => void\n  onPlaceholderChange: (date: DateValue) => void\n  fullCalendarLabel: Ref<string>\n  parentElement: Ref<HTMLElement | undefined>\n  headingValue: Ref<string>\n  isInvalid: Ref<boolean>\n  isDateDisabled: Matcher\n  isDateSelected: Matcher\n  isDateUnavailable?: Matcher\n  isOutsideVisibleView: (date: DateValue) => boolean\n  prevPage: (prevPageFunc?: (date: DateValue) => DateValue) => void\n  nextPage: (nextPageFunc?: (date: DateValue) => DateValue) => void\n  isNextButtonDisabled: (nextPageFunc?: (date: DateValue) => DateValue) => boolean\n  isPrevButtonDisabled: (prevPageFunc?: (date: DateValue) => DateValue) => boolean\n  formatter: Formatter\n  dir: Ref<Direction>\n  disableDaysOutsideCurrentView: Ref<boolean>\n}\n\nexport interface CalendarRootProps extends PrimitiveProps {\n  /** The default value for the calendar */\n  defaultValue?: DateValue\n  /** The default placeholder date */\n  defaultPlaceholder?: DateValue\n  /** The placeholder date, which is used to determine what month to display when no date is selected */\n  placeholder?: DateValue\n  /** This property causes the previous and next buttons to navigate by the number of months displayed at once, rather than one month */\n  pagedNavigation?: boolean\n  /** Whether or not to prevent the user from deselecting a date without selecting another date first */\n  preventDeselect?: boolean\n  /** The day of the week to start the calendar on */\n  weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6\n  /** The format to use for the weekday strings provided via the weekdays slot prop */\n  weekdayFormat?: WeekDayFormat\n  /** The accessible label for the calendar */\n  calendarLabel?: string\n  /** Whether or not to always display 6 weeks in the calendar */\n  fixedWeeks?: boolean\n  /** The maximum date that can be selected */\n  maxValue?: DateValue\n  /** The minimum date that can be selected */\n  minValue?: DateValue\n  /** The locale to use for formatting dates */\n  locale?: string\n  /** The number of months to display at once */\n  numberOfMonths?: number\n  /** Whether the calendar is disabled */\n  disabled?: boolean\n  /** Whether the calendar is readonly */\n  readonly?: boolean\n  /** If true, the calendar will focus the selected day, today, or the first day of the month depending on what is visible when the calendar is mounted */\n  initialFocus?: boolean\n  /** A function that returns whether or not a date is disabled */\n  isDateDisabled?: Matcher\n  /** A function that returns whether or not a date is unavailable */\n  isDateUnavailable?: Matcher\n  /** The reading direction of the calendar when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** A function that returns the next page of the calendar. It receives the current placeholder as an argument inside the component. */\n  nextPage?: (placeholder: DateValue) => DateValue\n  /** A function that returns the previous page of the calendar. It receives the current placeholder as an argument inside the component. */\n  prevPage?: (placeholder: DateValue) => DateValue\n  /** The controlled checked state of the calendar */\n  modelValue?: DateValue | DateValue[] | undefined\n  /** Whether multiple dates can be selected */\n  multiple?: boolean\n  /** Whether or not to disable days outside the current view. */\n  disableDaysOutsideCurrentView?: boolean\n}\n\nexport type CalendarRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [date: DateValue | undefined]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: DateValue]\n}\n\nexport const [injectCalendarRootContext, provideCalendarRootContext]\n  = createContext<CalendarRootContext>('CalendarRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { onMounted, toRefs, watch } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CalendarRootProps>(), {\n  defaultValue: undefined,\n  as: 'div',\n  pagedNavigation: false,\n  preventDeselect: false,\n  weekStartsOn: 0,\n  weekdayFormat: 'narrow',\n  fixedWeeks: false,\n  multiple: false,\n  numberOfMonths: 1,\n  disabled: false,\n  readonly: false,\n  initialFocus: false,\n  placeholder: undefined,\n  isDateDisabled: undefined,\n  isDateUnavailable: undefined,\n  disableDaysOutsideCurrentView: false,\n})\nconst emits = defineEmits<CalendarRootEmits>()\ndefineSlots<{\n  default?: (props: {\n    /** The current date of the placeholder */\n    date: DateValue\n    /** The grid of dates */\n    grid: Grid<DateValue>[]\n    /** The days of the week */\n    weekDays: string[]\n    /** The start of the week */\n    weekStartsOn: 0 | 1 | 2 | 3 | 4 | 5 | 6\n    /** The calendar locale */\n    locale: string\n    /** Whether or not to always display 6 weeks in the calendar */\n    fixedWeeks: boolean\n    /** The current date of the calendar */\n    modelValue: DateValue | DateValue[] | undefined\n  }) => any\n}>()\n\nconst {\n  disabled,\n  readonly,\n  initialFocus,\n  pagedNavigation,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  multiple,\n  minValue,\n  maxValue,\n  numberOfMonths,\n  preventDeselect,\n  isDateDisabled: propsIsDateDisabled,\n  isDateUnavailable: propsIsDateUnavailable,\n  calendarLabel,\n  defaultValue,\n  nextPage: propsNextPage,\n  prevPage: propsPrevPage,\n  dir: propDir,\n  locale: propLocale,\n  disableDaysOutsideCurrentView,\n} = toRefs(props)\n\nconst { primitiveElement, currentElement: parentElement }\n  = usePrimitiveElement()\nconst locale = useLocale(propLocale)\nconst dir = useDirection(propDir)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: defaultValue.value,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<DateValue | DateValue[] | undefined>\n\nconst defaultDate = getDefaultDate({\n  defaultPlaceholder: props.placeholder,\n  defaultValue: modelValue.value,\n  locale: props.locale,\n})\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<DateValue>\n\nfunction onPlaceholderChange(value: DateValue) {\n  placeholder.value = value.copy()\n}\n\nconst {\n  fullCalendarLabel,\n  headingValue,\n  isDateDisabled,\n  isDateUnavailable,\n  isNextButtonDisabled,\n  isPrevButtonDisabled,\n  weekdays,\n  isOutsideVisibleView,\n  nextPage,\n  prevPage,\n  formatter,\n  grid,\n} = useCalendar({\n  locale,\n  placeholder,\n  weekStartsOn,\n  fixedWeeks,\n  numberOfMonths,\n  minValue,\n  maxValue,\n  disabled,\n  weekdayFormat,\n  pagedNavigation,\n  isDateDisabled: propsIsDateDisabled.value,\n  isDateUnavailable: propsIsDateUnavailable.value,\n  calendarLabel,\n  nextPage: propsNextPage,\n  prevPage: propsPrevPage,\n})\n\nconst {\n  isInvalid,\n  isDateSelected,\n} = useCalendarState({\n  date: modelValue,\n  isDateDisabled,\n  isDateUnavailable,\n})\n\nwatch(modelValue, (_modelValue) => {\n  if (Array.isArray(_modelValue) && _modelValue.length) {\n    const lastValue = _modelValue[_modelValue.length - 1]\n    if (lastValue && !isEqualDay(placeholder.value, lastValue))\n      onPlaceholderChange(lastValue)\n  }\n  else if (!Array.isArray(_modelValue) && _modelValue && !isEqualDay(placeholder.value, _modelValue)) {\n    onPlaceholderChange(_modelValue)\n  }\n})\n\nfunction onDateChange(value: DateValue) {\n  if (!multiple.value) {\n    if (!modelValue.value) {\n      modelValue.value = value.copy()\n      return\n    }\n\n    if (!preventDeselect.value && isEqualDay(modelValue.value as DateValue, value)) {\n      placeholder.value = value.copy()\n      modelValue.value = undefined\n    }\n    else { modelValue.value = value.copy() }\n  }\n  else if (!modelValue.value) {\n    modelValue.value = [value.copy()]\n  }\n  else if (Array.isArray(modelValue.value)) {\n    const index = modelValue.value.findIndex(date => isSameDay(date, value))\n    if (index === -1) {\n      modelValue.value = [...modelValue.value, value]\n    }\n    else if (!preventDeselect.value) {\n      const next = modelValue.value.filter(date => !isSameDay(date, value))\n      if (!next.length) {\n        placeholder.value = value.copy()\n        modelValue.value = undefined\n        return\n      }\n      modelValue.value = next.map(date => date.copy())\n    }\n  }\n}\n\nonMounted(() => {\n  if (initialFocus.value)\n    handleCalendarInitialFocus(parentElement.value)\n})\n\nprovideCalendarRootContext({\n  isDateUnavailable,\n  dir,\n  isDateDisabled,\n  locale,\n  formatter,\n  modelValue,\n  placeholder,\n  disabled,\n  initialFocus,\n  pagedNavigation,\n  grid,\n  weekDays: weekdays,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  multiple,\n  numberOfMonths,\n  readonly,\n  preventDeselect,\n  fullCalendarLabel,\n  headingValue,\n  isInvalid,\n  isDateSelected,\n  isNextButtonDisabled,\n  isPrevButtonDisabled,\n  isOutsideVisibleView,\n  nextPage,\n  prevPage,\n  parentElement,\n  onPlaceholderChange,\n  onDateChange,\n  disableDaysOutsideCurrentView,\n})\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    role=\"application\"\n    :aria-label=\"fullCalendarLabel\"\n    :data-readonly=\"readonly ? '' : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :dir=\"dir\"\n  >\n    <slot\n      :date=\"placeholder\"\n      :grid=\"grid\"\n      :week-days=\"weekdays\"\n      :week-starts-on=\"weekStartsOn\"\n      :locale=\"locale\"\n      :fixed-weeks=\"fixedWeeks\"\n      :model-value=\"modelValue\"\n    />\n    <div\n      style=\"border: 0px; clip: rect(0px, 0px, 0px, 0px); clip-path: inset(50%); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; white-space: nowrap; width: 1px;\"\n    >\n      <div\n        role=\"heading\"\n        aria-level=\"2\"\n      >\n        {{ fullCalendarLabel }}\n      </div>\n    </div>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarCellProps extends PrimitiveProps {\n  /** The date value for the cell */\n  date: DateValue\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectCalendarRootContext } from './CalendarRoot.vue'\n\nwithDefaults(defineProps<CalendarCellProps>(), { as: 'td' })\nconst rootContext = injectCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    role=\"gridcell\"\n    :aria-selected=\"rootContext.isDateSelected(date) ? true : undefined\"\n    :aria-disabled=\"rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date) || rootContext.disableDaysOutsideCurrentView.value\"\n    :data-disabled=\"rootContext.isDateDisabled(date) || rootContext.disableDaysOutsideCurrentView.value ? '' : undefined\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "export const SELECTOR\n  = '[data-reka-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])'\nexport function getSelectableCells(calendar: HTMLElement): HTMLElement[] {\n  return Array.from(calendar.querySelectorAll(SELECTOR)) ?? []\n}\n", "export function useKbd() {\n  return {\n    ALT: 'Alt',\n    ARROW_DOWN: 'ArrowDown',\n    ARROW_LEFT: 'ArrowLeft',\n    ARROW_RIGHT: 'ArrowRight',\n    ARROW_UP: 'ArrowUp',\n    BACKSPACE: 'Backspace',\n    CAPS_LOCK: 'CapsLock',\n    CONTROL: 'Control',\n    DELETE: 'Delete',\n    END: 'End',\n    ENTER: 'Enter',\n    ESCAPE: 'Escape',\n    F1: 'F1',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    HOME: 'Home',\n    META: 'Meta',\n    PAGE_DOWN: 'PageDown',\n    PAGE_UP: 'PageUp',\n    SHIFT: 'Shift',\n    SPACE: ' ',\n    TAB: 'Tab',\n    CTRL: 'Control',\n    ASTERISK: '*',\n    SPACE_CODE: 'Space',\n  }\n}\n\n/**\n * A wrapper around the internal kbd object to make it easier to use in tests\n * which require the key names to be wrapped in curly braces.\n */\nexport type KbdKeys = keyof ReturnType<typeof useKbd>\n\nexport function useTestKbd() {\n  const kbd = useKbd()\n\n  const initTestKbd: Record<KbdKeys, string> = Object.entries(kbd).reduce((acc, [key, value]) => {\n    acc[key as KbdKeys] = `{${value}}`\n    return acc\n  }, {} as Record<KbdKeys, string>)\n\n  return {\n    ...initTestKbd,\n    SHIFT_TAB: `{Shift>}{${kbd.TAB}}`,\n  }\n}\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\nimport {\n\n  getLocalTimeZone,\n  isSameDay,\n  isSameMonth,\n  isToday,\n} from '@internationalized/date'\nimport { computed, nextTick } from 'vue'\nimport { getDaysInMonth, toDate } from '@/date'\nimport { useKbd } from '@/shared'\nimport { getSelectableCells } from './utils'\n\nexport interface CalendarCellTriggerProps extends PrimitiveProps {\n  /** The date value provided to the cell trigger */\n  day: DateValue\n  /** The month in which the cell is rendered */\n  month: DateValue\n}\n\nexport interface CalendarCellTriggerSlot {\n  default?: (props: {\n    /** Current day */\n    dayValue: string\n    /** Current disable state */\n    disabled: boolean\n    /** Current selected state */\n    selected: boolean\n    /** Current today state */\n    today: boolean\n    /** Current outside view state */\n    outsideView: boolean\n    /** Current outside visible view state */\n    outsideVisibleView: boolean\n    /** Current unavailable state */\n    unavailable: boolean\n  }) => any\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { injectCalendarRootContext } from './CalendarRoot.vue'\n\nconst props = withDefaults(defineProps<CalendarCellTriggerProps>(), {\n  as: 'div',\n})\n\ndefineSlots<CalendarCellTriggerSlot>()\n\nconst kbd = useKbd()\nconst rootContext = injectCalendarRootContext()\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\n\nconst dayValue = computed(() => props.day.day.toLocaleString(rootContext.locale.value))\n\nconst labelText = computed(() => {\n  return rootContext.formatter.custom(toDate(props.day), {\n    weekday: 'long',\n    month: 'long',\n    day: 'numeric',\n    year: 'numeric',\n  })\n})\n\nconst isUnavailable = computed(() =>\n  rootContext.isDateUnavailable?.(props.day) ?? false,\n)\nconst isDateToday = computed(() => {\n  return isToday(props.day, getLocalTimeZone())\n})\nconst isOutsideView = computed(() => {\n  return !isSameMonth(props.day, props.month)\n})\n\nconst isOutsideVisibleView = computed(() =>\n  rootContext.isOutsideVisibleView(props.day),\n)\n\nconst isDisabled = computed(() => rootContext.isDateDisabled(props.day) || (rootContext.disableDaysOutsideCurrentView.value && isOutsideView.value))\n\nconst isFocusedDate = computed(() => {\n  return !rootContext.disabled.value && isSameDay(props.day, rootContext.placeholder.value)\n})\nconst isSelectedDate = computed(() => rootContext.isDateSelected(props.day))\n\nfunction changeDate(date: DateValue) {\n  if (rootContext.readonly.value)\n    return\n  if (rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date))\n    return\n\n  rootContext.onDateChange(date)\n}\n\nfunction handleClick() {\n  if (isDisabled.value)\n    return\n  changeDate(props.day)\n}\n\nfunction handleArrowKey(e: KeyboardEvent) {\n  if (isDisabled.value)\n    return\n  e.preventDefault()\n  e.stopPropagation()\n  const parentElement = rootContext.parentElement.value!\n  const indexIncrementation = 7\n  const sign = rootContext.dir.value === 'rtl' ? -1 : 1\n  switch (e.code) {\n    case kbd.ARROW_RIGHT:\n      shiftFocus(currentElement.value, sign)\n      break\n    case kbd.ARROW_LEFT:\n      shiftFocus(currentElement.value, -sign)\n      break\n    case kbd.ARROW_UP:\n      shiftFocus(currentElement.value, -indexIncrementation)\n      break\n    case kbd.ARROW_DOWN:\n      shiftFocus(currentElement.value, indexIncrementation)\n      break\n    case kbd.ENTER:\n    case kbd.SPACE_CODE:\n      changeDate(props.day)\n  }\n\n  function shiftFocus(node: HTMLElement, add: number) {\n    const allCollectionItems: HTMLElement[] = getSelectableCells(parentElement)\n    if (!allCollectionItems.length)\n      return\n\n    const index = allCollectionItems.indexOf(node)\n    const newIndex = index + add\n\n    if (newIndex >= 0 && newIndex < allCollectionItems.length) {\n      if (allCollectionItems[newIndex].hasAttribute('data-disabled')) {\n        shiftFocus(allCollectionItems[newIndex], add)\n      }\n      allCollectionItems[newIndex].focus()\n      return\n    }\n\n    if (newIndex < 0) {\n      if (rootContext.isPrevButtonDisabled())\n        return\n      rootContext.prevPage()\n      nextTick(() => {\n        const newCollectionItems: HTMLElement[] = getSelectableCells(parentElement)\n        if (!newCollectionItems.length)\n          return\n        if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {\n        // Placeholder is set to first month of the new page\n          const numberOfDays = getDaysInMonth(rootContext.placeholder.value)\n          const computedIndex = numberOfDays - Math.abs(newIndex)\n          if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n            shiftFocus(newCollectionItems[computedIndex], add)\n          }\n          newCollectionItems[\n            computedIndex\n          ].focus()\n          return\n        }\n        const computedIndex = newCollectionItems.length - Math.abs(newIndex)\n        if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n          shiftFocus(newCollectionItems[computedIndex], add)\n        }\n        newCollectionItems[\n          computedIndex\n        ].focus()\n      })\n      return\n    }\n\n    if (newIndex >= allCollectionItems.length) {\n      if (rootContext.isNextButtonDisabled())\n        return\n      rootContext.nextPage()\n      nextTick(() => {\n        const newCollectionItems: HTMLElement[] = getSelectableCells(parentElement)\n        if (!newCollectionItems.length)\n          return\n\n        if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {\n        // Placeholder is set to first month of the new page\n          const numberOfDays = getDaysInMonth(\n            rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 }),\n          )\n\n          const computedIndex = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays)\n\n          if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n            shiftFocus(newCollectionItems[computedIndex], add)\n          }\n          newCollectionItems[computedIndex].focus()\n          return\n        }\n\n        const computedIndex = newIndex - allCollectionItems.length\n        if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n          shiftFocus(newCollectionItems[computedIndex], add)\n        }\n\n        newCollectionItems[computedIndex].focus()\n      })\n    }\n  }\n}\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    v-bind=\"props\"\n    role=\"button\"\n    :aria-label=\"labelText\"\n    data-reka-calendar-cell-trigger\n    :aria-disabled=\"isDisabled || isUnavailable ? true : undefined\"\n    :data-selected=\"isSelectedDate ? true : undefined\"\n    :data-value=\"day.toString()\"\n    :data-disabled=\"isDisabled ? '' : undefined\"\n    :data-unavailable=\"isUnavailable ? '' : undefined\"\n    :data-today=\"isDateToday ? '' : undefined\"\n    :data-outside-view=\"isOutsideView ? '' : undefined\"\n    :data-outside-visible-view=\"isOutsideVisibleView ? '' : undefined\"\n    :data-focused=\"isFocusedDate ? '' : undefined\"\n    :tabindex=\"isFocusedDate ? 0 : isOutsideView || isDisabled ? undefined : -1\"\n    @click=\"handleClick\"\n    @keydown.up.down.left.right.space.enter=\"handleArrowKey\"\n    @keydown.enter.prevent\n  >\n    <slot\n      :day-value=\"dayValue\"\n      :disabled=\"isDisabled\"\n      :today=\"isDateToday\"\n      :selected=\"isSelectedDate\"\n      :outside-view=\"isOutsideView\"\n      :outside-visible-view=\"isOutsideVisibleView\"\n      :unavailable=\"isUnavailable\"\n    >\n      {{ dayValue }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarGridProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectCalendarRootContext } from './CalendarRoot.vue'\n\nconst props = withDefaults(defineProps<CalendarGridProps>(), { as: 'table' })\n\nconst rootContext = injectCalendarRootContext()\nconst disabled = computed(() => rootContext.disabled.value ? true : undefined)\nconst readonly = computed(() => rootContext.readonly.value ? true : undefined)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    tabindex=\"-1\"\n    role=\"grid\"\n    :aria-readonly=\"readonly\"\n    :aria-disabled=\"disabled\"\n    :data-readonly=\"readonly && ''\"\n    :data-disabled=\"disabled && ''\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarGridBodyProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CalendarGridBodyProps>(), { as: 'tbody' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarGridHeadProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CalendarGridHeadProps>(), { as: 'thead' })\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-hidden=\"true\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarGridRowProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CalendarGridRowProps>(), { as: 'tr' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarHeadCellProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CalendarHeadCellProps>(), { as: 'th' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarHeaderProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<CalendarHeaderProps>(), { as: 'div' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarHeadingProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectCalendarRootContext } from './CalendarRoot.vue'\n\nconst props = withDefaults(defineProps<CalendarHeadingProps>(), { as: 'div' })\n\ndefineSlots<{\n  default?: (props: {\n    /** Current month and year */\n    headingValue: string\n  }) => any\n}>()\n\nconst rootContext = injectCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n  >\n    <slot :heading-value=\"rootContext.headingValue.value\">\n      {{ rootContext.headingValue.value }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarNextProps extends PrimitiveProps {\n  /** The function to be used for the next page. Overwrites the `nextPage` function set on the `CalendarRoot`. */\n  nextPage?: (placeholder: DateValue) => DateValue\n}\n\nexport interface CalendarNextSlot {\n  default?: (props: {\n    /** Current disable state */\n    disabled: boolean\n  }) => any\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectCalendarRootContext } from './CalendarRoot.vue'\n\nconst props = withDefaults(defineProps<CalendarNextProps>(), { as: 'button', step: 'month' })\ndefineSlots<CalendarNextSlot>()\n\nconst disabled = computed(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props.nextPage))\n\nconst rootContext = injectCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    :as=\"props.as\"\n    :as-child=\"props.asChild\"\n    aria-label=\"Next page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :aria-disabled=\"disabled || undefined\"\n    :data-disabled=\"disabled || undefined\"\n    :disabled=\"disabled\"\n    @click=\"rootContext.nextPage(props.nextPage)\"\n  >\n    <slot :disabled>\n      Next page\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface CalendarPrevProps extends PrimitiveProps {\n  /** The function to be used for the prev page. Overwrites the `prevPage` function set on the `CalendarRoot`. */\n  prevPage?: (placeholder: DateValue) => DateValue\n}\n\nexport interface CalendarPrevSlot {\n  default?: (props: {\n    /** Current disable state */\n    disabled: boolean\n  }) => any\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectCalendarRootContext } from './CalendarRoot.vue'\n\nconst props = withDefaults(defineProps<CalendarPrevProps>(), { as: 'button', step: 'month' })\ndefineSlots<CalendarPrevSlot>()\n\nconst disabled = computed(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props.prevPage))\n\nconst rootContext = injectCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    aria-label=\"Previous page\"\n    :as=\"props.as\"\n    :as-child=\"props.asChild\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :aria-disabled=\"disabled || undefined\"\n    :data-disabled=\"disabled || undefined\"\n    :disabled=\"disabled\"\n    @click=\"rootContext.prevPage(props.prevPage)\"\n  >\n    <slot :disabled>\n      Prev page\n    </slot>\n  </Primitive>\n</template>\n", "import type { MaybeElementRef } from '@vueuse/core'\nimport { toValue, unrefElement } from '@vueuse/core'\nimport { computed } from 'vue'\n\nexport function useFormControl(el: MaybeElementRef) {\n  // We set this to true by default so that events bubble to forms without JS (SSR)\n  return computed(() => toValue(el) ? Boolean(unrefElement(el)?.closest('form')) : true)\n}\n", "import type { Ref } from 'vue'\nimport { computed, defineComponent, h, inject, markRaw, provide, ref, watch, watchEffect } from 'vue'\nimport { Slot, usePrimitiveElement } from '@/Primitive'\n\ninterface CollectionContext<ItemData = {}> {\n  collectionRef: Ref<HTMLElement | undefined>\n  itemMap: Ref<Map<HTMLElement, { ref: HTMLElement, value?: any } & ItemData>>\n}\n\nconst ITEM_DATA_ATTR = 'data-reka-collection-item'\n\nexport function useCollection<ItemData = {}>(options: { key?: string, isProvider?: boolean } = {}) {\n  const { key = '', isProvider = false } = options\n  const injectionKey = `${key}CollectionProvider`\n  let context: CollectionContext<ItemData>\n\n  if (isProvider) {\n    const itemMap = ref<Map<HTMLElement, { ref: HTMLElement } & ItemData>>(new Map())\n    const collectionRef = ref<HTMLElement>()\n\n    context = {\n      collectionRef,\n      itemMap,\n    } as CollectionContext<ItemData>\n    provide(injectionKey, context)\n  }\n  else {\n    context = inject(injectionKey) as CollectionContext<ItemData>\n  }\n\n  const getItems = (includeDisabledItem = false) => {\n    const collectionNode = context.collectionRef.value\n    if (!collectionNode)\n      return []\n    const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`))\n    const items = Array.from(context.itemMap.value.values())\n    const orderedItems = items.sort(\n      (a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref),\n    )\n\n    if (includeDisabledItem)\n      return orderedItems\n    else\n      return orderedItems.filter(i => i.ref.dataset.disabled !== '')\n  }\n\n  const CollectionSlot = defineComponent({\n    name: 'CollectionSlot',\n    setup(_, { slots }) {\n      const { primitiveElement, currentElement } = usePrimitiveElement()\n      watch(currentElement, () => {\n        context.collectionRef.value = currentElement.value\n      })\n      return () => h(Slot, { ref: primitiveElement }, slots)\n    },\n  })\n\n  const CollectionItem = defineComponent({\n    name: 'CollectionItem',\n    inheritAttrs: false,\n    props: {\n      value: {\n        // It accepts any value\n        validator: () => true,\n      },\n    },\n    setup(props, { slots, attrs }) {\n      const { primitiveElement, currentElement } = usePrimitiveElement()\n\n      watchEffect((cleanupFn) => {\n        if (currentElement.value) {\n          const key = markRaw(currentElement.value)\n          // @ts-expect-error ignore assignment of unknown to any\n          context.itemMap.value.set(key, { ref: currentElement.value!, value: props.value })\n          cleanupFn(() => context.itemMap.value.delete(key))\n        }\n      })\n\n      return () => h(Slot, { ...attrs, [ITEM_DATA_ATTR]: '', ref: primitiveElement }, slots)\n    },\n  })\n\n  const reactiveItems = computed(() => Array.from(context.itemMap.value.values()))\n  const itemMapSize = computed(() => context.itemMap.value.size)\n\n  return { getItems, reactiveItems, itemMapSize, CollectionSlot, CollectionItem }\n}\n", "import { getActiveElement } from '@/shared'\n\nexport type Orientation = 'horizontal' | 'vertical'\nexport type Direction = 'ltr' | 'rtl'\n\nexport const ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus'\nexport const EVENT_OPTIONS = { bubbles: false, cancelable: true }\n\nexport const MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev',\n  ArrowUp: 'prev',\n  ArrowRight: 'next',\n  ArrowDown: 'next',\n  PageUp: 'first',\n  Home: 'first',\n  PageDown: 'last',\n  End: 'last',\n}\n\nexport function getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl')\n    return key\n  return key === 'ArrowLeft'\n    ? 'ArrowRight'\n    : key === 'ArrowRight'\n      ? 'ArrowLeft'\n      : key\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next'\n\nexport function getFocusIntent(\n  event: KeyboardEvent,\n  orientation?: Orientation,\n  dir?: Direction,\n) {\n  const key = getDirectionAwareKey(event.key, dir)\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key))\n    return undefined\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key))\n    return undefined\n  return MAP_KEY_TO_FOCUS_INTENT[key]\n}\n\nexport function focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement()\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)\n      return\n    candidate.focus({ preventScroll })\n    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT)\n      return\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nexport function wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length])\n}\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type {\n  Direction,\n  Orientation,\n} from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useDirection } from '@/shared'\n\nexport interface RovingFocusGroupProps extends PrimitiveProps {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean\n  /** The controlled value of the current stop item. Can be binded as `v-model`. */\n  currentTabStopId?: string | null\n  /**\n   * The value of the current stop item.\n   *\n   * Use when you do not need to control the state of the stop item.\n   */\n  defaultCurrentTabStopId?: string\n  /**\n   * When `true`, will prevent scrolling to the focus item when focused.\n   */\n  preventScrollOnEntryFocus?: boolean\n}\n\nexport type RovingFocusGroupEmits = {\n  'entryFocus': [event: Event]\n  'update:currentTabStopId': [value: string | null | undefined]\n}\n\ninterface RovingContext {\n  orientation: Ref<Orientation | undefined>\n  dir: Ref<Direction>\n  loop: Ref<boolean>\n  currentTabStopId: Ref<string | null | undefined>\n  onItemFocus: (tabStopId: string) => void\n  onItemShiftTab: () => void\n  onFocusableItemAdd: () => void\n  onFocusableItemRemove: () => void\n}\n\nexport const [injectRovingFocusGroupContext, provideRovingFocusGroupContext]\n  = createContext<RovingContext>('RovingFocusGroup')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\nimport { ENTRY_FOCUS, EVENT_OPTIONS, focusFirst } from './utils'\n\nconst props = withDefaults(defineProps<RovingFocusGroupProps>(), {\n  loop: false,\n  orientation: undefined,\n  preventScrollOnEntryFocus: false,\n})\nconst emits = defineEmits<RovingFocusGroupEmits>()\n\nconst { loop, orientation, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nconst currentTabStopId = useVModel(props, 'currentTabStopId', emits, {\n  defaultValue: props.defaultCurrentTabStopId,\n  passive: (props.currentTabStopId === undefined) as false,\n})\nconst isTabbingBackOut = ref(false)\nconst isClickFocus = ref(false)\nconst focusableItemsCount = ref(0)\n\nconst { getItems, CollectionSlot } = useCollection({ isProvider: true })\n\nfunction handleFocus(event: FocusEvent) {\n  // We normally wouldn't need this check, because we already check\n  // that the focus is on the current target and not bubbling to it.\n  // We do this because Safari doesn't focus buttons when clicked, and\n  // instead, the wrapper will get focused and not through a bubbling event.\n  const isKeyboardFocus = !isClickFocus.value\n\n  if (\n    event.currentTarget\n    && event.target === event.currentTarget\n    && isKeyboardFocus\n    && !isTabbingBackOut.value\n  ) {\n    const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS)\n    event.currentTarget.dispatchEvent(entryFocusEvent)\n    emits('entryFocus', entryFocusEvent)\n\n    if (!entryFocusEvent.defaultPrevented) {\n      const items = getItems().map(i => i.ref).filter(i => i.dataset.disabled !== '')\n      const activeItem = items.find(item => item.getAttribute('data-active') === '')\n      const currentItem = items.find(\n        item => item.id === currentTabStopId.value,\n      )\n      const candidateItems = [activeItem, currentItem, ...items].filter(\n        Boolean,\n      ) as typeof items\n      focusFirst(candidateItems, props.preventScrollOnEntryFocus)\n    }\n  }\n  isClickFocus.value = false\n}\n\nfunction handleMouseUp() {\n  // reset `isClickFocus` after 1 tick because handleFocus might not triggered due to focused element\n  setTimeout(() => {\n    isClickFocus.value = false\n  }, 1)\n}\n\ndefineExpose({\n  getItems,\n})\n\nprovideRovingFocusGroupContext({\n  loop,\n  dir,\n  orientation,\n  currentTabStopId,\n  onItemFocus: (tabStopId) => {\n    currentTabStopId.value = tabStopId\n  },\n  onItemShiftTab: () => {\n    isTabbingBackOut.value = true\n  },\n  onFocusableItemAdd: () => {\n    focusableItemsCount.value++\n  },\n  onFocusableItemRemove: () => {\n    focusableItemsCount.value--\n  },\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <Primitive\n      :tabindex=\"isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0\"\n      :data-orientation=\"orientation\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :dir=\"dir\"\n      style=\"outline: none\"\n      @mousedown=\"isClickFocus = true\"\n      @mouseup=\"handleMouseUp\"\n      @focus=\"handleFocus\"\n      @blur=\"isTabbingBackOut = false\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nexport interface VisuallyHiddenInputBubbleProps<T> {\n  name: string\n  value: T\n  checked?: boolean\n  required?: boolean\n  disabled?: boolean\n  feature?: VisuallyHiddenProps['feature']\n}\n</script>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport type { VisuallyHiddenProps } from './VisuallyHidden.vue'\nimport { computed, watch } from 'vue'\nimport { usePrimitiveElement } from '@/Primitive'\nimport VisuallyHidden from './VisuallyHidden.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<VisuallyHiddenInputBubbleProps<T>>(), {\n  feature: 'fully-hidden',\n  checked: undefined,\n})\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst valueState = computed(() => props.checked ?? props.value)\n\nwatch(valueState, (cur, prev) => {\n  if (!currentElement.value)\n    return\n\n  const input = currentElement.value as HTMLInputElement\n  const inputProto = window.HTMLInputElement.prototype\n  const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor\n  const setValue = descriptor.set\n  if (setValue && cur !== prev) {\n    const inputEvent = new Event('input', { bubbles: true })\n    const changeEvent = new Event('change', { bubbles: true })\n    setValue.call(input, cur)\n    input.dispatchEvent(inputEvent)\n    input.dispatchEvent(changeEvent)\n  }\n})\n</script>\n\n<template>\n  <VisuallyHidden\n    ref=\"primitiveElement\"\n    v-bind=\"{ ...props, ...$attrs }\"\n    as=\"input\"\n  />\n</template>\n", "<script setup lang=\"ts\" generic=\"T\">\nimport type { VisuallyHiddenInputBubbleProps } from './VisuallyHiddenInputBubble.vue'\nimport { computed } from 'vue'\nimport VisuallyHiddenInputBubble from './VisuallyHiddenInputBubble.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<VisuallyHiddenInputBubbleProps<T>>(), {\n  feature: 'fully-hidden',\n  checked: undefined,\n})\n\nconst isFormArrayEmptyAndRequired = computed(() =>\n  typeof props.value === 'object'\n  && Array.isArray(props.value)\n  && props.value.length === 0\n  && props.required,\n)\n\nconst parsedValue = computed(() => {\n  // if primitive value\n  if (typeof props.value === 'string' || typeof props.value === 'number' || typeof props.value === 'boolean') {\n    return [{ name: props.name, value: props.value }]\n  }\n\n  // if array value\n  else if (typeof props.value === 'object' && Array.isArray(props.value)) {\n    return props.value.flatMap((obj, index) => {\n      // if item in array is object\n      if (typeof obj === 'object')\n        return Object.entries(obj).map(([key, value]) => ({ name: `[${props.name}][${index}][${key}]`, value }))\n      // if item in array is not object, may be primitive\n      else\n        return ({ name: `[${props.name}][${index}]`, value: obj })\n    })\n  }\n\n  // if object value\n  else if (props.value !== null && typeof props.value === 'object' && !Array.isArray(props.value)) {\n    return Object.entries(props.value as object).map(([key, value]) => ({ name: `[${props.name}][${key}]`, value }))\n  }\n\n  return []\n})\n</script>\n\n<template>\n  <!-- We render single input if it's required -->\n  <VisuallyHiddenInputBubble\n    v-if=\"isFormArrayEmptyAndRequired\"\n    :key=\"name\"\n    v-bind=\"{ ...props, ...$attrs }\"\n    :name=\"name\"\n    :value=\"value\"\n  />\n\n  <VisuallyHiddenInputBubble\n    v-for=\"parsed in parsedValue\"\n    v-else\n    :key=\"parsed.name\"\n    v-bind=\"{ ...props, ...$attrs }\"\n    :name=\"parsed.name\"\n    :value=\"parsed.value\"\n  />\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { RovingFocusGroupProps } from '@/RovingFocus'\nimport type { AcceptableValue, FormFieldProps } from '@/shared/types'\nimport { useVModel } from '@vueuse/core'\nimport { computed, toRefs } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { createContext, useDirection, useFormControl } from '@/shared'\n\nexport interface CheckboxGroupRootProps<T = AcceptableValue> extends Pick<RovingFocusGroupProps, 'as' | 'asChild' | 'dir' | 'orientation' | 'loop'>, FormFieldProps {\n  /** The value of the checkbox when it is initially rendered. Use when you do not need to control its value. */\n  defaultValue?: T[]\n  /** The controlled value of the checkbox. Can be binded with v-model. */\n  modelValue?: T[]\n  /** When `false`, navigating through the items using arrow keys will be disabled. */\n  rovingFocus?: boolean\n  /** When `true`, prevents the user from interacting with the checkboxes */\n  disabled?: boolean\n}\n\nexport type CheckboxGroupRootEmits<T = AcceptableValue> = {\n  /** Event handler called when the value of the checkbox changes. */\n  'update:modelValue': [value: T[]]\n}\n\ninterface CheckboxGroupRootContext {\n  modelValue: Ref<AcceptableValue[]>\n  rovingFocus: Ref<boolean>\n  disabled: Ref<boolean>\n}\n\nexport const [injectCheckboxGroupRootContext, provideCheckboxGroupRootContext]\n  = createContext<CheckboxGroupRootContext>('CheckboxGroupRoot')\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport { RovingFocusGroup } from '@/RovingFocus'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\n\nconst props = withDefaults(defineProps<CheckboxGroupRootProps<T>>(), {\n  rovingFocus: true,\n})\nconst emits = defineEmits<CheckboxGroupRootEmits<T>>()\n\nconst { disabled, rovingFocus, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst isFormControl = useFormControl(currentElement)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? [],\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<T[]>\n\nconst rovingFocusProps = computed(() => {\n  return rovingFocus.value ? { loop: props.loop, dir: dir.value, orientation: props.orientation } : {}\n})\n\nprovideCheckboxGroupRootContext({\n  modelValue,\n  rovingFocus,\n  disabled,\n})\n</script>\n\n<template>\n  <component\n    :is=\"rovingFocus ? RovingFocusGroup : Primitive\"\n    ref=\"primitiveElement\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    v-bind=\"rovingFocusProps\"\n  >\n    <slot />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name\"\n      :name=\"name\"\n      :value=\"modelValue\"\n      :required=\"required\"\n    />\n  </component>\n</template>\n", "export type CheckedState = boolean | 'indeterminate'\n\nexport function isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate'\n}\n\nexport function getState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked'\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RovingFocusItemProps extends PrimitiveProps {\n  tabStopId?: string\n  /**\n   * When `false`, item will not be focusable.\n   * @defaultValue `true`\n   */\n  focusable?: boolean\n  /** When `true`, item will be initially focused. */\n  active?: boolean\n  /** When `true`, shift + arrow key will allow focusing on next/previous item. */\n  allowShiftKey?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, nextTick, onMounted, onUnmounted } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\nimport { useId } from '@/shared'\nimport { injectRovingFocusGroupContext } from './RovingFocusGroup.vue'\nimport { focusFirst, getFocusIntent, wrapArray } from './utils'\n\nconst props = withDefaults(defineProps<RovingFocusItemProps>(), {\n  focusable: true,\n  as: 'span',\n})\n\nconst context = injectRovingFocusGroupContext()\nconst randomId = useId()\nconst id = computed(() => props.tabStopId || randomId)\nconst isCurrentTabStop = computed(\n  () => context.currentTabStopId.value === id.value,\n)\n\nconst { getItems, CollectionItem } = useCollection()\n\nonMounted(() => {\n  if (props.focusable)\n    context.onFocusableItemAdd()\n})\nonUnmounted(() => {\n  if (props.focusable)\n    context.onFocusableItemRemove()\n})\n\nfunction handleKeydown(event: KeyboardEvent) {\n  if (event.key === 'Tab' && event.shiftKey) {\n    context.onItemShiftTab()\n    return\n  }\n\n  if (event.target !== event.currentTarget)\n    return\n\n  const focusIntent = getFocusIntent(\n    event,\n    context.orientation.value,\n    context.dir.value,\n  )\n\n  if (focusIntent !== undefined) {\n    if (event.metaKey || event.ctrlKey || event.altKey || (props.allowShiftKey ? false : event.shiftKey))\n      return\n    event.preventDefault()\n    let candidateNodes = [...getItems().map(i => i.ref).filter(i => i.dataset.disabled !== '')]\n\n    if (focusIntent === 'last') {\n      candidateNodes.reverse()\n    }\n    else if (focusIntent === 'prev' || focusIntent === 'next') {\n      if (focusIntent === 'prev')\n        candidateNodes.reverse()\n      const currentIndex = candidateNodes.indexOf(\n        event.currentTarget as HTMLElement,\n      )\n\n      candidateNodes = context.loop.value\n        ? wrapArray(candidateNodes, currentIndex + 1)\n        : candidateNodes.slice(currentIndex + 1)\n    }\n\n    nextTick(() => focusFirst(candidateNodes))\n  }\n}\n</script>\n\n<template>\n  <CollectionItem>\n    <Primitive\n      :tabindex=\"isCurrentTabStop ? 0 : -1\"\n      :data-orientation=\"context.orientation.value\"\n      :data-active=\"active ? '' : undefined\"\n      :data-disabled=\"!focusable ? '' : undefined\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      @mousedown=\"\n        (event) => {\n          // We prevent focusing non-focusable items on `mousedown`.\n          // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n          if (!focusable) event.preventDefault();\n          // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n          else context.onItemFocus(id);\n        }\n      \"\n      @focus=\"context.onItemFocus(id)\"\n      @keydown=\"handleKeydown\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { CheckedState } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue, FormFieldProps } from '@/shared/types'\nimport { useVModel } from '@vueuse/core'\nimport { createContext, isNullish, isValueEqualOrExist, useFormControl, useForwardExpose } from '@/shared'\nimport { injectCheckboxGroupRootContext } from './CheckboxGroupRoot.vue'\n\nexport interface CheckboxRootProps extends PrimitiveProps, FormFieldProps {\n  /** The value of the checkbox when it is initially rendered. Use when you do not need to control its value. */\n  defaultValue?: boolean | 'indeterminate'\n  /** The controlled value of the checkbox. Can be binded with v-model. */\n  modelValue?: boolean | 'indeterminate' | null\n  /** When `true`, prevents the user from interacting with the checkbox */\n  disabled?: boolean\n  /**\n   * The value given as data when submitted with a `name`.\n   *  @defaultValue \"on\"\n   */\n  value?: AcceptableValue\n  /** Id of the element */\n  id?: string\n}\n\nexport type CheckboxRootEmits = {\n  /** Event handler called when the value of the checkbox changes. */\n  'update:modelValue': [value: boolean | 'indeterminate']\n}\n\ninterface CheckboxRootContext {\n  disabled: Ref<boolean>\n  state: Ref<CheckedState>\n}\n\nexport const [injectCheckboxRootContext, provideCheckboxRootContext]\n  = createContext<CheckboxRootContext>('CheckboxRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { isEqual } from 'ohash'\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\nimport { getState, isIndeterminate } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<CheckboxRootProps>(), {\n  modelValue: undefined,\n  value: 'on',\n  as: 'button',\n})\nconst emits = defineEmits<CheckboxRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current value */\n    modelValue: typeof modelValue.value\n    /** Current state */\n    state: typeof checkboxState.value\n  }) => any\n}>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst checkboxGroupContext = injectCheckboxGroupRootContext(null)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<CheckedState>\n\nconst disabled = computed(() => checkboxGroupContext?.disabled.value || props.disabled)\n\nconst checkboxState = computed<CheckedState>(() => {\n  if (!isNullish(checkboxGroupContext?.modelValue.value)) {\n    return isValueEqualOrExist(checkboxGroupContext.modelValue.value, props.value)\n  }\n  else {\n    return modelValue.value === 'indeterminate' ? 'indeterminate' : modelValue.value\n  }\n})\n\nfunction handleClick() {\n  if (!isNullish(checkboxGroupContext?.modelValue.value)) {\n    const modelValueArray = [...(checkboxGroupContext.modelValue.value || [])]\n    if (isValueEqualOrExist(modelValueArray, props.value)) {\n      const index = modelValueArray.findIndex(i => isEqual(i, props.value))\n      modelValueArray.splice(index, 1)\n    }\n    else {\n      modelValueArray.push(props.value)\n    }\n    checkboxGroupContext.modelValue.value = modelValueArray\n  }\n  else {\n    modelValue.value = isIndeterminate(modelValue.value) ? true : !modelValue.value\n  }\n}\n\nconst isFormControl = useFormControl(currentElement)\nconst ariaLabel = computed(() => props.id && currentElement.value\n  ? (document.querySelector(`[for=\"${props.id}\"]`) as HTMLLabelElement)?.innerText\n  : undefined)\n\nprovideCheckboxRootContext({\n  disabled,\n  state: checkboxState,\n})\n</script>\n\n<template>\n  <component\n    v-bind=\"$attrs\"\n    :is=\"checkboxGroupContext?.rovingFocus.value ? RovingFocusItem : Primitive\"\n    :id=\"id\"\n    :ref=\"forwardRef\"\n    role=\"checkbox\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :aria-checked=\"isIndeterminate(checkboxState) ? 'mixed' : checkboxState\"\n    :aria-required=\"required\"\n    :aria-label=\"$attrs['aria-label'] || ariaLabel\"\n    :data-state=\"getState(checkboxState)\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :disabled=\"disabled\"\n    :focusable=\"checkboxGroupContext?.rovingFocus.value ? !disabled : undefined\"\n    @keydown.enter.prevent=\"() => {\n      // According to WAI ARIA, Checkboxes don't activate on enter keypress\n    }\"\n    @click=\"handleClick\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :state=\"checkboxState\"\n    />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name && !checkboxGroupContext\"\n      type=\"checkbox\"\n      :checked=\"!!checkboxState\"\n      :name=\"name\"\n      :value=\"value\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n    />\n  </component>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface CheckboxIndicatorProps extends PrimitiveProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { Primitive } from '@/Primitive'\nimport { injectCheckboxRootContext } from './CheckboxRoot.vue'\nimport { getState, isIndeterminate } from './utils'\n\nwithDefaults(defineProps<CheckboxIndicatorProps>(), {\n  as: 'span',\n})\nconst { forwardRef } = useForwardExpose()\n\nconst rootContext = injectCheckboxRootContext()\n</script>\n\n<template>\n  <Presence\n    :present=\"forceMount || isIndeterminate(rootContext.state.value) || rootContext.state.value === true\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :data-state=\"getState(rootContext.state.value)\"\n      :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n      :style=\"{ pointerEvents: 'none' }\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      v-bind=\"$attrs\"\n    >\n      <slot />\n    </Primitive>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { ReferenceElement } from '@floating-ui/vue'\nimport type { Ref } from 'vue'\nimport { createContext } from '@/shared'\n\nexport interface Measurable {\n  getBoundingClientRect: () => DOMRect\n}\n\ninterface PopperRootContext {\n  anchor: Ref<ReferenceElement | undefined>\n  onAnchorChange: (element: ReferenceElement | undefined) => void\n}\n\nexport const [injectPopperRootContext, providePopperRootContext]\n  = createContext<PopperRootContext>('PopperRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst anchor = ref<ReferenceElement>()\n\nprovidePopperRootContext({\n  anchor,\n  onAnchorChange: element => anchor.value = element,\n})\n</script>\n\n<template>\n  <slot />\n</template>\n", "<script lang=\"ts\">\nimport type { ReferenceElement } from '@floating-ui/vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PopperAnchorProps extends PrimitiveProps {\n  /**\n   *  The reference (or anchor) element that is being referred to for positioning.\n   *\n   *  If not provided will use the current component as anchor.\n   */\n  reference?: ReferenceElement\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { watchPostEffect } from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectPopperRootContext } from './PopperRoot.vue'\n\nconst props = defineProps<PopperAnchorProps>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst rootContext = injectPopperRootContext()\n\nwatchPostEffect(() => {\n  rootContext.onAnchorChange(props.reference ?? currentElement.value)\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nexport interface ComboboxAnchorProps extends PopperAnchorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport type { PopperAnchorProps } from '@/Popper'\nimport { PopperAnchor } from '@/Popper'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\ndefineProps<ComboboxAnchorProps>()\n\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <PopperAnchor\n    as-child\n    :reference=\"reference\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      v-bind=\"$attrs\"\n    >\n      <slot />\n    </Primitive>\n  </PopperAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '../useForwardExpose'\n\nexport interface ArrowProps extends PrimitiveProps {\n  /**\n   * The width of the arrow in pixels.\n   *\n   * @defaultValue 10\n   */\n  width?: number\n  /**\n   * The height of the arrow in pixels.\n   *\n   * @defaultValue 5\n   */\n  height?: number\n  /**\n   * When `true`, render the rounded version of arrow. Do not work with `as`/`asChild`\n   *\n   * @defaultValue false\n   */\n  rounded?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<ArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :width=\"width\"\n    :height=\"height\"\n    :viewBox=\"asChild ? undefined : '0 0 12 6'\"\n    :preserveAspectRatio=\"asChild ? undefined : 'none'\"\n  >\n    <slot>\n      <path\n        v-if=\"!rounded\"\n        d=\"M0 0L6 6L12 0\"\n      />\n      <path\n        v-else\n        d=\"M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0\"\n      />\n    </slot>\n  </Primitive>\n</template>\n", "import type { Middleware, Placement } from '@floating-ui/vue'\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const\n\nexport type Side = (typeof SIDE_OPTIONS)[number]\nexport type Align = (typeof ALIGN_OPTIONS)[number]\n\nexport function isNotNull<T>(value: T | null): value is T {\n  return value !== null\n}\n\nexport function transformOrigin(options: {\n  arrowWidth: number\n  arrowHeight: number\n}): Middleware {\n  return {\n    name: 'transformOrigin',\n    options,\n    fn(data) {\n      const { placement, rects, middlewareData } = data\n\n      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0\n      const isArrowHidden = cannotCenterArrow\n      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth\n      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight\n\n      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement)\n      const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[\n        placedAlign\n      ]\n\n      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2\n      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2\n\n      let x = ''\n      let y = ''\n\n      if (placedSide === 'bottom') {\n        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`\n        y = `${-arrowHeight}px`\n      }\n      else if (placedSide === 'top') {\n        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`\n        y = `${rects.floating.height + arrowHeight}px`\n      }\n      else if (placedSide === 'right') {\n        x = `${-arrowHeight}px`\n        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`\n      }\n      else if (placedSide === 'left') {\n        x = `${rects.floating.width + arrowHeight}px`\n        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`\n      }\n      return { data: { x, y } }\n    },\n  }\n}\n\nexport function getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-')\n  return [side as Side, align as Align] as const\n}\n", "import type { MaybeElementRef } from '@vueuse/core'\nimport { unrefElement } from '@vueuse/core'\nimport { computed, onMounted, ref } from 'vue'\n\nexport function useSize(element: MaybeElementRef) {\n  const size = ref<{ width: number, height: number }>()\n  const width = computed(() => size.value?.width ?? 0)\n  const height = computed(() => size.value?.height ?? 0)\n\n  onMounted(() => {\n    const el = unrefElement(element) as HTMLElement\n    if (el) {\n      // provide size as early as possible\n      size.value = { width: el.offsetWidth, height: el.offsetHeight }\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries))\n          return\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length)\n          return\n\n        const entry = entries[0]\n        let width: number\n        let height: number\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry.borderBoxSize\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry)\n            ? borderSizeEntry[0]\n            : borderSizeEntry\n          width = borderSize.inlineSize\n          height = borderSize.blockSize\n        }\n        else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate it ourselves to get the correct border box.\n          width = el.offsetWidth\n          height = el.offsetHeight\n        }\n\n        // temporary disable width/height from resize observer. borderSizeEntry seems to be incorrect\n        size.value = { width, height }\n      })\n\n      resizeObserver.observe(el, { box: 'border-box' })\n\n      return () => resizeObserver.unobserve(el)\n    }\n    else {\n      // We only want to reset to `undefined` when the element becomes `null`,\n      // not if it changes to another element.\n      size.value = undefined\n    }\n  })\n\n  return {\n    width,\n    height,\n  }\n}\n", "<script lang=\"ts\">\nimport type {\n  Middleware,\n  Placement,\n  ReferenceElement,\n} from '@floating-ui/vue'\nimport type { Ref } from 'vue'\nimport type {\n  Align,\n  Side,\n} from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useForwardExpose, useSize } from '@/shared'\n\nexport const PopperContentPropsDefaultValue = {\n  side: 'bottom' as Side,\n  sideOffset: 0,\n  align: 'center' as Align,\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: true,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: 'partial' as 'partial' | 'always',\n  hideWhenDetached: false,\n  positionStrategy: 'fixed' as 'absolute' | 'fixed',\n  updatePositionStrategy: 'optimized' as 'optimized' | 'always',\n  prioritizePosition: false,\n}\n\nexport interface PopperContentProps extends PrimitiveProps {\n  /**\n   * The preferred side of the trigger to render against when open.\n   * Will be reversed when collisions occur and avoidCollisions\n   * is enabled.\n   *\n   * @defaultValue \"top\"\n   */\n  side?: Side\n\n  /**\n   * The distance in pixels from the trigger.\n   *\n   * @defaultValue 0\n   */\n  sideOffset?: number\n\n  /**\n   * The preferred alignment against the trigger.\n   * May change when collisions occur.\n   *\n   * @defaultValue \"center\"\n   */\n  align?: Align\n\n  /**\n   * An offset in pixels from the `start` or `end` alignment options.\n   *\n   * @defaultValue 0\n   */\n  alignOffset?: number\n\n  /**\n   * When `true`, overrides the side and align preferences\n   * to prevent collisions with boundary edges.\n   *\n   * @defaultValue true\n   */\n  avoidCollisions?: boolean\n\n  /**\n   * The element used as the collision boundary. By default\n   * this is the viewport, though you can provide additional\n   * element(s) to be included in this check.\n   *\n   * @defaultValue []\n   */\n  collisionBoundary?: Element | null | Array<Element | null>\n\n  /**\n   * The distance in pixels from the boundary edges where collision\n   * detection should occur. Accepts a number (same for all sides),\n   * or a partial padding object, for example: { top: 20, left: 20 }.\n   *\n   * @defaultValue 0\n   */\n  collisionPadding?: number | Partial<Record<Side, number>>\n\n  /**\n   * The padding between the arrow and the edges of the content.\n   * If your content has border-radius, this will prevent it from\n   * overflowing the corners.\n   *\n   * @defaultValue 0\n   */\n  arrowPadding?: number\n\n  /**\n   * The sticky behavior on the align axis. `partial` will keep the\n   * content in the boundary as long as the trigger is at least partially\n   * in the boundary whilst \"always\" will keep the content in the boundary\n   * regardless.\n   *\n   * @defaultValue \"partial\"\n   */\n  sticky?: 'partial' | 'always'\n\n  /**\n   * Whether to hide the content when the trigger becomes fully occluded.\n   *\n   * @defaultValue false\n   */\n  hideWhenDetached?: boolean\n\n  /**\n   *  The type of CSS position property to use.\n   */\n  positionStrategy?: 'absolute' | 'fixed'\n\n  /**\n   * Strategy to update the position of the floating element on every animation frame.\n   *\n   * @defaultValue 'optimized'\n   */\n  updatePositionStrategy?: 'optimized' | 'always'\n\n  /**\n   * Whether to disable the update position for the content when the layout shifted.\n   *\n   * @defaultValue false\n   */\n  disableUpdateOnLayoutShift?: boolean\n\n  /**\n   * Force content to be position within the viewport.\n   *\n   * Might overlap the reference element, which may not be desired.\n   *\n   * @defaultValue false\n   */\n  prioritizePosition?: boolean\n\n  /**\n   *  The custom element or virtual element that will be set as the reference\n   *  to position the floating element.\n   *\n   *  If provided, it will replace the default anchor element.\n   */\n  reference?: ReferenceElement\n}\n\nexport interface PopperContentContext {\n  placedSide: Ref<Side>\n  onArrowChange: (arrow: HTMLElement | undefined) => void\n  arrowX?: Ref<number>\n  arrowY?: Ref<number>\n  shouldHideArrow: Ref<boolean>\n}\n\nexport const [injectPopperContentContext, providePopperContentContext]\n  = createContext<PopperContentContext>('PopperContent')\n</script>\n\n<script setup lang=\"ts\">\nimport {\n  autoUpdate,\n  flip,\n  arrow as floatingUIarrow,\n  hide,\n  limitShift,\n  offset,\n  shift,\n  size,\n  useFloating,\n} from '@floating-ui/vue'\nimport { computedEager } from '@vueuse/core'\nimport { computed, ref, watchEffect, watchPostEffect } from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectPopperRootContext } from './PopperRoot.vue'\nimport {\n  getSideAndAlignFromPlacement,\n  isNotNull,\n  transformOrigin,\n} from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<PopperContentProps>(), {\n  ...PopperContentPropsDefaultValue,\n})\nconst emits = defineEmits<{\n  placed: [void]\n}>()\n\nconst rootContext = injectPopperRootContext()\nconst { forwardRef, currentElement: contentElement } = useForwardExpose()\n\nconst floatingRef = ref<HTMLElement>()\n\nconst arrow = ref<HTMLElement>()\nconst { width: arrowWidth, height: arrowHeight } = useSize(arrow)\n\nconst desiredPlacement = computed(\n  () =>\n    (props.side\n      + (props.align !== 'center' ? `-${props.align}` : '')) as Placement,\n)\n\nconst collisionPadding = computed(() => {\n  return typeof props.collisionPadding === 'number'\n    ? props.collisionPadding\n    : { top: 0, right: 0, bottom: 0, left: 0, ...props.collisionPadding }\n})\n\nconst boundary = computed(() => {\n  return Array.isArray(props.collisionBoundary)\n    ? props.collisionBoundary\n    : [props.collisionBoundary]\n})\n\nconst detectOverflowOptions = computed(() => {\n  return {\n    padding: collisionPadding.value,\n    boundary: boundary.value.filter(isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: boundary.value.length > 0,\n  }\n})\n\nconst computedMiddleware = computedEager(() => {\n  return [\n    offset({\n      mainAxis: props.sideOffset + arrowHeight.value,\n      alignmentAxis: props.alignOffset,\n    }),\n    props.prioritizePosition\n    && props.avoidCollisions\n    && flip({\n      ...detectOverflowOptions.value,\n    }),\n    props.avoidCollisions\n    && shift({\n      mainAxis: true,\n      crossAxis: !!props.prioritizePosition,\n      limiter: props.sticky === 'partial' ? limitShift() : undefined,\n      ...detectOverflowOptions.value,\n    }),\n    !props.prioritizePosition\n    && props.avoidCollisions\n    && flip({\n      ...detectOverflowOptions.value,\n    }),\n    size({\n      ...detectOverflowOptions.value,\n      apply: ({ elements, rects, availableWidth, availableHeight }) => {\n        const { width: anchorWidth, height: anchorHeight } = rects.reference\n        const contentStyle = elements.floating.style\n        contentStyle.setProperty(\n          '--reka-popper-available-width',\n          `${availableWidth}px`,\n        )\n        contentStyle.setProperty(\n          '--reka-popper-available-height',\n          `${availableHeight}px`,\n        )\n        contentStyle.setProperty(\n          '--reka-popper-anchor-width',\n          `${anchorWidth}px`,\n        )\n        contentStyle.setProperty(\n          '--reka-popper-anchor-height',\n          `${anchorHeight}px`,\n        )\n      },\n    }),\n    arrow.value\n    && floatingUIarrow({ element: arrow.value, padding: props.arrowPadding }),\n    transformOrigin({\n      arrowWidth: arrowWidth.value,\n      arrowHeight: arrowHeight.value,\n    }),\n    props.hideWhenDetached\n    && hide({ strategy: 'referenceHidden', ...detectOverflowOptions.value }),\n  ] as Middleware[]\n})\n\n// If provided custom reference, it will overwrite the default anchor element\nconst reference = computed(() => props.reference ?? rootContext.anchor.value)\n\nconst { floatingStyles, placement, isPositioned, middlewareData, update } = useFloating(\n  reference,\n  floatingRef,\n  {\n    strategy: props.positionStrategy,\n    placement: desiredPlacement,\n    whileElementsMounted: (...args) => {\n      const cleanup = autoUpdate(...args, {\n        layoutShift: !props.disableUpdateOnLayoutShift,\n        animationFrame: props.updatePositionStrategy === 'always',\n      })\n      return cleanup\n    },\n    middleware: computedMiddleware,\n  },\n)\n\nconst placedSide = computed(\n  () => getSideAndAlignFromPlacement(placement.value)[0],\n)\nconst placedAlign = computed(\n  () => getSideAndAlignFromPlacement(placement.value)[1],\n)\n\nwatchPostEffect(() => {\n  if (isPositioned.value)\n    emits('placed')\n})\n\nconst cannotCenterArrow = computed(\n  () => middlewareData.value.arrow?.centerOffset !== 0,\n)\n\nconst contentZIndex = ref('')\nwatchEffect(() => {\n  if (contentElement.value)\n    contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex\n})\n\nconst arrowX = computed(() => middlewareData.value.arrow?.x ?? 0)\nconst arrowY = computed(() => middlewareData.value.arrow?.y ?? 0)\n\nprovidePopperContentContext({\n  placedSide,\n  onArrowChange: element => arrow.value = element,\n  arrowX,\n  arrowY,\n  shouldHideArrow: cannotCenterArrow,\n})\n</script>\n\n<template>\n  <div\n    ref=\"floatingRef\"\n    data-reka-popper-content-wrapper=\"\"\n    :style=\"{\n      ...floatingStyles,\n      transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n      minWidth: 'max-content',\n      zIndex: contentZIndex,\n      ['--reka-popper-transform-origin' as any]: [\n        middlewareData.transformOrigin?.x,\n        middlewareData.transformOrigin?.y,\n      ].join(' '),\n\n      // hide the content if using the hide middleware and should be hidden\n      // set visibility to hidden and disable pointer events so the UI behaves\n      // as if the PopperContent isn't there at all\n      ...(middlewareData.hide?.referenceHidden && {\n        visibility: 'hidden',\n        pointerEvents: 'none',\n      }),\n    }\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      v-bind=\"$attrs\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n      :data-side=\"placedSide\"\n      :data-align=\"placedAlign\"\n      :style=\"{\n        // if the PopperContent hasn't been placed yet (not all measurements done)\n        // we prevent animations so that users's animation don't kick in too early referring wrong sides\n        animation: !isPositioned ? 'none' : undefined,\n      }\"\n    >\n      <slot />\n    </Primitive>\n  </div>\n</template>\n", "<script lang=\"ts\">\nimport type { Side } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { ArrowProps } from '@/shared/component/Arrow.vue'\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n}\n\nexport interface PopperArrowProps extends ArrowProps, PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport Arrow from '@/shared/component/Arrow.vue'\nimport { injectPopperContentContext } from './PopperContent.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nwithDefaults(\n  defineProps<PopperArrowProps>(),\n  { as: 'svg' },\n)\n\nconst { forwardRef } = useForwardExpose()\nconst contentContext = injectPopperContentContext()\n\nconst baseSide = computed(() => OPPOSITE_SIDE[contentContext.placedSide.value])\n</script>\n\n<template>\n  <span\n    :ref=\"(el: HTMLElement) => {\n      contentContext.onArrowChange(el)\n      return undefined\n    }\"\n    :style=\"{\n      position: 'absolute',\n      left: contentContext.arrowX?.value ? `${contentContext.arrowX?.value}px` : undefined,\n      top: contentContext.arrowY?.value ? `${contentContext.arrowY?.value}px` : undefined,\n      [baseSide]: 0,\n      transformOrigin: {\n        top: '',\n        right: '0 0',\n        bottom: 'center 0',\n        left: '100% 0',\n      }[contentContext.placedSide.value],\n      transform: {\n        top: 'translateY(100%)',\n        right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n        bottom: `rotate(180deg)`,\n        left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n      }[contentContext.placedSide.value],\n      visibility: contentContext.shouldHideArrow.value ? 'hidden' : undefined,\n    }\"\n  >\n    <Arrow\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      :style=\"{\n        display: 'block',\n      }\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :rounded=\"rounded\"\n      :width=\"width\"\n      :height=\"height\"\n    >\n      <slot />\n    </Arrow>\n  </span>\n</template>\n", "import type { MaybeRef } from 'vue'\nimport { computed, unref } from 'vue'\n\n/**\n * Provides locale-aware string filtering functions.\n * Uses `Intl.Collator` for comparison to ensure proper Unicode handling.\n *\n * @param options - Optional collator options to customize comparison behavior.\n *   See [Intl.CollatorOptions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator/Collator#options) for details.\n * @returns An object with methods to check if a string starts with, ends with, or contains a substring.\n *\n * @example\n * const { startsWith, endsWith, contains } = useFilter();\n *\n * startsWith('hello', 'he'); // true\n * endsWith('hello', 'lo'); // true\n * contains('hello', 'ell'); // true\n */\nexport function useFilter(options?: MaybeRef<Intl.CollatorOptions>) {\n  const computedOptions = computed(() => unref(options))\n  const collator = computed(() => new Intl.Collator('en', { usage: 'search', ...computedOptions.value }))\n\n  const startsWith = (string: string, substring: string) => {\n    if (substring.length === 0)\n      return true\n\n    string = string.normalize('NFC')\n    substring = substring.normalize('NFC')\n    return collator.value.compare(string.slice(0, substring.length), substring) === 0\n  }\n\n  const endsWith = (string: string, substring: string) => {\n    if (substring.length === 0)\n      return true\n\n    string = string.normalize('NFC')\n    substring = substring.normalize('NFC')\n    return collator.value.compare(string.slice(-substring.length), substring) === 0\n  }\n\n  const contains = (string: string, substring: string) => {\n    if (substring.length === 0)\n      return true\n\n    string = string.normalize('NFC')\n    substring = substring.normalize('NFC')\n\n    let scan = 0\n    const sliceLen = substring.length\n    for (; scan + sliceLen <= string.length; scan++) {\n      const slice = string.slice(scan, scan + sliceLen)\n      if (collator.value.compare(substring, slice) === 0)\n        return true\n    }\n\n    return false\n  }\n\n  return {\n    startsWith,\n    endsWith,\n    contains,\n  }\n}\n", "import { isEqual } from 'ohash'\n\nexport function queryCheckedElement(parentEl: HTMLElement | null) {\n  return parentEl?.querySelector('[data-state=checked]') as HTMLElement | null\n}\n\nexport function valueComparator<T>(value: T | T[] | undefined, currentValue: T, comparator?: string | ((a: T, b: T) => boolean)) {\n  if (value === undefined)\n    return false\n  else if (Array.isArray(value))\n    return value.some(val => compare(val, currentValue, comparator))\n  else\n    return compare(value, currentValue, comparator)\n}\n\nexport function compare<T>(value?: T, currentValue?: T, comparator?: string | ((a: T, b: T) => boolean)) {\n  if (value === undefined || currentValue === undefined)\n    return false\n\n  if (typeof value === 'string')\n    return value === currentValue\n\n  if (typeof comparator === 'function')\n    return comparator(value, currentValue)\n\n  if (typeof comparator === 'string')\n    return value?.[comparator as keyof T] === currentValue?.[comparator as keyof T]\n\n  return isEqual(value, currentValue)\n}\n", "import { refAutoReset } from '@vueuse/shared'\nimport { getActiveElement } from './getActiveElement'\n\nexport function useTypeahead(callback?: (search: string) => void) {\n  // Reset `search` 1 second after it was last updated\n  const search = refAutoReset('', 1000)\n\n  const handleTypeaheadSearch = (key: string, items: { ref: HTMLElement, value?: any }[]) => {\n    search.value = search.value + key\n\n    if (callback) {\n      callback(key)\n    }\n    else {\n      const currentItem = getActiveElement()\n      const itemsWithTextValue = items.map(item => ({\n        ...item,\n        textValue: item.value?.textValue ?? item.ref.textContent?.trim() ?? '',\n      }))\n      const currentMatch = itemsWithTextValue.find(item => item.ref === currentItem)\n      const values = itemsWithTextValue.map(item => item.textValue)\n      const nextMatch = getNextMatch(values, search.value, currentMatch?.textValue)\n\n      const newItem = itemsWithTextValue.find(item => item.textValue === nextMatch)\n\n      if (newItem)\n        (newItem.ref as HTMLElement).focus()\n      return newItem?.ref\n    }\n  }\n\n  const resetTypeahead = () => {\n    search.value = ''\n  }\n\n  return {\n    search,\n    handleTypeaheadSearch,\n    resetTypeahead,\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nexport function wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length])\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nexport function getNextMatch(\n  values: string[],\n  search: string,\n  currentMatch?: string,\n) {\n  const isRepeated\n    = search.length > 1 && Array.from(search).every(char => char === search[0])\n  const normalizedSearch = isRepeated ? search[0] : search\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0))\n  const excludeCurrentMatch = normalizedSearch.length === 1\n  if (excludeCurrentMatch)\n    wrappedValues = wrappedValues.filter(v => v !== currentMatch)\n  const nextMatch = wrappedValues.find(value =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase()),\n  )\n  return nextMatch !== currentMatch ? nextMatch : undefined\n}\n", "import { isEqual } from 'ohash'\n\n/**\n * The function `areEqual` compares two arrays and returns true if they are equal in length and have\n * the same elements at corresponding indexes.\n * @param {any[]} arrayA - An array of any type of elements.\n * @param {any[]} arrayB - It looks like you haven't provided the value for `arrayB`. Could you please\n * provide the arrayB value so that I can assist you further?\n * @returns The function `areEqual` is returning a boolean value, either `true` if the two input arrays\n * `arrayA` and `arrayB` are equal, or `false` if they are not equal.\n */\nexport function areEqual(arrayA: any[], arrayB: any[]): boolean {\n  if (arrayA.length !== arrayB.length)\n    return false\n\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index])\n      return false\n  }\n\n  return true\n}\n\n/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk<T>(arr: T[], size: number): T[][] {\n  const result = []\n  for (let i = 0; i < arr.length; i += size)\n    result.push(arr.slice(i, i + size))\n\n  return result\n}\n\n/**\n * The function `findValuesBetween` takes an array and two values, then returns a subarray containing\n * elements between the first occurrence of the start value and the first occurrence of the end value\n * in the array.\n * @param {T[]} array - The `array` parameter is an array of values of type `T`.\n * @param {T} start - The `start` parameter is the value that marks the beginning of the range you want\n * to find in the array.\n * @param {T} end - The `end` parameter in the `findValuesBetween` function represents the end value\n * that you want to find in the array. This function will return a subarray of values that are between\n * the `start` and `end` values in the original array.\n * @returns The `findValuesBetween` function returns an array of values from the input array that are\n * between the `start` and `end` values (inclusive). If either the `start` or `end` values are not\n * found in the input array, an empty array is returned.\n */\nexport function findValuesBetween<T>(array: T[], start: T, end: T) {\n  const startIndex = array.findIndex(i => isEqual(i, start))\n  const endIndex = array.findIndex(i => isEqual(i, end))\n  if (startIndex === -1 || endIndex === -1)\n    return []\n\n  const [minIndex, maxIndex] = [startIndex, endIndex].sort((a, b) => a - b)\n\n  return array.slice(minIndex, maxIndex + 1)\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue, DataOrientation, Direction, FormFieldProps } from '@/shared/types'\nimport { usePrimitiveElement } from '@/Primitive'\nimport { getFocusIntent } from '@/RovingFocus/utils'\nimport { createContext, findValuesBetween, useDirection, useFormControl, useKbd, useTypeahead } from '@/shared'\nimport { Primitive } from '..'\n\ntype ListboxRootContext<T> = {\n  modelValue: Ref<T | Array<T> | undefined>\n  onValueChange: (val: T) => void\n  multiple: Ref<boolean>\n  orientation: Ref<DataOrientation>\n  dir: Ref<Direction>\n  disabled: Ref<boolean>\n  highlightOnHover: Ref<boolean>\n  highlightedElement: Ref<HTMLElement | null>\n  isVirtual: Ref<boolean>\n  virtualFocusHook: EventHook<Event | null | undefined>\n  virtualKeydownHook: EventHook<KeyboardEvent>\n  virtualHighlightHook: EventHook<any>\n  by?: string | ((a: T, b: T) => boolean)\n  firstValue?: Ref<T | undefined>\n  selectionBehavior?: Ref<'toggle' | 'replace'>\n\n  focusable: Ref<boolean>\n\n  onLeave: (event: Event) => void\n  onEnter: (event: Event) => void\n  changeHighlight: (el: HTMLElement, scrollIntoView?: boolean) => void\n  onKeydownNavigation: (event: KeyboardEvent) => void\n  onKeydownEnter: (event: KeyboardEvent) => void\n  onKeydownTypeAhead: (event: KeyboardEvent) => void\n  onCompositionStart: () => void\n  onCompositionEnd: () => void\n  highlightFirstItem: () => void\n}\n\nexport const [injectListboxRootContext, provideListboxRootContext]\n  = createContext<ListboxRootContext<AcceptableValue>>('ListboxRoot')\n\nexport interface ListboxRootProps<T = AcceptableValue> extends PrimitiveProps, FormFieldProps {\n  /** The controlled value of the listbox. Can be binded with with `v-model`. */\n  modelValue?: T | Array<T>\n  /** The value of the listbox when initially rendered. Use when you do not need to control the state of the Listbox */\n  defaultValue?: T | Array<T>\n  /** Whether multiple options can be selected or not. */\n  multiple?: boolean\n  /** The orientation of the listbox. <br>Mainly so arrow navigation is done accordingly (left & right vs. up & down) */\n  orientation?: DataOrientation\n  /** The reading direction of the listbox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** When `true`, prevents the user from interacting with listbox */\n  disabled?: boolean\n  /**\n   * How multiple selection should behave in the collection.\n   * @defaultValue 'toggle'\n   */\n  selectionBehavior?: 'toggle' | 'replace'\n  /** When `true`, hover over item will trigger highlight */\n  highlightOnHover?: boolean\n  /** Use this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared. */\n  by?: string | ((a: T, b: T) => boolean)\n}\n\nexport type ListboxRootEmits<T = AcceptableValue> = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [value: T]\n  /** Event handler when highlighted element changes. */\n  'highlight': [payload: { ref: HTMLElement, value: T } | undefined]\n  /** Event handler called when container is being focused. Can be prevented. */\n  'entryFocus': [event: CustomEvent]\n  /** Event handler called when the mouse leave the container */\n  'leave': [event: Event]\n}\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport type { EventHook } from '@vueuse/core'\nimport type { Ref } from 'vue'\nimport { createEventHook, useVModel } from '@vueuse/core'\nimport { nextTick, ref, toRefs, watch } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\nimport { compare } from './utils'\n\nconst props = withDefaults(defineProps<ListboxRootProps>(), {\n  selectionBehavior: 'toggle',\n  orientation: 'vertical',\n})\nconst emits = defineEmits<ListboxRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current active value */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { multiple, highlightOnHover, orientation, disabled, selectionBehavior, dir: propDir } = toRefs(props)\nconst { getItems } = useCollection<{ value: T }>({ isProvider: true })\nconst { handleTypeaheadSearch } = useTypeahead()\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst kbd = useKbd()\nconst dir = useDirection(propDir)\n\nconst isFormControl = useFormControl(currentElement)\n\nconst firstValue = ref<T>()\nconst isUserAction = ref(false)\nconst focusable = ref(true)\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? (multiple.value ? [] : undefined),\n  passive: (props.modelValue === undefined) as false,\n  deep: true,\n}) as Ref<T | T[] | undefined>\n\nfunction onValueChange(val: T) {\n  isUserAction.value = true\n  if (props.multiple) {\n    const modelArray = Array.isArray(modelValue.value) ? [...modelValue.value] : []\n    const index = modelArray.findIndex(i => compare(i, val, props.by))\n    if (props.selectionBehavior === 'toggle') {\n      index === -1 ? modelArray.push(val) : modelArray.splice(index, 1)\n      modelValue.value = modelArray\n    }\n    else {\n      modelValue.value = [val]\n      firstValue.value = val\n    }\n  }\n  else {\n    if (props.selectionBehavior === 'toggle') {\n      if (compare(modelValue.value, val, props.by))\n        modelValue.value = undefined\n      else\n        modelValue.value = val\n    }\n    else {\n      modelValue.value = val\n    }\n  }\n  setTimeout(() => {\n    isUserAction.value = false\n  }, 1)\n}\n\nconst highlightedElement = ref<HTMLElement | null>(null)\nconst previousElement = ref<HTMLElement | null>(null)\nconst isVirtual = ref(false)\nconst isComposing = ref(false)\nconst virtualFocusHook = createEventHook<Event | null | undefined>()\nconst virtualKeydownHook = createEventHook<KeyboardEvent>()\nconst virtualHighlightHook = createEventHook<T>()\n\nfunction getCollectionItem() {\n  return getItems().map(i => i.ref).filter(i => i.dataset.disabled !== '')\n}\n\nfunction changeHighlight(el: HTMLElement, scrollIntoView = true) {\n  if (!el)\n    return\n\n  highlightedElement.value = el\n  if (focusable.value)\n    highlightedElement.value.focus()\n  if (scrollIntoView)\n    highlightedElement.value.scrollIntoView({ block: 'nearest' })\n\n  const highlightedItem = getItems().find(i => i.ref === el)\n  emits('highlight', highlightedItem)\n}\n\nfunction highlightItem(value: T) {\n  if (isVirtual.value) {\n    virtualHighlightHook.trigger(value)\n  }\n  else {\n    const item = getItems().find(i => compare(i.value, value, props.by))\n    if (item) {\n      highlightedElement.value = item.ref\n      changeHighlight(item.ref)\n    }\n  }\n}\n\nfunction onKeydownEnter(event: KeyboardEvent) {\n  if (highlightedElement.value && highlightedElement.value.isConnected) {\n    event.preventDefault()\n    event.stopPropagation()\n\n    if (!isComposing.value) {\n      highlightedElement.value.click()\n    }\n  }\n}\n\nfunction onKeydownTypeAhead(event: KeyboardEvent) {\n  if (!focusable.value)\n    return\n  isUserAction.value = true\n  if (isVirtual.value) {\n    virtualKeydownHook.trigger(event)\n  }\n  else {\n    const isMetaKey = event.altKey || event.ctrlKey || event.metaKey\n\n    if (isMetaKey && event.key === 'a' && multiple.value) {\n      const collection = getItems()\n      const values = collection.map(i => i.value)\n      modelValue.value = [...values]\n      event.preventDefault()\n      changeHighlight(collection[collection.length - 1].ref)\n    }\n    else if (!isMetaKey) {\n      const el = handleTypeaheadSearch(event.key, getItems())\n      if (el)\n        changeHighlight(el)\n    }\n  }\n  setTimeout(() => {\n    isUserAction.value = false\n  }, 1)\n}\n\nfunction onCompositionStart() {\n  isComposing.value = true\n}\nfunction onCompositionEnd() {\n  requestAnimationFrame(() => {\n    isComposing.value = false\n  })\n}\n\nfunction highlightFirstItem() {\n  nextTick(() => {\n    const event = new KeyboardEvent('keydown', { key: 'PageUp' })\n    onKeydownNavigation(event)\n  })\n}\n\nfunction onLeave(event: Event) {\n  const el = highlightedElement.value\n\n  if ((el as Node)?.isConnected) {\n    previousElement.value = el\n  }\n\n  highlightedElement.value = null\n  emits('leave', event)\n}\n\nfunction onEnter(event: Event) {\n  const entryFocusEvent = new CustomEvent('listbox.entryFocus', { bubbles: false, cancelable: true })\n  event.currentTarget?.dispatchEvent(entryFocusEvent)\n  emits('entryFocus', entryFocusEvent)\n\n  if (entryFocusEvent.defaultPrevented)\n    return\n\n  if (previousElement.value) {\n    changeHighlight(previousElement.value)\n  }\n  else {\n    const el = getCollectionItem()?.[0]\n    changeHighlight(el)\n  }\n}\n\nfunction onKeydownNavigation(event: KeyboardEvent) {\n  const intent = getFocusIntent(event, orientation.value, dir.value)\n  if (!intent)\n    return\n\n  let collection = getCollectionItem()\n  if (highlightedElement.value) {\n    if (intent === 'last') {\n      collection.reverse()\n    }\n    else if (intent === 'prev' || intent === 'next') {\n      if (intent === 'prev')\n        collection.reverse()\n\n      const currentIndex = collection.indexOf(highlightedElement.value)\n      collection = collection.slice(currentIndex + 1)\n    }\n    handleMultipleReplace(event, collection[0])\n  }\n\n  if (collection.length) {\n    const index = !highlightedElement.value && intent === 'prev' ? collection.length - 1 : 0\n    changeHighlight(collection[index])\n  }\n\n  if (isVirtual.value)\n    return virtualKeydownHook.trigger(event)\n}\n\nfunction handleMultipleReplace(event: KeyboardEvent, targetEl: HTMLElement) {\n  if (isVirtual.value || props.selectionBehavior !== 'replace' || !multiple.value || !Array.isArray(modelValue.value))\n    return\n  const isMetaKey = event.altKey || event.ctrlKey || event.metaKey\n  if (isMetaKey && !event.shiftKey)\n    return\n\n  if (event.shiftKey) {\n    const collection = getItems().filter(i => i.ref.dataset.disabled !== '')\n    let lastValue = collection.find(i => i.ref === targetEl)?.value\n\n    if (event.key === kbd.END)\n      lastValue = collection[collection.length - 1].value\n    else if (event.key === kbd.HOME)\n      lastValue = collection[0].value\n\n    if (!lastValue || !firstValue.value)\n      return\n\n    const values = findValuesBetween(collection.map(i => i.value), firstValue.value, lastValue)\n    modelValue.value = values\n  }\n}\n\nasync function highlightSelected(event?: Event) {\n  await nextTick()\n  if (isVirtual.value) {\n    // Trigger on nextTick for Virtualizer to be mounted\n    virtualFocusHook.trigger(event)\n  }\n  else {\n    const collection = getCollectionItem()\n    const item = collection.find(i => i.dataset.state === 'checked')\n    if (item)\n      changeHighlight(item)\n    else if (collection.length)\n      changeHighlight(collection[0])\n  }\n}\n\n// watch for only programmatic changes\nwatch(modelValue, () => {\n  if (!isUserAction.value) {\n    nextTick(() => {\n      highlightSelected()\n    })\n  }\n}, { immediate: true, deep: true })\n\ndefineExpose({\n  highlightedElement,\n  highlightItem,\n  highlightFirstItem,\n  highlightSelected,\n  getItems,\n})\n\nprovideListboxRootContext({\n  modelValue,\n  // @ts-expect-error ignoring\n  onValueChange,\n  multiple,\n  orientation,\n  dir,\n  disabled,\n  highlightOnHover,\n  highlightedElement,\n  isVirtual,\n  virtualFocusHook,\n  virtualKeydownHook,\n  virtualHighlightHook,\n  by: props.by,\n  firstValue,\n  selectionBehavior,\n\n  focusable,\n  onLeave,\n  onEnter,\n  changeHighlight,\n  onKeydownEnter,\n  onKeydownNavigation,\n  onKeydownTypeAhead,\n  onCompositionStart,\n  onCompositionEnd,\n  highlightFirstItem,\n})\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :dir=\"dir\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    @pointerleave=\"onLeave\"\n    @focusout=\"async (event: FocusEvent) => {\n      const target = (event.relatedTarget || event.target) as HTMLElement | null\n      await nextTick()\n      if (highlightedElement && currentElement && !currentElement.contains(target)) {\n        onLeave(event)\n      }\n    }\"\n  >\n    <slot :model-value=\"modelValue\" />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name\"\n      :name=\"name\"\n      :value=\"modelValue\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { ListboxRootProps } from '@/Listbox'\nimport type { AcceptableValue, GenericComponentInstance } from '@/shared/types'\nimport { usePrimitiveElement } from '@/Primitive'\nimport { createContext, useDirection, useFilter } from '@/shared'\n\ntype ComboboxRootContext<T> = {\n  modelValue: Ref<T | Array<T>>\n  multiple: Ref<boolean>\n  disabled: Ref<boolean>\n  open: Ref<boolean>\n  onOpenChange: (value: boolean) => void\n  isUserInputted: Ref<boolean>\n  isVirtual: Ref<boolean>\n  contentId: string\n  inputElement: Ref<HTMLInputElement | undefined>\n  onInputElementChange: (el: HTMLInputElement) => void\n  triggerElement: Ref<HTMLElement | undefined>\n  onTriggerElementChange: (el: HTMLElement) => void\n  highlightedElement: Ref<HTMLElement | undefined>\n  parentElement: Ref<HTMLElement | undefined>\n  resetSearchTermOnSelect: Ref<boolean>\n  onResetSearchTerm: EventHookOn\n  allItems: Ref<Map<string, string>>\n  allGroups: Ref<Map<string, Set<string>>>\n  filterSearch: Ref<string>\n  filterState: ComputedRef<{ count: number, items: Map<string, number>, groups: Set<string> }>\n  ignoreFilter: Ref<boolean>\n}\n\nexport const [injectComboboxRootContext, provideComboboxRootContext]\n  = createContext<ComboboxRootContext<AcceptableValue>>('ComboboxRoot')\n\nexport type ComboboxRootEmits<T = AcceptableValue> = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [value: T]\n  /** Event handler when highlighted element changes. */\n  'highlight': [payload: { ref: HTMLElement, value: T } | undefined]\n  /** Event handler called when the open state of the combobox changes. */\n  'update:open': [value: boolean]\n}\n\nexport interface ComboboxRootProps<T = AcceptableValue> extends Omit<ListboxRootProps<T>, 'orientation' | 'selectionBehavior'> {\n  /** The controlled open state of the Combobox. Can be binded with with `v-model:open`. */\n  open?: boolean\n  /** The open state of the combobox when it is initially rendered. <br> Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n  /**\n   * Whether to reset the searchTerm when the Combobox input blurred\n   * @defaultValue `true`\n   */\n  resetSearchTermOnBlur?: boolean\n  /**\n   * Whether to reset the searchTerm when the Combobox value is selected\n   * @defaultValue `true`\n   */\n  resetSearchTermOnSelect?: boolean\n  /**\n   * When `true`, disable the default filters\n   */\n  ignoreFilter?: boolean\n}\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport type { EventHookOn } from '@vueuse/core'\nimport { createEventHook, useVModel } from '@vueuse/core'\nimport { computed, getCurrentInstance, nextTick, onMounted, ref, toRefs } from 'vue'\nimport { ListboxRoot } from '@/Listbox'\nimport { PopperRoot } from '@/Popper'\n\nconst props = withDefaults(defineProps<ComboboxRootProps<T>>(), {\n  open: undefined,\n  resetSearchTermOnBlur: true,\n  resetSearchTermOnSelect: true,\n})\nconst emits = defineEmits<ComboboxRootEmits<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n    /** Current active value */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { primitiveElement, currentElement: parentElement } = usePrimitiveElement<GenericComponentInstance<typeof ListboxRoot>>()\nconst { multiple, disabled, ignoreFilter, resetSearchTermOnSelect, dir: propDir } = toRefs(props)\n\nconst dir = useDirection(propDir)\n\nconst modelValue = useVModel(props as ComboboxRootProps<T>, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? (multiple.value ? [] : undefined),\n  passive: (props.modelValue === undefined) as false,\n  deep: true,\n}) as Ref<T | T[]>\n\nconst open = useVModel(props, 'open', emits, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nasync function onOpenChange(val: boolean) {\n  open.value = val\n  filterSearch.value = ''\n\n  if (val) {\n    // make sure dom is ready then only highlight the selected\n    await nextTick()\n    primitiveElement.value?.highlightSelected()\n    isUserInputted.value = true\n  }\n  else {\n    isUserInputted.value = false\n  }\n\n  inputElement.value?.focus()\n  setTimeout(() => {\n    if (!val && props.resetSearchTermOnBlur)\n      resetSearchTerm.trigger()\n  }, 1)\n}\n\nconst resetSearchTerm = createEventHook()\nconst isUserInputted = ref(false)\nconst isVirtual = ref(false)\nconst inputElement = ref<HTMLInputElement>()\nconst triggerElement = ref<HTMLElement>()\n\nconst highlightedElement = computed(() => primitiveElement.value?.highlightedElement ?? undefined)\n\nconst allItems = ref<Map<string, string>>(new Map())\nconst allGroups = ref<Map<string, Set<string>>>(new Map())\n\nconst { contains } = useFilter({ sensitivity: 'base' })\n\nconst filterSearch = ref('')\n\nconst filterState = computed<{\n  count: number\n  items: Map<string, number>\n  groups: Set<string>\n}>((oldValue) => {\n  if (!filterSearch.value || props.ignoreFilter || isVirtual.value) {\n    // Do nothing, each item will know to show itself because search is empty\n    return {\n      count: allItems.value.size,\n      items: oldValue?.items ?? new Map(),\n      groups: oldValue?.groups ?? new Set(allGroups.value.keys()),\n    }\n  }\n\n  let itemCount = 0\n  const filteredItems = new Map<string, number>()\n  const filteredGroups = new Set<string>()\n\n  // Check which items should be included\n  for (const [id, value] of allItems.value) {\n    const score = contains(value, filterSearch.value)\n    filteredItems.set(id, score ? 1 : 0)\n    if (score)\n      itemCount++\n  }\n\n  // Check which groups have at least 1 item shown\n  for (const [groupId, group] of allGroups.value) {\n    for (const itemId of group) {\n      if (filteredItems.get(itemId)! > 0) {\n        filteredGroups.add(groupId)\n        break\n      }\n    }\n  }\n\n  return {\n    count: itemCount,\n    items: filteredItems,\n    groups: filteredGroups,\n  }\n})\n\nconst inst = getCurrentInstance()\nonMounted(() => {\n  if (inst?.exposed) {\n    inst.exposed.highlightItem = primitiveElement.value?.highlightItem\n    inst.exposed.highlightFirstItem = primitiveElement.value?.highlightFirstItem\n    inst.exposed.highlightSelected = primitiveElement.value?.highlightSelected\n  }\n})\n\ndefineExpose({\n  filtered: filterState,\n  highlightedElement,\n  highlightItem: primitiveElement.value?.highlightItem,\n  highlightFirstItem: primitiveElement.value?.highlightFirstItem,\n  highlightSelected: primitiveElement.value?.highlightSelected,\n})\n\nprovideComboboxRootContext({\n  modelValue,\n  multiple,\n  disabled,\n  open,\n  onOpenChange,\n  contentId: '',\n  isUserInputted,\n  isVirtual,\n  inputElement,\n  highlightedElement,\n  onInputElementChange: val => inputElement.value = val,\n  triggerElement,\n  onTriggerElementChange: val => triggerElement.value = val,\n  parentElement,\n  resetSearchTermOnSelect,\n  onResetSearchTerm: resetSearchTerm.on,\n  allItems,\n  allGroups,\n  filterSearch,\n  filterState,\n  ignoreFilter,\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <ListboxRoot\n      ref=\"primitiveElement\"\n      v-bind=\"$attrs\"\n      v-model=\"modelValue\"\n      :style=\"{\n        pointerEvents: open ? 'auto' : undefined,\n      }\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :dir=\"dir\"\n      :multiple=\"multiple\"\n      :name=\"name\"\n      :required=\"required\"\n      :disabled=\"disabled\"\n      :highlight-on-hover=\"true\"\n      :by=\"props.by as any\"\n      @highlight=\"emits('highlight', $event as any)\"\n    >\n      <slot\n        :open=\"open\"\n        :model-value=\"modelValue\"\n      />\n    </ListboxRoot>\n  </PopperRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '..'\nimport { refAutoReset } from '@vueuse/shared'\nimport { Primitive } from '..'\nimport { injectListboxRootContext } from './ListboxRoot.vue'\n\nexport interface ListboxContentProps extends PrimitiveProps { }\n</script>\n\n<script setup lang=\"ts\">\nimport { useCollection } from '@/Collection'\n\ndefineProps<ListboxContentProps>()\n\nconst { CollectionSlot } = useCollection()\nconst rootContext = injectListboxRootContext()\n\nconst isClickFocus = refAutoReset(false, 10)\n</script>\n\n<template>\n  <CollectionSlot>\n    <Primitive\n      role=\"listbox\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :tabindex=\"rootContext.focusable.value ? rootContext.highlightedElement.value ? '-1' : '0' : undefined\"\n      :aria-orientation=\"rootContext.orientation.value\"\n      :aria-multiselectable=\"!!rootContext.multiple.value\"\n      :data-orientation=\"rootContext.orientation.value\"\n      @mousedown.left=\"isClickFocus = true\"\n      @focus=\"(ev) => {\n        if (isClickFocus)\n          return\n        rootContext.onEnter(ev)\n      }\"\n      @keydown.down.up.left.right.home.end.prevent=\"(event) => {\n        rootContext.focusable.value ? rootContext.onKeydownNavigation(event) : undefined\n      }\"\n      @keydown.enter=\"rootContext.onKeydownEnter\"\n      @keydown=\"rootContext.onKeydownTypeAhead\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { DismissableLayerEmits, DismissableLayerProps } from '@/DismissableLayer'\nimport type { PopperContentProps } from '@/Popper'\n\nimport { createContext, useForwardExpose, useForwardProps, useHideOthers } from '@/shared'\nimport { useBodyScrollLock } from '@/shared/useBodyScrollLock'\n\nexport type ComboboxContentImplEmits = DismissableLayerEmits\n\nexport interface ComboboxContentImplProps extends PopperContentProps, DismissableLayerProps {\n  /**\n   * The positioning mode to use, <br>\n   * `inline` is the default and you can control the position using CSS. <br>\n   * `popper` positions content in the same way as our other primitives, for example `Popover` or `DropdownMenu`.\n   */\n  position?: 'inline' | 'popper'\n  /** The document.body will be lock, and scrolling will be disabled. */\n  bodyLock?: boolean\n}\n\nexport const [injectComboboxContentContext, provideComboboxContentContext]\n  = createContext<{\n    position: Ref<'inline' | 'popper'>\n  }>('ComboboxContent')\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, onUnmounted, ref, toRefs } from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { ListboxContent } from '@/Listbox'\nimport { PopperContent } from '@/Popper'\nimport { Primitive } from '@/Primitive'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = withDefaults(defineProps<ComboboxContentImplProps>(), {\n  position: 'inline',\n})\nconst emits = defineEmits<ComboboxContentImplEmits>()\n\nconst { position } = toRefs(props)\nconst rootContext = injectComboboxRootContext()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nuseBodyScrollLock(props.bodyLock)\nuseHideOthers(rootContext.parentElement)\n\nconst pickedProps = computed(() => {\n  if (props.position === 'popper')\n    return props\n  else return {}\n})\n\nconst forwardedProps = useForwardProps(pickedProps.value)\n\nconst popperStyle = {\n  // Ensure border-box for floating-ui calculations\n  'boxSizing': 'border-box',\n  '--reka-combobox-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n  '--reka-combobox-content-available-width':\n        'var(--reka-popper-available-width)',\n  '--reka-combobox-content-available-height':\n        'var(--reka-popper-available-height)',\n  '--reka-combobox-trigger-width': 'var(--reka-popper-anchor-width)',\n  '--reka-combobox-trigger-height': 'var(--reka-popper-anchor-height)',\n}\n\nprovideComboboxContentContext({ position })\n\n// Handle case where input position within the content\nconst isInputWithinContent = ref(false)\nonMounted(() => {\n  if (rootContext.inputElement.value) {\n    isInputWithinContent.value = currentElement.value.contains(rootContext.inputElement.value)\n    if (isInputWithinContent.value) {\n      rootContext.inputElement.value.focus()\n    }\n  }\n})\n\nonUnmounted(() => {\n  if (isInputWithinContent.value) {\n    rootContext.triggerElement.value?.focus()\n  }\n})\n</script>\n\n<template>\n  <ListboxContent as-child>\n    <DismissableLayer\n      as-child\n      :disable-outside-pointer-events=\"disableOutsidePointerEvents\"\n      @dismiss=\"rootContext.onOpenChange(false)\"\n      @focus-outside=\"(ev) => {\n        // if clicking inside the combobox, prevent dismiss\n        if (rootContext.parentElement.value?.contains(ev.target as Node)) ev.preventDefault()\n        emits('focusOutside', ev)\n      }\"\n      @interact-outside=\"emits('interactOutside', $event)\"\n      @escape-key-down=\"emits('escapeKeyDown', $event)\"\n      @pointer-down-outside=\"(ev) => {\n        // if clicking inside the combobox, prevent dismiss\n        if (rootContext.parentElement.value?.contains(ev.target as Node)) ev.preventDefault()\n        emits('pointerDownOutside', ev)\n      }\"\n    >\n      <component\n        :is=\"position === 'popper' ? PopperContent : Primitive\"\n        v-bind=\"{ ...$attrs, ...forwardedProps }\"\n        :id=\"rootContext.contentId\"\n        :ref=\"forwardRef\"\n        :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n        :style=\"{\n          // flex layout so we can place the scroll buttons properly\n          display: 'flex',\n          flexDirection: 'column',\n          // reset the outline by default as the content MAY get focused\n          outline: 'none',\n          ...(position === 'popper' ? popperStyle : {}),\n        }\"\n      >\n        <slot />\n      </component>\n    </DismissableLayer>\n  </ListboxContent>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperArrowProps } from '@/Popper'\n\nexport interface ComboboxArrowProps extends PopperArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperArrow } from '@/Popper'\nimport { useForwardExpose } from '@/shared'\nimport { injectComboboxContentContext } from './ComboboxContentImpl.vue'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = withDefaults(defineProps<ComboboxArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nconst rootContext = injectComboboxRootContext()\nconst contentContext = injectComboboxContentContext()\n\nuseForwardExpose()\n</script>\n\n<template>\n  <PopperArrow\n    v-if=\"rootContext.open.value && contentContext.position.value === 'popper'\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </PopperArrow>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface ComboboxCancelProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = withDefaults(defineProps<ComboboxCancelProps>(), {\n  as: 'button',\n})\n\nuseForwardExpose()\nconst rootContext = injectComboboxRootContext()\n\nfunction handleClick() {\n  // Reset the search to show all options.\n  rootContext.filterSearch.value = ''\n\n  if (rootContext.inputElement.value) {\n    rootContext.inputElement.value.value = ''\n    rootContext.inputElement.value.focus()\n  }\n}\n</script>\n\n<template>\n  <Primitive\n    :type=\"as === 'button' ? 'button' : undefined\"\n    v-bind=\"props\"\n    tabindex=\"-1\"\n    @click=\"handleClick\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ComboboxContentImplEmits, ComboboxContentImplProps } from './ComboboxContentImpl.vue'\n\nexport type ComboboxContentEmits = ComboboxContentImplEmits\nexport interface ComboboxContentProps extends ComboboxContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardExpose, useForwardPropsEmits, useId } from '@/shared'\nimport ComboboxContentImpl from './ComboboxContentImpl.vue'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = defineProps<ComboboxContentProps>()\nconst emits = defineEmits<ComboboxContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nconst { forwardRef } = useForwardExpose()\n\nconst rootContext = injectComboboxRootContext()\n\nrootContext.contentId ||= useId(undefined, 'reka-combobox-content')\n</script>\n\n<template>\n  <Presence :present=\"forceMount || rootContext.open.value\">\n    <ComboboxContentImpl\n      v-bind=\"{ ...forwarded, ...$attrs }\"\n      :ref=\"forwardRef\"\n    >\n      <slot />\n    </ComboboxContentImpl>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed } from 'vue'\n\nexport interface ComboboxEmptyProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = defineProps<ComboboxEmptyProps>()\nconst rootContext = injectComboboxRootContext()\n\nconst isRender = computed(() => rootContext.ignoreFilter.value\n  ? rootContext.allItems.value.size === 0\n  : rootContext.filterState.value.count === 0,\n)\n</script>\n\n<template>\n  <Primitive\n    v-if=\"isRender\"\n    v-bind=\"props\"\n  >\n    <slot>No options</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useId } from '@/shared'\n\nexport interface ListboxGroupProps extends PrimitiveProps {}\n\ninterface ListboxGroupContext {\n  id: string\n}\n\nexport const [injectListboxGroupContext, provideListboxGroupContext]\n  = createContext<ListboxGroupContext>('ListboxGroup')\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<ListboxGroupProps>()\n\nconst id = useId(undefined, 'reka-listbox-group')\nprovideListboxGroupContext({ id })\n</script>\n\n<template>\n  <Primitive\n    role=\"group\"\n    v-bind=\"props\"\n    :aria-labelledby=\"id\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ListboxGroupProps } from '@/Listbox'\nimport { computed, onMounted, onUnmounted } from 'vue'\nimport { createContext, useId } from '@/shared'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nexport interface ComboboxGroupProps extends ListboxGroupProps {}\n\ntype ComboboxGroupContext = {\n  id: string\n  labelId: string\n}\n\nexport const [injectComboboxGroupContext, provideComboboxGroupContext]\n  = createContext<ComboboxGroupContext>('ComboboxGroup')\n</script>\n\n<script setup lang=\"ts\">\nimport { ListboxGroup } from '@/Listbox'\n\nconst props = defineProps<ComboboxGroupProps>()\nconst id = useId(undefined, 'reka-combobox-group')\nconst rootContext = injectComboboxRootContext()\n\nconst isRender = computed(() => rootContext.ignoreFilter.value ? true : !rootContext.filterSearch.value ? true : rootContext.filterState.value.groups.has(id))\n\nconst context = provideComboboxGroupContext({\n  id,\n  labelId: '',\n})\n\nonMounted(() => {\n  if (!rootContext.allGroups.value.has(id))\n    rootContext.allGroups.value.set(id, new Set())\n})\nonUnmounted(() => {\n  rootContext.allGroups.value.delete(id)\n})\n</script>\n\n<template>\n  <ListboxGroup\n    :id=\"id\"\n    :aria-labelledby=\"context.labelId\"\n    v-bind=\"props\"\n    :hidden=\"isRender ? undefined : true\"\n  >\n    <slot />\n  </ListboxGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '..'\nimport { useVModel } from '@vueuse/core'\nimport { computed, onMounted, onUnmounted, ref, watchSyncEffect } from 'vue'\nimport { usePrimitiveElement } from '@/Primitive'\nimport { Primitive } from '..'\nimport { injectListboxRootContext } from './ListboxRoot.vue'\n\nexport interface ListboxFilterProps extends PrimitiveProps {\n  /** The controlled value of the filter. Can be binded with with v-model. */\n  modelValue?: string\n  /** Focus on element when mounted. */\n  autoFocus?: boolean\n  /** When `true`, prevents the user from interacting with item */\n  disabled?: boolean\n}\n\nexport type ListboxFilterEmits = {\n  'update:modelValue': [string]\n}\n</script>\n\n<script setup lang=\"ts\">\nconst props = withDefaults(defineProps<ListboxFilterProps>(), {\n  as: 'input',\n})\nconst emits = defineEmits<ListboxFilterEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: '',\n  passive: (props.modelValue === undefined) as false,\n})\n\nconst rootContext = injectListboxRootContext()\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst disabled = computed(() => props.disabled || rootContext.disabled.value || false)\n\nconst activedescendant = ref<string | undefined>()\nwatchSyncEffect(() => activedescendant.value = rootContext.highlightedElement.value?.id)\n\nonMounted(() => {\n  rootContext.focusable.value = false\n\n  setTimeout(() => {\n    // make sure all DOM was flush then only capture the focus\n    if (props.autoFocus)\n      currentElement.value?.focus()\n  }, 1)\n})\n\nonUnmounted(() => {\n  rootContext.focusable.value = true\n})\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :value=\"modelValue\"\n    :disabled=\"disabled ? '' : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :aria-disabled=\"disabled ?? undefined\"\n    :aria-activedescendant=\"activedescendant\"\n    type=\"text\"\n    @keydown.down.up.home.end.prevent=\"rootContext.onKeydownNavigation\"\n    @keydown.enter=\"rootContext.onKeydownEnter\"\n    @input=\"(event: InputEvent) => {\n      modelValue = (event.target as HTMLInputElement).value\n      rootContext.highlightFirstItem()\n    }\"\n    @compositionstart=\"rootContext.onCompositionStart\"\n    @compositionend=\"rootContext.onCompositionEnd\"\n  >\n    <slot :model-value=\"modelValue\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ListboxFilterEmits, ListboxFilterProps } from '@/Listbox'\nimport { useVModel } from '@vueuse/core'\nimport { nextTick, onMounted, watch } from 'vue'\nimport { usePrimitiveElement } from '@/Primitive'\n\nexport type ComboboxInputEmits = ListboxFilterEmits\nexport interface ComboboxInputProps extends ListboxFilterProps {\n  /** The display value of input for selected item. Does not work with `multiple`. */\n  displayValue?: (val: any) => string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { ListboxFilter } from '@/Listbox'\nimport { injectListboxRootContext } from '@/Listbox/ListboxRoot.vue'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = withDefaults(defineProps<ComboboxInputProps>(), {\n  as: 'input',\n})\nconst emits = defineEmits<ComboboxInputEmits>()\n\nconst rootContext = injectComboboxRootContext()\nconst listboxContext = injectListboxRootContext()\nconst { primitiveElement, currentElement } = usePrimitiveElement()\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  passive: (props.modelValue === undefined) as false,\n})\n\nonMounted(() => {\n  if (currentElement.value)\n    rootContext.onInputElementChange(currentElement.value as HTMLInputElement)\n})\n\nfunction handleKeyDown(ev: KeyboardEvent) {\n  if (!rootContext.open.value)\n    rootContext.onOpenChange(true)\n}\n\nfunction handleInput(event: InputEvent) {\n  const target = event.target as HTMLInputElement\n  if (!rootContext.open.value) {\n    rootContext.onOpenChange(true)\n    nextTick(() => {\n      if (target.value) {\n        rootContext.filterSearch.value = target.value\n        listboxContext.highlightFirstItem()\n      }\n    })\n  }\n  else {\n    rootContext.filterSearch.value = target.value\n  }\n}\n\nfunction resetSearchTerm() {\n  const rootModelValue = rootContext.modelValue.value\n\n  if (props.displayValue) {\n    modelValue.value = props.displayValue(rootModelValue)\n  }\n  else if (!rootContext.multiple.value && rootModelValue && !Array.isArray(rootModelValue)) {\n    if (typeof rootModelValue !== 'object')\n      modelValue.value = rootModelValue.toString()\n    else modelValue.value = ''\n  }\n  else {\n    modelValue.value = ''\n  }\n\n  nextTick(() => {\n    // Temporary force reassign\n    // eslint-disable-next-line no-self-assign\n    modelValue.value = modelValue.value\n  })\n}\n\nrootContext.onResetSearchTerm(() => {\n  resetSearchTerm()\n})\n\nwatch(rootContext.modelValue, async () => {\n  if (!rootContext.isUserInputted.value && rootContext.resetSearchTermOnSelect.value)\n    resetSearchTerm()\n}, { immediate: true, deep: true })\n\nwatch(rootContext.filterState, () => {\n  // we exclude virtualized list as the state would be constantly updated\n  if (!rootContext.isVirtual.value) {\n    listboxContext.highlightFirstItem()\n  }\n})\n</script>\n\n<template>\n  <ListboxFilter\n    ref=\"primitiveElement\"\n    v-model=\"modelValue\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :auto-focus=\"autoFocus\"\n    :aria-expanded=\"rootContext.open.value\"\n    :aria-controls=\"rootContext.contentId\"\n    aria-autocomplete=\"list\"\n    role=\"combobox\"\n    autocomplete=\"false\"\n    @input=\"handleInput\"\n    @keydown.down.up.prevent=\"handleKeyDown\"\n  >\n    <slot />\n  </ListboxFilter>\n</template>\n", "<script lang=\"ts\">\nimport { createContext, handleAndDispatchCustomEvent, useForwardExpose, useId } from '@/shared'\n\nexport interface ListboxItemProps<T = AcceptableValue> extends PrimitiveProps {\n  /** The value given as data when submitted with a `name`. */\n  value: T\n  /** When `true`, prevents the user from interacting with the item. */\n  disabled?: boolean\n}\nexport type SelectEvent<T> = CustomEvent<{ originalEvent: PointerEvent, value?: T }>\n\nexport type ListboxItemEmits<T = AcceptableValue> = {\n  /** Event handler called when the selecting item. <br> It can be prevented by calling `event.preventDefault`. */\n  select: [event: SelectEvent<T>]\n}\n\nconst LISTBOX_SELECT = 'listbox.select'\n\ninterface ListboxItemContext {\n  isSelected: Ref<boolean>\n}\n\nexport const [injectListboxItemContext, provideListboxItemContext]\n  = createContext<ListboxItemContext>('ListboxItem')\n</script>\n\n<script setup lang=\"ts\"  generic=\"T extends AcceptableValue = AcceptableValue\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '..'\nimport type { AcceptableValue } from '@/shared/types'\nimport { computed } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '..'\nimport { injectListboxRootContext } from './ListboxRoot.vue'\nimport { valueComparator } from './utils'\n\nconst props = withDefaults(defineProps<ListboxItemProps<T>>(), {\n  as: 'div',\n})\nconst emits = defineEmits<ListboxItemEmits<T>>()\n\nconst id = useId(undefined, 'reka-listbox-item')\nconst { CollectionItem } = useCollection()\nconst { forwardRef, currentElement } = useForwardExpose()\nconst rootContext = injectListboxRootContext()\n\nconst isHighlighted = computed(() => currentElement.value === rootContext.highlightedElement.value)\nconst isSelected = computed(() => valueComparator(rootContext.modelValue.value, props.value, rootContext.by))\n\nconst disabled = computed(() => rootContext.disabled.value || props.disabled)\n\nasync function handleSelect(ev: SelectEvent<T>) {\n  emits('select', ev)\n  if (ev?.defaultPrevented)\n    return\n\n  if (!disabled.value && ev) {\n    rootContext.onValueChange(props.value)\n    rootContext.changeHighlight(currentElement.value)\n  }\n}\n\nfunction handleSelectCustomEvent(ev: PointerEvent) {\n  const eventDetail = { originalEvent: ev, value: props.value as T }\n  handleAndDispatchCustomEvent(LISTBOX_SELECT, handleSelect, eventDetail)\n}\n\nprovideListboxItemContext({\n  isSelected,\n})\n</script>\n\n<template>\n  <CollectionItem :value=\"value\">\n    <Primitive\n      :id=\"id\"\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      v-memo=\"[isHighlighted, isSelected]\"\n      role=\"option\"\n      :tabindex=\"rootContext.focusable.value ? isHighlighted ? '0' : '-1' : -1\"\n      :aria-selected=\"isSelected\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :disabled=\"disabled ? '' : undefined\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :data-highlighted=\"isHighlighted ? '' : undefined\"\n      :data-state=\"isSelected ? 'checked' : 'unchecked'\"\n      @click=\"handleSelectCustomEvent\"\n      @keydown.space.prevent=\"handleSelectCustomEvent\"\n      @pointermove=\"(event) => {\n        if (rootContext.highlightedElement.value === currentElement)\n          return\n\n        if (rootContext.highlightOnHover.value)\n          rootContext.changeHighlight(currentElement, false)\n        else\n          rootContext.focusable.value ? undefined : rootContext.changeHighlight(currentElement, false)\n      }\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { ListboxItemEmits, ListboxItemProps } from '@/Listbox'\nimport type { AcceptableValue } from '@/shared/types'\nimport { computed, onMounted, onUnmounted } from 'vue'\nimport { usePrimitiveElement } from '@/Primitive'\nimport { useId } from '@/shared'\nimport { injectComboboxGroupContext } from './ComboboxGroup.vue'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nexport { injectListboxItemContext as injectComboboxItemContext } from '@/Listbox'\n\nexport type ComboboxItemEmits<T = AcceptableValue> = ListboxItemEmits<T>\nexport interface ComboboxItemProps<T = AcceptableValue> extends ListboxItemProps<T> {\n  /**\n   * A string representation of the item contents.\n   *\n   * If the children are not plain text, then the `textValue` prop must also be set to a plain text representation, which will be used for autocomplete in the ComboBox.\n   */\n  textValue?: string\n}\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport { ListboxItem } from '@/Listbox'\n\nconst props = defineProps<ComboboxItemProps<T>>()\nconst emits = defineEmits<ComboboxItemEmits<T>>()\n\nconst id = useId(undefined, 'reka-combobox-item')\nconst rootContext = injectComboboxRootContext()\nconst groupContext = injectComboboxGroupContext(null)\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\n\nif (props.value === '') {\n  throw new Error(\n    'A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.',\n  )\n}\n\nconst isRender = computed(() => {\n  if (rootContext.isVirtual.value || rootContext.ignoreFilter.value || !rootContext.filterSearch.value) {\n    return true\n  }\n  else {\n    const filteredCurrentItem = rootContext.filterState.value.items.get(id)\n    // If the filtered items is undefined means not in the all times map yet\n    // Do the first render to add into the map\n    if (filteredCurrentItem === undefined) {\n      return true\n    }\n\n    // Check with filter\n    return filteredCurrentItem > 0\n  }\n})\n\nonMounted(() => {\n  // textValue to perform filter\n  rootContext.allItems.value.set(id, props.textValue || currentElement.value.textContent || currentElement.value.innerText)\n\n  const groupId = groupContext?.id\n  if (groupId) {\n    if (!rootContext.allGroups.value.has(groupId)) {\n      rootContext.allGroups.value.set(groupId, new Set([id]))\n    }\n    else {\n      rootContext.allGroups.value.get(groupId)?.add(id)\n    }\n  }\n})\nonUnmounted(() => {\n  rootContext.allItems.value.delete(id)\n})\n</script>\n\n<template>\n  <ListboxItem\n    v-if=\"isRender\"\n    v-bind=\"props\"\n    :id=\"id\"\n    ref=\"primitiveElement\"\n    :disabled=\"rootContext.disabled.value || disabled\"\n    @select=\"(event) => {\n      emits('select', event as any)\n      if (event.defaultPrevented)\n        return\n\n      if (!rootContext.multiple.value && !disabled && !rootContext.disabled.value) {\n        event.preventDefault()\n        rootContext.onOpenChange(false)\n        rootContext.modelValue.value = props.value\n      }\n    }\"\n  >\n    <slot>{{ value }}</slot>\n  </ListboxItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ListboxItemIndicatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectListboxItemContext } from './ListboxItem.vue'\n\nconst props = withDefaults(defineProps<ListboxItemIndicatorProps>(), {\n  as: 'span',\n})\n\nuseForwardExpose()\nconst itemContext = injectListboxItemContext()\n</script>\n\n<template>\n  <Primitive\n    v-if=\"itemContext.isSelected.value\"\n    aria-hidden=\"true\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ListboxItemIndicatorProps } from '@/Listbox'\n\nexport interface ComboboxItemIndicatorProps extends ListboxItemIndicatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ListboxItemIndicator } from '@/Listbox'\n\nconst props = withDefaults(defineProps<ComboboxItemIndicatorProps>(), {\n  as: 'span',\n})\n</script>\n\n<template>\n  <ListboxItemIndicator\n    v-bind=\"props\"\n  >\n    <slot />\n  </ListboxItemIndicator>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface ComboboxLabelProps extends PrimitiveProps {\n  for?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose, useId } from '@/shared'\nimport { injectComboboxGroupContext } from './ComboboxGroup.vue'\n\nconst props = withDefaults(defineProps<ComboboxLabelProps>(), {\n  as: 'div',\n})\n\nuseForwardExpose()\nconst groupContext = injectComboboxGroupContext({ id: '', labelId: '' })\n\ngroupContext.labelId ||= useId(undefined, 'reka-combobox-group-label')\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"groupContext.labelId\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface ComboboxPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<ComboboxPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ComboboxSeparatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<ComboboxSeparatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-hidden=\"true\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface ComboboxTriggerProps extends PrimitiveProps {\n  /** When `true`, prevents the user from interacting with item */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = withDefaults(defineProps<ComboboxTriggerProps>(), {\n  as: 'button',\n})\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst rootContext = injectComboboxRootContext()\nconst disabled = computed(() => props.disabled || rootContext.disabled.value || false)\n\nonMounted(() => {\n  if (currentElement.value)\n    rootContext.onTriggerElementChange(currentElement.value)\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :ref=\"forwardRef\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    tabindex=\"-1\"\n    aria-label=\"Show popup\"\n    aria-haspopup=\"listbox\"\n    :aria-expanded=\"rootContext.open.value\"\n    :aria-controls=\"rootContext.contentId\"\n    :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n    :disabled=\"disabled\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :aria-disabled=\"disabled ?? undefined\"\n    @click=\"rootContext.onOpenChange(!rootContext.open.value)\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import type { Ref } from 'vue'\nimport { computed, ref } from 'vue'\nimport { injectConfigProviderContext } from '@/ConfigProvider/ConfigProvider.vue'\n\nexport function useNonce(nonce?: Ref<string | undefined>) {\n  const context = injectConfigProviderContext({\n    nonce: ref(),\n  })\n  return computed(() => nonce?.value || context.nonce?.value)\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { toRefs } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport { useNonce } from '@/shared/useNonce'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nexport interface ComboboxViewportProps extends PrimitiveProps {\n  /**\n   * Will add `nonce` attribute to the style tag which can be used by Content Security Policy. <br> If omitted, inherits globally from `ConfigProvider`.\n   */\n  nonce?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<ComboboxViewportProps>()\nconst { forwardRef } = useForwardExpose()\n\nconst { nonce: propNonce } = toRefs(props)\nconst nonce = useNonce(propNonce)\n\nconst rootContext = injectComboboxRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"{ ...$attrs, ...props }\"\n    :ref=\"forwardRef\"\n    data-reka-combobox-viewport\n    role=\"presentation\"\n    :style=\"{\n      // we use position: 'relative' here on the `viewport` so that when we call\n      // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n      // (independent of the scrollUpButton).\n      position: 'relative',\n      flex: rootContext.isVirtual.value ? undefined : 1,\n      overflow: 'auto',\n    }\"\n  >\n    <slot />\n  </Primitive>\n  <Primitive\n    as=\"style\"\n    :nonce=\"nonce\"\n  >\n    /* Hide scrollbars cross-browser and enable momentum scroll for touch\n    devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none;\n    -webkit-overflow-scrolling: touch; }\n    [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; }\n  </Primitive>\n</template>\n", "export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => boolean\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n\n  function memoizedFunction(): TResult {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    opts?.onChange?.(result)\n\n    return result\n  }\n\n  // Attach updateDeps to the function itself\n  memoizedFunction.updateDeps = (newDeps: [...TDeps]) => {\n    deps = newDeps\n  }\n\n  return memoizedFunction\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n", "import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string | bigint\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0]\n      if (entry?.borderBoxSize) {\n        const box = entry.borderBoxSize[0]\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize })\n          return\n        }\n      }\n      handler(element.getBoundingClientRect())\n    }\n\n    instance.options.useAnimationFrameWithResizeObserver\n      ? requestAnimationFrame(run)\n      : run()\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    const { horizontal, isRtl } = instance.options\n    offset = horizontal\n      ? element['scrollLeft'] * ((isRtl && -1) || 1)\n      : element['scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: ObserveOffsetCallBack,\n  ) => void | (() => void)\n  // Optional\n  debug?: boolean\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem>\n  lanes?: number\n  isScrollingResetDelay?: number\n  useScrollendEvent?: boolean\n  enabled?: boolean\n  isRtl?: boolean\n  useAnimationFrameWithResizeObserver?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private scrollToIndexTimeoutId: number | null = null\n  measurementsCache: Array<VirtualItem> = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          const run = () => {\n            this._measureElement(entry.target as TItemElement, entry)\n          }\n          this.options.useAnimationFrameWithResizeObserver\n            ? requestAnimationFrame(run)\n            : run()\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => {\n        get()?.disconnect()\n        _ro = null\n      },\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: false,\n      useAnimationFrameWithResizeObserver: false,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.observer.disconnect()\n    this.scrollElement = null\n    this.targetWindow = null\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.maybeNotify()\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this.elementsCache.forEach((cached) => {\n        this.observer.observe(cached)\n      })\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n          this.isScrolling = isScrolling\n\n          this.maybeNotify()\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        return []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end + this.options.gap\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [\n      this.getMeasurements(),\n      this.getSize(),\n      this.getScrollOffset(),\n      this.options.lanes,\n    ],\n    (measurements, outerSize, scrollOffset, lanes) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n              lanes,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualIndexes = memo(\n    () => {\n      let startIndex: number | null = null\n      let endIndex: number | null = null\n      const range = this.calculateRange()\n      if (range) {\n        startIndex = range.startIndex\n        endIndex = range.endIndex\n      }\n      this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex])\n      return [\n        this.options.rangeExtractor,\n        this.options.overscan,\n        this.options.count,\n        startIndex,\n        endIndex,\n      ]\n    },\n    (rangeExtractor, overscan, count, startIndex, endIndex) => {\n      return startIndex === null || endIndex === null\n        ? []\n        : rangeExtractor({\n            startIndex,\n            endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const index = this.indexFromElement(node)\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const key = item.key\n    const prevNode = this.elementsCache.get(key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(key, node)\n    }\n\n    if (node.isConnected) {\n      this.resizeItem(index, this.options.measureElement(node, entry, this))\n    }\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      this.elementsCache.forEach((cached, key) => {\n        if (!cached.isConnected) {\n          this.observer.unobserve(cached)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getVirtualIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualItems',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (\n    toOffset: number,\n    align: ScrollAlignment,\n    itemSize = 0,\n  ) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      align = toOffset >= scrollOffset + size ? 'end' : 'start'\n    }\n\n    if (align === 'center') {\n      // When aligning to a particular item (e.g. with scrollToIndex),\n      // adjust offset by the size of the item to center on the item\n      toOffset += (itemSize - size) / 2\n    } else if (align === 'end') {\n      toOffset -= size\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [\n      this.getOffsetForAlignment(toOffset, align, item.size),\n      align,\n    ] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n      this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const offsetAndAlign = this.getOffsetForIndex(index, initialAlign)\n    if (!offsetAndAlign) return\n\n    const [offset, align] = offsetAndAlign\n\n    this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode() && this.targetWindow) {\n      this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.elementsCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [latestOffset] = notUndefined(\n            this.getOffsetForIndex(index, align),\n          )\n\n          if (!approxEqual(latestOffset, this.getScrollOffset())) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    // If there is only one lane, use the last measurement's end\n    // Otherwise find the maximum end value among all measurements\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else if (this.options.lanes === 1) {\n      end = measurements[measurements.length - 1]?.end ?? 0\n    } else {\n      const endByLane = Array<number | null>(this.options.lanes).fill(null)\n      let endIndex = measurements.length - 1\n      while (endIndex > 0 && endByLane.some((val) => val === null)) {\n        const item = measurements[endIndex]!\n        if (endByLane[item.lane] === null) {\n          endByLane[item.lane] = item.end\n        }\n\n        endIndex--\n      }\n\n      end = Math.max(...endByLane.filter((val): val is number => val !== null))\n    }\n\n    return Math.max(\n      end - this.options.scrollMargin + this.options.paddingEnd,\n      0,\n    )\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes,\n}: {\n  measurements: Array<VirtualItem>\n  outerSize: number\n  scrollOffset: number\n  lanes: number\n}) {\n  const lastIndex = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  // handle case when item count is less than or equal to lanes\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex,\n    }\n  }\n\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset,\n  )\n  let endIndex = startIndex\n\n  if (lanes === 1) {\n    while (\n      endIndex < lastIndex &&\n      measurements[endIndex]!.end < scrollOffset + outerSize\n    ) {\n      endIndex++\n    }\n  } else if (lanes > 1) {\n    // Expand forward until we include the visible items from all lanes\n    // which are closer to the end of the virtualizer window\n    const endPerLane = Array(lanes).fill(0)\n    while (\n      endIndex < lastIndex &&\n      endPerLane.some((pos) => pos < scrollOffset + outerSize)\n    ) {\n      const item = measurements[endIndex]!\n      endPerLane[item.lane] = item.end\n      endIndex++\n    }\n\n    // Expand backward until we include all lanes' visible items\n    // closer to the top\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize)\n    while (startIndex > 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex]!\n      startPerLane[item.lane] = item.start\n      startIndex--\n    }\n\n    // Align startIndex to the beginning of its lane\n    startIndex = Math.max(0, startIndex - (startIndex % lanes))\n    // Align endIndex to the end of its lane\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - (endIndex % lanes)))\n  }\n\n  return { startIndex, endIndex }\n}\n", "import {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport {\n  computed,\n  onScopeDispose,\n  shallowRef,\n  triggerRef,\n  unref,\n  watch,\n} from 'vue'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\nimport type { Ref } from 'vue'\n\nexport * from '@tanstack/virtual-core'\n\ntype MaybeRef<T> = T | Ref<T>\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: MaybeRef<VirtualizerOptions<TScrollElement, TItemElement>>,\n): Ref<Virtualizer<TScrollElement, TItemElement>> {\n  const virtualizer = new Virtualizer(unref(options))\n  const state = shallowRef(virtualizer)\n\n  const cleanup = virtualizer._didMount()\n\n  watch(\n    () => unref(options).getScrollElement(),\n    (el) => {\n      if (el) {\n        virtualizer._willUpdate()\n      }\n    },\n    {\n      immediate: true,\n    },\n  )\n\n  watch(\n    () => unref(options),\n    (options) => {\n      virtualizer.setOptions({\n        ...options,\n        onChange: (instance, sync) => {\n          triggerRef(state)\n          options.onChange?.(instance, sync)\n        },\n      })\n\n      virtualizer._willUpdate()\n      triggerRef(state)\n    },\n    {\n      immediate: true,\n    },\n  )\n\n  onScopeDispose(cleanup)\n\n  return state\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: MaybeRef<\n    PartialKeys<\n      VirtualizerOptions<TScrollElement, TItemElement>,\n      'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n    >\n  >,\n): Ref<Virtualizer<TScrollElement, TItemElement>> {\n  return useVirtualizerBase<TScrollElement, TItemElement>(\n    computed(() => ({\n      observeElementRect: observeElementRect,\n      observeElementOffset: observeElementOffset,\n      scrollToFn: elementScroll,\n      ...unref(options),\n    })),\n  )\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: MaybeRef<\n    PartialKeys<\n      VirtualizerOptions<Window, TItemElement>,\n      | 'observeElementRect'\n      | 'observeElementOffset'\n      | 'scrollToFn'\n      | 'getScrollElement'\n    >\n  >,\n): Ref<Virtualizer<Window, TItemElement>> {\n  return useVirtualizerBase<Window, TItemElement>(\n    computed(() => ({\n      getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n      observeElementRect: observeWindowRect,\n      observeElementOffset: observeWindowOffset,\n      scrollToFn: windowScroll,\n      initialOffset: () =>\n        typeof document !== 'undefined' ? window.scrollY : 0,\n      ...unref(options),\n    })),\n  )\n}\n", "<script lang=\"ts\">\nexport interface ListboxVirtualizerProps<T extends AcceptableValue = AcceptableValue> {\n  /** List of items */\n  options: T[]\n  /** Number of items rendered outside the visible area */\n  overscan?: number\n  /** Estimated size (in px) of each item */\n  estimateSize?: number\n  /** Text content for each item to achieve type-ahead feature */\n  textContent?: (option: T) => string\n}\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport type { VirtualItem, Virtualizer } from '@tanstack/vue-virtual'\nimport type { Ref, VNode } from 'vue'\nimport type { AcceptableValue } from '@/shared/types'\nimport { useVirtualizer } from '@tanstack/vue-virtual'\nimport { useParentElement } from '@vueuse/core'\nimport { refAutoReset } from '@vueuse/shared'\nimport { cloneVNode, computed, Fragment, useSlots } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { MAP_KEY_TO_FOCUS_INTENT } from '@/RovingFocus/utils'\nimport { findValuesBetween, getActiveElement } from '@/shared'\nimport { getNextMatch } from '@/shared/useTypeahead'\nimport { injectListboxRootContext } from './ListboxRoot.vue'\nimport { compare, queryCheckedElement } from './utils'\n\nconst props = defineProps<ListboxVirtualizerProps<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    option: T\n    virtualizer: Virtualizer<HTMLElement, Element>\n    virtualItem: VirtualItem\n  }) => any\n}>()\n\nconst slots = useSlots()\nconst rootContext = injectListboxRootContext()\nconst parentEl = useParentElement() as Ref<HTMLElement>\nconst { getItems } = useCollection<{ value: T }>()\n\n// set virtual true when this component mounted\nrootContext.isVirtual.value = true\n\nconst padding = computed(() => {\n  const el = parentEl.value\n  if (!el) {\n    return { start: 0, end: 0 }\n  }\n  else {\n    const styles = window.getComputedStyle(el)\n    return {\n      start: Number.parseFloat(styles.paddingBlockStart || styles.paddingTop),\n      end: Number.parseFloat(styles.paddingBlockEnd || styles.paddingBottom),\n    }\n  }\n})\n\nconst virtualizer = useVirtualizer(\n  {\n    get scrollPaddingStart() { return padding.value.start },\n    get scrollPaddingEnd() { return padding.value.end },\n    get count() { return props.options.length },\n    get horizontal() { return rootContext.orientation.value === 'horizontal' },\n    estimateSize() {\n      return props.estimateSize ?? 28\n    },\n    getScrollElement() { return parentEl.value },\n    overscan: props.overscan ?? 12,\n  },\n)\n\nconst virtualizedItems = computed(() => virtualizer.value.getVirtualItems().map((item) => {\n  const defaultNode = slots.default!({\n    option: props.options[item.index],\n    virtualizer: virtualizer.value,\n    virtualItem: item,\n  })[0]\n\n  const targetNode = defaultNode.type === Fragment && Array.isArray(defaultNode.children)\n    ? defaultNode.children[0] as VNode\n    : defaultNode\n\n  return {\n    item,\n    is: cloneVNode(targetNode, {\n      'key': `${item.key}`,\n      'data-index': item.index,\n      'aria-setsize': props.options.length,\n      'aria-posinset': item.index + 1,\n      'style': {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        transform: `translateY(${item.start}px)`,\n        overflowAnchor: 'none',\n      },\n    }),\n  }\n}))\n\nrootContext.virtualFocusHook.on((event) => {\n  const index = props.options.findIndex((option) => {\n    if (Array.isArray(rootContext.modelValue.value))\n      return compare(option, rootContext.modelValue.value[0], rootContext.by)\n    else\n      return compare(option, rootContext.modelValue.value!, rootContext.by)\n  })\n  if (index !== -1) {\n    event?.preventDefault()\n\n    virtualizer.value.scrollToIndex(index, { align: 'start' })\n    requestAnimationFrame(() => {\n      const item = queryCheckedElement(parentEl.value)\n      if (item) {\n        rootContext.changeHighlight(item)\n        if (event)\n          item?.focus()\n      }\n    })\n  }\n  else {\n    rootContext.highlightFirstItem()\n  }\n})\n\nrootContext.virtualHighlightHook.on((value) => {\n  const index = props.options.findIndex((option) => {\n    return compare(option, value, rootContext.by)\n  })\n  virtualizer.value.scrollToIndex(index, { align: 'start' })\n  requestAnimationFrame(() => {\n    const item = queryCheckedElement(parentEl.value)\n    if (item)\n      rootContext.changeHighlight(item)\n  })\n})\n\n// Reset `search` 1 second after it was last updated\nconst search = refAutoReset('', 1000)\nconst optionsWithMetadata = computed(() => {\n  const parseTextContent = (option: T) => {\n    if (props.textContent)\n      return props.textContent(option)\n    else\n      return option?.toString().toLowerCase()\n  }\n\n  return props.options.map((option, index) => ({\n    index,\n    textContent: parseTextContent(option),\n  }))\n})\n\nfunction handleMultipleReplace(event: Event, intent: 'first' | 'last' | 'prev' | 'next') {\n  if (!rootContext.firstValue?.value || !rootContext.multiple.value || !Array.isArray(rootContext.modelValue.value))\n    return\n\n  const collection = getItems().filter(i => i.ref.dataset.disabled !== '')\n  const lastValue = collection.find(i => i.ref === rootContext.highlightedElement.value)?.value\n  if (!lastValue)\n    return\n\n  let value: T[] | null = null\n  switch (intent) {\n    case 'prev':\n    case 'next': {\n      value = findValuesBetween(props.options, rootContext.firstValue.value as T, lastValue)\n      break\n    }\n    case 'first': {\n      value = findValuesBetween(props.options, rootContext.firstValue.value as T, props.options?.[0])\n      break\n    }\n    case 'last': {\n      value = findValuesBetween(props.options, rootContext.firstValue.value as T, props.options?.[props.options.length - 1])\n      break\n    }\n  }\n  rootContext.modelValue.value = value\n}\n\nrootContext.virtualKeydownHook.on((event) => {\n  const isMetaKey = event.altKey || event.ctrlKey || event.metaKey\n  const isTabKey = event.key === 'Tab' && !isMetaKey\n  if (isTabKey)\n    return\n\n  let intent = MAP_KEY_TO_FOCUS_INTENT[event.key]\n\n  // Meta + A, select all feature\n  if (isMetaKey && event.key === 'a' && rootContext.multiple.value) {\n    event.preventDefault()\n    rootContext.modelValue.value = [...props.options]\n    // purposely make the focus to last\n    intent = 'last'\n  }\n  else if (event.shiftKey && intent) {\n    handleMultipleReplace(event, intent)\n  }\n\n  if (['first', 'last'].includes(intent)) {\n    event.preventDefault()\n\n    const index = intent === 'first' ? 0 : props.options.length - 1\n    virtualizer.value.scrollToIndex(index)\n    requestAnimationFrame(() => {\n      const items = getItems()\n      const item = intent === 'first' ? items[0] : items[items.length - 1]\n      if (item)\n        rootContext.changeHighlight(item.ref)\n    })\n  }\n  else if (!intent && !isMetaKey) {\n    search.value += event.key\n    const currentIndex = Number(getActiveElement()?.getAttribute('data-index'))\n    const currentMatch = optionsWithMetadata.value[currentIndex].textContent\n    const filteredOptions = optionsWithMetadata.value.map(i => i.textContent ?? '')\n    const next = getNextMatch(filteredOptions, search.value, currentMatch)\n\n    const nextMatch = optionsWithMetadata.value.find(option => option.textContent === next)\n    if (nextMatch) {\n      virtualizer.value.scrollToIndex(nextMatch.index, { align: 'start' })\n      requestAnimationFrame(() => {\n        const item = parentEl.value.querySelector(`[data-index=\"${nextMatch.index}\"]`)\n        if (item instanceof HTMLElement)\n          rootContext.changeHighlight(item)\n      })\n    }\n  }\n})\n</script>\n\n<template>\n  <div\n    data-reka-virtualizer\n    :style=\"{\n      position: 'relative',\n      width: '100%',\n      height: `${virtualizer.getTotalSize()}px`,\n    }\"\n  >\n    <component\n      :is=\"is\"\n      v-for=\"{ is, item } in virtualizedItems\"\n      :key=\"item.index\"\n    />\n  </div>\n</template>\n", "<script lang=\"ts\">\nexport interface ComboboxVirtualizerProps<T extends AcceptableValue = AcceptableValue> extends ListboxVirtualizerProps<T> {}\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport type { VirtualItem, Virtualizer } from '@tanstack/vue-virtual'\nimport type { ListboxVirtualizerProps } from '@/Listbox/ListboxVirtualizer.vue'\nimport type { AcceptableValue } from '@/shared/types'\nimport ListboxVirtualizer from '@/Listbox/ListboxVirtualizer.vue'\nimport { injectComboboxRootContext } from './ComboboxRoot.vue'\n\nconst props = defineProps<ComboboxVirtualizerProps<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    option: T\n    virtualizer: Virtualizer<HTMLElement, Element>\n    virtualItem: VirtualItem\n  }) => any\n}>()\n\nconst rootContext = injectComboboxRootContext()\n// set virtual true when this component mounted\nrootContext.isVirtual.value = true\n</script>\n\n<template>\n  <ListboxVirtualizer\n    v-slot=\"slotProps\"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </ListboxVirtualizer>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperArrowProps } from '@/Popper'\n\nexport interface MenuArrowProps extends PopperArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperArrow } from '@/Popper'\n\nconst props = defineProps<MenuArrowProps>()\n</script>\n\n<template>\n  <PopperArrow v-bind=\"props\">\n    <slot />\n  </PopperArrow>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuArrowProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ContextMenuArrowProps extends MenuArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuArrow } from '@/Menu'\n\nconst props = withDefaults(defineProps<ContextMenuArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\n\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuArrow v-bind=\"props\">\n    <slot />\n  </MenuArrow>\n</template>\n", "import { createSharedComposable, useEventListener } from '@vueuse/core'\nimport { onMounted, ref } from 'vue'\n\nfunction useIsUsingKeyboardImpl() {\n  const isUsingKeyboard = ref(false)\n\n  onMounted(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    useEventListener('keydown', () => {\n      isUsingKeyboard.value = true\n    }, { capture: true, passive: true })\n\n    useEventListener(['pointerdown', 'pointermove'], () => {\n      isUsingKeyboard.value = false\n    }, { capture: true, passive: true })\n  })\n\n  return isUsingKeyboard\n}\n\nexport const useIsUsingKeyboard = createSharedComposable(useIsUsingKeyboardImpl)\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Direction } from './utils'\nimport { createContext, useDirection } from '@/shared'\nimport { useIsUsingKeyboard } from '@/shared/useIsUsingKeyboard'\n\nexport interface MenuContext {\n  open: Ref<boolean>\n  onOpenChange: (open: boolean) => void\n  content: Ref<HTMLElement | undefined>\n  onContentChange: (content: HTMLElement | undefined) => void\n}\n\nexport interface MenuRootContext {\n  onClose: () => void\n  dir: Ref<Direction>\n  isUsingKeyboardRef: Ref<boolean>\n  modal: Ref<boolean>\n}\n\nexport interface MenuProps {\n  /** The controlled open state of the menu. Can be used as `v-model:open`. */\n  open?: boolean\n  /**\n   * The reading direction of the combobox when applicable.\n   *\n   * If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode.\n   */\n  dir?: Direction\n  /**\n   * The modality of the dropdown menu.\n   *\n   * When set to `true`, interaction with outside elements will be disabled and only menu content will be visible to screen readers.\n   */\n  modal?: boolean\n}\n\nexport type MenuEmits = {\n  'update:open': [payload: boolean]\n}\n\nexport const [injectMenuContext, provideMenuContext]\n  = createContext<MenuContext>(['MenuRoot', 'MenuSub'], 'MenuContext')\n\nexport const [injectMenuRootContext, provideMenuRootContext]\n  = createContext<MenuRootContext>('MenuRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport {\n  ref,\n  toRefs,\n} from 'vue'\nimport { PopperRoot } from '@/Popper'\n\nconst props = withDefaults(defineProps<MenuProps>(), {\n  open: false,\n  modal: true,\n})\nconst emits = defineEmits<MenuEmits>()\nconst { modal, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\n\nconst open = useVModel(props, 'open', emits)\n\nconst content = ref<HTMLElement>()\nconst isUsingKeyboardRef = useIsUsingKeyboard()\n\nprovideMenuContext({\n  open,\n  onOpenChange: (value) => {\n    open.value = value\n  },\n  content,\n  onContentChange: (element) => {\n    content.value = element\n  },\n})\n\nprovideMenuRootContext({\n  onClose: () => {\n    open.value = false\n  },\n  isUsingKeyboardRef,\n  dir,\n  modal,\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <slot />\n  </PopperRoot>\n</template>\n", "import { isClient } from '@vueuse/shared'\nimport { watchEffect } from 'vue'\n\n/** Number of components which have requested interest to have focus guards */\nlet count = 0\n\n/**\n * Injects a pair of focus guards at the edges of the whole DOM tree\n * to ensure `focusin` & `focusout` events can be caught consistently.\n */\nexport function useFocusGuards() {\n  watchEffect((cleanupFn) => {\n    if (!isClient)\n      return\n    const edgeGuards = document.querySelectorAll('[data-reka-focus-guard]')\n    document.body.insertAdjacentElement(\n      'afterbegin',\n      edgeGuards[0] ?? createFocusGuard(),\n    )\n    document.body.insertAdjacentElement(\n      'beforeend',\n      edgeGuards[1] ?? createFocusGuard(),\n    )\n    count++\n\n    cleanupFn(() => {\n      if (count === 1) {\n        document\n          .querySelectorAll('[data-reka-focus-guard]')\n          .forEach(node => node.remove())\n      }\n      count--\n    })\n  })\n}\n\nfunction createFocusGuard() {\n  const element = document.createElement('span')\n  element.setAttribute('data-reka-focus-guard', '')\n  element.tabIndex = 0\n  element.style.outline = 'none'\n  element.style.opacity = '0'\n  element.style.position = 'fixed'\n  element.style.pointerEvents = 'none'\n  return element\n}\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type {\n  GraceIntent,\n  Side,\n} from './utils'\nimport type {\n  DismissableLayerEmits,\n  DismissableLayerProps,\n} from '@/DismissableLayer'\nimport type { FocusScopeProps } from '@/FocusScope'\nimport type { PopperContentProps } from '@/Popper'\nimport type { RovingFocusGroupEmits } from '@/RovingFocus'\n\nimport {\n  createContext,\n  getActiveElement,\n  useArrowNavigation,\n  useFocusGuards,\n  useForwardExpose,\n  useTypeahead,\n} from '@/shared'\nimport { useBodyScrollLock } from '@/shared/useBodyScrollLock'\n\nexport interface MenuContentContext {\n  onItemEnter: (event: PointerEvent) => boolean\n  onItemLeave: (event: PointerEvent) => void\n  onTriggerLeave: (event: PointerEvent) => boolean\n  searchRef: Ref<string>\n  pointerGraceTimerRef: Ref<number>\n  onPointerGraceIntentChange: (intent: GraceIntent | null) => void\n}\n\nexport const [injectMenuContentContext, provideMenuContentContext]\n  = createContext<MenuContentContext>('MenuContent')\n\nexport interface MenuContentImplPrivateProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents']\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * @defaultValue false\n   */\n  disableOutsideScroll?: boolean\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * @defaultValue also\n   */\n  trapFocus?: FocusScopeProps['trapped']\n}\n\nexport type MenuContentImplEmits = DismissableLayerEmits & Omit<RovingFocusGroupEmits, 'update:currentTabStopId'> & {\n  openAutoFocus: [event: Event]\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  closeAutoFocus: [event: Event]\n}\n\ntype MenuContentImplPrivateEmits = MenuContentImplEmits & {\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  dismiss: []\n}\n\nexport interface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n  Omit<PopperContentProps, 'dir'> {\n  /**\n   * When `true`, keyboard navigation will loop from last item to first, and vice versa.\n   * @defaultValue false\n   */\n  loop?: boolean\n}\n\nexport interface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, 'disableOutsidePointerEvents' | 'disableOutsideScroll' | 'trapFocus'> {}\n</script>\n\n<script setup lang=\"ts\">\nimport {\n  onUnmounted,\n  ref,\n  toRefs,\n  watch,\n} from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { FocusScope } from '@/FocusScope'\nimport {\n  PopperContent,\n  PopperContentPropsDefaultValue,\n} from '@/Popper'\nimport { RovingFocusGroup } from '@/RovingFocus'\nimport { injectMenuContext, injectMenuRootContext } from './MenuRoot.vue'\nimport {\n  FIRST_LAST_KEYS,\n  focusFirst,\n  getOpenState,\n  isMouseEvent,\n  isPointerInGraceArea,\n  LAST_KEYS,\n} from './utils'\n\nconst props = withDefaults(defineProps<MenuContentImplProps>(), {\n  ...PopperContentPropsDefaultValue,\n})\nconst emits = defineEmits<MenuContentImplPrivateEmits>()\nconst menuContext = injectMenuContext()\nconst rootContext = injectMenuRootContext()\n\nconst { trapFocus, disableOutsidePointerEvents, loop } = toRefs(props)\n\nuseFocusGuards()\nuseBodyScrollLock(disableOutsidePointerEvents.value)\n\nconst searchRef = ref('')\nconst timerRef = ref(0)\nconst pointerGraceTimerRef = ref(0)\nconst pointerGraceIntentRef = ref<GraceIntent | null>(null)\nconst pointerDirRef = ref<Side>('right')\nconst lastPointerXRef = ref(0)\nconst currentItemId = ref<string | null>(null)\n\nconst rovingFocusGroupRef = ref<InstanceType<typeof RovingFocusGroup>>()\nconst { forwardRef, currentElement: contentElement } = useForwardExpose()\nconst { handleTypeaheadSearch } = useTypeahead()\n\nwatch(contentElement, (el) => {\n  menuContext!.onContentChange(el)\n})\n\nonUnmounted(() => {\n  window.clearTimeout(timerRef.value)\n})\n\nfunction isPointerMovingToSubmenu(event: PointerEvent) {\n  const isMovingTowards\n    = pointerDirRef.value === pointerGraceIntentRef.value?.side\n\n  return (\n    isMovingTowards\n    && isPointerInGraceArea(event, pointerGraceIntentRef.value?.area)\n  )\n}\n\nasync function handleMountAutoFocus(event: Event) {\n  emits('openAutoFocus', event)\n  if (event.defaultPrevented)\n    return\n  // when opening, explicitly focus the content area only and leave\n  // `onEntryFocus` in  control of focusing first item\n  event.preventDefault()\n  contentElement.value?.focus({\n    preventScroll: true,\n  })\n}\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  if (event.defaultPrevented)\n    return\n  // submenu key events bubble through portals. We only care about keys in this menu.\n  const target = event.target as HTMLElement\n  const isKeyDownInside\n    = target.closest('[data-reka-menu-content]') === event.currentTarget\n  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey\n  const isCharacterKey = event.key.length === 1\n\n  const el = useArrowNavigation(\n    event,\n    getActiveElement() as HTMLElement,\n    contentElement.value,\n    {\n      loop: loop.value,\n      arrowKeyOptions: 'vertical',\n      dir: rootContext?.dir.value,\n      focus: true,\n      attributeName: '[data-reka-collection-item]:not([data-disabled])',\n    },\n  )\n  if (el)\n    return el?.focus()\n\n  // prevent \"Space\" taken account into handleTypeahead\n  if (event.code === 'Space')\n    return\n\n  const collectionItems = rovingFocusGroupRef.value?.getItems() ?? []\n\n  if (isKeyDownInside) {\n    // menus should not be navigated using tab key so we prevent it\n    if (event.key === 'Tab')\n      event.preventDefault()\n    if (!isModifierKey && isCharacterKey)\n      handleTypeaheadSearch(event.key, collectionItems)\n  }\n\n  // focus first/last item based on key pressed\n  if (event.target !== contentElement.value)\n    return\n  if (!FIRST_LAST_KEYS.includes(event.key))\n    return\n  event.preventDefault()\n  const candidateNodes = [...collectionItems.map(item => item.ref)]\n  if (LAST_KEYS.includes(event.key))\n    candidateNodes.reverse()\n  focusFirst(candidateNodes)\n}\n\nfunction handleBlur(event: FocusEvent) {\n  // clear search buffer when leaving the menu\n  // @ts-expect-error the provided currentTarget and target should be HTMLElement\n  if (!event?.currentTarget?.contains?.(event.target)) {\n    window.clearTimeout(timerRef.value)\n    searchRef.value = ''\n  }\n}\n\nfunction handlePointerMove(event: PointerEvent) {\n  if (!isMouseEvent(event))\n    return\n  const target = event.target as HTMLElement\n  const pointerXHasChanged = lastPointerXRef.value !== event.clientX\n\n  // We don't use `event.movementX` for this check because Safari will\n  // always return `0` on a pointer event.\n  if (\n    (event?.currentTarget as HTMLElement)?.contains(target)\n    && pointerXHasChanged\n  ) {\n    const newDir = event.clientX > lastPointerXRef.value ? 'right' : 'left'\n    pointerDirRef.value = newDir\n    lastPointerXRef.value = event.clientX\n  }\n}\n\nprovideMenuContentContext({\n  onItemEnter: (event) => {\n    // event.preventDefault() we can't prevent pointerMove event\n    if (isPointerMovingToSubmenu(event))\n      return true\n    else\n      return false\n  },\n  onItemLeave: (event) => {\n    if (isPointerMovingToSubmenu(event))\n      return\n    contentElement.value?.focus()\n    currentItemId.value = null\n  },\n  onTriggerLeave: (event) => {\n    // event.preventDefault() we can't prevent pointerLeave event\n    if (isPointerMovingToSubmenu(event))\n      return true\n    else\n      return false\n  },\n  searchRef,\n  pointerGraceTimerRef,\n  onPointerGraceIntentChange: (intent) => {\n    pointerGraceIntentRef.value = intent\n  },\n})\n</script>\n\n<template>\n  <FocusScope\n    as-child\n    :trapped=\"trapFocus\"\n    @mount-auto-focus=\"handleMountAutoFocus\"\n    @unmount-auto-focus=\"emits('closeAutoFocus', $event)\"\n  >\n    <DismissableLayer\n      as-child\n      :disable-outside-pointer-events=\"disableOutsidePointerEvents\"\n      @escape-key-down=\"emits('escapeKeyDown', $event)\"\n      @pointer-down-outside=\"emits('pointerDownOutside', $event)\"\n      @focus-outside=\"emits('focusOutside', $event)\"\n      @interact-outside=\"emits('interactOutside', $event)\"\n      @dismiss=\"emits('dismiss')\"\n    >\n      <RovingFocusGroup\n        ref=\"rovingFocusGroupRef\"\n        v-model:current-tab-stop-id=\"currentItemId\"\n        as-child\n        orientation=\"vertical\"\n        :dir=\"rootContext.dir.value\"\n        :loop=\"loop\"\n        @entry-focus=\"(event) => {\n          emits('entryFocus', event)\n          // only focus first item when using keyboard\n          if (!rootContext.isUsingKeyboardRef.value) event.preventDefault();\n        }\"\n      >\n        <PopperContent\n          :ref=\"forwardRef\"\n          role=\"menu\"\n          :as=\"as\"\n          :as-child=\"asChild\"\n          aria-orientation=\"vertical\"\n          data-reka-menu-content\n          :data-state=\"getOpenState(menuContext.open.value)\"\n          :dir=\"rootContext.dir.value\"\n          :side=\"side\"\n          :side-offset=\"sideOffset\"\n          :align=\"align\"\n          :align-offset=\"alignOffset\"\n          :avoid-collisions=\"avoidCollisions\"\n          :collision-boundary=\"collisionBoundary\"\n          :collision-padding=\"collisionPadding\"\n          :arrow-padding=\"arrowPadding\"\n          :prioritize-position=\"prioritizePosition\"\n          :position-strategy=\"positionStrategy\"\n          :update-position-strategy=\"updatePositionStrategy\"\n          :sticky=\"sticky\"\n          :hide-when-detached=\"hideWhenDetached\"\n          :reference=\"reference\"\n          @keydown=\"handleKeyDown\"\n          @blur=\"handleBlur\"\n          @pointermove=\"handlePointerMove\"\n        >\n          <slot />\n        </PopperContent>\n      </RovingFocusGroup>\n    </DismissableLayer>\n  </FocusScope>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface MenuItemImplProps extends PrimitiveProps {\n  /** When `true`, prevents the user from interacting with the item. */\n  disabled?: boolean\n  /**\n   * Optional text used for typeahead purposes. By default the typeahead behavior will use the `.textContent` of the item. <br>\n   *  Use this when the content is complex, or you have non-textual content inside.\n   */\n  textValue?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, ref } from 'vue'\nimport { useCollection } from '@/Collection'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectMenuContentContext } from './MenuContentImpl.vue'\nimport { isMouseEvent } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<MenuItemImplProps>()\n\nconst contentContext = injectMenuContentContext()\nconst { forwardRef } = useForwardExpose()\nconst { CollectionItem } = useCollection()\n\nconst isFocused = ref(false)\n\nasync function handlePointerMove(event: PointerEvent) {\n  if (event.defaultPrevented)\n    return\n  if (!isMouseEvent(event))\n    return\n\n  if (props.disabled) {\n    contentContext.onItemLeave(event)\n  }\n  else {\n    const defaultPrevented = contentContext.onItemEnter(event)\n    if (!defaultPrevented) {\n      const item = event.currentTarget;\n      (item as HTMLElement)?.focus({ preventScroll: true })\n    }\n  }\n}\n\nasync function handlePointerLeave(event: PointerEvent) {\n  await nextTick()\n  if (event.defaultPrevented)\n    return\n  if (!isMouseEvent(event))\n    return\n\n  contentContext.onItemLeave(event)\n}\n</script>\n\n<template>\n  <CollectionItem :value=\"{ textValue }\">\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"menuitem\"\n      tabindex=\"-1\"\n      v-bind=\"$attrs\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :aria-disabled=\"disabled || undefined\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :data-highlighted=\"isFocused ? '' : undefined\"\n      @pointermove=\"handlePointerMove\"\n      @pointerleave=\"handlePointerLeave\"\n      @focus=\"\n        async (event) => {\n          await nextTick();\n          if (event.defaultPrevented || disabled) return;\n          isFocused = true;\n        }\n      \"\n      @blur=\"\n        async (event) => {\n          await nextTick();\n          if (event.defaultPrevented) return;\n          isFocused = false;\n        }\n      \"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemImplProps } from './MenuItemImpl.vue'\nimport { useForwardExpose } from '@/shared'\n\nexport type MenuItemEmits = {\n  /**\n   * Event handler called when the user selects an item (via mouse or keyboard). <br>\n   *  Calling `event.preventDefault` in this handler will prevent the menu from closing when selecting that item.\n   */\n  select: [event: Event]\n}\n\nexport interface MenuItemProps extends MenuItemImplProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, ref } from 'vue'\nimport { injectMenuContentContext } from './MenuContentImpl.vue'\nimport MenuItemImpl from './MenuItemImpl.vue'\nimport { injectMenuRootContext } from './MenuRoot.vue'\nimport { ITEM_SELECT, SELECTION_KEYS } from './utils'\n\nconst props = defineProps<MenuItemProps>()\nconst emits = defineEmits<MenuItemEmits>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst rootContext = injectMenuRootContext()\nconst contentContext = injectMenuContentContext()\n\nconst isPointerDownRef = ref(false)\n\nasync function handleSelect() {\n  const menuItem = currentElement.value\n  if (!props.disabled && menuItem) {\n    const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\n      bubbles: true,\n      cancelable: true,\n    })\n    emits('select', itemSelectEvent)\n    // let select event finish\n    await nextTick()\n    if (itemSelectEvent.defaultPrevented)\n      isPointerDownRef.value = false\n    else rootContext.onClose()\n  }\n}\n</script>\n\n<template>\n  <MenuItemImpl\n    v-bind=\"props\"\n    :ref=\"forwardRef\"\n    @click=\"handleSelect\"\n    @pointerdown=\"\n      () => {\n        isPointerDownRef = true;\n      }\n    \"\n    @pointerup=\"\n      async (event) => {\n        await nextTick();\n        if (event.defaultPrevented) return;\n        // Pointer down can move to a different menu item which should activate it on pointer up.\n        // We dispatch a click for selection to allow composition with click based triggers and to\n        // prevent Firefox from getting stuck in text selection mode when the menu closes.\n        if (!isPointerDownRef) event.currentTarget?.click();\n      }\n    \"\n    @keydown=\"\n      async (event) => {\n        const isTypingAhead = contentContext.searchRef.value !== '';\n        if (disabled || (isTypingAhead && event.key === ' ')) return;\n        if (SELECTION_KEYS.includes(event.key)) {\n          event.currentTarget.click();\n          /**\n           * We prevent default browser behaviour for selection keys as they should trigger\n           * a selection only:\n           * - prevents space from scrolling the page.\n           * - if keydown causes focus to move, prevents keydown from firing on the new target.\n           */\n          event.preventDefault();\n        }\n      }\n    \"\n  >\n    <slot />\n  </MenuItemImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { CheckedState } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext } from '@/shared'\n\ninterface MenuItemIndicatorContext {\n  modelValue: Ref<CheckedState>\n}\n\nexport interface MenuItemIndicatorProps extends PrimitiveProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n\nexport const [injectMenuItemIndicatorContext, provideMenuItemIndicatorContext]\n  = createContext<MenuItemIndicatorContext>(\n    ['MenuCheckboxItem', 'MenuRadioItem'],\n    'MenuItemIndicatorContext',\n  )\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { Presence } from '@/Presence'\nimport { Primitive } from '@/Primitive'\nimport { getCheckedState, isIndeterminate } from './utils'\n\nwithDefaults(defineProps<MenuItemIndicatorProps>(), {\n  as: 'span',\n})\n\nconst indicatorContext = injectMenuItemIndicatorContext({\n  modelValue: ref(false),\n})\n</script>\n\n<template>\n  <Presence\n    :present=\"\n      forceMount\n        || isIndeterminate(indicatorContext.modelValue.value)\n        || indicatorContext.modelValue.value === true\n    \"\n  >\n    <Primitive\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :data-state=\"getCheckedState(indicatorContext.modelValue.value)\"\n    >\n      <slot />\n    </Primitive>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuItemEmits,\n  MenuItemProps,\n} from './MenuItem.vue'\nimport type { CheckedState } from './utils'\n\nexport type MenuCheckboxItemEmits = MenuItemEmits & {\n  /** Event handler called when the checked state changes. */\n  'update:modelValue': [payload: boolean]\n}\n\nexport interface MenuCheckboxItemProps extends MenuItemProps {\n  /** The controlled checked state of the item. Can be used as `v-model`. */\n  modelValue?: CheckedState\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport MenuItem from './MenuItem.vue'\nimport { provideMenuItemIndicatorContext } from './MenuItemIndicator.vue'\nimport { getCheckedState, isIndeterminate } from './utils'\n\nconst props = withDefaults(defineProps<MenuCheckboxItemProps>(), {\n  modelValue: false,\n})\nconst emits = defineEmits<MenuCheckboxItemEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current modelValue state */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emits)\n\nprovideMenuItemIndicatorContext({ modelValue })\n</script>\n\n<template>\n  <MenuItem\n    role=\"menuitemcheckbox\"\n    v-bind=\"props\"\n    :aria-checked=\"isIndeterminate(modelValue) ? 'mixed' : modelValue\"\n    :data-state=\"getCheckedState(modelValue)\"\n    @select=\"\n      async (event) => {\n        emits('select', event);\n        if (isIndeterminate(modelValue)) {\n          modelValue = true;\n        }\n        else {\n          modelValue = !modelValue;\n        }\n      }\n    \"\n  >\n    <slot :model-value=\"modelValue\" />\n  </MenuItem>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuCheckboxItemEmits,\n  MenuCheckboxItemProps,\n} from '@/Menu'\n\nexport type ContextMenuCheckboxItemEmits = MenuCheckboxItemEmits\n\nexport interface ContextMenuCheckboxItemProps extends MenuCheckboxItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuCheckboxItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<ContextMenuCheckboxItemProps>()\nconst emits = defineEmits<ContextMenuCheckboxItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuCheckboxItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuCheckboxItem>\n</template>\n", "<script setup lang=\"ts\">\nimport type { MenuContentImplEmits, MenuRootContentTypeProps } from './MenuContentImpl.vue'\nimport { useForwardExpose, useForwardPropsEmits, useHideOthers } from '@/shared'\nimport MenuContentImpl from './MenuContentImpl.vue'\nimport { injectMenuContext } from './MenuRoot.vue'\n\nconst props = defineProps<MenuRootContentModalProps>()\nconst emits = defineEmits<MenuRootContentModalEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\n\nconst menuContext = injectMenuContext()\n\ninterface MenuRootContentModalProps extends MenuRootContentTypeProps {}\ntype MenuRootContentModalEmits = MenuContentImplEmits\n\nconst { forwardRef, currentElement } = useForwardExpose()\nuseHideOthers(currentElement)\n</script>\n\n<template>\n  <MenuContentImpl\n    v-bind=\"forwarded\"\n    :ref=\"forwardRef\"\n    :trap-focus=\"menuContext.open.value\"\n    :disable-outside-pointer-events=\"menuContext.open.value\"\n    :disable-outside-scroll=\"true\"\n    @dismiss=\"menuContext.onOpenChange(false)\"\n    @focus-outside.prevent=\"emits('focusOutside', $event)\"\n  >\n    <slot />\n  </MenuContentImpl>\n</template>\n", "<script setup lang=\"ts\">\nimport type { MenuContentImplEmits, MenuRootContentTypeProps } from './MenuContentImpl.vue'\nimport { useForwardPropsEmits } from '@/shared'\nimport MenuContentImpl from './MenuContentImpl.vue'\nimport { injectMenuContext } from './MenuRoot.vue'\n\nconst props = defineProps<MenuRootContentNonModalProps>()\nconst emits = defineEmits<MenuRootContentModalEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\n\nconst menuContext = injectMenuContext()\n\ninterface MenuRootContentNonModalProps extends MenuRootContentTypeProps {}\ntype MenuRootContentModalEmits = MenuContentImplEmits\n</script>\n\n<template>\n  <MenuContentImpl\n    v-bind=\"forwarded\"\n    :trap-focus=\"false\"\n    :disable-outside-pointer-events=\"false\"\n    :disable-outside-scroll=\"false\"\n    @dismiss=\"menuContext.onOpenChange(false)\"\n  >\n    <slot />\n  </MenuContentImpl>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuContentImplEmits,\n  MenuRootContentTypeProps,\n} from './MenuContentImpl.vue'\n\nexport type MenuContentEmits = Omit<MenuContentImplEmits, 'entryFocus' | 'openAutoFocus'>\n\nexport interface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardPropsEmits } from '@/shared'\nimport { injectMenuContext, injectMenuRootContext } from './MenuRoot.vue'\nimport MenuRootContentModal from './MenuRootContentModal.vue'\nimport MenuRootContentNonModal from './MenuRootContentNonModal.vue'\n\nconst props = defineProps<MenuContentProps>()\nconst emits = defineEmits<MenuContentImplEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\n\nconst menuContext = injectMenuContext()\nconst rootContext = injectMenuRootContext()\n</script>\n\n<template>\n  <Presence :present=\"forceMount || menuContext.open.value\">\n    <MenuRootContentModal\n      v-if=\"rootContext.modal.value\"\n      v-bind=\"{ ...$attrs, ...forwarded }\"\n    >\n      <slot />\n    </MenuRootContentModal>\n    <MenuRootContentNonModal\n      v-else\n      v-bind=\"{ ...$attrs, ...forwarded }\"\n    >\n      <slot />\n    </MenuRootContentNonModal>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { MenuEmits, MenuProps } from '@/Menu'\nimport type { Direction } from '@/shared/types'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\ntype ContextMenuRootContext = {\n  open: Ref<boolean>\n  onOpenChange: (open: boolean) => void\n  modal: Ref<boolean>\n  dir: Ref<Direction>\n  triggerElement: Ref<HTMLElement | undefined>\n}\n\nexport interface ContextMenuRootProps extends Omit<MenuProps, 'open'> {}\nexport type ContextMenuRootEmits = MenuEmits\n\nexport const [injectContextMenuRootContext, provideContextMenuRootContext]\n  = createContext<ContextMenuRootContext>('ContextMenuRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { ref, toRefs, watch } from 'vue'\nimport { MenuRoot } from '@/Menu'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ContextMenuRootProps>(), {\n  modal: true,\n})\nconst emits = defineEmits<ContextMenuRootEmits>()\nconst { dir: propDir, modal } = toRefs(props)\nuseForwardExpose()\nconst dir = useDirection(propDir)\n\nconst open = ref(false)\nconst triggerElement = ref<HTMLElement>()\n\nprovideContextMenuRootContext({\n  open,\n  onOpenChange: (value: boolean) => {\n    open.value = value\n  },\n  dir,\n  modal,\n  triggerElement,\n})\n\nwatch(open, (value) => {\n  emits('update:open', value)\n})\n</script>\n\n<template>\n  <MenuRoot\n    v-model:open=\"open\"\n    :dir=\"dir\"\n    :modal=\"modal\"\n  >\n    <slot />\n  </MenuRoot>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuContentEmits,\n  MenuContentProps,\n} from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\n\nexport type ContextMenuContentEmits = MenuContentEmits\n\nexport interface ContextMenuContentProps\n  extends Omit<\n    MenuContentProps,\n    | 'side'\n    | 'sideOffset'\n    | 'align'\n    | 'arrowPadding'\n    | 'updatePositionStrategy'\n  > {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { MenuContent } from '@/Menu'\nimport { injectContextMenuRootContext } from './ContextMenuRoot.vue'\n\nconst props = withDefaults(defineProps<ContextMenuContentProps>(), {\n  alignOffset: 0,\n  avoidCollisions: true,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: 'partial',\n  hideWhenDetached: false,\n})\nconst emits = defineEmits<ContextMenuContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\n\nuseForwardExpose()\nconst rootContext = injectContextMenuRootContext()\nconst hasInteractedOutside = ref(false)\n</script>\n\n<template>\n  <MenuContent\n    v-bind=\"forwarded\"\n    side=\"right\"\n    :side-offset=\"2\"\n    align=\"start\"\n    update-position-strategy=\"always\"\n    :style=\"{\n      '--reka-context-menu-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-context-menu-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-context-menu-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-context-menu-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-context-menu-trigger-height':\n        'var(--reka-popper-anchor-height)',\n    }\"\n    @close-auto-focus=\"\n      (event) => {\n        if (!event.defaultPrevented && hasInteractedOutside) {\n          event.preventDefault();\n        }\n        hasInteractedOutside = false;\n      }\n    \"\n    @interact-outside=\"\n      (event) => {\n        const originalEvent = event.detail.originalEvent as PointerEvent\n        // Prevent closing when right click (button=2) with the trigger element\n        if (originalEvent.button === 2 && event.target === rootContext.triggerElement.value) {\n          event.preventDefault()\n        }\n        if (!event.defaultPrevented && !rootContext.modal.value)\n          hasInteractedOutside = true;\n      }\n    \"\n  >\n    <slot />\n  </MenuContent>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface MenuGroupProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<MenuGroupProps>()\n</script>\n\n<template>\n  <Primitive\n    role=\"group\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuGroupProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ContextMenuGroupProps extends MenuGroupProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuGroup } from '@/Menu'\n\nconst props = defineProps<ContextMenuGroupProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuGroup v-bind=\"props\">\n    <slot />\n  </MenuGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemEmits, MenuItemProps } from '@/Menu'\n\nexport type ContextMenuItemEmits = MenuItemEmits\n\nexport interface ContextMenuItemProps extends MenuItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<MenuItemProps>()\nconst emits = defineEmits<MenuItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuItem>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemIndicatorProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ContextMenuItemIndicatorProps extends MenuItemIndicatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuItemIndicator } from '@/Menu'\n\nconst props = defineProps<ContextMenuItemIndicatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuItemIndicator v-bind=\"props\">\n    <slot />\n  </MenuItemIndicator>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface MenuLabelProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<MenuLabelProps>(), {\n  as: 'div',\n})\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuLabelProps } from '@/Menu'\n\nexport interface ContextMenuLabelProps extends MenuLabelProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuLabel } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = defineProps<ContextMenuLabelProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuLabel v-bind=\"props\">\n    <slot />\n  </MenuLabel>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface MenuPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<MenuPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script setup lang=\"ts\">\nimport type { MenuPortalProps } from '@/Menu'\nimport { MenuPortal } from '@/Menu'\n\nexport interface ContextMenuPortalProps extends MenuPortalProps {}\nconst props = defineProps<ContextMenuPortalProps>()\n</script>\n\n<template>\n  <MenuPortal v-bind=\"props\">\n    <slot />\n  </MenuPortal>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { MenuGroupProps } from './MenuGroup.vue'\nimport { createContext } from '@/shared'\n\ninterface MenuRadioGroupContext {\n  modelValue: Ref<string>\n  onValueChange: (payload: string) => void\n}\n\nexport interface MenuRadioGroupProps extends MenuGroupProps {\n  /** The value of the selected item in the group. */\n  modelValue?: string\n}\n\nexport type MenuRadioGroupEmits = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [payload: string]\n}\n\nexport const [injectMenuRadioGroupContext, provideMenuRadioGroupContext]\n  = createContext<MenuRadioGroupContext>('MenuRadioGroup')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport MenuGroup from './MenuGroup.vue'\n\nconst props = withDefaults(defineProps<MenuRadioGroupProps>(), {\n  modelValue: '',\n})\nconst emits = defineEmits<MenuRadioGroupEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emits)\n\nprovideMenuRadioGroupContext({\n  modelValue,\n  onValueChange: (payload) => {\n    modelValue.value = payload\n  },\n})\n</script>\n\n<template>\n  <MenuGroup v-bind=\"props\">\n    <slot :model-value=\"modelValue\" />\n  </MenuGroup>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuRadioGroupEmits,\n  MenuRadioGroupProps,\n} from '@/Menu'\n\nexport type ContextMenuRadioGroupEmits = MenuRadioGroupEmits\n\nexport interface ContextMenuRadioGroupProps extends MenuRadioGroupProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuRadioGroup } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<ContextMenuRadioGroupProps>()\nconst emits = defineEmits<ContextMenuRadioGroupEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuRadioGroup v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuRadioGroup>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuItemEmits,\n  MenuItemProps,\n} from './MenuItem.vue'\n\nexport type MenuRadioItemEmits = MenuItemEmits\n\nexport interface MenuRadioItemProps extends MenuItemProps {\n  /** The unique value of the item. */\n  value: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, toRefs } from 'vue'\nimport MenuItem from './MenuItem.vue'\nimport { provideMenuItemIndicatorContext } from './MenuItemIndicator.vue'\nimport { injectMenuRadioGroupContext } from './MenuRadioGroup.vue'\nimport { getCheckedState } from './utils'\n\nconst props = defineProps<MenuRadioItemProps>()\nconst emits = defineEmits<MenuRadioItemEmits>()\n\nconst { value } = toRefs(props)\nconst radioGroupContext = injectMenuRadioGroupContext()\nconst modelValue = computed(\n  () => radioGroupContext.modelValue.value === value?.value,\n)\n\nprovideMenuItemIndicatorContext({ modelValue })\n</script>\n\n<template>\n  <MenuItem\n    role=\"menuitemradio\"\n    v-bind=\"props\"\n    :aria-checked=\"modelValue\"\n    :data-state=\"getCheckedState(modelValue)\"\n    @select=\"\n      async (event) => {\n        emits('select', event);\n        radioGroupContext.onValueChange(value);\n      }\n    \"\n  >\n    <slot />\n  </MenuItem>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuItemEmits,\n  MenuRadioItemProps,\n} from '@/Menu'\n\nexport type ContextMenuRadioItemEmits = MenuItemEmits\n\nexport interface ContextMenuRadioItemProps extends MenuRadioItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuRadioItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<ContextMenuRadioItemProps>()\nconst emits = defineEmits<ContextMenuRadioItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuRadioItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuRadioItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface MenuSeparatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<MenuSeparatorProps>()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    role=\"separator\"\n    aria-orientation=\"horizontal\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuSeparatorProps } from '@/Menu'\n\nexport interface ContextMenuSeparatorProps extends MenuSeparatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSeparator } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = defineProps<ContextMenuSeparatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSeparator v-bind=\"props\">\n    <slot />\n  </MenuSeparator>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { MenuContext } from './MenuRoot.vue'\nimport { createContext } from '@/shared'\n\nexport interface MenuSubContext {\n  contentId: string\n  triggerId: string\n  trigger: Ref<HTMLElement | undefined>\n  onTriggerChange: (trigger: HTMLElement | undefined) => void\n  parentMenuContext?: MenuContext\n}\n\nexport const [injectMenuSubContext, provideMenuSubContext]\n  = createContext<MenuSubContext>('MenuSub')\n\nexport interface MenuSubProps {\n  /** The controlled open state of the menu. Can be used as `v-model:open`. */\n  open?: boolean\n}\n\nexport type MenuSubEmits = {\n  /** Event handler called when the open state of the submenu changes. */\n  'update:open': [payload: boolean]\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport {\n  ref,\n  watchEffect,\n} from 'vue'\nimport { PopperRoot } from '@/Popper'\nimport { injectMenuContext, provideMenuContext } from './MenuRoot.vue'\n\nconst props = withDefaults(defineProps<MenuSubProps>(), {\n  open: undefined,\n})\nconst emits = defineEmits<MenuSubEmits>()\n\nconst open = useVModel(props, 'open', emits, {\n  defaultValue: false,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst parentMenuContext = injectMenuContext()\nconst trigger = ref<HTMLElement>()\nconst content = ref<HTMLElement>()\n\n// Prevent the parent menu from reopening with open submenus.\nwatchEffect((cleanupFn) => {\n  if (parentMenuContext?.open.value === false)\n    open.value = false\n  cleanupFn(() => (open.value = false))\n})\n\nprovideMenuContext({\n  open,\n  onOpenChange: (value) => {\n    open.value = value\n  },\n  content,\n  onContentChange: (element) => {\n    content.value = element\n  },\n})\n\nprovideMenuSubContext({\n  triggerId: '',\n  contentId: '',\n  trigger,\n  onTriggerChange: (element) => {\n    trigger.value = element\n  },\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <slot />\n  </PopperRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { MenuSubEmits, MenuSubProps } from '@/Menu'\n\nexport type ContextMenuSubEmits = MenuSubEmits\nexport interface ContextMenuSubProps extends MenuSubProps {\n  /** The open state of the submenu when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { MenuSub } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = withDefaults(defineProps<ContextMenuSubProps>(), {\n  open: undefined,\n})\nconst emit = defineEmits<ContextMenuSubEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nuseForwardExpose()\n\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n</script>\n\n<template>\n  <MenuSub v-model:open=\"open\">\n    <slot :open=\"open\" />\n  </MenuSub>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuContentImplEmits,\n  MenuContentImplProps,\n} from './MenuContentImpl.vue'\n\nexport type MenuSubContentEmits = MenuContentImplEmits\n\n// reference: https://github.com/radix-ui/primitives/blob/main/packages/react/menu/src/Menu.tsx#L1152\nexport interface MenuSubContentProps extends Omit<MenuContentImplProps, 'disableOutsidePointerEvents' | 'disableOutsideScroll' | 'trapFocus' | 'side' | 'align'> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardExpose, useForwardPropsEmits, useId } from '@/shared'\nimport MenuContentImpl from './MenuContentImpl.vue'\nimport { injectMenuContext, injectMenuRootContext } from './MenuRoot.vue'\nimport { injectMenuSubContext } from './MenuSub.vue'\nimport { SUB_CLOSE_KEYS } from './utils'\n\nconst props = withDefaults(defineProps<MenuSubContentProps>(), {\n  prioritizePosition: true,\n})\nconst emits = defineEmits<MenuSubContentEmits>()\n\nconst forwarded = useForwardPropsEmits(props, emits)\n\nconst menuContext = injectMenuContext()\nconst rootContext = injectMenuRootContext()\nconst menuSubContext = injectMenuSubContext()\n\nconst { forwardRef, currentElement: subContentElement } = useForwardExpose()\n\nmenuSubContext.contentId ||= useId(undefined, 'reka-menu-sub-content')\n</script>\n\n<template>\n  <Presence :present=\"forceMount || menuContext.open.value\">\n    <MenuContentImpl\n      v-bind=\"forwarded\"\n      :id=\"menuSubContext.contentId\"\n      :ref=\"forwardRef\"\n      :aria-labelledby=\"menuSubContext.triggerId\"\n      align=\"start\"\n      :side=\"rootContext.dir.value === 'rtl' ? 'left' : 'right'\"\n      :disable-outside-pointer-events=\"false\"\n      :disable-outside-scroll=\"false\"\n      :trap-focus=\"false\"\n      @open-auto-focus.prevent=\"(event) => {\n        // when opening a submenu, focus content for keyboard users only\n        if (rootContext.isUsingKeyboardRef.value) subContentElement?.focus();\n      }\"\n      @close-auto-focus.prevent\n      @focus-outside=\"\n        (event) => {\n          if (event.defaultPrevented) return;\n          // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n          // on pointer interaction.\n          if (event.target !== menuSubContext.trigger.value)\n            menuContext.onOpenChange(false);\n        }\n      \"\n      @escape-key-down=\"\n        (event) => {\n          rootContext.onClose();\n          // ensure pressing escape in submenu doesn't escape full screen mode\n          event.preventDefault();\n        }\n      \"\n      @keydown=\"(event: KeyboardEvent) => {\n        // Submenu key events bubble through portals. We only care about keys in this menu.\n        const isKeyDownInside = (event.currentTarget as HTMLElement)?.contains(event.target as HTMLElement);\n        const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir.value].includes(event.key);\n        if (isKeyDownInside && isCloseKey) {\n          menuContext.onOpenChange(false);\n          // We focus manually because we prevented it in `onCloseAutoFocus`\n          menuSubContext.trigger.value?.focus();\n          // prevent window from scrolling\n          event.preventDefault();\n        }\n      }\"\n    >\n      <slot />\n    </MenuContentImpl>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuSubContentEmits,\n  MenuSubContentProps,\n} from '@/Menu'\n\nexport type ContextMenuSubContentEmits = MenuSubContentEmits\nexport interface ContextMenuSubContentProps extends MenuSubContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSubContent } from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\n\nconst props = defineProps<ContextMenuSubContentProps>()\n\nconst emits = defineEmits<ContextMenuSubContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSubContent\n    v-bind=\"forwarded\"\n    :style=\"{\n      '--reka-context-menu-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-context-menu-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-context-menu-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-context-menu-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-context-menu-trigger-height':\n        'var(--reka-popper-anchor-height)',\n    }\"\n  >\n    <slot />\n  </MenuSubContent>\n</template>\n", "<script setup lang=\"ts\">\nimport type { PopperAnchorProps } from '@/Popper'\nimport { PopperAnchor } from '@/Popper'\n\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst props = defineProps<MenuAnchorProps>()\n</script>\n\n<template>\n  <PopperAnchor v-bind=\"props\">\n    <slot />\n  </PopperAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemImplProps } from './MenuItemImpl.vue'\nimport type { Side } from './utils'\n\nexport interface MenuSubTriggerProps extends MenuItemImplProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport type { ComponentPublicInstance } from 'vue'\nimport { nextTick, onUnmounted, ref } from 'vue'\nimport { useId } from '@/shared'\nimport MenuAnchor from './MenuAnchor.vue'\nimport { injectMenuContentContext } from './MenuContentImpl.vue'\nimport MenuItemImpl from './MenuItemImpl.vue'\nimport { injectMenuContext, injectMenuRootContext } from './MenuRoot.vue'\nimport { injectMenuSubContext } from './MenuSub.vue'\nimport { getOpenState, isMouseEvent, SUB_OPEN_KEYS } from './utils'\n\nconst props = defineProps<MenuSubTriggerProps>()\n\nconst menuContext = injectMenuContext()\nconst rootContext = injectMenuRootContext()\nconst subContext = injectMenuSubContext()\nconst contentContext = injectMenuContentContext()\n\nconst openTimerRef = ref<number | null>(null)\n\nsubContext.triggerId ||= useId(undefined, 'reka-menu-sub-trigger')\n\nfunction clearOpenTimer() {\n  if (openTimerRef.value)\n    window.clearTimeout(openTimerRef.value)\n  openTimerRef.value = null\n}\n\nonUnmounted(() => {\n  clearOpenTimer()\n})\n\nfunction handlePointerMove(event: PointerEvent) {\n  if (!isMouseEvent(event))\n    return\n  const defaultPrevented = contentContext.onItemEnter(event)\n  if (defaultPrevented)\n    return\n\n  if (!props.disabled && !menuContext.open.value && !openTimerRef.value) {\n    contentContext.onPointerGraceIntentChange(null)\n    openTimerRef.value = window.setTimeout(() => {\n      menuContext.onOpenChange(true)\n      clearOpenTimer()\n    }, 100)\n  }\n}\n\nasync function handlePointerLeave(event: PointerEvent) {\n  if (!isMouseEvent(event))\n    return\n  clearOpenTimer()\n\n  const contentRect = menuContext.content.value?.getBoundingClientRect()\n  if (contentRect?.width) {\n    // TODO (Radix UI): make sure to update this when we change positioning logic\n    // https://github.com/radix-ui/primitives/blob/main/packages/react/menu/src/Menu.tsx#L1088\n    const side = menuContext.content.value?.dataset.side as Side\n\n    const rightSide = side === 'right'\n    const bleed = rightSide ? -5 : +5\n    const contentNearEdge = contentRect[rightSide ? 'left' : 'right']\n    const contentFarEdge = contentRect[rightSide ? 'right' : 'left']\n\n    contentContext.onPointerGraceIntentChange({\n      area: [\n        // Apply a bleed on clientX to ensure that our exit point is\n        // consistently within polygon bounds\n        { x: event.clientX + bleed, y: event.clientY },\n        { x: contentNearEdge, y: contentRect.top },\n        { x: contentFarEdge, y: contentRect.top },\n        { x: contentFarEdge, y: contentRect.bottom },\n        { x: contentNearEdge, y: contentRect.bottom },\n      ],\n      side,\n    })\n\n    window.clearTimeout(contentContext.pointerGraceTimerRef.value)\n    contentContext.pointerGraceTimerRef.value = window.setTimeout(\n      () => contentContext.onPointerGraceIntentChange(null),\n      300,\n    )\n  }\n  else {\n    const defaultPrevented = contentContext.onTriggerLeave(event)\n    if (defaultPrevented)\n      return\n\n    // There's 100ms where the user may leave an item before the submenu was opened.\n    contentContext.onPointerGraceIntentChange(null)\n  }\n}\n\nasync function handleKeyDown(event: KeyboardEvent) {\n  const isTypingAhead = contentContext.searchRef.value !== ''\n  if (props.disabled || (isTypingAhead && event.key === ' '))\n    return\n  if (SUB_OPEN_KEYS[rootContext.dir.value].includes(event.key)) {\n    menuContext.onOpenChange(true)\n\n    await nextTick()\n    // The trigger may hold focus if opened via pointer interaction\n    // so we ensure content is given focus again when switching to keyboard.\n    menuContext.content.value?.focus()\n    // prevent window from scrolling\n    event.preventDefault()\n  }\n}\n</script>\n\n<template>\n  <MenuAnchor as-child>\n    <MenuItemImpl\n      v-bind=\"props\"\n      :id=\"subContext.triggerId\"\n      :ref=\"\n        (vnode: ComponentPublicInstance) => {\n          // @ts-ignore\n          subContext?.onTriggerChange(vnode?.$el);\n          return undefined\n        }\n      \"\n      aria-haspopup=\"menu\"\n      :aria-expanded=\"menuContext.open.value\"\n      :aria-controls=\"subContext.contentId\"\n      :data-state=\"getOpenState(menuContext.open.value)\"\n      @click=\"\n        async (event) => {\n          if (props.disabled || event.defaultPrevented) return;\n          /**\n           * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n           * and we rely heavily on `onFocusOutside` for submenus to close when switching\n           * between separate submenus.\n           */\n          event.currentTarget.focus();\n          if (!menuContext.open.value) menuContext.onOpenChange(true);\n        }\n      \"\n      @pointermove=\"handlePointerMove\"\n      @pointerleave=\"handlePointerLeave\"\n      @keydown=\"handleKeyDown\"\n    >\n      <slot />\n    </MenuItemImpl>\n  </MenuAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuSubTriggerProps } from '@/Menu'\n\nexport interface ContextMenuSubTriggerProps extends MenuSubTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSubTrigger } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = defineProps<ContextMenuSubTriggerProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSubTrigger v-bind=\"props\">\n    <slot />\n  </MenuSubTrigger>\n</template>\n", "export function isTouchOrPen(event: PointerEvent) {\n  return event.pointerType !== 'mouse'\n}\n", "<script lang=\"ts\">\nimport type { Point } from '@/Menu/utils'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface ContextMenuTriggerProps extends PrimitiveProps {\n  /**\n   * When `true`, the context menu would not open when right-clicking.\n   *\n   * Note that this will also restore the native context menu.\n   */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, nextTick, onMounted, ref, toRefs } from 'vue'\nimport { MenuAnchor } from '@/Menu'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectContextMenuRootContext } from './ContextMenuRoot.vue'\nimport { isTouchOrPen } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ContextMenuTriggerProps>(), {\n  as: 'span',\n  disabled: false,\n})\nconst { disabled } = toRefs(props)\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst rootContext = injectContextMenuRootContext()\nconst point = ref<Point>({ x: 0, y: 0 })\nconst virtualEl = computed(() => ({\n  getBoundingClientRect: () =>\n    ({\n      width: 0,\n      height: 0,\n      left: point.value.x,\n      right: point.value.x,\n      top: point.value.y,\n      bottom: point.value.y,\n      ...point.value,\n    } as DOMRect),\n}))\n\nconst longPressTimer = ref(0)\nfunction clearLongPress() {\n  window.clearTimeout(longPressTimer.value)\n}\n\nfunction handleOpen(event: MouseEvent | PointerEvent) {\n  point.value = { x: event.clientX, y: event.clientY }\n  rootContext.onOpenChange(true)\n}\n\nasync function handleContextMenu(event: PointerEvent) {\n  if (!disabled.value) {\n    await nextTick()\n    if (!event.defaultPrevented) {\n      clearLongPress()\n      handleOpen(event)\n      event.preventDefault()\n    }\n  }\n}\n\nasync function handlePointerDown(event: PointerEvent) {\n  if (!disabled.value) {\n    await nextTick()\n\n    if (isTouchOrPen(event) && !event.defaultPrevented) {\n      // clear the long press here in case there's multiple touch points\n      clearLongPress()\n      longPressTimer.value = window.setTimeout(() => handleOpen(event), 700)\n    }\n  }\n}\n\nasync function handlePointerEvent(event: PointerEvent) {\n  if (!disabled.value) {\n    await nextTick()\n    if (isTouchOrPen(event) && !event.defaultPrevented)\n      clearLongPress()\n  }\n}\n\nonMounted(() => {\n  if (currentElement.value) {\n    rootContext.triggerElement.value = currentElement.value\n  }\n})\n</script>\n\n<template>\n  <MenuAnchor\n    as=\"template\"\n    :reference=\"virtualEl\"\n  />\n\n  <Primitive\n    :ref=\"forwardRef\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :style=\"{\n      WebkitTouchCallout: 'none',\n      pointerEvents: 'auto',\n    }\"\n    v-bind=\"$attrs\"\n    @contextmenu=\"handleContextMenu\"\n    @pointerdown=\"handlePointerDown\"\n    @pointermove=\"handlePointerEvent\"\n    @pointercancel=\"handlePointerEvent\"\n    @pointerup=\"handlePointerEvent\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import { useKbd } from '@/shared'\n\nexport function isSegmentNavigationKey(key: string) {\n  const kbd = useKbd()\n  if (key === kbd.ARROW_RIGHT || key === kbd.ARROW_LEFT)\n    return true\n  return false\n}\n\nexport function isNumberString(value: string) {\n  if (Number.isNaN(Number.parseInt(value)))\n    return false\n  return true\n}\n\nexport function isAcceptableSegmentKey(key: string) {\n  const kbd = useKbd()\n  const acceptableSegmentKeys = [\n    kbd.ENTER,\n    kbd.ARROW_UP,\n    kbd.ARROW_DOWN,\n    kbd.ARROW_LEFT,\n    kbd.ARROW_RIGHT,\n    kbd.BACKSPACE,\n    kbd.SPACE,\n    'a',\n    'A',\n    'p',\n    'P',\n  ]\n  if (acceptableSegmentKeys.includes(key))\n    return true\n  if (isNumberString(key))\n    return true\n  return false\n}\n\nexport function getSegmentElements(parentElement: HTMLElement): Element[] {\n  return Array.from(parentElement.querySelectorAll('[data-reka-date-field-segment]')).filter(item => item.getAttribute('data-reka-date-field-segment') !== 'literal')\n}\n\nexport function getTimeFieldSegmentElements(parentElement: HTMLElement): Element[] {\n  return Array.from(parentElement.querySelectorAll('[data-reka-time-field-segment]')).filter(item => item.getAttribute('data-reka-time-field-segment') !== 'literal')\n}\n", "import type { CalendarDateTime, CycleTimeOptions, DateFields, DateValue, TimeFields } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { AnyExceptLiteral, DateStep, HourCycle, SegmentPart, SegmentValueObj } from './types'\nimport type { Formatter } from '@/shared'\nimport { computed } from 'vue'\nimport { getDaysInMonth, toDate } from '@/date'\nimport { useKbd } from '@/shared'\nimport { isAcceptableSegmentKey, isNumberString, isSegmentNavigationKey } from './segment'\n\ntype MinuteSecondIncrementProps = {\n  e: KeyboardEvent\n  part: keyof TimeFields\n  dateRef: DateValue\n  prevValue: number | null\n}\n\ntype DateTimeValueIncrementation = {\n  e: KeyboardEvent\n  part: keyof Omit<DateFields, 'era'> | keyof TimeFields\n  dateRef: DateValue\n  prevValue: number | null\n  hourCycle?: HourCycle\n}\n\ntype SegmentAttrProps = {\n  disabled: boolean\n  segmentValues: SegmentValueObj\n  hourCycle: HourCycle\n  placeholder: DateValue\n  formatter: Formatter\n}\n\nfunction commonSegmentAttrs(props: SegmentAttrProps) {\n  return {\n    role: 'spinbutton',\n    contenteditable: true,\n    tabindex: props.disabled ? undefined : 0,\n    spellcheck: false,\n    inputmode: 'numeric',\n    autocorrect: 'off',\n    enterkeyhint: 'next',\n    style: 'caret-color: transparent;',\n  }\n}\n\nfunction daySegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, placeholder } = props\n  const isEmpty = segmentValues.day === null\n  const date = segmentValues.day ? placeholder.set({ day: segmentValues.day }) : placeholder\n\n  const valueNow = date.day\n  const valueMin = 1\n  const valueMax = getDaysInMonth(date)\n  const valueText = isEmpty ? 'Empty' : `${valueNow}`\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'day,',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n    'data-placeholder': isEmpty ? '' : undefined,\n  }\n}\n\nfunction monthSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, placeholder, formatter } = props\n  const isEmpty = segmentValues.month === null\n  const date = segmentValues.month\n    ? placeholder.set({ month: segmentValues.month })\n    : placeholder\n  const valueNow = date.month\n  const valueMin = 1\n  const valueMax = 12\n  const valueText = isEmpty ? 'Empty' : `${valueNow} - ${formatter.fullMonth(toDate(date))}`\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'month, ',\n    'contenteditable': true,\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n    'data-placeholder': isEmpty ? '' : undefined,\n  }\n}\n\nfunction yearSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, placeholder } = props\n  const isEmpty = segmentValues.year === null\n  const date = segmentValues.year ? placeholder.set({ year: segmentValues.year }) : placeholder\n  const valueMin = 1\n  const valueMax = 9999\n  const valueNow = date.year\n  const valueText = isEmpty ? 'Empty' : `${valueNow}`\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'year, ',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n    'data-placeholder': isEmpty ? '' : undefined,\n  }\n}\n\nfunction hourSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, hourCycle, placeholder } = props\n\n  if (!('hour' in segmentValues) || !('hour' in placeholder))\n    return {}\n  const isEmpty = segmentValues.hour === null\n  const date = segmentValues.hour ? placeholder.set({ hour: segmentValues.hour }) : placeholder\n  const valueMin = hourCycle === 12 ? 1 : 0\n  const valueMax = hourCycle === 12 ? 12 : 23\n  const valueNow = date.hour\n  const valueText = isEmpty ? 'Empty' : `${valueNow} ${segmentValues.dayPeriod ?? ''}`\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'hour, ',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n    'data-placeholder': isEmpty ? '' : undefined,\n  }\n}\n\nfunction minuteSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, placeholder } = props\n  if (!('minute' in segmentValues) || !('minute' in placeholder))\n    return {}\n  const isEmpty = segmentValues.minute === null\n  const date = segmentValues.minute\n    ? placeholder.set({ minute: segmentValues.minute })\n    : placeholder\n  const valueNow = date.minute\n  const valueMin = 0\n  const valueMax = 59\n  const valueText = isEmpty ? 'Empty' : `${valueNow}`\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'minute, ',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n    'data-placeholder': isEmpty ? '' : undefined,\n  }\n}\n\nfunction secondSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, placeholder } = props\n  if (!('second' in segmentValues) || !('second' in placeholder))\n    return {}\n  const isEmpty = segmentValues.second === null\n  const date = segmentValues.second\n    ? placeholder.set({ second: segmentValues.second })\n    : placeholder\n  const valueNow = date.second\n  const valueMin = 0\n  const valueMax = 59\n  const valueText = isEmpty ? 'Empty' : `${valueNow}`\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'second, ',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n    'data-placeholder': isEmpty ? '' : undefined,\n  }\n}\n\nfunction dayPeriodSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues } = props\n  if (!('dayPeriod' in segmentValues))\n    return {}\n\n  const valueMin = 0\n  const valueMax = 12\n  const valueNow = segmentValues.hour ? (segmentValues.hour > 12 ? segmentValues.hour - 12 : segmentValues.hour) : 0\n  const valueText = segmentValues.dayPeriod ?? 'AM'\n\n  return {\n    ...commonSegmentAttrs(props),\n    'inputmode': 'text',\n    'aria-label': 'AM/PM',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n  }\n}\n\nfunction literalSegmentAttrs(_props: SegmentAttrProps) {\n  return {\n    'aria-hidden': true,\n    'data-segment': 'literal',\n  }\n}\n\nfunction timeZoneSegmentAttrs(props: SegmentAttrProps) {\n  return {\n    'role': 'textbox',\n    'aria-label': 'timezone, ',\n    'data-readonly': true,\n    'data-segment': 'timeZoneName',\n    'tabindex': props.disabled ? undefined : 0,\n    'style': 'caret-color: transparent;',\n  }\n}\n\nfunction eraSegmentAttrs(props: SegmentAttrProps) {\n  const { segmentValues, placeholder } = props\n\n  const valueMin = 0\n  const valueMax = 0\n  const valueNow = 0\n  const valueText = 'era' in segmentValues ? segmentValues.era : placeholder.era\n\n  return {\n    ...commonSegmentAttrs(props),\n    'aria-label': 'era',\n    'aria-valuemin': valueMin,\n    'aria-valuemax': valueMax,\n    'aria-valuenow': valueNow,\n    'aria-valuetext': valueText,\n  }\n}\n\nexport const segmentBuilders = {\n  day: {\n    attrs: daySegmentAttrs,\n  },\n  month: {\n    attrs: monthSegmentAttrs,\n  },\n  year: {\n    attrs: yearSegmentAttrs,\n  },\n  hour: {\n    attrs: hourSegmentAttrs,\n  },\n  minute: {\n    attrs: minuteSegmentAttrs,\n  },\n  second: {\n    attrs: secondSegmentAttrs,\n  },\n  dayPeriod: {\n    attrs: dayPeriodSegmentAttrs,\n  },\n  literal: {\n    attrs: literalSegmentAttrs,\n  },\n  timeZoneName: {\n    attrs: timeZoneSegmentAttrs,\n  },\n  era: {\n    attrs: eraSegmentAttrs,\n  },\n}\n\nexport type UseDateFieldProps = {\n  hasLeftFocus: Ref<boolean>\n  lastKeyZero: Ref<boolean>\n  placeholder: Ref<DateValue>\n  hourCycle: HourCycle\n  step: Ref<DateStep>\n  formatter: Formatter\n  segmentValues: Ref<SegmentValueObj>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  part: SegmentPart\n  modelValue: Ref<DateValue | undefined>\n  focusNext: () => void\n}\n\nexport function useDateField(props: UseDateFieldProps) {\n  const kbd = useKbd()\n\n  function minuteSecondIncrementation({ e, part, dateRef, prevValue }: MinuteSecondIncrementProps): number {\n    const step = props.step.value[part] ?? 1\n    const sign = e.key === kbd.ARROW_UP ? step : -step\n    const min = 0\n    const max = 59\n\n    if (prevValue === null)\n      return sign > 0 ? min : max\n\n    const cycleArgs: [keyof TimeFields, number] = [part, sign]\n    return (dateRef as CalendarDateTime).set({ [part]: prevValue }).cycle(...cycleArgs)[part]\n  }\n\n  function deleteValue(prevValue: number | null) {\n    props.hasLeftFocus.value = false\n    if (prevValue === null)\n      return prevValue\n\n    const str = prevValue.toString()\n    if (str.length === 1) {\n      props.modelValue.value = undefined\n      return null\n    }\n\n    return Number.parseInt(str.slice(0, -1))\n  }\n  function dateTimeValueIncrementation({ e, part, dateRef, prevValue, hourCycle }: DateTimeValueIncrementation): number {\n    const step = props.step.value[part] ?? 1\n    const sign = e.key === kbd.ARROW_UP ? step : -step\n\n    if (prevValue === null)\n      return dateRef[part as keyof Omit<DateFields, 'era'>]\n\n    if (part === 'hour' && 'hour' in dateRef) {\n      const cycleArgs: [keyof DateFields | keyof TimeFields, number, CycleTimeOptions?] = [part, sign, { hourCycle }]\n      return dateRef.set({ [part as keyof DateValue]: prevValue }).cycle(...cycleArgs)[part]\n    }\n\n    const cycleArgs: [keyof DateFields, number] = [part as keyof DateFields, sign]\n    if (part === 'day') {\n      return dateRef.set({\n        [part as keyof DateValue]: prevValue,\n        /**\n         * Edge case for the day field:\n         *\n         * 1. If the month is filled,\n         *   we need to ensure that the day snaps to the maximum value of that month.\n         * 2. If the month is not filled,\n         *   we default to the month with the maximum number of days (here just using January, 31 days),\n         *   so that user can input any possible day.\n         */\n        month: props.segmentValues.value.month ?? 1,\n      }).cycle(...cycleArgs)[part as keyof Omit<DateFields, 'era'>]\n    }\n\n    return dateRef.set({ [part as keyof DateValue]: prevValue }).cycle(...cycleArgs)[part as keyof Omit<DateFields, 'era'>]\n  }\n  function updateDayOrMonth(max: number, num: number, prev: number | null) {\n    let moveToNext = false\n    const maxStart = Math.floor(max / 10)\n\n    /**\n     * If the user has left the segment, we want to reset the\n     * `prev` value so that we can start the segment over again\n     * when the user types a number.\n     */\n    if (props.hasLeftFocus.value) {\n      props.hasLeftFocus.value = false\n      prev = null\n    }\n\n    if (prev === null) {\n    /**\n     * If the user types a 0 as the first number, we want\n     * to keep track of that so that when they type the next\n     * number, we can move to the next segment.\n     */\n\n      if (num === 0) {\n        props.lastKeyZero.value = true\n        return { value: null, moveToNext }\n      }\n      /**\n       * If the last key was a 0, or if the first number is\n       * greater than the max start digit (0-3 in most cases), then\n       * we want to move to the next segment, since it's not possible\n       * to continue typing a valid number in this segment.\n       */\n\n      if (props.lastKeyZero.value || num > maxStart) {\n      // move to next\n        moveToNext = true\n      }\n      props.lastKeyZero.value = false\n      /**\n       * If none of the above conditions are met, then we can just\n       * return the number as the segment value and continue typing\n       * in this segment.\n       */\n      return { value: num, moveToNext }\n    }\n\n    /**\n     * If the number of digits is 2, or if the total with the existing digit\n     * and the pressed digit is greater than the maximum value for this\n     * month, then we will reset the segment as if the user had pressed the\n     * backspace key and then typed the number.\n     */\n    const digits = prev.toString().length\n    const total = Number.parseInt(prev.toString() + num.toString())\n    /**\n     * If the number of digits is 2, or if the total with the existing digit\n     * and the pressed digit is greater than the maximum value for this\n     * month, then we will reset the segment as if the user had pressed the\n     * backspace key and then typed the number.\n     */\n\n    if (digits === 2 || total > max) {\n    /**\n     * As we're doing elsewhere, we're checking if the number is greater\n     * than the max start digit (0-3 in most months), and if so, we're\n     * going to move to the next segment.\n     */\n      if (num > maxStart || total > max) {\n      // move to next\n        moveToNext = true\n      }\n      return { value: num, moveToNext }\n    }\n    // move to next\n    moveToNext = true\n    return { value: total, moveToNext }\n  }\n\n  function updateMinuteOrSecond(num: number, prev: number | null) {\n    const max = 59\n    let moveToNext = false\n    const maxStart = Math.floor(max / 10)\n\n    /**\n     * If the user has left the segment, we want to reset the\n     * `prev` value so that we can start the segment over again\n     * when the user types a number.\n     */\n    if (props.hasLeftFocus.value) {\n      props.hasLeftFocus.value = false\n      prev = null\n    }\n\n    if (prev === null) {\n    /**\n     * If the user types a 0 as the first number, we want\n     * to keep track of that so that when they type the next\n     * number, we can move to the next segment.\n     */\n\n      if (num === 0) {\n        props.lastKeyZero.value = true\n        return { value: 0, moveToNext }\n      }\n      /**\n       * If the last key was a 0, or if the first number is\n       * greater than the max start digit (0-3 in most cases), then\n       * we want to move to the next segment, since it's not possible\n       * to continue typing a valid number in this segment.\n       */\n\n      if (props.lastKeyZero.value || num > maxStart) {\n      // move to next\n        moveToNext = true\n      }\n      props.lastKeyZero.value = false\n      /**\n       * If none of the above conditions are met, then we can just\n       * return the number as the segment value and continue typing\n       * in this segment.\n       */\n      return { value: num, moveToNext }\n    }\n\n    /**\n     * If the number of digits is 2, or if the total with the existing digit\n     * and the pressed digit is greater than the maximum value for this\n     * month, then we will reset the segment as if the user had pressed the\n     * backspace key and then typed the number.\n     */\n    const digits = prev.toString().length\n    const total = Number.parseInt(prev.toString() + num.toString())\n\n    /**\n     * If the number of digits is 2, or if the total with the existing digit\n     * and the pressed digit is greater than the maximum value for this\n     * month, then we will reset the segment as if the user had pressed the\n     * backspace key and then typed the number.\n     */\n\n    if (digits === 2 || total > max) {\n    /**\n     * As we're doing elsewhere, we're checking if the number is greater\n     * than the max start digit (0-3 in most months), and if so, we're\n     * going to move to the next segment.\n     */\n      if (num > maxStart) {\n      // move to next\n        moveToNext = true\n      }\n      return { value: num, moveToNext }\n    }\n    // move to next\n    moveToNext = true\n    return { value: total, moveToNext }\n  }\n\n  function updateHour(num: number, prev: number | null) {\n    const max = 24\n    let moveToNext = false\n    const maxStart = Math.floor(max / 10)\n\n    /**\n     * If the user has left the segment, we want to reset the\n     * `prev` value so that we can start the segment over again\n     * when the user types a number.\n     */\n    // probably not implement, kind of weird\n    if (props.hasLeftFocus.value) {\n      props.hasLeftFocus.value = false\n      prev = null\n    }\n\n    if (prev === null) {\n    /**\n     * If the user types a 0 as the first number, we want\n     * to keep track of that so that when they type the next\n     * number, we can move to the next segment.\n     */\n\n      if (num === 0) {\n        props.lastKeyZero.value = true\n        return { value: 0, moveToNext }\n      }\n      /**\n       * If the last key was a 0, or if the first number is\n       * greater than the max start digit (0-3 in most cases), then\n       * we want to move to the next segment, since it's not possible\n       * to continue typing a valid number in this segment.\n       */\n\n      if (props.lastKeyZero.value || num > maxStart) {\n      // move to next\n        moveToNext = true\n      }\n      props.lastKeyZero.value = false\n      /**\n       * If none of the above conditions are met, then we can just\n       * return the number as the segment value and continue typing\n       * in this segment.\n       */\n      return { value: num, moveToNext }\n    }\n\n    /**\n     * If the number of digits is 2, or if the total with the existing digit\n     * and the pressed digit is greater than the maximum value for this\n     * month, then we will reset the segment as if the user had pressed the\n     * backspace key and then typed the number.\n     */\n    const digits = prev.toString().length\n    const total = Number.parseInt(prev.toString() + num.toString())\n\n    /**\n     * If the number of digits is 2, or if the total with the existing digit\n     * and the pressed digit is greater than the maximum value for this\n     * month, then we will reset the segment as if the user had pressed the\n     * backspace key and then typed the number.\n     */\n\n    if (digits === 2 || total > max) {\n    /**\n     * As we're doing elsewhere, we're checking if the number is greater\n     * than the max start digit (0-3 in most months), and if so, we're\n     * going to move to the next segment.\n     */\n      if (num > maxStart) {\n      // move to next\n        moveToNext = true\n      }\n      return { value: num, moveToNext }\n    }\n    // move to next\n    moveToNext = true\n    return { value: total, moveToNext }\n  }\n\n  function updateYear(num: number, prev: number | null) {\n    let moveToNext = false\n\n    /**\n     * If the user has left the segment, we want to reset the\n     * `prev` value so that we can start the segment over again\n     * when the user types a number.\n     */\n    // probably not implement, kind of weird\n    if (props.hasLeftFocus.value) {\n      props.hasLeftFocus.value = false\n      prev = null\n    }\n\n    if (prev === null)\n      return { value: num === 0 ? 1 : num, moveToNext }\n\n    const str = prev.toString() + num.toString()\n\n    if (str.length > 4)\n      return { value: num === 0 ? 1 : num, moveToNext }\n\n    if (str.length === 4)\n      moveToNext = true\n\n    const int = Number.parseInt(str)\n    return { value: int, moveToNext }\n  }\n\n  const attributes = computed(() => segmentBuilders[props.part]?.attrs({\n    disabled: props.disabled.value,\n    placeholder: props.placeholder.value,\n    hourCycle: props.hourCycle,\n    segmentValues: props.segmentValues.value,\n    formatter: props.formatter,\n  }) ?? {})\n\n  // TODO: look into abstracting segment keydown functions since they have the same structure (checks -> arrow_up, arrow_down update -> number string update -> move to next -> backspace update)\n  function handleDaySegmentKeydown(e: KeyboardEvent) {\n    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key))\n      return\n\n    const prevValue = props.segmentValues.value.day\n\n    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {\n      props.segmentValues.value.day = dateTimeValueIncrementation({ e, part: 'day', dateRef: props.placeholder.value, prevValue })\n      return\n    }\n\n    if (isNumberString(e.key)) {\n      const num = Number.parseInt(e.key)\n      const segmentMonthValue = props.segmentValues.value.month\n\n      const daysInMonth = segmentMonthValue\n        ? getDaysInMonth(props.placeholder.value.set({ month: segmentMonthValue }))\n        // if the month is not set, we default to the maximum number of days in a month\n        // so that user can input any possible day\n        : 31\n\n      const { value, moveToNext } = updateDayOrMonth(daysInMonth, num, prevValue)\n\n      props.segmentValues.value.day = value\n\n      if (moveToNext)\n        props.focusNext()\n    }\n\n    if (e.key === kbd.BACKSPACE) {\n      props.hasLeftFocus.value = false\n      props.segmentValues.value.day = deleteValue(prevValue)\n    }\n  }\n\n  function handleMonthSegmentKeydown(e: KeyboardEvent) {\n    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key))\n      return\n\n    const prevValue = props.segmentValues.value.month\n\n    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {\n      props.segmentValues.value.month = dateTimeValueIncrementation({ e, part: 'month', dateRef: props.placeholder.value, prevValue })\n      return\n    }\n\n    if (isNumberString(e.key)) {\n      const num = Number.parseInt(e.key)\n      const { value, moveToNext } = updateDayOrMonth(12, num, prevValue)\n\n      props.segmentValues.value.month = value\n\n      if (moveToNext)\n        props.focusNext()\n    }\n\n    if (e.key === kbd.BACKSPACE) {\n      props.hasLeftFocus.value = false\n      props.segmentValues.value.month = deleteValue(prevValue)\n    }\n  }\n\n  function handleYearSegmentKeydown(e: KeyboardEvent) {\n    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key))\n      return\n\n    const prevValue = props.segmentValues.value.year\n\n    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {\n      props.segmentValues.value.year = dateTimeValueIncrementation({ e, part: 'year', dateRef: props.placeholder.value, prevValue })\n      return\n    }\n\n    if (isNumberString(e.key)) {\n      const num = Number.parseInt(e.key)\n      const { value, moveToNext } = updateYear(num, prevValue)\n\n      props.segmentValues.value.year = value\n\n      if (moveToNext)\n        props.focusNext()\n    }\n\n    if (e.key === kbd.BACKSPACE) {\n      props.hasLeftFocus.value = false\n      props.segmentValues.value.year = deleteValue(prevValue)\n    }\n  }\n\n  function handleHourSegmentKeydown(e: KeyboardEvent) {\n    const dateRef = props.placeholder.value\n    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !('hour' in dateRef) || !('hour' in props.segmentValues.value))\n      return\n\n    const prevValue = props.segmentValues.value.hour\n\n    const hourCycle = props.hourCycle\n\n    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {\n      props.segmentValues.value.hour = dateTimeValueIncrementation({ e, part: 'hour', dateRef: props.placeholder.value, prevValue, hourCycle })\n\n      if ('dayPeriod' in props.segmentValues.value) {\n        if (props.segmentValues.value.hour < 12)\n          props.segmentValues.value.dayPeriod = 'AM'\n        else if (props.segmentValues.value.hour)\n          props.segmentValues.value.dayPeriod = 'PM'\n      }\n\n      return\n    }\n\n    if (isNumberString(e.key)) {\n      const num = Number.parseInt(e.key)\n      const { value, moveToNext } = updateHour(num, prevValue)\n\n      if ('dayPeriod' in props.segmentValues.value && value && value > 12)\n        props.segmentValues.value.dayPeriod = 'PM'\n      else if ('dayPeriod' in props.segmentValues.value && value)\n        props.segmentValues.value.dayPeriod = 'AM'\n\n      props.segmentValues.value.hour = value\n\n      if (moveToNext)\n        props.focusNext()\n    }\n\n    if (e.key === kbd.BACKSPACE) {\n      props.hasLeftFocus.value = false\n      props.segmentValues.value.hour = deleteValue(prevValue)\n    }\n  }\n\n  function handleMinuteSegmentKeydown(e: KeyboardEvent) {\n    const dateRef = props.placeholder.value\n\n    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !('minute' in dateRef) || !('minute' in props.segmentValues.value))\n      return\n\n    const prevValue = props.segmentValues.value.minute\n\n    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {\n      props.segmentValues.value.minute = minuteSecondIncrementation({ e, part: 'minute', dateRef: props.placeholder.value, prevValue })\n    }\n\n    if (isNumberString(e.key)) {\n      const num = Number.parseInt(e.key)\n\n      const { value, moveToNext } = updateMinuteOrSecond(num, prevValue)\n\n      props.segmentValues.value.minute = value\n\n      if (moveToNext)\n        props.focusNext()\n    }\n\n    if (e.key === kbd.BACKSPACE) {\n      props.hasLeftFocus.value = false\n      props.segmentValues.value.minute = deleteValue(prevValue)\n    }\n  }\n\n  function handleSecondSegmentKeydown(e: KeyboardEvent) {\n    const dateRef = props.placeholder.value\n\n    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !('second' in dateRef) || !('second' in props.segmentValues.value))\n      return\n\n    const prevValue = props.segmentValues.value.second\n\n    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {\n      props.segmentValues.value.second = minuteSecondIncrementation({ e, part: 'second', dateRef: props.placeholder.value, prevValue })\n    }\n\n    if (isNumberString(e.key)) {\n      const num = Number.parseInt(e.key)\n      const { value, moveToNext } = updateMinuteOrSecond(num, prevValue)\n\n      props.segmentValues.value.second = value\n\n      if (moveToNext)\n        props.focusNext()\n    }\n\n    if (e.key === kbd.BACKSPACE) {\n      props.hasLeftFocus.value = false\n      props.segmentValues.value.second = deleteValue(prevValue)\n    }\n  }\n\n  function handleDayPeriodSegmentKeydown(e: KeyboardEvent) {\n    if (((!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) && e.key !== 'a' && e.key !== 'p') || !('hour' in props.placeholder.value) || !('dayPeriod' in props.segmentValues.value))\n      return\n\n    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {\n      if (props.segmentValues.value.dayPeriod === 'AM') {\n        props.segmentValues.value.dayPeriod = 'PM'\n        props.segmentValues.value.hour = props.segmentValues.value.hour! + 12\n        return\n      }\n      props.segmentValues.value.dayPeriod = 'AM'\n      props.segmentValues.value.hour = props.segmentValues.value.hour! - 12\n      return\n    }\n\n    if (['a', 'A'].includes(e.key) && props.segmentValues.value.dayPeriod !== 'AM') {\n      props.segmentValues.value.dayPeriod = 'AM'\n      props.segmentValues.value.hour = props.segmentValues.value.hour! - 12\n      return\n    }\n\n    if (['p', 'P'].includes(e.key) && props.segmentValues.value.dayPeriod !== 'PM') {\n      props.segmentValues.value.dayPeriod = 'PM'\n      props.segmentValues.value.hour = props.segmentValues.value.hour! + 12\n    }\n  }\n\n  function handleSegmentClick(e: MouseEvent) {\n    const disabled = props.disabled.value\n    if (disabled)\n      e.preventDefault()\n  }\n\n  function handleSegmentKeydown(e: KeyboardEvent) {\n    const disabled = props.disabled.value\n    const readonly = props.readonly.value\n    if (e.key !== kbd.TAB)\n      e.preventDefault()\n\n    if (disabled || readonly)\n      return\n    const segmentKeydownHandlers = {\n      day: handleDaySegmentKeydown,\n      month: handleMonthSegmentKeydown,\n      year: handleYearSegmentKeydown,\n      hour: handleHourSegmentKeydown,\n      minute: handleMinuteSegmentKeydown,\n      second: handleSecondSegmentKeydown,\n      dayPeriod: handleDayPeriodSegmentKeydown,\n      timeZoneName: () => {},\n    } as const\n\n    segmentKeydownHandlers[props.part as keyof typeof segmentKeydownHandlers](e)\n\n    if (![kbd.ARROW_LEFT, kbd.ARROW_RIGHT].includes(e.key) && e.key !== kbd.TAB && e.key !== kbd.SHIFT && isAcceptableSegmentKey(e.key)) {\n      if (Object.values(props.segmentValues.value).every(item => item !== null)) {\n        const updateObject = { ...props.segmentValues.value as Record<AnyExceptLiteral, number> }\n\n        let dateRef = props.placeholder.value.copy()\n\n        Object.keys(updateObject).forEach((part) => {\n          const value = updateObject[part as AnyExceptLiteral]\n          dateRef = dateRef.set({ [part]: value })\n        })\n\n        props.modelValue.value = dateRef.copy()\n      }\n    }\n  }\n\n  return {\n    handleSegmentClick,\n    handleSegmentKeydown,\n    attributes,\n  }\n}\n", "/*\n  * Implementation ported from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/builders/date-field/_internal/helpers.ts\n*/\n\nimport type { DateSegmentPart, EditableSegmentPart, SegmentPart, TimeSegmentPart } from './types'\n\nexport const DATE_SEGMENT_PARTS = ['day', 'month', 'year'] as const\nexport const TIME_SEGMENT_PARTS = ['hour', 'minute', 'second', 'dayPeriod'] as const\nexport const NON_EDITABLE_SEGMENT_PARTS = ['literal', 'timeZoneName'] as const\nexport const EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS] as const\nexport const EDITABLE_TIME_SEGMENT_PARTS = [...TIME_SEGMENT_PARTS] as const\nexport const ALL_SEGMENT_PARTS = [\n  ...EDITABLE_SEGMENT_PARTS,\n  ...NON_EDITABLE_SEGMENT_PARTS,\n] as const\nexport const ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter(part => part !== 'literal')\n\nexport function isDateSegmentPart(part: unknown): part is DateSegmentPart {\n  return DATE_SEGMENT_PARTS.includes(part as DateSegmentPart)\n}\n\nexport function isTimeSegmentPart(part: unknown): part is TimeSegmentPart {\n  return TIME_SEGMENT_PARTS.includes(part as TimeSegmentPart)\n}\n\nexport function isSegmentPart(part: string): part is EditableSegmentPart {\n  return EDITABLE_SEGMENT_PARTS.includes(part as EditableSegmentPart)\n}\n\nexport function isAnySegmentPart(part: unknown): part is SegmentPart {\n  return ALL_SEGMENT_PARTS.includes(part as EditableSegmentPart)\n}\n", "/*\n * Implementation ported from from from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/internal/helpers/date/placeholders.ts\n*/\n\nconst supportedLocales = [\n  'ach',\n  'af',\n  'am',\n  'an',\n  'ar',\n  'ast',\n  'az',\n  'be',\n  'bg',\n  'bn',\n  'br',\n  'bs',\n  'ca',\n  'cak',\n  'ckb',\n  'cs',\n  'cy',\n  'da',\n  'de',\n  'dsb',\n  'el',\n  'en',\n  'eo',\n  'es',\n  'et',\n  'eu',\n  'fa',\n  'ff',\n  'fi',\n  'fr',\n  'fy',\n  'ga',\n  'gd',\n  'gl',\n  'he',\n  'hr',\n  'hsb',\n  'hu',\n  'ia',\n  'id',\n  'it',\n  'ja',\n  'ka',\n  'kk',\n  'kn',\n  'ko',\n  'lb',\n  'lo',\n  'lt',\n  'lv',\n  'meh',\n  'ml',\n  'ms',\n  'nl',\n  'nn',\n  'no',\n  'oc',\n  'pl',\n  'pt',\n  'rm',\n  'ro',\n  'ru',\n  'sc',\n  'scn',\n  'sk',\n  'sl',\n  'sr',\n  'sv',\n  'szl',\n  'tg',\n  'th',\n  'tr',\n  'uk',\n  'zh-CN',\n  'zh-TW',\n] as const\n\nconst placeholderFields = ['year', 'month', 'day'] as const\n\ntype PlaceholderField = (typeof placeholderFields)[number]\nexport type SupportedLocale = (typeof supportedLocales)[number]\nexport type PlaceholderMap = Record<SupportedLocale, Record<PlaceholderField, string>>\n\nconst placeholders: PlaceholderMap = {\n  'ach': { year: 'mwaka', month: 'dwe', day: 'nino' },\n  'af': { year: 'jjjj', month: 'mm', day: 'dd' },\n  'am': { year: '', month: '', day: '' },\n  'an': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'ar': { year: '', month: '', day: '' },\n  'ast': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'az': { year: 'iiii', month: 'aa', day: 'gg' },\n  'be': { year: '', month: '', day: '' },\n  'bg': { year: '', month: '', day: '' },\n  'bn': { year: 'yyyy', month: '', day: 'dd' },\n  'br': { year: 'bbbb', month: 'mm', day: 'dd' },\n  'bs': { year: 'gggg', month: 'mm', day: 'dd' },\n  'ca': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'cak': { year: 'jjjj', month: 'ii', day: 'q\\'q\\'' },\n  'ckb': { year: '', month: '', day: '' },\n  'cs': { year: 'rrrr', month: 'mm', day: 'dd' },\n  'cy': { year: 'bbbb', month: 'mm', day: 'dd' },\n  'da': { year: '', month: 'mm', day: 'dd' },\n  'de': { year: 'jjjj', month: 'mm', day: 'tt' },\n  'dsb': { year: 'llll', month: 'mm', day: '' },\n  'el': { year: '', month: '', day: '' },\n  'en': { year: 'yyyy', month: 'mm', day: 'dd' },\n  'eo': { year: 'jjjj', month: 'mm', day: 'tt' },\n  'es': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'et': { year: 'aaaa', month: 'kk', day: 'pp' },\n  'eu': { year: 'uuuu', month: 'hh', day: 'ee' },\n  'fa': { year: '', month: '', day: '' },\n  'ff': { year: 'hhhh', month: 'll', day: '' },\n  'fi': { year: 'vvvv', month: 'kk', day: 'pp' },\n  'fr': { year: 'aaaa', month: 'mm', day: 'jj' },\n  'fy': { year: 'jjjj', month: 'mm', day: 'dd' },\n  'ga': { year: 'bbbb', month: 'mm', day: 'll' },\n  'gd': { year: 'bbbb', month: 'mm', day: 'll' },\n  'gl': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'he': { year: '', month: '', day: '' },\n  'hr': { year: 'gggg', month: 'mm', day: 'dd' },\n  'hsb': { year: 'llll', month: 'mm', day: 'dd' },\n  'hu': { year: '', month: 'hh', day: 'nn' },\n  'ia': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'id': { year: 'tttt', month: 'bb', day: 'hh' },\n  'it': { year: 'aaaa', month: 'mm', day: 'gg' },\n  'ja': { year: '  ', month: '', day: '' },\n  'ka': { year: '', month: '', day: '' },\n  'kk': { year: '', month: '', day: '' },\n  'kn': { year: '', month: '', day: '' },\n  'ko': { year: '', month: '', day: '' },\n  'lb': { year: 'jjjj', month: 'mm', day: 'dd' },\n  'lo': { year: '', month: '', day: '' },\n  'lt': { year: 'mmmm', month: 'mm', day: 'dd' },\n  'lv': { year: 'gggg', month: 'mm', day: 'dd' },\n  'meh': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'ml': { year: '', month: '', day: '' },\n  'ms': { year: 'tttt', month: 'mm', day: 'hh' },\n  'nl': { year: 'jjjj', month: 'mm', day: 'dd' },\n  'nn': { year: '', month: 'mm', day: 'dd' },\n  'no': { year: '', month: 'mm', day: 'dd' },\n  'oc': { year: 'aaaa', month: 'mm', day: 'jj' },\n  'pl': { year: 'rrrr', month: 'mm', day: 'dd' },\n  'pt': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'rm': { year: 'oooo', month: 'mm', day: 'dd' },\n  'ro': { year: 'aaaa', month: 'll', day: 'zz' },\n  'ru': { year: '', month: '', day: '' },\n  'sc': { year: 'aaaa', month: 'mm', day: 'dd' },\n  'scn': { year: 'aaaa', month: 'mm', day: 'jj' },\n  'sk': { year: 'rrrr', month: 'mm', day: 'dd' },\n  'sl': { year: 'llll', month: 'mm', day: 'dd' },\n  'sr': { year: '', month: '', day: '' },\n  'sv': { year: '', month: 'mm', day: 'dd' },\n  'szl': { year: 'rrrr', month: 'mm', day: 'dd' },\n  'tg': { year: '', month: '', day: '' },\n  'th': { year: '', month: '', day: '' },\n  'tr': { year: 'yyyy', month: 'aa', day: 'gg' },\n  'uk': { year: '', month: '', day: '' },\n  'zh-CN': { year: '', month: '', day: '' },\n  'zh-TW': { year: '', month: '', day: '' },\n}\n\nfunction getPlaceholderObj(locale: SupportedLocale | (string & {})) {\n  if (!isSupportedLocale(locale)) {\n    const localeLanguage = getLocaleLanguage(locale)\n    if (!isSupportedLocale(localeLanguage))\n      return placeholders.en\n\n    else\n      return placeholders[localeLanguage]\n  }\n  else {\n    return placeholders[locale]\n  }\n}\n\ntype Field = 'era' | 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' | 'dayPeriod'\n\nexport function getPlaceholder(\n  field: Field,\n  value: string,\n  locale: SupportedLocale | (string & {}),\n) {\n  if (isPlaceholderField(field))\n    return getPlaceholderObj(locale)[field]\n\n  if (isDefaultField(field))\n    return value\n\n  if (isTimeField(field))\n    return ''\n\n  return ''\n}\n\nfunction isSupportedLocale(locale: string): locale is SupportedLocale {\n  return supportedLocales.includes(locale as SupportedLocale)\n}\n\nfunction isPlaceholderField(field: unknown): field is PlaceholderField {\n  return placeholderFields.includes(field as PlaceholderField)\n}\n\nfunction isTimeField(field: unknown): field is 'hour' | 'minute' | 'second' {\n  return field === 'hour' || field === 'minute' || field === 'second'\n}\n\nfunction isDefaultField(field: unknown): field is 'era' | 'dayPeriod' {\n  return field === 'era' || field === 'dayPeriod'\n}\n\nfunction getLocaleLanguage(locale: string) {\n  if (Intl.Locale)\n    return new Intl.Locale(locale).language\n\n  return locale.split('-')[0]\n}\n", "import type { DateFields, DateValue } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { Formatter } from '@/shared'\nimport type { DateSegmentPart, Granularity, HourCycle, SegmentContentObj, SegmentPart, SegmentValueObj, TimeSegmentPart } from '@/shared/date'\nimport { isZonedDateTime, toDate } from '@/date'\nimport { DATE_SEGMENT_PARTS, EDITABLE_SEGMENT_PARTS, getOptsByGranularity, getPlaceholder, isDateSegmentPart, isSegmentPart, normalizeHourCycle, TIME_SEGMENT_PARTS } from '@/shared/date'\n\nconst calendarDateTimeGranularities = ['hour', 'minute', 'second']\n\ntype SyncDateSegmentValuesProps = {\n  value: DateValue\n  formatter: Formatter\n}\n\ntype SyncTimeSegmentValuesProps = {\n  value: DateValue\n  formatter: Formatter\n}\n\nexport function syncTimeSegmentValues(props: SyncTimeSegmentValuesProps) {\n  return Object.fromEntries(TIME_SEGMENT_PARTS.map((part) => {\n    if (part === 'dayPeriod')\n      return [part, props.formatter.dayPeriod(toDate(props.value))]\n    return [part, props.value[part as keyof DateValue]]\n  })) as SegmentValueObj\n}\n\nexport function syncSegmentValues(props: SyncDateSegmentValuesProps) {\n  const { formatter } = props\n\n  const dateValues = DATE_SEGMENT_PARTS.map((part) => {\n    return [part, props.value[part]]\n  })\n  if ('hour' in props.value) {\n    const timeValues = syncTimeSegmentValues({ value: props.value, formatter })\n\n    return { ...Object.fromEntries(dateValues), ...timeValues } as SegmentValueObj\n  }\n\n  return Object.fromEntries(dateValues) as SegmentValueObj\n}\n\nexport function initializeTimeSegmentValues(granularity: 'hour' | 'minute' | 'second'): SegmentValueObj {\n  return Object.fromEntries(\n    TIME_SEGMENT_PARTS.map((part) => {\n      if (part === 'dayPeriod')\n        return [part, 'AM']\n      return [part, null]\n    }).filter(([key]) => {\n      if (key === 'literal' || key === null)\n        return false\n      if (granularity === 'minute' && key === 'second')\n        return false\n      if (granularity === 'hour' && (key === 'second' || key === 'minute'))\n        return false\n      else return true\n    }),\n  )\n}\n\nexport function initializeSegmentValues(granularity: Granularity): SegmentValueObj {\n  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {\n    if (part === 'dayPeriod')\n      return [part, 'AM']\n\n    return [part, null]\n  }).filter(([key]) => {\n    if (key === 'literal' || key === null)\n      return false\n    if (granularity === 'minute' && key === 'second')\n      return false\n    if (granularity === 'hour' && (key === 'second' || key === 'minute'))\n      return false\n    if (granularity === 'day')\n      return !calendarDateTimeGranularities.includes(key) && key !== 'dayPeriod'\n    else return true\n  })\n\n  return Object.fromEntries(initialParts)\n}\n\ntype SharedContentProps = {\n  granularity: Granularity\n  dateRef: DateValue\n  formatter: Formatter\n  hideTimeZone: boolean\n  hourCycle: HourCycle\n  isTimeValue?: boolean\n}\n\ntype CreateContentObjProps = SharedContentProps & {\n  segmentValues: SegmentValueObj\n  locale: Ref<string>\n}\n\ntype CreateContentArrProps = SharedContentProps & {\n  contentObj: SegmentContentObj\n}\n\nfunction createContentObj(props: CreateContentObjProps) {\n  const { segmentValues, formatter, locale } = props\n  function getPartContent(part: DateSegmentPart | TimeSegmentPart) {\n    if ('hour' in segmentValues) {\n      const value = segmentValues[part]\n      if (value !== null) {\n        if (part === 'day') {\n          return formatter.part(props.dateRef.set({\n            [part as keyof DateFields]: value,\n            /**\n             * Edge case for the day field:\n             *\n             * 1. If the month is filled,\n             *   we need to ensure that the day snaps to the maximum value of that month.\n             * 2. If the month is not filled,\n             *   we default to the month with the maximum number of days (here just using January, 31 days),\n             *   so that user can input any possible day.\n             */\n            month: segmentValues.month ?? 1,\n          }), part, { hourCycle: normalizeHourCycle(props.hourCycle) })\n        }\n        return formatter.part(props.dateRef.set({ [part]: value }), part, {\n          hourCycle: normalizeHourCycle(props.hourCycle),\n        })\n      }\n      else {\n        return getPlaceholder(part, '', locale.value)\n      }\n    }\n    else {\n      if (isDateSegmentPart(part)) {\n        const value = segmentValues[part]\n        if (value !== null) {\n          if (part === 'day') {\n            return formatter.part(props.dateRef.set({\n              [part]: value,\n              // Same logic as above for the day field\n              month: segmentValues.month ?? 1,\n            }), part)\n          }\n\n          return formatter.part(props.dateRef.set({ [part]: value }), part)\n        }\n\n        else {\n          return getPlaceholder(part, '', locale.value)\n        }\n      }\n      return ''\n    }\n  }\n\n  const content = Object.keys(segmentValues).reduce((obj, part) => {\n    if (!isSegmentPart(part))\n      return obj\n    if ('hour' in segmentValues && part === 'dayPeriod') {\n      const value = segmentValues[part]\n\n      if (value !== null)\n        obj[part] = value\n\n      else\n        obj[part] = getPlaceholder(part, 'AM', locale.value)\n    }\n    else {\n      obj[part] = getPartContent(part)\n    }\n\n    return obj\n  }, {} as SegmentContentObj)\n\n  return content\n}\n\nfunction createContentArr(props: CreateContentArrProps) {\n  const { granularity, formatter, contentObj, hideTimeZone, hourCycle, isTimeValue } = props\n  const parts = formatter.toParts(props.dateRef, getOptsByGranularity(granularity, hourCycle, isTimeValue))\n\n  const segmentContentArr = parts\n    .map((part) => {\n      const defaultParts = ['literal', 'timeZoneName', null]\n\n      if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {\n        return {\n          part: part.type,\n          value: part.value,\n        }\n      }\n\n      return {\n        part: part.type,\n        value: contentObj[part.type],\n      }\n    })\n    .filter((segment): segment is { part: SegmentPart, value: string } => {\n      if (segment.part === null || segment.value === null)\n        return false\n      if (segment.part === 'timeZoneName' && (!isZonedDateTime(props.dateRef) || hideTimeZone))\n        return false\n\n      return true\n    })\n\n  return segmentContentArr\n}\n\ntype CreateContentProps = CreateContentObjProps\n\nexport function createContent(props: CreateContentProps) {\n  const contentObj = createContentObj(props)\n\n  const contentArr = createContentArr({\n    contentObj,\n    ...props,\n  })\n\n  return {\n    obj: contentObj,\n    arr: contentArr,\n  }\n}\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { Matcher } from '@/date'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { DateStep, Formatter } from '@/shared'\nimport type { Granularity, HourCycle, SegmentPart, SegmentValueObj } from '@/shared/date'\nimport type { Direction, FormFieldProps } from '@/shared/types'\nimport { hasTime, isBefore } from '@/date'\nimport { createContext, isNullish, useDateFormatter, useDirection, useKbd, useLocale } from '@/shared'\nimport {\n  createContent,\n  getDefaultDate,\n  getSegmentElements,\n  initializeSegmentValues,\n  isSegmentNavigationKey,\n  normalizeDateStep,\n  normalizeHourCycle,\n  syncSegmentValues,\n} from '@/shared/date'\n\ntype DateFieldRootContext = {\n  locale: Ref<string>\n  modelValue: Ref<DateValue | undefined>\n  placeholder: Ref<DateValue>\n  isDateUnavailable?: Matcher\n  isInvalid: Ref<boolean>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  formatter: Formatter\n  hourCycle: HourCycle\n  step: Ref<DateStep>\n  segmentValues: Ref<SegmentValueObj>\n  segmentContents: Ref<{ part: SegmentPart, value: string }[]>\n  elements: Ref<Set<HTMLElement>>\n  focusNext: () => void\n  setFocusedElement: (el: HTMLElement) => void\n}\n\nexport interface DateFieldRootProps extends PrimitiveProps, FormFieldProps {\n  /** The default value for the calendar */\n  defaultValue?: DateValue\n  /** The default placeholder date */\n  defaultPlaceholder?: DateValue\n  /** The placeholder date, which is used to determine what month to display when no date is selected. This updates as the user navigates the calendar and can be used to programmatically control the calendar view */\n  placeholder?: DateValue\n  /** The controlled checked state of the calendar. Can be bound as `v-model`. */\n  modelValue?: DateValue | null\n  /** The hour cycle used for formatting times. Defaults to the local preference */\n  hourCycle?: HourCycle\n  /** The stepping interval for the time fields. Defaults to `1`. */\n  step?: DateStep\n  /** The granularity to use for formatting times. Defaults to day if a CalendarDate is provided, otherwise defaults to minute. The field will render segments for each part of the date up to and including the specified granularity */\n  granularity?: Granularity\n  /** Whether or not to hide the time zone segment of the field */\n  hideTimeZone?: boolean\n  /** The maximum date that can be selected */\n  maxValue?: DateValue\n  /** The minimum date that can be selected */\n  minValue?: DateValue\n  /** The locale to use for formatting dates */\n  locale?: string\n  /** Whether or not the date field is disabled */\n  disabled?: boolean\n  /** Whether or not the date field is readonly */\n  readonly?: boolean\n  /** A function that returns whether or not a date is unavailable */\n  isDateUnavailable?: Matcher\n  /** Id of the element */\n  id?: string\n  /** The reading direction of the date field when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n}\n\nexport type DateFieldRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [date: DateValue | undefined]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: DateValue]\n}\n\nexport const [injectDateFieldRootContext, provideDateFieldRootContext]\n  = createContext<DateFieldRootContext>('DateFieldRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, nextTick, onMounted, ref, toRefs, watch } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { VisuallyHidden } from '@/VisuallyHidden'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<DateFieldRootProps>(), {\n  defaultValue: undefined,\n  disabled: false,\n  readonly: false,\n  placeholder: undefined,\n  isDateUnavailable: undefined,\n})\nconst emits = defineEmits<DateFieldRootEmits>()\ndefineSlots<{\n  default?: (props: {\n    /** The current date of the field */\n    modelValue: DateValue | undefined\n    /** The date field segment contents */\n    segments: { part: SegmentPart, value: string }[]\n    /** Value if the input is invalid */\n    isInvalid: boolean\n  }) => any\n}>()\n\nconst { disabled, readonly, isDateUnavailable: propsIsDateUnavailable, granularity, defaultValue, dir: propDir, locale: propLocale } = toRefs(props)\nconst locale = useLocale(propLocale)\nconst dir = useDirection(propDir)\n\nconst formatter = useDateFormatter(locale.value, {\n  hourCycle: normalizeHourCycle(props.hourCycle),\n})\nconst { primitiveElement, currentElement: parentElement }\n  = usePrimitiveElement()\nconst segmentElements = ref<Set<HTMLElement>>(new Set())\n\nonMounted(() => {\n  getSegmentElements(parentElement.value).forEach(item => segmentElements.value.add(item as HTMLElement))\n})\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: defaultValue.value,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<DateValue>\n\nconst defaultDate = getDefaultDate({\n  defaultPlaceholder: props.placeholder,\n  granularity: granularity.value,\n  defaultValue: modelValue.value,\n  locale: props.locale,\n})\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<DateValue>\n\nconst step = computed(() => normalizeDateStep(props))\n\nconst inferredGranularity = computed(() => {\n  if (props.granularity)\n    return !hasTime(placeholder.value) ? 'day' : props.granularity\n\n  return hasTime(placeholder.value) ? 'minute' : 'day'\n})\n\nconst isInvalid = computed(() => {\n  if (!modelValue.value)\n    return false\n\n  if (propsIsDateUnavailable.value?.(modelValue.value))\n    return true\n\n  if (props.minValue && isBefore(modelValue.value, props.minValue))\n    return true\n\n  if (props.maxValue && isBefore(props.maxValue, modelValue.value))\n    return true\n\n  return false\n})\n\nconst initialSegments = initializeSegmentValues(inferredGranularity.value)\n\nconst segmentValues = ref<SegmentValueObj>(modelValue.value ? { ...syncSegmentValues({ value: modelValue.value, formatter }) } : { ...initialSegments })\n\nconst allSegmentContent = computed(() => createContent({\n  granularity: inferredGranularity.value,\n  dateRef: placeholder.value,\n  formatter,\n  hideTimeZone: props.hideTimeZone,\n  hourCycle: props.hourCycle,\n  segmentValues: segmentValues.value,\n  locale,\n}))\n\nconst segmentContents = computed(() => allSegmentContent.value.arr)\n\nconst editableSegmentContents = computed(() => segmentContents.value.filter(({ part }) => part !== 'literal'))\n\nwatch(locale, (value) => {\n  if (formatter.getLocale() !== value) {\n    formatter.setLocale(value)\n    // Locale changed, so we need to clear the segment elements and re-get them (different order)\n    // Get the focusable elements again on the next tick\n    nextTick(() => {\n      segmentElements.value.clear()\n      getSegmentElements(parentElement.value).forEach(item => segmentElements.value.add(item as HTMLElement))\n    })\n  }\n})\n\nwatch(modelValue, (_modelValue) => {\n  if (!isNullish(_modelValue) && placeholder.value.compare(_modelValue) !== 0) {\n    placeholder.value = _modelValue.copy()\n  }\n})\n\nwatch([modelValue, locale], ([_modelValue]) => {\n  if (!isNullish(_modelValue)) {\n    segmentValues.value = { ...syncSegmentValues({ value: _modelValue, formatter }) }\n  }\n  // If segment has null value, means that user modified it, thus do not reset the segmentValues\n  else if (Object.values(segmentValues.value).every(value => value !== null) && isNullish(_modelValue)) {\n    segmentValues.value = { ...initialSegments }\n  }\n})\n\nconst currentFocusedElement = ref<HTMLElement | null>(null)\n\nconst currentSegmentIndex = computed(() =>\n  Array.from(segmentElements.value).findIndex(el =>\n    el.getAttribute('data-reka-date-field-segment')\n    === currentFocusedElement.value?.getAttribute('data-reka-date-field-segment')))\n\nconst nextFocusableSegment = computed(() => {\n  const sign = dir.value === 'rtl' ? -1 : 1\n  const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1\n  if (nextCondition)\n    return null\n  const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign]\n  return segmentToFocus\n})\n\nconst prevFocusableSegment = computed(() => {\n  const sign = dir.value === 'rtl' ? -1 : 1\n  const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1\n  if (prevCondition)\n    return null\n\n  const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign]\n  return segmentToFocus\n})\n\nconst kbd = useKbd()\n\nfunction handleKeydown(e: KeyboardEvent) {\n  if (!isSegmentNavigationKey(e.key))\n    return\n  if (e.key === kbd.ARROW_LEFT)\n    prevFocusableSegment.value?.focus()\n  if (e.key === kbd.ARROW_RIGHT)\n    nextFocusableSegment.value?.focus()\n}\n\nfunction setFocusedElement(el: HTMLElement) {\n  currentFocusedElement.value = el\n}\n\nprovideDateFieldRootContext({\n  isDateUnavailable: propsIsDateUnavailable.value,\n  locale,\n  modelValue,\n  placeholder,\n  disabled,\n  formatter,\n  hourCycle: props.hourCycle,\n  step,\n  readonly,\n  segmentValues,\n  isInvalid,\n  segmentContents: editableSegmentContents,\n  elements: segmentElements,\n  setFocusedElement,\n  focusNext() {\n    nextFocusableSegment.value?.focus()\n  },\n})\n\ndefineExpose({\n  /** Helper to set the focused element inside the DateField */\n  setFocusedElement,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    ref=\"primitiveElement\"\n    role=\"group\"\n    :aria-disabled=\"disabled ? true : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-readonly=\"readonly ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :dir=\"dir\"\n    @keydown.left.right=\"handleKeydown\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :segments=\"segmentContents\"\n      :is-invalid=\"isInvalid\"\n    />\n\n    <VisuallyHidden\n      :id=\"id\"\n      as=\"input\"\n      feature=\"focusable\"\n      tabindex=\"-1\"\n      :value=\"modelValue ? modelValue.toString() : ''\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n      @focus=\"Array.from(segmentElements)?.[0]?.focus()\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { SegmentPart } from '@/shared/date'\nimport { computed, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useDateField } from '@/shared/date/useDateField'\nimport { injectDateFieldRootContext } from './DateFieldRoot.vue'\n\nexport interface DateFieldInputProps extends PrimitiveProps {\n  /** The part of the date to render */\n  part: SegmentPart\n}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateFieldInputProps>()\n\nconst rootContext = injectDateFieldRootContext()\n\nconst hasLeftFocus = ref(true)\nconst lastKeyZero = ref(false)\n\nconst {\n  handleSegmentClick,\n  handleSegmentKeydown,\n  attributes,\n} = useDateField({\n  hasLeftFocus,\n  lastKeyZero,\n  placeholder: rootContext.placeholder,\n  hourCycle: rootContext.hourCycle,\n  step: rootContext.step,\n  segmentValues: rootContext.segmentValues,\n  formatter: rootContext.formatter,\n  part: props.part,\n  disabled: rootContext.disabled,\n  readonly: rootContext.readonly,\n  focusNext: rootContext.focusNext,\n  modelValue: rootContext.modelValue,\n})\n\nconst disabled = computed(() => rootContext.disabled.value)\nconst readonly = computed(() => rootContext.readonly.value)\nconst isInvalid = computed(() => rootContext.isInvalid.value)\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    v-bind=\"attributes\"\n    :contenteditable=\"disabled || readonly ? false : part !== 'literal'\"\n    :data-reka-date-field-segment=\"part\"\n    :aria-disabled=\"disabled ? true : undefined\"\n    :aria-readonly=\"readonly ? true : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :aria-invalid=\"isInvalid ? true : undefined\"\n    v-on=\"part !== 'literal' ? {\n      mousedown: handleSegmentClick,\n      keydown: handleSegmentKeydown,\n      focusout: () => { hasLeftFocus = true },\n      focusin: (e: FocusEvent) => {\n        rootContext.setFocusedElement(e.target as HTMLElement)\n      },\n    } : {}\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { createContext } from '@/shared'\n\nexport interface PopoverRootProps {\n  /**\n   * The open state of the popover when it is initially rendered. Use when you do not need to control its open state.\n   */\n  defaultOpen?: boolean\n  /**\n   * The controlled open state of the popover.\n   */\n  open?: boolean\n  /**\n   * The modality of the popover. When set to true, interaction with outside elements will be disabled and only popover content will be visible to screen readers.\n   *\n   * @defaultValue false\n   */\n  modal?: boolean\n}\nexport type PopoverRootEmits = {\n  /**\n   * Event handler called when the open state of the popover changes.\n   */\n  'update:open': [value: boolean]\n}\n\nexport interface PopoverRootContext {\n  triggerElement: Ref<HTMLElement | undefined>\n  triggerId: string\n  contentId: string\n  open: Ref<boolean>\n  modal: Ref<boolean>\n  onOpenChange: (value: boolean) => void\n  onOpenToggle: () => void\n  hasCustomAnchor: Ref<boolean>\n}\n\nexport const [injectPopoverRootContext, providePopoverRootContext]\n  = createContext<PopoverRootContext>('PopoverRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs } from 'vue'\nimport { PopperRoot } from '@/Popper'\n\nconst props = withDefaults(defineProps<PopoverRootProps>(), {\n  defaultOpen: false,\n  open: undefined,\n  modal: false,\n})\nconst emit = defineEmits<PopoverRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nconst { modal } = toRefs(props)\n\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst triggerElement = ref<HTMLElement>()\nconst hasCustomAnchor = ref(false)\n\nprovidePopoverRootContext({\n  contentId: '',\n  triggerId: '',\n  modal,\n  open,\n  onOpenChange: (value) => {\n    open.value = value\n  },\n  onOpenToggle: () => {\n    open.value = !open.value\n  },\n  triggerElement,\n  hasCustomAnchor,\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <slot :open=\"open\" />\n  </PopperRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperAnchorProps } from '@/Popper'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PopoverAnchorProps extends PopperAnchorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onBeforeMount, onUnmounted } from 'vue'\nimport { PopperAnchor } from '@/Popper'\nimport { injectPopoverRootContext } from './PopoverRoot.vue'\n\nconst props = defineProps<PopoverAnchorProps>()\n\nuseForwardExpose()\nconst rootContext = injectPopoverRootContext()\n\nonBeforeMount(() => {\n  rootContext.hasCustomAnchor.value = true\n})\nonUnmounted(() => {\n  rootContext.hasCustomAnchor.value = false\n})\n</script>\n\n<template>\n  <PopperAnchor v-bind=\"props\">\n    <slot />\n  </PopperAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperArrowProps } from '@/Popper'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PopoverArrowProps extends PopperArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperArrow } from '@/Popper'\n\nconst props = withDefaults(defineProps<PopoverArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nuseForwardExpose()\n</script>\n\n<template>\n  <PopperArrow v-bind=\"props\">\n    <slot />\n  </PopperArrow>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverArrowProps } from '..'\nimport { PopoverArrow } from '..'\n\nexport interface DatePickerArrowProps extends PopoverArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerArrowProps>()\n</script>\n\n<template>\n  <PopoverArrow v-bind=\"props\">\n    <slot />\n  </PopoverArrow>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\n\nimport type { Ref } from 'vue'\nimport type { CalendarRootProps, DateFieldRoot, DateFieldRootProps, PopoverRootEmits, PopoverRootProps } from '..'\nimport type { Matcher, WeekDayFormat } from '@/date'\nimport type { Granularity, HourCycle } from '@/shared/date'\nimport type { Direction } from '@/shared/types'\nimport { computed, ref, toRefs, watch } from 'vue'\nimport { createContext, useDirection } from '@/shared'\nimport { getDefaultDate } from '@/shared/date'\nimport { PopoverRoot } from '..'\n\ntype DatePickerRootContext = {\n  id: Ref<string | undefined>\n  name: Ref<string | undefined>\n  minValue: Ref<DateValue | undefined>\n  maxValue: Ref<DateValue | undefined>\n  hourCycle: Ref<HourCycle | undefined>\n  granularity: Ref<Granularity | undefined>\n  hideTimeZone: Ref<boolean>\n  required: Ref<boolean>\n  locale: Ref<string>\n  dateFieldRef: Ref<InstanceType<typeof DateFieldRoot> | undefined>\n  modelValue: Ref<DateValue | undefined>\n  placeholder: Ref<DateValue>\n  pagedNavigation: Ref<boolean>\n  preventDeselect: Ref<boolean>\n  weekStartsOn: Ref<0 | 1 | 2 | 3 | 4 | 5 | 6>\n  weekdayFormat: Ref<WeekDayFormat>\n  fixedWeeks: Ref<boolean>\n  numberOfMonths: Ref<number>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  isDateDisabled?: Matcher\n  isDateUnavailable?: Matcher\n  defaultOpen: Ref<boolean>\n  open: Ref<boolean>\n  modal: Ref<boolean>\n  onDateChange: (date: DateValue | undefined) => void\n  onPlaceholderChange: (date: DateValue) => void\n  dir: Ref<Direction>\n}\n\nexport type DatePickerRootProps = DateFieldRootProps & PopoverRootProps & Pick<CalendarRootProps, 'isDateDisabled' | 'pagedNavigation' | 'weekStartsOn' | 'weekdayFormat' | 'fixedWeeks' | 'numberOfMonths' | 'preventDeselect'>\n\nexport type DatePickerRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [date: DateValue | undefined]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: DateValue]\n}\n\nexport const [injectDatePickerRootContext, provideDatePickerRootContext]\n  = createContext<DatePickerRootContext>('DatePickerRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\n\ndefineOptions({\n  inheritAttrs: false,\n})\nconst props = withDefaults(defineProps<DatePickerRootProps>(), {\n  defaultValue: undefined,\n  defaultOpen: false,\n  open: undefined,\n  modal: false,\n  pagedNavigation: false,\n  preventDeselect: false,\n  weekStartsOn: 0,\n  weekdayFormat: 'narrow',\n  fixedWeeks: false,\n  numberOfMonths: 1,\n  disabled: false,\n  readonly: false,\n  initialFocus: false,\n  placeholder: undefined,\n  locale: 'en',\n  isDateDisabled: undefined,\n  isDateUnavailable: undefined,\n})\nconst emits = defineEmits<DatePickerRootEmits & PopoverRootEmits>()\nconst {\n  locale,\n  disabled,\n  readonly,\n  pagedNavigation,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  numberOfMonths,\n  preventDeselect,\n  isDateDisabled: propsIsDateDisabled,\n  isDateUnavailable: propsIsDateUnavailable,\n  defaultOpen,\n  modal,\n  id,\n  name,\n  required,\n  minValue,\n  maxValue,\n  granularity,\n  hideTimeZone,\n  hourCycle,\n  defaultValue,\n  dir: propDir,\n} = toRefs(props)\n\nconst dir = useDirection(propDir)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: defaultValue.value,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<DateValue | undefined>\n\nconst defaultDate = computed(() => getDefaultDate({\n  defaultPlaceholder: props.placeholder,\n  granularity: props.granularity,\n  defaultValue: modelValue.value,\n  locale: props.locale,\n}))\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.value.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<DateValue>\n\nconst open = useVModel(props, 'open', emits, {\n  defaultValue: defaultOpen.value,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst dateFieldRef = ref<InstanceType<typeof DateFieldRoot> | undefined>()\n\nwatch(modelValue, (value) => {\n  if (value && value.compare(placeholder.value) !== 0) {\n    placeholder.value = value.copy()\n  }\n})\n\nprovideDatePickerRootContext({\n  isDateUnavailable: propsIsDateUnavailable.value,\n  isDateDisabled: propsIsDateDisabled.value,\n  locale,\n  disabled,\n  pagedNavigation,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  numberOfMonths,\n  readonly,\n  preventDeselect,\n  modelValue,\n  placeholder,\n  defaultOpen,\n  modal,\n  open,\n  id,\n  name,\n  required,\n  minValue,\n  maxValue,\n  granularity,\n  hideTimeZone,\n  hourCycle,\n  dateFieldRef,\n  dir,\n  onDateChange(date: DateValue | undefined) {\n    if (!date || !modelValue.value) {\n      modelValue.value = date?.copy() ?? undefined\n    }\n    else if (!preventDeselect.value && date && modelValue.value.compare(date) === 0) {\n      modelValue.value = undefined\n    }\n    else {\n      modelValue.value = date.copy()\n    }\n  },\n  onPlaceholderChange(date: DateValue) {\n    placeholder.value = date.copy()\n  },\n})\n</script>\n\n<template>\n  <PopoverRoot\n    v-model:open=\"open\"\n    :default-open=\"defaultOpen\"\n    :modal=\"modal\"\n  >\n    <slot />\n  </PopoverRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport { isEqualDay } from '@internationalized/date'\nimport { CalendarRoot } from '..'\nimport { injectDatePickerRootContext } from './DatePickerRoot.vue'\n</script>\n\n<script setup lang=\"ts\">\nconst rootContext = injectDatePickerRootContext()\n</script>\n\n<template>\n  <CalendarRoot\n    v-slot=\"{ weekDays, grid, date, weekStartsOn, locale, fixedWeeks }\"\n    v-bind=\"{\n      isDateDisabled: rootContext.isDateDisabled,\n      isDateUnavailable: rootContext.isDateUnavailable,\n      minValue: rootContext.minValue.value,\n      maxValue: rootContext.maxValue.value,\n      locale: rootContext.locale.value,\n      disabled: rootContext.disabled.value,\n      pagedNavigation: rootContext.pagedNavigation.value,\n      weekStartsOn: rootContext.weekStartsOn.value,\n      weekdayFormat: rootContext.weekdayFormat.value,\n      fixedWeeks: rootContext.fixedWeeks.value,\n      numberOfMonths: rootContext.numberOfMonths.value,\n      readonly: rootContext.readonly.value,\n      preventDeselect: rootContext.preventDeselect.value,\n      dir: rootContext.dir.value,\n    }\"\n    :model-value=\"rootContext.modelValue.value\"\n    :placeholder=\"rootContext.placeholder.value\"\n    initial-focus\n    :multiple=\"false\"\n    @update:model-value=\"(date: DateValue | undefined) => {\n      if (date && rootContext.modelValue.value && isEqualDay(date, rootContext.modelValue.value)) return\n      rootContext.onDateChange(date)\n    }\"\n    @update:placeholder=\"(date: DateValue) => {\n      if (isEqualDay(date, rootContext.placeholder.value)) return\n      rootContext.onPlaceholderChange(date)\n    }\"\n  >\n    <slot\n      :date=\"date\"\n      :grid=\"grid\"\n      :week-days=\"weekDays\"\n      :week-starts-on=\"weekStartsOn\"\n      :locale=\"locale\"\n      :fixed-weeks=\"fixedWeeks\"\n    />\n  </CalendarRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarCellProps } from '..'\nimport { CalendarCell } from '..'\n\nexport interface DatePickerCellProps extends CalendarCellProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerCellProps>()\n</script>\n\n<template>\n  <CalendarCell v-bind=\"props\">\n    <slot />\n  </CalendarCell>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarCellTriggerProps } from '..'\nimport type { CalendarCellTriggerSlot } from '@/Calendar/CalendarCellTrigger.vue'\nimport { CalendarCellTrigger } from '..'\n\nexport interface DatePickerCellTriggerProps extends CalendarCellTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerCellTriggerProps>()\ndefineSlots<CalendarCellTriggerSlot>()\n</script>\n\n<template>\n  <CalendarCellTrigger\n    v-slot=\"slotProps\"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </CalendarCellTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PopoverCloseProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport {\n  injectPopoverRootContext,\n} from './PopoverRoot.vue'\n\nconst props = withDefaults(defineProps<PopoverCloseProps>(), {\n  as: 'button',\n})\n\nuseForwardExpose()\nconst rootContext = injectPopoverRootContext()\n</script>\n\n<template>\n  <Primitive\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :as=\"as\"\n    :as-child=\"props.asChild\"\n    @click=\"rootContext.onOpenChange(false)\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverCloseProps } from '..'\nimport { PopoverClose } from '..'\n\nexport interface DatePickerCloseProps extends PopoverCloseProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerCloseProps>()\n</script>\n\n<template>\n  <PopoverClose v-bind=\"props\">\n    <slot />\n  </PopoverClose>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface PopoverPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<PopoverPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  DismissableLayerEmits,\n  DismissableLayerProps,\n} from '@/DismissableLayer'\nimport type { FocusScopeProps } from '@/FocusScope'\nimport type { PopperContentProps } from '@/Popper'\nimport { reactiveOmit } from '@vueuse/shared'\n\nexport type PopoverContentImplEmits = DismissableLayerEmits & {\n  /**\n   * Event handler called when auto-focusing on open.\n   * Can be prevented.\n   */\n  openAutoFocus: [event: Event]\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  closeAutoFocus: [event: Event]\n}\n\nexport interface PopoverContentImplProps extends PopperContentProps, DismissableLayerProps {}\n\ninterface PopoverContentImplPrivateProps extends PopoverContentImplProps {\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * @defaultValue false\n   */\n  trapFocus?: FocusScopeProps['trapped']\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { FocusScope } from '@/FocusScope'\nimport { PopperContent } from '@/Popper'\nimport { useFocusGuards, useForwardExpose, useForwardProps } from '@/shared'\nimport { injectPopoverRootContext } from './PopoverRoot.vue'\n\nconst props = defineProps<PopoverContentImplPrivateProps>()\nconst emits = defineEmits<PopoverContentImplEmits>()\n\nconst forwarded = useForwardProps(reactiveOmit(props, 'trapFocus', 'disableOutsidePointerEvents'))\nconst { forwardRef } = useForwardExpose()\n\nconst rootContext = injectPopoverRootContext()\nuseFocusGuards()\n</script>\n\n<template>\n  <FocusScope\n    as-child\n    loop\n    :trapped=\"trapFocus\"\n    @mount-auto-focus=\"emits('openAutoFocus', $event)\"\n    @unmount-auto-focus=\"emits('closeAutoFocus', $event)\"\n  >\n    <DismissableLayer\n      as-child\n      :disable-outside-pointer-events=\"disableOutsidePointerEvents\"\n      @pointer-down-outside=\"emits('pointerDownOutside', $event)\"\n      @interact-outside=\"emits('interactOutside', $event)\"\n      @escape-key-down=\"emits('escapeKeyDown', $event)\"\n      @focus-outside=\"emits('focusOutside', $event)\"\n      @dismiss=\"rootContext.onOpenChange(false)\"\n    >\n      <PopperContent\n        v-bind=\"forwarded\"\n        :id=\"rootContext.contentId\"\n        :ref=\"forwardRef\"\n        :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n        :aria-labelledby=\"rootContext.triggerId\"\n        :style=\"{\n          '--reka-popover-content-transform-origin':\n            'var(--reka-popper-transform-origin)',\n          '--reka-popover-content-available-width':\n            'var(--reka-popper-available-width)',\n          '--reka-popover-content-available-height':\n            'var(--reka-popper-available-height)',\n          '--reka-popover-trigger-width': 'var(--reka-popper-anchor-width)',\n          '--reka-popover-trigger-height': 'var(--reka-popper-anchor-height)',\n        }\"\n        role=\"dialog\"\n      >\n        <slot />\n      </PopperContent>\n    </DismissableLayer>\n  </FocusScope>\n</template>\n", "<script setup lang=\"ts\">\nimport type { PopoverContentImplEmits, PopoverContentImplProps } from './PopoverContentImpl.vue'\nimport { ref } from 'vue'\nimport { useForwardExpose, useForwardPropsEmits, useHideOthers } from '@/shared'\nimport { useBodyScrollLock } from '@/shared/useBodyScrollLock'\nimport PopoverContentImpl from './PopoverContentImpl.vue'\nimport { injectPopoverRootContext } from './PopoverRoot.vue'\n\nconst props = defineProps<PopoverContentImplProps>()\nconst emits = defineEmits<PopoverContentImplEmits>()\nconst rootContext = injectPopoverRootContext()\nconst isRightClickOutsideRef = ref(false)\n\nuseBodyScrollLock(true)\n\nconst forwarded = useForwardPropsEmits(props, emits)\n\nconst { forwardRef, currentElement } = useForwardExpose()\nuseHideOthers(currentElement)\n</script>\n\n<template>\n  <PopoverContentImpl\n    v-bind=\"forwarded\"\n    :ref=\"forwardRef\"\n    :trap-focus=\"rootContext.open.value\"\n    disable-outside-pointer-events\n    @close-auto-focus.prevent=\"\n      (event) => {\n        emits('closeAutoFocus', event);\n\n        if (!isRightClickOutsideRef) rootContext.triggerElement.value?.focus();\n      }\n    \"\n    @pointer-down-outside=\"\n      (event) => {\n        emits('pointerDownOutside', event);\n\n        const originalEvent = event.detail.originalEvent;\n        const ctrlLeftClick\n          = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n\n        isRightClickOutsideRef = isRightClick;\n      }\n    \"\n    @focus-outside.prevent\n  >\n    <slot />\n  </PopoverContentImpl>\n</template>\n", "<script setup lang=\"ts\">\nimport type { PopoverContentImplEmits, PopoverContentImplProps } from './PopoverContentImpl.vue'\nimport { ref } from 'vue'\nimport { useForwardPropsEmits } from '@/shared'\nimport PopoverContentImpl from './PopoverContentImpl.vue'\nimport { injectPopoverRootContext } from './PopoverRoot.vue'\n\nconst props = defineProps<PopoverContentImplProps>()\nconst emits = defineEmits<PopoverContentImplEmits>()\nconst rootContext = injectPopoverRootContext()\nconst hasInteractedOutsideRef = ref(false)\nconst hasPointerDownOutsideRef = ref(false)\n\nconst forwarded = useForwardPropsEmits(props, emits)\n</script>\n\n<template>\n  <PopoverContentImpl\n    v-bind=\"forwarded\"\n    :trap-focus=\"false\"\n    :disable-outside-pointer-events=\"false\"\n    @close-auto-focus=\"\n      (event) => {\n        emits('closeAutoFocus', event);\n\n        if (!event.defaultPrevented) {\n          if (!hasInteractedOutsideRef) rootContext.triggerElement.value?.focus();\n          // Always prevent auto focus because we either focus manually or want user agent focus\n          event.preventDefault();\n        }\n\n        hasInteractedOutsideRef = false;\n        hasPointerDownOutsideRef = false;\n      }\n    \"\n    @interact-outside=\"\n      async (event) => {\n        emits('interactOutside', event);\n\n        if (!event.defaultPrevented) {\n          hasInteractedOutsideRef = true;\n          if (event.detail.originalEvent.type === 'pointerdown') {\n            hasPointerDownOutsideRef = true;\n          }\n        }\n\n        // Prevent dismissing when clicking the trigger.\n        // As the trigger is already setup to close, without doing so would\n        // cause it to close and immediately open.\n        const target = event.target as HTMLElement;\n        const targetIsTrigger = rootContext.triggerElement.value?.contains(target);\n        if (targetIsTrigger) event.preventDefault();\n\n        // On Safari if the trigger is inside a container with tabIndex={0}, when clicked\n        // we will get the pointer down outside event on the trigger, but then a subsequent\n        // focus outside event on the container, we ignore any focus outside event when we've\n        // already had a pointer down outside event.\n        if (\n          event.detail.originalEvent.type === 'focusin'\n          && hasPointerDownOutsideRef\n        ) {\n          event.preventDefault();\n        }\n      }\n    \"\n  >\n    <slot />\n  </PopoverContentImpl>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  PopoverContentImplEmits,\n  PopoverContentImplProps,\n} from './PopoverContentImpl.vue'\n\nexport type PopoverContentEmits = PopoverContentImplEmits\n\nexport interface PopoverContentProps extends PopoverContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardExpose, useForwardPropsEmits, useId } from '@/shared'\nimport PopoverContentModal from './PopoverContentModal.vue'\nimport PopoverContentNonModal from './PopoverContentNonModal.vue'\nimport { injectPopoverRootContext } from './PopoverRoot.vue'\n\nconst props = defineProps<PopoverContentProps>()\nconst emits = defineEmits<PopoverContentEmits>()\n\nconst rootContext = injectPopoverRootContext()\n\nconst forwarded = useForwardPropsEmits(props, emits)\nconst { forwardRef } = useForwardExpose()\n\nrootContext.contentId ||= useId(undefined, 'reka-popover-content')\n</script>\n\n<template>\n  <Presence :present=\"forceMount || rootContext.open.value\">\n    <PopoverContentModal\n      v-if=\"rootContext.modal.value\"\n      v-bind=\"forwarded\"\n      :ref=\"forwardRef\"\n    >\n      <slot />\n    </PopoverContentModal>\n    <PopoverContentNonModal\n      v-else\n      v-bind=\"forwarded\"\n      :ref=\"forwardRef\"\n    >\n      <slot />\n    </PopoverContentNonModal>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverContentEmits, PopoverContentProps, PopoverPortalProps } from '..'\nimport { computed } from 'vue'\nimport { PopoverContent, PopoverPortal, useForwardPropsEmits } from '..'\n\nexport interface DatePickerContentProps extends PopoverContentProps {\n  /**\n   * Props to control the portal wrapped around the content.\n   */\n  portal?: PopoverPortalProps\n}\nexport interface DatePickerContentEmits extends PopoverContentEmits {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerContentProps>()\nconst emits = defineEmits<DatePickerContentEmits>()\n\nconst propsToForward = computed(() => ({\n  ...props,\n  portal: undefined,\n}))\nconst forwarded = useForwardPropsEmits(propsToForward, emits)\n</script>\n\n<template>\n  <PopoverPortal v-bind=\"portal\">\n    <PopoverContent\n      v-bind=\"{ ...forwarded, ...$attrs }\"\n    >\n      <slot />\n    </PopoverContent>\n  </PopoverPortal>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport { DateFieldRoot } from '..'\nimport { injectDatePickerRootContext } from './DatePickerRoot.vue'\n</script>\n\n<script setup lang=\"ts\">\nconst rootContext = injectDatePickerRootContext()\n</script>\n\n<template>\n  <DateFieldRoot\n    v-slot=\"{ segments, modelValue }\"\n    :ref=\"rootContext.dateFieldRef\"\n    :model-value=\"rootContext.modelValue.value\"\n    :placeholder=\"rootContext.placeholder.value\"\n    v-bind=\"{\n      id: rootContext.id.value,\n      name: rootContext.name.value,\n      disabled: rootContext.disabled.value,\n      minValue: rootContext.minValue.value,\n      maxValue: rootContext.maxValue.value,\n      readonly: rootContext.readonly.value,\n      hourCycle: rootContext.hourCycle.value,\n      granularity: rootContext.granularity.value,\n      hideTimeZone: rootContext.hideTimeZone.value,\n      locale: rootContext.locale.value,\n      isDateUnavailable: rootContext.isDateUnavailable,\n      required: rootContext.required.value,\n      dir: rootContext.dir.value,\n    }\"\n    @update:model-value=\"(date: DateValue | undefined) => {\n      if (date && rootContext.modelValue.value && date.compare(rootContext.modelValue.value) === 0) return\n      rootContext.onDateChange(date)\n    }\"\n    @update:placeholder=\"(date: DateValue) => {\n      if (date.compare(rootContext.placeholder.value) === 0) return\n      rootContext.onPlaceholderChange(date)\n    }\"\n  >\n    <slot\n      :segments=\"segments\"\n      :model-value=\"modelValue\"\n    />\n  </DateFieldRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarGridProps } from '..'\nimport { CalendarGrid } from '..'\n\nexport interface DatePickerGridProps extends CalendarGridProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerGridProps>()\n</script>\n\n<template>\n  <CalendarGrid v-bind=\"props\">\n    <slot />\n  </CalendarGrid>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarGridBodyProps } from '..'\nimport { CalendarGridBody } from '..'\n\nexport interface DatePickerGridBodyProps extends CalendarGridBodyProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerGridBodyProps>()\n</script>\n\n<template>\n  <CalendarGridBody v-bind=\"props\">\n    <slot />\n  </CalendarGridBody>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarGridHeadProps } from '..'\nimport { CalendarGridHead } from '..'\n\nexport interface DatePickerGridHeadProps extends CalendarGridHeadProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerGridHeadProps>()\n</script>\n\n<template>\n  <CalendarGridHead v-bind=\"props\">\n    <slot />\n  </CalendarGridHead>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarGridRowProps } from '..'\nimport { CalendarGridRow } from '..'\n\nexport interface DatePickerGridRowProps extends CalendarGridRowProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerGridRowProps>()\n</script>\n\n<template>\n  <CalendarGridRow v-bind=\"props\">\n    <slot />\n  </CalendarGridRow>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarHeadCellProps } from '..'\nimport { CalendarHeadCell } from '..'\n\nexport interface DatePickerHeadCellProps extends CalendarHeadCellProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerHeadCellProps>()\n</script>\n\n<template>\n  <CalendarHeadCell v-bind=\"props\">\n    <slot />\n  </CalendarHeadCell>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarHeaderProps } from '..'\nimport { CalendarHeader } from '..'\n\nexport interface DatePickerHeaderProps extends CalendarHeaderProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerHeaderProps>()\n</script>\n\n<template>\n  <CalendarHeader v-bind=\"props\">\n    <slot />\n  </CalendarHeader>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarHeadingProps } from '..'\nimport { CalendarHeading } from '..'\n\nexport interface DatePickerHeadingProps extends CalendarHeadingProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerHeadingProps>()\ndefineSlots<{\n  default?: (props: {\n    /** Current month and year */\n    headingValue: string\n  }) => any\n}>()\n</script>\n\n<template>\n  <CalendarHeading\n    v-slot=\"{ headingValue }\"\n    v-bind=\"props\"\n  >\n    <slot :heading-value=\"headingValue\">\n      {{ headingValue }}\n    </slot>\n  </CalendarHeading>\n</template>\n", "<script lang=\"ts\">\nimport type { DateFieldInputProps } from '..'\nimport { DateFieldInput } from '..'\n\nexport interface DatePickerInputProps extends DateFieldInputProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerInputProps>()\n</script>\n\n<template>\n  <DateFieldInput v-bind=\"props\">\n    <slot />\n  </DateFieldInput>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarNextProps } from '..'\nimport type { CalendarNextSlot } from '@/Calendar/CalendarNext.vue'\nimport { CalendarNext } from '..'\n\nexport interface DatePickerNextProps extends CalendarNextProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerNextProps>()\n\ndefineSlots<CalendarNextSlot>()\n</script>\n\n<template>\n  <CalendarNext\n    v-slot=\"slotProps\"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </CalendarNext>\n</template>\n", "<script lang=\"ts\">\nimport type { CalendarPrevProps } from '..'\nimport type { CalendarPrevSlot } from '@/Calendar/CalendarPrev.vue'\nimport { CalendarPrev } from '..'\n\nexport interface DatePickerPrevProps extends CalendarPrevProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerPrevProps>()\ndefineSlots<CalendarPrevSlot>()\n</script>\n\n<template>\n  <CalendarPrev\n    v-slot=\"slotProps\"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </CalendarPrev>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose, useId } from '@/shared'\n\nexport interface PopoverTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport { PopperAnchor } from '@/Popper'\nimport { Primitive } from '@/Primitive'\nimport { injectPopoverRootContext } from './PopoverRoot.vue'\n\nconst props = withDefaults(defineProps<PopoverTriggerProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectPopoverRootContext()\n\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\n\nrootContext.triggerId ||= useId(undefined, 'reka-popover-trigger')\nonMounted(() => {\n  rootContext.triggerElement.value = triggerElement.value\n})\n</script>\n\n<template>\n  <component\n    :is=\"rootContext.hasCustomAnchor.value ? Primitive : PopperAnchor\"\n    as-child\n  >\n    <Primitive\n      :id=\"rootContext.triggerId\"\n      :ref=\"forwardRef\"\n      :type=\"as === 'button' ? 'button' : undefined\"\n      aria-haspopup=\"dialog\"\n      :aria-expanded=\"rootContext.open.value\"\n      :aria-controls=\"rootContext.contentId\"\n      :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n      :as=\"as\"\n      :as-child=\"props.asChild\"\n      @click=\"rootContext.onOpenToggle\"\n    >\n      <slot />\n    </Primitive>\n  </component>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverTriggerProps } from '..'\nimport { PopoverTrigger } from '..'\nimport { injectDatePickerRootContext } from './DatePickerRoot.vue'\n\nexport interface DatePickerTriggerProps extends PopoverTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerTriggerProps>()\nconst rootContext = injectDatePickerRootContext()\n</script>\n\n<template>\n  <PopoverTrigger\n    data-reka-date-field-segment=\"trigger\"\n    v-bind=\"props\"\n    :disabled=\"rootContext.disabled.value\"\n    @focusin=\"(e: FocusEvent) => {\n      rootContext.dateFieldRef.value?.setFocusedElement(e.target as HTMLElement)\n    }\"\n  >\n    <slot />\n  </PopoverTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\n\nimport type { Ref } from 'vue'\nimport type { Matcher } from '@/date'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { Formatter } from '@/shared'\nimport type { DateRange, DateStep, Granularity, HourCycle, SegmentPart, SegmentValueObj } from '@/shared/date'\nimport type { Direction, FormFieldProps } from '@/shared/types'\nimport {\n  areAllDaysBetweenValid,\n  hasTime,\n  isBefore,\n  isBeforeOrSame,\n\n} from '@/date'\nimport { createContext, useDateFormatter, useDirection, useKbd, useLocale } from '@/shared'\nimport {\n  createContent,\n\n  getDefaultDate,\n  getSegmentElements,\n\n  initializeSegmentValues,\n  isSegmentNavigationKey,\n  normalizeDateStep,\n  normalizeHourCycle,\n\n  syncSegmentValues,\n} from '@/shared/date'\n\nexport type DateRangeType = 'start' | 'end'\n\ntype DateRangeFieldRootContext = {\n  locale: Ref<string>\n  startValue: Ref<DateValue | undefined>\n  endValue: Ref<DateValue | undefined>\n  placeholder: Ref<DateValue>\n  isDateUnavailable?: Matcher\n  isInvalid: Ref<boolean>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  formatter: Formatter\n  hourCycle: HourCycle\n  step: Ref<DateStep>\n  segmentValues: Record<DateRangeType, Ref<SegmentValueObj>>\n  segmentContents: Ref<{ start: { part: SegmentPart, value: string }[], end: { part: SegmentPart, value: string }[] }>\n  elements: Ref<Set<HTMLElement>>\n  focusNext: () => void\n  setFocusedElement: (el: HTMLElement) => void\n}\n\nexport interface DateRangeFieldRootProps extends PrimitiveProps, FormFieldProps {\n  /** The default value for the calendar */\n  defaultValue?: DateRange\n  /** The default placeholder date */\n  defaultPlaceholder?: DateValue\n  /** The placeholder date, which is used to determine what month to display when no date is selected. This updates as the user navigates the calendar and can be used to programmatically control the calendar view */\n  placeholder?: DateValue\n  /** The controlled checked state of the calendar. Can be bound as `v-model`. */\n  modelValue?: DateRange | null\n  /** The hour cycle used for formatting times. Defaults to the local preference */\n  hourCycle?: HourCycle\n  /** The stepping interval for the time fields. Defaults to `1`. */\n  step?: DateStep\n  /** The granularity to use for formatting times. Defaults to day if a CalendarDate is provided, otherwise defaults to minute. The field will render segments for each part of the date up to and including the specified granularity */\n  granularity?: Granularity\n  /** Whether or not to hide the time zone segment of the field */\n  hideTimeZone?: boolean\n  /** The maximum date that can be selected */\n  maxValue?: DateValue\n  /** The minimum date that can be selected */\n  minValue?: DateValue\n  /** The locale to use for formatting dates */\n  locale?: string\n  /** Whether or not the date field is disabled */\n  disabled?: boolean\n  /** Whether or not the date field is readonly */\n  readonly?: boolean\n  /** A function that returns whether or not a date is unavailable */\n  isDateUnavailable?: Matcher\n  /** Id of the element */\n  id?: string\n  /** The reading direction of the date field when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n}\n\nexport type DateRangeFieldRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [DateRange]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: DateValue]\n}\n\nexport const [injectDateRangeFieldRootContext, provideDateRangeFieldRootContext]\n  = createContext<DateRangeFieldRootContext>('DateRangeFieldRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, nextTick, onMounted, ref, toRefs, watch } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { VisuallyHidden } from '@/VisuallyHidden'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<DateRangeFieldRootProps>(), {\n  defaultValue: undefined,\n  disabled: false,\n  readonly: false,\n  placeholder: undefined,\n  isDateUnavailable: undefined,\n})\nconst emits = defineEmits<DateRangeFieldRootEmits>()\nconst { disabled, readonly, isDateUnavailable: propsIsDateUnavailable, dir: propDir, locale: propLocale } = toRefs(props)\nconst locale = useLocale(propLocale)\nconst dir = useDirection(propDir)\n\nconst formatter = useDateFormatter(locale.value, {\n  hourCycle: normalizeHourCycle(props.hourCycle),\n})\nconst { primitiveElement, currentElement: parentElement }\n  = usePrimitiveElement()\nconst segmentElements = ref<Set<HTMLElement>>(new Set())\n\nonMounted(() => {\n  getSegmentElements(parentElement.value).forEach(item => segmentElements.value.add(item as HTMLElement))\n})\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? { start: undefined, end: undefined },\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<DateRange | null>\n\nconst defaultDate = getDefaultDate({\n  defaultPlaceholder: props.placeholder,\n  granularity: props.granularity,\n  defaultValue: modelValue.value?.start,\n  locale: props.locale,\n})\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<DateValue>\n\nconst step = computed(() => normalizeDateStep(props))\n\nconst inferredGranularity = computed(() => {\n  if (props.granularity)\n    return !hasTime(placeholder.value) ? 'day' : props.granularity\n\n  return hasTime(placeholder.value) ? 'minute' : 'day'\n})\n\nconst isStartInvalid = computed(() => {\n  if (!modelValue.value?.start)\n    return false\n\n  if (propsIsDateUnavailable.value?.(modelValue.value.start))\n    return true\n\n  if (props.minValue && isBefore(modelValue.value.start, props.minValue))\n    return true\n\n  if (props.maxValue && isBefore(props.maxValue, modelValue.value.start))\n    return true\n\n  return false\n})\n\nconst isEndInvalid = computed(() => {\n  if (!modelValue.value?.end)\n    return false\n\n  if (propsIsDateUnavailable.value?.(modelValue.value.end))\n    return true\n\n  if (props.minValue && isBefore(modelValue.value.end, props.minValue))\n    return true\n\n  if (props.maxValue && isBefore(props.maxValue, modelValue.value.end))\n    return true\n\n  return false\n})\n\nconst isInvalid = computed(() => {\n  if (isStartInvalid.value || isEndInvalid.value)\n    return true\n\n  if (!modelValue.value?.start || !modelValue.value?.end)\n    return false\n\n  if (!isBeforeOrSame(modelValue.value.start, modelValue.value.end))\n    return true\n\n  if (propsIsDateUnavailable.value !== undefined) {\n    const allValid = areAllDaysBetweenValid(\n      modelValue.value.start,\n      modelValue.value.end,\n      propsIsDateUnavailable.value,\n      undefined,\n    )\n    if (!allValid)\n      return true\n  }\n  return false\n})\n\nconst initialSegments = initializeSegmentValues(inferredGranularity.value)\n\nconst startSegmentValues = ref<SegmentValueObj>(modelValue.value?.start ? { ...syncSegmentValues({ value: modelValue.value.start, formatter }) } : { ...initialSegments })\nconst endSegmentValues = ref<SegmentValueObj>(modelValue.value?.end ? { ...syncSegmentValues({ value: modelValue.value.end, formatter }) } : { ...initialSegments })\n\nconst startSegmentContent = computed(() => createContent({\n  granularity: inferredGranularity.value,\n  dateRef: placeholder.value,\n  formatter,\n  hideTimeZone: props.hideTimeZone,\n  hourCycle: props.hourCycle,\n  segmentValues: startSegmentValues.value,\n  locale,\n}))\n\nconst endSegmentContent = computed(() => createContent({\n  granularity: inferredGranularity.value,\n  dateRef: placeholder.value,\n  formatter,\n  hideTimeZone: props.hideTimeZone,\n  hourCycle: props.hourCycle,\n  segmentValues: endSegmentValues.value,\n  locale,\n}))\n\nconst segmentContents = computed(() => ({\n  start: startSegmentContent.value.arr,\n  end: endSegmentContent.value.arr,\n}))\n\nconst editableSegmentContents = computed(() => ({ start: segmentContents.value.start.filter(({ part }) => part !== 'literal'), end: segmentContents.value.end.filter(({ part }) => part !== 'literal') }))\n\nconst startValue = ref(modelValue.value?.start?.copy()) as Ref<DateValue | undefined>\nconst endValue = ref(modelValue.value?.end?.copy()) as Ref<DateValue | undefined>\n\nwatch([startValue, endValue], ([_startValue, _endValue]) => {\n  modelValue.value = { start: _startValue?.copy(), end: _endValue?.copy() }\n})\n\nwatch(modelValue, (_modelValue) => {\n  const isStartChanged = _modelValue?.start && startValue.value\n    ? _modelValue.start.compare(startValue.value) !== 0\n    : _modelValue?.start !== startValue.value\n  if (isStartChanged) {\n    startValue.value = _modelValue?.start?.copy()\n  }\n\n  const isEndChanged = _modelValue?.end && endValue.value\n    ? _modelValue.end.compare(endValue.value) !== 0\n    : _modelValue?.end !== endValue.value\n  if (isEndChanged) {\n    endValue.value = _modelValue?.end?.copy()\n  }\n})\n\nwatch([startValue, locale], ([_startValue]) => {\n  if (_startValue !== undefined) {\n    startSegmentValues.value = { ...syncSegmentValues({ value: _startValue, formatter }) }\n  }\n  // If segment has null value, means that user modified it, thus do not reset the segmentValues\n  else if (Object.values(startSegmentValues.value).every(value => value !== null) && _startValue === undefined) {\n    startSegmentValues.value = { ...initialSegments }\n  }\n})\n\nwatch(locale, (value) => {\n  if (formatter.getLocale() !== value) {\n    formatter.setLocale(value)\n    // Locale changed, so we need to clear the segment elements and re-get them (different order)\n    // Get the focusable elements again on the next tick\n    nextTick(() => {\n      segmentElements.value.clear()\n      getSegmentElements(parentElement.value).forEach(item => segmentElements.value.add(item as HTMLElement))\n    })\n  }\n})\n\nwatch(modelValue, (_modelValue) => {\n  if (_modelValue && _modelValue.start !== undefined && placeholder.value.compare(_modelValue.start) !== 0)\n    placeholder.value = _modelValue.start.copy()\n})\n\nwatch([endValue, locale], ([_endValue]) => {\n  if (_endValue !== undefined) {\n    endSegmentValues.value = { ...syncSegmentValues({ value: _endValue, formatter }) }\n  }\n  // If segment has null value, means that user modified it, thus do not reset the segmentValues\n  else if (Object.values(endSegmentValues.value).every(value => value !== null) && _endValue === undefined) {\n    endSegmentValues.value = { ...initialSegments }\n  }\n})\n\nconst currentFocusedElement = ref<HTMLElement | null>(null)\n\nconst currentSegmentIndex = computed(() => Array.from(segmentElements.value).findIndex(el =>\n  el.getAttribute('data-reka-date-field-segment') === currentFocusedElement.value?.getAttribute('data-reka-date-field-segment')\n  && el.getAttribute('data-reka-date-range-field-segment-type') === currentFocusedElement.value?.getAttribute('data-reka-date-range-field-segment-type')))\n\nconst nextFocusableSegment = computed(() => {\n  const sign = dir.value === 'rtl' ? -1 : 1\n  const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1\n  if (nextCondition)\n    return null\n  const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign]\n  return segmentToFocus\n})\n\nconst prevFocusableSegment = computed(() => {\n  const sign = dir.value === 'rtl' ? -1 : 1\n  const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1\n  if (prevCondition)\n    return null\n\n  const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign]\n  return segmentToFocus\n})\n\nconst kbd = useKbd()\n\nfunction handleKeydown(e: KeyboardEvent) {\n  if (!isSegmentNavigationKey(e.key))\n    return\n  if (e.key === kbd.ARROW_LEFT)\n    prevFocusableSegment.value?.focus()\n  if (e.key === kbd.ARROW_RIGHT)\n    nextFocusableSegment.value?.focus()\n}\n\nfunction setFocusedElement(el: HTMLElement) {\n  currentFocusedElement.value = el\n}\n\nprovideDateRangeFieldRootContext({\n  isDateUnavailable: propsIsDateUnavailable.value,\n  locale,\n  startValue,\n  endValue,\n  placeholder,\n  disabled,\n  formatter,\n  hourCycle: props.hourCycle,\n  step,\n  readonly,\n  segmentValues: { start: startSegmentValues, end: endSegmentValues },\n  isInvalid,\n  segmentContents: editableSegmentContents,\n  elements: segmentElements,\n  setFocusedElement,\n  focusNext() {\n    nextFocusableSegment.value?.focus()\n  },\n})\n\ndefineExpose({\n  setFocusedElement,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    ref=\"primitiveElement\"\n    role=\"group\"\n    :aria-disabled=\"disabled ? true : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-readonly=\"readonly ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :dir=\"dir\"\n    @keydown.left.right=\"handleKeydown\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :segments=\"segmentContents\"\n    />\n\n    <VisuallyHidden\n      :id=\"id\"\n      as=\"input\"\n      feature=\"focusable\"\n      tabindex=\"-1\"\n      :value=\"`${modelValue?.start?.toString()} - ${modelValue?.end?.toString()}`\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n      @focus=\"Array.from(segmentElements)?.[0]?.focus()\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DateRangeType } from './DateRangeFieldRoot.vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { SegmentPart } from '@/shared/date'\nimport { computed, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useDateField } from '@/shared/date/useDateField'\nimport { injectDateRangeFieldRootContext } from './DateRangeFieldRoot.vue'\n\nexport interface DateRangeFieldInputProps extends PrimitiveProps {\n  /** The part of the date to render */\n  part: SegmentPart\n  /** The type of field to render (start or end) */\n  type: DateRangeType\n}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangeFieldInputProps>()\n\nconst rootContext = injectDateRangeFieldRootContext()\n\nconst hasLeftFocus = ref(true)\nconst lastKeyZero = ref(false)\n\nconst {\n  handleSegmentClick,\n  handleSegmentKeydown,\n  attributes,\n} = useDateField({\n  hasLeftFocus,\n  lastKeyZero,\n  placeholder: rootContext.placeholder,\n  hourCycle: rootContext.hourCycle,\n  step: rootContext.step,\n  segmentValues: rootContext.segmentValues[props.type],\n  formatter: rootContext.formatter,\n  part: props.part,\n  disabled: rootContext.disabled,\n  readonly: rootContext.readonly,\n  focusNext: rootContext.focusNext,\n  modelValue: props.type === 'start' ? rootContext.startValue : rootContext.endValue,\n})\n\nconst disabled = computed(() => rootContext.disabled.value)\nconst readonly = computed(() => rootContext.readonly.value)\nconst isInvalid = computed(() => rootContext.isInvalid.value)\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    v-bind=\"attributes\"\n    :contenteditable=\"disabled || readonly ? false : part !== 'literal'\"\n    :data-reka-date-field-segment=\"part\"\n    :aria-disabled=\"disabled ? true : undefined\"\n    :aria-readonly=\"readonly ? true : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-reka-date-range-field-segment-type=\"type\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :aria-invalid=\"isInvalid ? true : undefined\"\n    v-on=\"part !== 'literal' ? {\n      mousedown: handleSegmentClick,\n      keydown: handleSegmentKeydown,\n      focusout: () => { hasLeftFocus = true },\n      focusin: (e: FocusEvent) => {\n        rootContext.setFocusedElement(e.target as HTMLElement)\n      },\n    } : {}\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverAnchorProps } from '..'\nimport { PopoverAnchor } from '..'\n\nexport interface DateRangePickerAnchorProps extends PopoverAnchorProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerAnchorProps>()\n</script>\n\n<template>\n  <PopoverAnchor v-bind=\"props\">\n    <slot />\n  </PopoverAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverArrowProps } from '..'\nimport { PopoverArrow } from '..'\n\nexport interface DateRangePickerArrowProps extends PopoverArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerArrowProps>()\n</script>\n\n<template>\n  <PopoverArrow v-bind=\"props\">\n    <slot />\n  </PopoverArrow>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\n\nimport type { Ref } from 'vue'\nimport type { DateRangeFieldRoot, DateRangeFieldRootProps, PopoverRootEmits, PopoverRootProps, RangeCalendarRootProps } from '..'\nimport type { Matcher, WeekDayFormat } from '@/date'\nimport type { DateRange, Granularity, HourCycle } from '@/shared/date'\n\nimport type { Direction } from '@/shared/types'\nimport { createContext, useDirection } from '@/shared'\nimport { getDefaultDate } from '@/shared/date'\nimport { PopoverRoot } from '..'\n\ntype DateRangePickerRootContext = {\n  id: Ref<string | undefined>\n  name: Ref<string | undefined>\n  minValue: Ref<DateValue | undefined>\n  maxValue: Ref<DateValue | undefined>\n  hourCycle: Ref<HourCycle | undefined>\n  granularity: Ref<Granularity | undefined>\n  hideTimeZone: Ref<boolean>\n  required: Ref<boolean>\n  locale: Ref<string>\n  dateFieldRef: Ref<InstanceType<typeof DateRangeFieldRoot> | undefined>\n  modelValue: Ref<{ start: DateValue | undefined, end: DateValue | undefined }>\n  placeholder: Ref<DateValue>\n  pagedNavigation: Ref<boolean>\n  preventDeselect: Ref<boolean>\n  weekStartsOn: Ref<0 | 1 | 2 | 3 | 4 | 5 | 6>\n  weekdayFormat: Ref<WeekDayFormat>\n  fixedWeeks: Ref<boolean>\n  numberOfMonths: Ref<number>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  isDateDisabled?: Matcher\n  isDateUnavailable?: Matcher\n  isDateHighlightable?: Matcher\n  defaultOpen: Ref<boolean>\n  open: Ref<boolean>\n  modal: Ref<boolean>\n  onDateChange: (date: DateRange) => void\n  onPlaceholderChange: (date: DateValue) => void\n  onStartValueChange: (date: DateValue | undefined) => void\n  dir: Ref<Direction>\n  allowNonContiguousRanges: Ref<boolean>\n  fixedDate: Ref<'start' | 'end' | undefined>\n  maximumDays?: Ref<number | undefined>\n}\n\nexport type DateRangePickerRootProps = DateRangeFieldRootProps & PopoverRootProps & Pick<RangeCalendarRootProps, 'isDateDisabled' | 'pagedNavigation' | 'weekStartsOn' | 'weekdayFormat' | 'fixedWeeks' | 'numberOfMonths' | 'preventDeselect' | 'isDateUnavailable' | 'isDateHighlightable' | 'allowNonContiguousRanges' | 'fixedDate' | 'maximumDays'>\n\nexport type DateRangePickerRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [date: DateRange]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: DateValue]\n  /** Event handler called whenever the start value changes */\n  'update:startValue': [date: DateValue | undefined]\n}\n\nexport const [injectDateRangePickerRootContext, provideDateRangePickerRootContext]\n  = createContext<DateRangePickerRootContext>('DateRangePickerRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs, watch } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\nconst props = withDefaults(defineProps<DateRangePickerRootProps>(), {\n  defaultValue: () => ({ start: undefined, end: undefined }),\n  defaultOpen: false,\n  open: undefined,\n  modal: false,\n  pagedNavigation: false,\n  preventDeselect: false,\n  weekStartsOn: 0,\n  weekdayFormat: 'narrow',\n  fixedWeeks: false,\n  numberOfMonths: 1,\n  disabled: false,\n  readonly: false,\n  initialFocus: false,\n  placeholder: undefined,\n  locale: 'en',\n  isDateDisabled: undefined,\n  isDateUnavailable: undefined,\n  isDateHighlightable: undefined,\n  allowNonContiguousRanges: false,\n  maximumDays: undefined,\n})\nconst emits = defineEmits<DateRangePickerRootEmits & PopoverRootEmits>()\nconst {\n  locale,\n  disabled,\n  readonly,\n  pagedNavigation,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  numberOfMonths,\n  preventDeselect,\n  isDateDisabled: propsIsDateDisabled,\n  isDateUnavailable: propsIsDateUnavailable,\n  isDateHighlightable: propsIsDateHighlightable,\n  defaultOpen,\n  modal,\n  id,\n  name,\n  required,\n  minValue,\n  maxValue,\n  granularity,\n  hideTimeZone,\n  hourCycle,\n  dir: propsDir,\n  allowNonContiguousRanges,\n  fixedDate,\n  maximumDays,\n} = toRefs(props)\n\nconst dir = useDirection(propsDir)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? { start: undefined, end: undefined },\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<DateRange>\n\nconst defaultDate = getDefaultDate({\n  defaultPlaceholder: props.placeholder,\n  granularity: props.granularity,\n  defaultValue: modelValue.value?.start,\n  locale: props.locale,\n})\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<DateValue>\n\nconst open = useVModel(props, 'open', emits, {\n  defaultValue: defaultOpen.value,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst dateFieldRef = ref<InstanceType<typeof DateRangeFieldRoot> | undefined>()\n\nwatch(modelValue, (value) => {\n  if (value && value.start && value.start.compare(placeholder.value) !== 0) {\n    placeholder.value = value.start.copy()\n  }\n})\n\nprovideDateRangePickerRootContext({\n  allowNonContiguousRanges,\n  isDateUnavailable: propsIsDateUnavailable.value,\n  isDateDisabled: propsIsDateDisabled.value,\n  isDateHighlightable: propsIsDateHighlightable.value,\n  locale,\n  disabled,\n  pagedNavigation,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  numberOfMonths,\n  readonly,\n  preventDeselect,\n  modelValue,\n  placeholder,\n  defaultOpen,\n  modal,\n  open,\n  id,\n  name,\n  required,\n  minValue,\n  maxValue,\n  granularity,\n  hideTimeZone,\n  hourCycle,\n  dateFieldRef,\n  dir,\n  fixedDate,\n  maximumDays,\n  onStartValueChange(date: DateValue | undefined) {\n    emits('update:startValue', date)\n  },\n  onDateChange(date: DateRange) {\n    modelValue.value = { start: date.start?.copy(), end: date.end?.copy() }\n  },\n  onPlaceholderChange(date: DateValue) {\n    placeholder.value = date.copy()\n  },\n})\n</script>\n\n<template>\n  <PopoverRoot\n    v-model:open=\"open\"\n    :default-open=\"defaultOpen\"\n    :modal=\"modal\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :open=\"open\"\n    />\n  </PopoverRoot>\n</template>\n", "/*\n  * Adapted from https://github.com/melt-ui/melt-ui/blob/develop/src/lib/builders/range-calendar/create.ts\n*/\n\nimport type { DateValue } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { Matcher } from '@/date'\nimport { isSameDay } from '@internationalized/date'\nimport { computed } from 'vue'\nimport { areAllDaysBetweenValid, getDaysBetween, isBefore, isBetween } from '@/date'\n\nexport type UseRangeCalendarProps = {\n  start: Ref<DateValue | undefined>\n  end: Ref<DateValue | undefined>\n  isDateDisabled: Matcher\n  isDateUnavailable: Matcher\n  isDateHighlightable?: Matcher\n  focusedValue: Ref<DateValue | undefined>\n  allowNonContiguousRanges: Ref<boolean>\n  fixedDate: Ref<'start' | 'end' | undefined>\n  maximumDays?: Ref<number | undefined>\n}\n\nexport function useRangeCalendarState(props: UseRangeCalendarProps) {\n  const isStartInvalid = computed(() => {\n    if (!props.start.value)\n      return false\n    if (props.isDateDisabled(props.start.value))\n      return true\n    return false\n  })\n\n  const isEndInvalid = computed(() => {\n    if (!props.end.value)\n      return false\n    if (props.isDateDisabled(props.end.value))\n      return true\n    return false\n  })\n\n  const isInvalid = computed(\n    () => {\n      if (isStartInvalid.value || isEndInvalid.value)\n        return false\n      if (props.start.value && props.end.value && isBefore(props.end.value, props.start.value))\n        return true\n      return false\n    },\n  )\n\n  const isSelectionStart = (date: DateValue) => {\n    if (!props.start.value)\n      return false\n    return isSameDay(props.start.value, date)\n  }\n\n  const isSelectionEnd = (date: DateValue) => {\n    if (!props.end.value)\n      return false\n    return isSameDay(props.end.value, date)\n  }\n\n  const isSelected = (date: DateValue) => {\n    if (props.start.value && isSameDay(props.start.value, date))\n      return true\n    if (props.end.value && isSameDay(props.end.value, date))\n      return true\n    if (props.end.value && props.start.value)\n      return isBetween(date, props.start.value, props.end.value)\n\n    return false\n  }\n\n  // Check if a date exceeds maximum days limit from the start date\n  const rangeIsDateDisabled = (date: DateValue) => {\n    if (props.isDateDisabled(date))\n      return true\n\n    // Check if exceeds maximum days limit\n    if (props.maximumDays?.value) {\n      if (props.start.value && props.end.value) {\n        if (props.fixedDate.value) {\n          const diff = getDaysBetween(props.start.value, props.end.value).length\n          if (diff <= props.maximumDays.value) {\n            const daysLeft = props.maximumDays.value - diff - 1\n            const startLimit = props.start.value.subtract({ days: daysLeft })\n            const endLimit = props.end.value.add({ days: daysLeft })\n            return !isBetween(date, startLimit, endLimit)\n          }\n        }\n        return false\n      }\n      if (props.start.value) {\n        const maxDate = props.start.value.add({ days: props.maximumDays.value })\n        const minDate = props.start.value.subtract({ days: props.maximumDays.value })\n        return !isBetween(date, minDate, maxDate)\n      }\n    }\n\n    if (!props.start.value || props.end.value || isSameDay(props.start.value, date))\n      return false\n\n    return false\n  }\n\n  const isDateHighlightable = (date: DateValue) => {\n    if (props.isDateHighlightable?.(date))\n      return true\n    return false\n  }\n\n  const highlightedRange = computed(() => {\n    if (props.start.value && props.end.value && !props.fixedDate.value)\n      return null\n    if (!props.start.value || !props.focusedValue.value)\n      return null\n\n    const isStartBeforeFocused = isBefore(props.start.value, props.focusedValue.value)\n    const start = isStartBeforeFocused ? props.start.value : props.focusedValue.value\n    const end = isStartBeforeFocused ? props.focusedValue.value : props.start.value\n\n    if (isSameDay(start, end)) {\n      return {\n        start,\n        end,\n      }\n    }\n\n    // If maximum days is set and the range exceeds it, limit the highlight\n    // We only apply this when we're in the middle of a selection (no end date yet)\n    if (props.maximumDays?.value && !props.end.value) {\n      // Determine the direction of selection and limit to maximum days\n      const cappedEnd = isStartBeforeFocused\n        ? start.add({ days: props.maximumDays.value })\n        : start.subtract({ days: props.maximumDays.value })\n\n      return {\n        start,\n        end: cappedEnd,\n      }\n    }\n\n    const isValid = areAllDaysBetweenValid(start, end, props.allowNonContiguousRanges.value ? () => false : props.isDateUnavailable, rangeIsDateDisabled, props.isDateHighlightable)\n    if (isValid) {\n      return {\n        start,\n        end,\n      }\n    }\n    return null\n  })\n\n  const isHighlightedStart = (date: DateValue) => {\n    if (!highlightedRange.value || !highlightedRange.value.start)\n      return false\n    return isSameDay(highlightedRange.value.start, date)\n  }\n\n  const isHighlightedEnd = (date: DateValue) => {\n    if (!highlightedRange.value || !highlightedRange.value.end)\n      return false\n    return isSameDay(highlightedRange.value.end, date)\n  }\n\n  return {\n    isInvalid,\n    isSelected,\n    isDateHighlightable,\n    highlightedRange,\n    isSelectionStart,\n    isSelectionEnd,\n    isHighlightedStart,\n    isHighlightedEnd,\n    isDateDisabled: rangeIsDateDisabled,\n  }\n}\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { Grid, Matcher, WeekDayFormat } from '@/date'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { Formatter } from '@/shared'\nimport type { DateRange } from '@/shared/date'\nimport type { Direction } from '@/shared/types'\nimport { isEqualDay } from '@internationalized/date'\nimport { useCalendar } from '@/Calendar/useCalendar'\nimport { isBefore } from '@/date'\nimport {\n  createContext,\n  isNullish,\n  useDirection,\n  useKbd,\n  useLocale,\n} from '@/shared'\nimport { getDefaultDate, handleCalendarInitialFocus } from '@/shared/date'\nimport { useRangeCalendarState } from './useRangeCalendar'\n\ntype RangeCalendarRootContext = {\n  modelValue: Ref<DateRange>\n  startValue: Ref<DateValue | undefined>\n  endValue: Ref<DateValue | undefined>\n  locale: Ref<string>\n  placeholder: Ref<DateValue>\n  pagedNavigation: Ref<boolean>\n  preventDeselect: Ref<boolean>\n  grid: Ref<Grid<DateValue>[]>\n  weekDays: Ref<string[]>\n  weekStartsOn: Ref<0 | 1 | 2 | 3 | 4 | 5 | 6>\n  weekdayFormat: Ref<WeekDayFormat>\n  fixedWeeks: Ref<boolean>\n  numberOfMonths: Ref<number>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  initialFocus: Ref<boolean>\n  onPlaceholderChange: (date: DateValue) => void\n  fullCalendarLabel: Ref<string>\n  parentElement: Ref<HTMLElement | undefined>\n  headingValue: Ref<string>\n  isInvalid: Ref<boolean>\n  isDateDisabled: Matcher\n  isDateUnavailable?: Matcher\n  isDateHighlightable?: Matcher\n  isOutsideVisibleView: (date: DateValue) => boolean\n  allowNonContiguousRanges: Ref<boolean>\n  highlightedRange: Ref<{ start: DateValue, end: DateValue } | null>\n  focusedValue: Ref<DateValue | undefined>\n  lastPressedDateValue: Ref<DateValue | undefined>\n  isSelected: (date: DateValue) => boolean\n  isSelectionEnd: (date: DateValue) => boolean\n  isSelectionStart: (date: DateValue) => boolean\n  isHighlightedStart: (date: DateValue) => boolean\n  isHighlightedEnd: (date: DateValue) => boolean\n  prevPage: (prevPageFunc?: (date: DateValue) => DateValue) => void\n  nextPage: (nextPageFunc?: (date: DateValue) => DateValue) => void\n  isNextButtonDisabled: (\n    nextPageFunc?: (date: DateValue) => DateValue\n  ) => boolean\n  isPrevButtonDisabled: (\n    prevPageFunc?: (date: DateValue) => DateValue\n  ) => boolean\n  formatter: Formatter\n  dir: Ref<Direction>\n  disableDaysOutsideCurrentView: Ref<boolean>\n  fixedDate: Ref<'start' | 'end' | undefined>\n  maximumDays: Ref<number | undefined>\n}\n\nexport interface RangeCalendarRootProps extends PrimitiveProps {\n  /** The default placeholder date */\n  defaultPlaceholder?: DateValue\n  /** The default value for the calendar */\n  defaultValue?: DateRange\n  /** The controlled checked state of the calendar. Can be bound as `v-model`. */\n  modelValue?: DateRange | null\n  /** The placeholder date, which is used to determine what month to display when no date is selected. This updates as the user navigates the calendar and can be used to programmatically control the calendar view */\n  placeholder?: DateValue\n  /** When combined with `isDateUnavailable`, determines whether non-contiguous ranges, i.e. ranges containing unavailable dates, may be selected. */\n  allowNonContiguousRanges?: boolean\n  /** This property causes the previous and next buttons to navigate by the number of months displayed at once, rather than one month */\n  pagedNavigation?: boolean\n  /** Whether or not to prevent the user from deselecting a date without selecting another date first */\n  preventDeselect?: boolean\n  /** The maximum number of days that can be selected in a range */\n  maximumDays?: number\n  /** The day of the week to start the calendar on */\n  weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6\n  /** The format to use for the weekday strings provided via the weekdays slot prop */\n  weekdayFormat?: WeekDayFormat\n  /** The accessible label for the calendar */\n  calendarLabel?: string\n  /** Whether or not to always display 6 weeks in the calendar */\n  fixedWeeks?: boolean\n  /** The maximum date that can be selected */\n  maxValue?: DateValue\n  /** The minimum date that can be selected */\n  minValue?: DateValue\n  /** The locale to use for formatting dates */\n  locale?: string\n  /** The number of months to display at once */\n  numberOfMonths?: number\n  /** Whether or not the calendar is disabled */\n  disabled?: boolean\n  /** Whether or not the calendar is readonly */\n  readonly?: boolean\n  /** If true, the calendar will focus the selected day, today, or the first day of the month depending on what is visible when the calendar is mounted */\n  initialFocus?: boolean\n  /** A function that returns whether or not a date is disabled */\n  isDateDisabled?: Matcher\n  /** A function that returns whether or not a date is unavailable */\n  isDateUnavailable?: Matcher\n  /** A function that returns whether or not a date is hightable */\n  isDateHighlightable?: Matcher\n  /** The reading direction of the calendar when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** A function that returns the next page of the calendar. It receives the current placeholder as an argument inside the component. */\n  nextPage?: (placeholder: DateValue) => DateValue\n  /** A function that returns the previous page of the calendar. It receives the current placeholder as an argument inside the component. */\n  prevPage?: (placeholder: DateValue) => DateValue\n  /** Whether or not to disable days outside the current view. */\n  disableDaysOutsideCurrentView?: boolean\n  /** Which part of the range should be fixed */\n  fixedDate?: 'start' | 'end'\n}\n\nexport type RangeCalendarRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [date: DateRange]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: DateValue]\n  /** Event handler called whenever the start value changes */\n  'update:startValue': [date: DateValue | undefined]\n}\n\nexport const [injectRangeCalendarRootContext, provideRangeCalendarRootContext]\n  = createContext<RangeCalendarRootContext>('RangeCalendarRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useEventListener, useVModel } from '@vueuse/core'\nimport { computed, onMounted, ref, toRefs, watch } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\n\nconst props = withDefaults(defineProps<RangeCalendarRootProps>(), {\n  defaultValue: () => ({ start: undefined, end: undefined }),\n  as: 'div',\n  pagedNavigation: false,\n  preventDeselect: false,\n  weekStartsOn: 0,\n  weekdayFormat: 'narrow',\n  fixedWeeks: false,\n  numberOfMonths: 1,\n  disabled: false,\n  readonly: false,\n  initialFocus: false,\n  placeholder: undefined,\n  isDateDisabled: undefined,\n  isDateUnavailable: undefined,\n  isDateHighlightable: undefined,\n  allowNonContiguousRanges: false,\n  maximumDays: undefined,\n  disableDaysOutsideCurrentView: false,\n})\nconst emits = defineEmits<RangeCalendarRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** The current date of the placeholder */\n    date: DateValue\n    /** The grid of dates */\n    grid: Grid<DateValue>[]\n    /** The days of the week */\n    weekDays: string[]\n    /** The start of the week */\n    weekStartsOn: 0 | 1 | 2 | 3 | 4 | 5 | 6\n    /** The calendar locale */\n    locale: string\n    /** Whether or not to always display 6 weeks in the calendar */\n    fixedWeeks: boolean\n    /** The current date range */\n    modelValue: DateRange\n  }) => any\n}>()\n\nconst {\n  disabled,\n  readonly,\n  initialFocus,\n  pagedNavigation,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  numberOfMonths,\n  preventDeselect,\n  isDateUnavailable: propsIsDateUnavailable,\n  isDateHighlightable: propsIsDateHighlightable,\n  isDateDisabled: propsIsDateDisabled,\n  calendarLabel,\n  maxValue,\n  minValue,\n  dir: propDir,\n  locale: propLocale,\n  nextPage: propsNextPage,\n  prevPage: propsPrevPage,\n  allowNonContiguousRanges,\n  disableDaysOutsideCurrentView,\n  fixedDate,\n  maximumDays,\n} = toRefs(props)\n\nconst { primitiveElement, currentElement: parentElement }\n  = usePrimitiveElement()\nconst dir = useDirection(propDir)\nconst locale = useLocale(propLocale)\n\nconst lastPressedDateValue = ref() as Ref<DateValue | undefined>\nconst focusedValue = ref() as Ref<DateValue | undefined>\nconst isEditing = ref(false)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? { start: undefined, end: undefined },\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<DateRange>\n\nconst currentModelValue = computed(() =>\n  isNullish(modelValue.value)\n    ? { start: undefined, end: undefined }\n    : modelValue.value,\n)\n\nconst defaultDate = getDefaultDate({\n  defaultPlaceholder: props.placeholder,\n  defaultValue: currentModelValue.value.start,\n  locale: props.locale,\n})\n\nconst startValue = ref(currentModelValue.value.start) as Ref<\n  DateValue | undefined\n>\nconst endValue = ref(currentModelValue.value.end) as Ref<DateValue | undefined>\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<DateValue>\n\nfunction onPlaceholderChange(value: DateValue) {\n  placeholder.value = value.copy()\n}\n\nconst {\n  fullCalendarLabel,\n  headingValue,\n  isDateDisabled,\n  isDateUnavailable,\n  isNextButtonDisabled,\n  isPrevButtonDisabled,\n  grid,\n  weekdays,\n  isOutsideVisibleView,\n  nextPage,\n  prevPage,\n  formatter,\n} = useCalendar({\n  locale,\n  placeholder,\n  weekStartsOn,\n  fixedWeeks,\n  numberOfMonths,\n  minValue,\n  maxValue,\n  disabled,\n  weekdayFormat,\n  pagedNavigation,\n  isDateDisabled: propsIsDateDisabled.value,\n  isDateUnavailable: propsIsDateUnavailable.value,\n  calendarLabel,\n  nextPage: propsNextPage,\n  prevPage: propsPrevPage,\n})\n\nconst {\n  isInvalid,\n  isSelected,\n  isDateHighlightable,\n  highlightedRange,\n  isSelectionStart,\n  isSelectionEnd,\n  isHighlightedStart,\n  isHighlightedEnd,\n  isDateDisabled: rangeIsDateDisabled,\n} = useRangeCalendarState({\n  start: startValue,\n  end: endValue,\n  isDateDisabled,\n  isDateUnavailable,\n  isDateHighlightable: propsIsDateHighlightable.value,\n  focusedValue,\n  allowNonContiguousRanges,\n  fixedDate,\n  maximumDays,\n})\n\nwatch(modelValue, (_modelValue, _prevValue) => {\n  if (\n    (!_prevValue?.start && _modelValue?.start)\n    || !_modelValue\n    || !_modelValue.start\n    || (startValue.value && !isEqualDay(_modelValue.start, startValue.value))\n  ) {\n    startValue.value = _modelValue?.start?.copy?.()\n  }\n\n  if (\n    (!_prevValue?.end && _modelValue.end)\n    || !_modelValue\n    || !_modelValue.end\n    || (endValue.value && !isEqualDay(_modelValue.end, endValue.value))\n  ) {\n    endValue.value = _modelValue?.end?.copy?.()\n  }\n})\n\nwatch(startValue, (_startValue) => {\n  if (_startValue && !isEqualDay(_startValue, placeholder.value))\n    onPlaceholderChange(_startValue)\n\n  emits('update:startValue', _startValue)\n})\n\nwatch([startValue, endValue], ([_startValue, _endValue]) => {\n  const value = currentModelValue.value\n\n  if (\n    value\n    && value.start\n    && value.end\n    && _startValue\n    && _endValue\n    && isEqualDay(value.start, _startValue)\n    && isEqualDay(value.end, _endValue)\n  ) {\n    return\n  }\n\n  isEditing.value = true\n  if (_startValue && _endValue) {\n    isEditing.value = false\n    if (\n      value.start\n      && value.end\n      && isEqualDay(value.start, _startValue)\n      && isEqualDay(value.end, _endValue)\n    ) {\n      return\n    }\n    if (isBefore(_endValue, _startValue)) {\n      modelValue.value = {\n        start: _endValue.copy(),\n        end: _startValue.copy(),\n      }\n    }\n    else {\n      modelValue.value = {\n        start: _startValue.copy(),\n        end: _endValue.copy(),\n      }\n    }\n  }\n})\n\nconst kbd = useKbd()\nuseEventListener('keydown', (ev) => {\n  if (ev.key === kbd.ESCAPE && isEditing.value) {\n    // Abort start and end selection\n    startValue.value = modelValue.value.start?.copy()\n    endValue.value = modelValue.value.end?.copy()\n  }\n})\n\nprovideRangeCalendarRootContext({\n  isDateUnavailable,\n  isDateHighlightable,\n  startValue,\n  endValue,\n  formatter,\n  modelValue,\n  placeholder,\n  disabled,\n  initialFocus,\n  pagedNavigation,\n  grid,\n  weekDays: weekdays,\n  weekStartsOn,\n  weekdayFormat,\n  fixedWeeks,\n  numberOfMonths,\n  readonly,\n  preventDeselect,\n  fullCalendarLabel,\n  headingValue,\n  isInvalid,\n  isDateDisabled: rangeIsDateDisabled,\n  allowNonContiguousRanges,\n  highlightedRange,\n  focusedValue,\n  lastPressedDateValue,\n  isSelected,\n  isSelectionEnd,\n  isSelectionStart,\n  isNextButtonDisabled,\n  isPrevButtonDisabled,\n  isOutsideVisibleView,\n  nextPage,\n  prevPage,\n  parentElement,\n  onPlaceholderChange,\n  locale,\n  dir,\n  isHighlightedStart,\n  isHighlightedEnd,\n  disableDaysOutsideCurrentView,\n  fixedDate,\n  maximumDays,\n})\n\nonMounted(() => {\n  if (initialFocus.value)\n    handleCalendarInitialFocus(parentElement.value)\n})\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    role=\"application\"\n    :aria-label=\"fullCalendarLabel\"\n    :data-readonly=\"readonly ? '' : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :dir=\"dir\"\n  >\n    <div\n      style=\"\n        border: 0px;\n        clip: rect(0px, 0px, 0px, 0px);\n        clip-path: inset(50%);\n        height: 1px;\n        margin: -1px;\n        overflow: hidden;\n        padding: 0px;\n        position: absolute;\n        white-space: nowrap;\n        width: 1px;\n      \"\n    >\n      <div\n        role=\"heading\"\n        aria-level=\"2\"\n      >\n        {{ fullCalendarLabel }}\n      </div>\n    </div>\n\n    <slot\n      :date=\"placeholder\"\n      :grid=\"grid\"\n      :week-days=\"weekdays\"\n      :week-starts-on=\"weekStartsOn\"\n      :locale=\"locale\"\n      :fixed-weeks=\"fixedWeeks\"\n      :model-value=\"modelValue\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport { isEqualDay } from '@internationalized/date'\nimport { RangeCalendarRoot } from '..'\nimport { injectDateRangePickerRootContext } from './DateRangePickerRoot.vue'\n</script>\n\n<script setup lang=\"ts\">\nconst rootContext = injectDateRangePickerRootContext()\n</script>\n\n<template>\n  <RangeCalendarRoot\n    v-slot=\"{ weekDays, grid, date, weekStartsOn, locale, fixedWeeks }\"\n    v-bind=\"{\n      allowNonContiguousRanges: rootContext.allowNonContiguousRanges.value,\n      isDateDisabled: rootContext.isDateDisabled,\n      isDateUnavailable: rootContext.isDateUnavailable,\n      isDateHighlightable: rootContext.isDateHighlightable,\n      locale: rootContext.locale.value,\n      disabled: rootContext.disabled.value,\n      pagedNavigation: rootContext.pagedNavigation.value,\n      weekStartsOn: rootContext.weekStartsOn.value,\n      weekdayFormat: rootContext.weekdayFormat.value,\n      fixedWeeks: rootContext.fixedWeeks.value,\n      numberOfMonths: rootContext.numberOfMonths.value,\n      readonly: rootContext.readonly.value,\n      preventDeselect: rootContext.preventDeselect.value,\n      minValue: rootContext.minValue.value,\n      maxValue: rootContext.maxValue.value,\n      dir: rootContext.dir.value,\n      fixedDate: rootContext.fixedDate.value,\n      maximumDays: rootContext.maximumDays?.value,\n    }\"\n    initial-focus\n    :model-value=\"rootContext.modelValue.value\"\n    :placeholder=\"rootContext.placeholder.value\"\n    @update:start-value=\"(date) => {\n      rootContext.onStartValueChange(date)\n    }\"\n    @update:model-value=\"(date) => {\n      if (date.start && rootContext.modelValue.value?.start && date.end && rootContext.modelValue.value?.end && isEqualDay(date.start, rootContext.modelValue.value?.start) && isEqualDay(date.end, rootContext.modelValue.value?.end)) return\n      rootContext.onDateChange(date)\n    }\"\n    @update:placeholder=\"(date) => {\n      if (isEqualDay(date, rootContext.placeholder.value)) return\n      rootContext.onPlaceholderChange(date)\n    }\"\n  >\n    <slot\n      :date=\"date\"\n      :grid=\"grid\"\n      :week-days=\"weekDays\"\n      :week-starts-on=\"weekStartsOn\"\n      :locale=\"locale\"\n      :fixed-weeks=\"fixedWeeks\"\n    />\n  </RangeCalendarRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarCellProps extends PrimitiveProps {\n  date: DateValue\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectRangeCalendarRootContext } from './RangeCalendarRoot.vue'\n\nwithDefaults(defineProps<RangeCalendarCellProps>(), { as: 'td' })\nconst rootContext = injectRangeCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    role=\"gridcell\"\n    :aria-selected=\"rootContext.isSelected(date) ? true : undefined\"\n    :aria-disabled=\"rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date) || rootContext.disableDaysOutsideCurrentView.value\"\n    :data-disabled=\"rootContext.isDateDisabled(date) || rootContext.disableDaysOutsideCurrentView.value ? '' : undefined\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarCellProps } from '..'\nimport { RangeCalendarCell } from '..'\n\nexport interface DateRangePickerCellProps extends RangeCalendarCellProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerCellProps>()\n</script>\n\n<template>\n  <RangeCalendarCell v-bind=\"props\">\n    <slot />\n  </RangeCalendarCell>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\nimport {\n\n  getLocalTimeZone,\n  isSameDay,\n  isSameMonth,\n  isToday,\n} from '@internationalized/date'\nimport { computed, nextTick } from 'vue'\nimport { getSelectableCells } from '@/Calendar/utils'\nimport { getDaysInMonth, isBetweenInclusive, toDate } from '@/date'\nimport { useKbd } from '@/shared'\n\nexport interface RangeCalendarCellTriggerProps extends PrimitiveProps {\n  day: DateValue\n  month: DateValue\n}\n\nexport interface RangeCalendarCellTriggerSlot {\n  default?: (props: {\n    /** Current day */\n    dayValue: string\n    /** Current disable state */\n    disabled: boolean\n    /** Current selected state */\n    selected: boolean\n    /** Current today state */\n    today: boolean\n    /** Current outside view state */\n    outsideView: boolean\n    /** Current outside visible view state */\n    outsideVisibleView: boolean\n    /** Current unavailable state */\n    unavailable: boolean\n    /** Current highlighted state */\n    highlighted: boolean\n    /** Current highlighted start state */\n    highlightedStart: boolean\n    /** Current highlighted end state */\n    highlightedEnd: boolean\n    /** Current selection start state */\n    selectionStart: boolean\n    /** Current selection end state */\n    selectionEnd: boolean\n\n  }) => any\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { injectRangeCalendarRootContext } from './RangeCalendarRoot.vue'\n\nconst props = withDefaults(defineProps<RangeCalendarCellTriggerProps>(), { as: 'div' })\ndefineSlots<RangeCalendarCellTriggerSlot>()\n\nconst rootContext = injectRangeCalendarRootContext()\n\nconst kbd = useKbd()\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\n\nconst labelText = computed(() => rootContext.formatter.custom(toDate(props.day), {\n  weekday: 'long',\n  month: 'long',\n  day: 'numeric',\n  year: 'numeric',\n}))\n\nconst isUnavailable = computed(() => rootContext.isDateUnavailable?.(props.day) ?? false)\nconst isSelectedDate = computed(() => rootContext.isSelected(props.day))\nconst isSelectionStart = computed(() => rootContext.isSelectionStart(props.day))\nconst isSelectionEnd = computed(() => rootContext.isSelectionEnd(props.day))\nconst isHighlightStart = computed(() => rootContext.isHighlightedStart(props.day))\nconst isHighlightEnd = computed(() => rootContext.isHighlightedEnd(props.day))\nconst isHighlighted = computed(() => rootContext.highlightedRange.value\n  ? isBetweenInclusive(props.day, rootContext.highlightedRange.value.start, rootContext.highlightedRange.value.end)\n  : false)\nconst allowNonContiguousRanges = computed(() => rootContext.allowNonContiguousRanges.value)\n\nconst isDateToday = computed(() => {\n  return isToday(props.day, getLocalTimeZone())\n})\nconst isOutsideView = computed(() => {\n  return !isSameMonth(props.day, props.month)\n})\nconst isOutsideVisibleView = computed(() =>\n  rootContext.isOutsideVisibleView(props.day),\n)\n\nconst isDisabled = computed(() => rootContext.isDateDisabled(props.day) || (rootContext.disableDaysOutsideCurrentView.value && isOutsideView.value))\n\nconst dayValue = computed(() => props.day.day.toLocaleString(rootContext.locale.value))\n\nconst isFocusedDate = computed(() => {\n  return !rootContext.disabled.value && isSameDay(props.day, rootContext.placeholder.value)\n})\n\nfunction changeDate(e: MouseEvent | KeyboardEvent, date: DateValue) {\n  if (rootContext.readonly.value)\n    return\n  if (rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date))\n    return\n\n  rootContext.lastPressedDateValue.value = date.copy()\n\n  if (rootContext.startValue.value && rootContext.highlightedRange.value === null) {\n    if (isSameDay(date, rootContext.startValue.value) && !rootContext.preventDeselect.value && !rootContext.endValue.value) {\n      rootContext.startValue.value = undefined\n      rootContext.onPlaceholderChange(date)\n      return\n    }\n    else if (!rootContext.endValue.value) {\n      e.preventDefault()\n      if (rootContext.lastPressedDateValue.value && isSameDay(rootContext.lastPressedDateValue.value, date))\n        rootContext.startValue.value = date.copy()\n      return\n    }\n  }\n\n  if (rootContext.startValue.value && rootContext.endValue.value && isSameDay(rootContext.endValue.value, date) && !rootContext.preventDeselect.value) {\n    rootContext.startValue.value = undefined\n    rootContext.endValue.value = undefined\n    rootContext.onPlaceholderChange(date)\n    return\n  }\n\n  if (!rootContext.startValue.value) {\n    rootContext.startValue.value = date.copy()\n  }\n  else if (!rootContext.endValue.value) {\n    rootContext.endValue.value = date.copy()\n  }\n  else if (rootContext.endValue.value && rootContext.startValue.value) {\n    if (!rootContext.fixedDate.value) {\n      rootContext.endValue.value = undefined\n      rootContext.startValue.value = date.copy()\n    }\n    else if (rootContext.fixedDate.value === 'start') {\n      if (date.compare(rootContext.startValue.value) < 0) {\n        rootContext.startValue.value = date.copy()\n      }\n      else {\n        rootContext.endValue.value = date.copy()\n      }\n    }\n    else if (rootContext.fixedDate.value === 'end') {\n      if (date.compare(rootContext.endValue.value) > 0) {\n        rootContext.endValue.value = date.copy()\n      }\n      else {\n        rootContext.startValue.value = date.copy()\n      }\n    }\n  }\n}\n\nfunction handleClick(e: MouseEvent) {\n  if (isDisabled.value)\n    return\n  changeDate(e, props.day)\n}\n\nfunction handleFocus() {\n  if (isDisabled.value || rootContext.isDateUnavailable?.(props.day))\n    return\n  rootContext.focusedValue.value = props.day.copy()\n}\n\nfunction handleArrowKey(e: KeyboardEvent) {\n  if (isDisabled.value)\n    return\n  e.preventDefault()\n  e.stopPropagation()\n  const parentElement = rootContext.parentElement.value!\n  const indexIncrementation = 7\n  const sign = rootContext.dir.value === 'rtl' ? -1 : 1\n  switch (e.code) {\n    case kbd.ARROW_RIGHT:\n      shiftFocus(currentElement.value, sign)\n      break\n    case kbd.ARROW_LEFT:\n      shiftFocus(currentElement.value, -sign)\n      break\n    case kbd.ARROW_UP:\n      shiftFocus(currentElement.value, -indexIncrementation)\n      break\n    case kbd.ARROW_DOWN:\n      shiftFocus(currentElement.value, indexIncrementation)\n      break\n    case kbd.ENTER:\n    case kbd.SPACE_CODE:\n      changeDate(e, props.day)\n  }\n\n  function shiftFocus(node: HTMLElement, add: number) {\n    const allCollectionItems: HTMLElement[] = getSelectableCells(parentElement)\n    if (!allCollectionItems.length)\n      return\n\n    const index = allCollectionItems.indexOf(node)\n    const newIndex = index + add\n\n    if (newIndex >= 0 && newIndex < allCollectionItems.length) {\n      if (allCollectionItems[newIndex].hasAttribute('data-disabled')) {\n        shiftFocus(allCollectionItems[newIndex], add)\n      }\n      allCollectionItems[newIndex].focus()\n      return\n    }\n\n    if (newIndex < 0) {\n      if (rootContext.isPrevButtonDisabled())\n        return\n      rootContext.prevPage()\n      nextTick(() => {\n        const newCollectionItems: HTMLElement[] = getSelectableCells(parentElement)\n        if (!newCollectionItems.length)\n          return\n        if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {\n        // Placeholder is set to first month of the new page\n          const numberOfDays = getDaysInMonth(rootContext.placeholder.value)\n          const computedIndex = numberOfDays - Math.abs(newIndex)\n          if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n            shiftFocus(newCollectionItems[computedIndex], add)\n          }\n          newCollectionItems[\n            computedIndex\n          ].focus()\n          return\n        }\n        const computedIndex = newCollectionItems.length - Math.abs(newIndex)\n        if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n          shiftFocus(newCollectionItems[computedIndex], add)\n        }\n        newCollectionItems[\n          computedIndex\n        ].focus()\n      })\n      return\n    }\n\n    if (newIndex >= allCollectionItems.length) {\n      if (rootContext.isNextButtonDisabled())\n        return\n      rootContext.nextPage()\n      nextTick(() => {\n        const newCollectionItems: HTMLElement[] = getSelectableCells(parentElement)\n        if (!newCollectionItems.length)\n          return\n\n        if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {\n        // Placeholder is set to first month of the new page\n          const numberOfDays = getDaysInMonth(\n            rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 }),\n          )\n\n          const computedIndex = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays)\n\n          if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n            shiftFocus(newCollectionItems[computedIndex], add)\n          }\n          newCollectionItems[computedIndex].focus()\n          return\n        }\n\n        const computedIndex = newIndex - allCollectionItems.length\n        if (newCollectionItems[computedIndex].hasAttribute('data-disabled')) {\n          shiftFocus(newCollectionItems[computedIndex], add)\n        }\n\n        newCollectionItems[computedIndex].focus()\n      })\n    }\n  }\n}\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    v-bind=\"props\"\n    role=\"button\"\n    :aria-label=\"labelText\"\n    data-reka-calendar-cell-trigger\n    :aria-selected=\"isSelectedDate && (allowNonContiguousRanges || !isUnavailable) ? true : undefined\"\n    :aria-disabled=\"isDisabled || isUnavailable ? true : undefined\"\n    :data-highlighted=\"isHighlighted && (allowNonContiguousRanges || !isUnavailable) ? '' : undefined\"\n    :data-selection-start=\"isSelectionStart ? true : undefined\"\n    :data-selection-end=\"isSelectionEnd ? true : undefined\"\n    :data-highlighted-start=\"isHighlightStart ? true : undefined\"\n    :data-highlighted-end=\"isHighlightEnd ? true : undefined\"\n    :data-selected=\"isSelectedDate && (allowNonContiguousRanges || !isUnavailable) ? true : undefined\"\n    :data-outside-visible-view=\"isOutsideVisibleView ? '' : undefined\"\n    :data-value=\"day.toString()\"\n    :data-disabled=\"isDisabled ? '' : undefined\"\n    :data-unavailable=\"isUnavailable ? '' : undefined\"\n    :data-today=\"isDateToday ? '' : undefined\"\n    :data-outside-view=\"isOutsideView ? '' : undefined\"\n    :data-focused=\"isFocusedDate ? '' : undefined\"\n    :tabindex=\"isFocusedDate ? 0 : isOutsideView || isDisabled ? undefined : -1\"\n    @click=\"handleClick\"\n    @focusin=\"handleFocus\"\n    @mouseenter=\"handleFocus\"\n    @keydown.up.down.left.right.enter.space=\"handleArrowKey\"\n  >\n    <slot\n      :day-value=\"dayValue\"\n      :disabled=\"isDisabled\"\n      :today=\"isDateToday\"\n      :selected=\"isSelectedDate\"\n      :outside-view=\"isOutsideView\"\n      :outside-visible-view=\"isOutsideVisibleView\"\n      :unavailable=\"isUnavailable\"\n      :highlighted=\"isHighlighted && (allowNonContiguousRanges || !isUnavailable)\"\n      :highlighted-start=\"isHighlightStart\"\n      :highlighted-end=\"isHighlightEnd\"\n      :selection-start=\"isSelectionStart\"\n      :selection-end=\"isSelectionEnd\"\n    >\n      {{ dayValue }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarCellTriggerProps, RangeCalendarCellTriggerSlot } from '@/RangeCalendar/RangeCalendarCellTrigger.vue'\nimport { RangeCalendarCellTrigger } from '..'\n\nexport interface DateRangePickerCellTriggerProps extends RangeCalendarCellTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerCellTriggerProps>()\n\ndefineSlots<RangeCalendarCellTriggerSlot>()\n</script>\n\n<template>\n  <RangeCalendarCellTrigger\n    v-slot=\"slotProps\"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </RangeCalendarCellTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverCloseProps } from '..'\nimport { PopoverClose } from '..'\n\nexport interface DateRangePickerCloseProps extends PopoverCloseProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerCloseProps>()\n</script>\n\n<template>\n  <PopoverClose v-bind=\"props\">\n    <slot />\n  </PopoverClose>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverContentEmits, PopoverContentProps, PopoverPortalProps } from '..'\nimport { computed } from 'vue'\nimport { PopoverContent, PopoverPortal, useForwardPropsEmits } from '..'\n\nexport interface DateRangePickerContentProps extends PopoverContentProps {\n  /**\n   * Props to control the portal wrapped around the content.\n   */\n  portal?: PopoverPortalProps\n}\nexport interface DateRangePickerContentEmits extends PopoverContentEmits {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerContentProps>()\nconst emits = defineEmits<DateRangePickerContentEmits>()\n\nconst propsToForward = computed(() => ({\n  ...props,\n  portal: undefined,\n}))\nconst forwarded = useForwardPropsEmits(propsToForward, emits)\n</script>\n\n<template>\n  <PopoverPortal v-bind=\"portal\">\n    <PopoverContent\n      v-bind=\"{ ...forwarded, ...$attrs }\"\n    >\n      <slot />\n    </PopoverContent>\n  </PopoverPortal>\n</template>\n", "<script lang=\"ts\">\nimport { isEqualDay } from '@internationalized/date'\nimport { DateRangeFieldRoot } from '..'\nimport { injectDateRangePickerRootContext } from './DateRangePickerRoot.vue'\n</script>\n\n<script setup lang=\"ts\">\nconst rootContext = injectDateRangePickerRootContext()\n</script>\n\n<template>\n  <DateRangeFieldRoot\n    v-slot=\"{ segments, modelValue }\"\n    :ref=\"rootContext.dateFieldRef\"\n    :model-value=\"rootContext.modelValue.value\"\n    :placeholder=\"rootContext.placeholder.value\"\n    v-bind=\"{\n      id: rootContext.id.value,\n      name: rootContext.name.value,\n      disabled: rootContext.disabled.value,\n      minValue: rootContext.minValue.value,\n      maxValue: rootContext.maxValue.value,\n      readonly: rootContext.readonly.value,\n      hourCycle: rootContext.hourCycle.value,\n      granularity: rootContext.granularity.value,\n      hideTimeZone: rootContext.hideTimeZone.value,\n      locale: rootContext.locale.value,\n      isDateUnavailable: rootContext.isDateUnavailable,\n      required: rootContext.required.value,\n      dir: rootContext.dir.value,\n    }\"\n    @update:model-value=\"(date) => {\n      if (date.start && rootContext.modelValue.value.start && date.end && rootContext.modelValue.value.end && date.start.compare(rootContext.modelValue.value.start) === 0 && date.end.compare(rootContext.modelValue.value.end) === 0) return\n      rootContext.onDateChange(date)\n    }\"\n    @update:placeholder=\"(date) => {\n      if (isEqualDay(date, rootContext.placeholder.value) && date.compare(rootContext.placeholder.value) === 0) return\n      rootContext.onPlaceholderChange(date)\n    }\"\n  >\n    <slot\n      :segments=\"segments\"\n      :model-value=\"modelValue\"\n    />\n  </DateRangeFieldRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarGridProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectRangeCalendarRootContext } from './RangeCalendarRoot.vue'\n\nconst props = withDefaults(defineProps<RangeCalendarGridProps>(), { as: 'table' })\n\nconst rootContext = injectRangeCalendarRootContext()\n\nconst disabled = computed(() => rootContext.disabled.value ? true : undefined)\nconst readonly = computed(() => rootContext.readonly.value ? true : undefined)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    tabindex=\"-1\"\n    role=\"grid\"\n    :aria-readonly=\"readonly\"\n    :aria-disabled=\"disabled\"\n    :data-readonly=\"readonly && ''\"\n    :data-disabled=\"disabled && ''\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarGridProps } from '..'\nimport { RangeCalendarGrid } from '..'\n\nexport interface DateRangePickerGridProps extends RangeCalendarGridProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerGridProps>()\n</script>\n\n<template>\n  <RangeCalendarGrid v-bind=\"props\">\n    <slot />\n  </RangeCalendarGrid>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarGridBodyProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<RangeCalendarGridBodyProps>(), { as: 'tbody' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarGridBodyProps } from '..'\nimport { RangeCalendarGridBody } from '..'\n\nexport interface DateRangePickerGridBodyProps extends RangeCalendarGridBodyProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerGridBodyProps>()\n</script>\n\n<template>\n  <RangeCalendarGridBody v-bind=\"props\">\n    <slot />\n  </RangeCalendarGridBody>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarGridHeadProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<RangeCalendarGridHeadProps>(), { as: 'thead' })\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-hidden=\"true\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarGridHeadProps } from '..'\nimport { RangeCalendarGridHead } from '..'\n\nexport interface DateRangePickerGridHeadProps extends RangeCalendarGridHeadProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerGridHeadProps>()\n</script>\n\n<template>\n  <RangeCalendarGridHead v-bind=\"props\">\n    <slot />\n  </RangeCalendarGridHead>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarGridRowProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<RangeCalendarGridRowProps>(), { as: 'tr' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarGridRowProps } from '..'\nimport { RangeCalendarGridRow } from '..'\n\nexport interface DateRangePickerGridRowProps extends RangeCalendarGridRowProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerGridRowProps>()\n</script>\n\n<template>\n  <RangeCalendarGridRow v-bind=\"props\">\n    <slot />\n  </RangeCalendarGridRow>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarHeadCellProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<RangeCalendarHeadCellProps>(), { as: 'th' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarHeadCellProps } from '..'\nimport { RangeCalendarHeadCell } from '..'\n\nexport interface DateRangePickerHeadCellProps extends RangeCalendarHeadCellProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerHeadCellProps>()\n</script>\n\n<template>\n  <RangeCalendarHeadCell v-bind=\"props\">\n    <slot />\n  </RangeCalendarHeadCell>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarHeaderProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<RangeCalendarHeaderProps>(), { as: 'div' })\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarHeaderProps } from '..'\nimport { RangeCalendarHeader } from '..'\n\nexport interface DateRangePickerHeaderProps extends RangeCalendarHeaderProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerHeaderProps>()\n</script>\n\n<template>\n  <RangeCalendarHeader v-bind=\"props\">\n    <slot />\n  </RangeCalendarHeader>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarHeadingProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectRangeCalendarRootContext } from './RangeCalendarRoot.vue'\n\nconst props = withDefaults(defineProps<RangeCalendarHeadingProps>(), { as: 'div' })\ndefineSlots<{\n  default?: (props: {\n    /** Current month and year */\n    headingValue: string\n  }) => any\n}>()\nconst rootContext = injectRangeCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n  >\n    <slot :heading-value=\"rootContext.headingValue.value\">\n      {{ rootContext.headingValue.value }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarHeadingProps } from '..'\nimport { RangeCalendarHeading } from '..'\n\nexport interface DateRangePickerHeadingProps extends RangeCalendarHeadingProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerHeadingProps>()\ndefineSlots<{\n  default?: (props: {\n    /** Current month and year */\n    headingValue: string\n  }) => any\n}>()\n</script>\n\n<template>\n  <RangeCalendarHeading\n    v-slot=\"{ headingValue }\"\n    v-bind=\"props\"\n  >\n    <slot :heading-value=\"headingValue\">\n      {{ headingValue }}\n    </slot>\n  </RangeCalendarHeading>\n</template>\n", "<script lang=\"ts\">\nimport type { DateRangeFieldInputProps } from '..'\nimport { DateRangeFieldInput } from '..'\n\nexport interface DateRangePickerInputProps extends DateRangeFieldInputProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerInputProps>()\n</script>\n\n<template>\n  <DateRangeFieldInput v-bind=\"props\">\n    <slot />\n  </DateRangeFieldInput>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarNextProps extends PrimitiveProps {\n  /** The function to be used for the next page. Overwrites the `nextPage` function set on the `RangeCalendarRoot`. */\n  nextPage?: (placeholder: DateValue) => DateValue\n}\n\nexport interface RangeCalendarNextSlot {\n  default?: (props: {\n    /** Current disable state */\n    disabled: boolean\n  }) => any\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectRangeCalendarRootContext } from './RangeCalendarRoot.vue'\n\nconst props = withDefaults(defineProps<RangeCalendarNextProps>(), { as: 'button' })\ndefineSlots<RangeCalendarNextSlot>()\n\nconst disabled = computed(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props.nextPage))\n\nconst rootContext = injectRangeCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"Next page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :aria-disabled=\"disabled || undefined\"\n    :data-disabled=\"disabled || undefined\"\n    :disabled=\"disabled\"\n    @click=\"rootContext.nextPage(props.nextPage)\"\n  >\n    <slot :disabled>\n      Next page\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarNextProps } from '..'\nimport type { RangeCalendarNextSlot } from '@/RangeCalendar/RangeCalendarNext.vue'\nimport { RangeCalendarNext } from '..'\n\nexport interface DateRangePickerNextProps extends RangeCalendarNextProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerNextProps>()\ndefineSlots<RangeCalendarNextSlot>()\n</script>\n\n<template>\n  <RangeCalendarNext\n    v-slot=\"slotProps \"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </RangeCalendarNext>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface RangeCalendarPrevProps extends PrimitiveProps {\n  /** The function to be used for the prev page. Overwrites the `prevPage` function set on the `RangeCalendarRoot`. */\n  prevPage?: (placeholder: DateValue) => DateValue\n}\n\nexport interface RangeCalendarPrevSlot {\n  default?: (props: {\n    /** Current disable state */\n    disabled: boolean\n  }) => any\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectRangeCalendarRootContext } from './RangeCalendarRoot.vue'\n\nconst props = withDefaults(defineProps<RangeCalendarPrevProps>(), { as: 'button' })\ndefineSlots<RangeCalendarPrevSlot>()\n\nconst disabled = computed(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props.prevPage))\n\nconst rootContext = injectRangeCalendarRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"Previous page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :aria-disabled=\"disabled || undefined\"\n    :data-disabled=\"disabled || undefined\"\n    :disabled=\"disabled\"\n    @click=\"rootContext.prevPage(props.prevPage)\"\n  >\n    <slot :disabled>\n      Prev page\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { RangeCalendarPrevProps } from '..'\nimport type { RangeCalendarPrevSlot } from '@/RangeCalendar/RangeCalendarPrev.vue'\nimport { RangeCalendarPrev } from '..'\n\nexport interface DateRangePickerPrevProps extends RangeCalendarPrevProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerPrevProps>()\ndefineSlots<RangeCalendarPrevSlot>()\n</script>\n\n<template>\n  <RangeCalendarPrev\n    v-slot=\"slotProps \"\n    v-bind=\"props\"\n  >\n    <slot v-bind=\"slotProps\" />\n  </RangeCalendarPrev>\n</template>\n", "<script lang=\"ts\">\nimport type { PopoverTriggerProps } from '..'\nimport { PopoverTrigger } from '..'\nimport { injectDateRangePickerRootContext } from './DateRangePickerRoot.vue'\n\nexport interface DateRangePickerTriggerProps extends PopoverTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DateRangePickerTriggerProps>()\nconst rootContext = injectDateRangePickerRootContext()\n</script>\n\n<template>\n  <PopoverTrigger\n    data-reka-date-field-segment=\"trigger\"\n    v-bind=\"props\"\n    :disabled=\"rootContext.disabled.value\"\n    @focusin=\"(e: FocusEvent) => {\n      rootContext.dateFieldRef.value?.setFocusedElement(e.target as HTMLElement)\n    }\"\n  >\n    <slot />\n  </PopoverTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface DialogPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<DialogPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuArrowProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuArrowProps extends MenuArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuArrow } from '@/Menu'\n\nconst props = withDefaults(defineProps<DropdownMenuArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuArrow v-bind=\"props\">\n    <slot />\n  </MenuArrow>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuCheckboxItemEmits,\n  MenuCheckboxItemProps,\n} from '@/Menu'\n\nexport type DropdownMenuCheckboxItemEmits = MenuCheckboxItemEmits\n\nexport interface DropdownMenuCheckboxItemProps extends MenuCheckboxItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuCheckboxItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<DropdownMenuCheckboxItemProps>()\nconst emits = defineEmits<DropdownMenuCheckboxItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuCheckboxItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuCheckboxItem>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Direction } from '../shared/types'\nimport type { MenuEmits, MenuProps } from '@/Menu'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuRootProps extends MenuProps {\n  /** The open state of the dropdown menu when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n}\nexport type DropdownMenuRootEmits = MenuEmits\n\nexport interface DropdownMenuRootContext {\n  open: Readonly<Ref<boolean>>\n  onOpenChange: (open: boolean) => void\n  onOpenToggle: () => void\n  triggerId: string\n  triggerElement: Ref<HTMLElement | undefined>\n  contentId: string\n  modal: Ref<boolean>\n  dir: Ref<Direction>\n}\n\nexport const [injectDropdownMenuRootContext, provideDropdownMenuRootContext]\n  = createContext<DropdownMenuRootContext>('DropdownMenuRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs } from 'vue'\nimport { MenuRoot } from '@/Menu'\n\nconst props = withDefaults(defineProps<DropdownMenuRootProps>(), {\n  modal: true,\n  open: undefined,\n})\nconst emit = defineEmits<DropdownMenuRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nuseForwardExpose()\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst triggerElement = ref<HTMLElement>()\n\nconst { modal, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nprovideDropdownMenuRootContext({\n  open,\n  onOpenChange: (value) => {\n    open.value = value\n  },\n  onOpenToggle: () => {\n    open.value = !open.value\n  },\n  triggerId: '',\n  triggerElement,\n  contentId: '',\n  modal,\n  dir,\n})\n</script>\n\n<template>\n  <MenuRoot\n    v-model:open=\"open\"\n    :dir=\"dir\"\n    :modal=\"modal\"\n  >\n    <slot :open=\"open\" />\n  </MenuRoot>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuContentEmits,\n  MenuContentProps,\n} from '@/Menu'\n\nexport type DropdownMenuContentEmits = MenuContentEmits\n\nexport interface DropdownMenuContentProps extends MenuContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { MenuContent } from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits, useId } from '@/shared'\nimport { injectDropdownMenuRootContext } from './DropdownMenuRoot.vue'\n\nconst props = defineProps<DropdownMenuContentProps>()\nconst emits = defineEmits<DropdownMenuContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n\nconst rootContext = injectDropdownMenuRootContext()\n\nconst hasInteractedOutsideRef = ref(false)\n\nfunction handleCloseAutoFocus(event: Event) {\n  if (event.defaultPrevented)\n    return\n  if (!hasInteractedOutsideRef.value) {\n    setTimeout(() => {\n      rootContext.triggerElement.value?.focus()\n    }, 0)\n  }\n  hasInteractedOutsideRef.value = false\n\n  // Always prevent auto focus because we either focus manually or want user agent focus\n  event.preventDefault()\n}\n\nrootContext.contentId ||= useId(undefined, 'reka-dropdown-menu-content')\n</script>\n\n<template>\n  <MenuContent\n    v-bind=\"forwarded\"\n    :id=\"rootContext.contentId\"\n    :aria-labelledby=\"rootContext?.triggerId\"\n    :style=\"{\n      '--reka-dropdown-menu-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-dropdown-menu-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-dropdown-menu-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-dropdown-menu-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-dropdown-menu-trigger-height':\n        'var(--reka-popper-anchor-height)',\n    }\"\n    @close-auto-focus=\"handleCloseAutoFocus\"\n    @interact-outside=\"(event) => {\n      if (event.defaultPrevented) return\n\n      const originalEvent = event.detail.originalEvent as PointerEvent;\n      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n      if (!rootContext.modal.value || isRightClick) hasInteractedOutsideRef = true;\n      if (rootContext.triggerElement.value?.contains(event.target as HTMLElement)) event.preventDefault()\n    }\"\n  >\n    <slot />\n  </MenuContent>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuGroupProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuGroupProps extends MenuGroupProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuGroup } from '@/Menu'\n\nconst props = defineProps<DropdownMenuGroupProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuGroup v-bind=\"props\">\n    <slot />\n  </MenuGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemEmits, MenuItemProps } from '@/Menu'\n\nexport type DropdownMenuItemEmits = MenuItemEmits\n\nexport interface DropdownMenuItemProps extends MenuItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<DropdownMenuItemProps>()\nconst emits = defineEmits<DropdownMenuItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuItem>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemIndicatorProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuItemIndicatorProps extends MenuItemIndicatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuItemIndicator } from '@/Menu'\n\nconst props = defineProps<DropdownMenuItemIndicatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuItemIndicator v-bind=\"props\">\n    <slot />\n  </MenuItemIndicator>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuLabelProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuLabelProps extends MenuLabelProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuLabel } from '@/Menu'\n\nconst props = defineProps<DropdownMenuLabelProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuLabel v-bind=\"props\">\n    <slot />\n  </MenuLabel>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuPortalProps } from '@/Menu'\n\nexport interface DropdownMenuPortalProps extends MenuPortalProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuPortal } from '@/Menu'\n\nconst props = defineProps<DropdownMenuPortalProps>()\n</script>\n\n<template>\n  <MenuPortal v-bind=\"props\">\n    <slot />\n  </MenuPortal>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuRadioGroupEmits,\n  MenuRadioGroupProps,\n} from '@/Menu'\n\nexport type DropdownMenuRadioGroupEmits = MenuRadioGroupEmits\n\nexport interface DropdownMenuRadioGroupProps extends MenuRadioGroupProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuRadioGroup } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<MenuRadioGroupProps>()\nconst emits = defineEmits<MenuRadioGroupEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuRadioGroup v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuRadioGroup>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuRadioItemEmits,\n  MenuRadioItemProps,\n} from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\n\nexport type DropdownMenuRadioItemEmits = MenuRadioItemEmits\n\nexport interface DropdownMenuRadioItemProps extends MenuRadioItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuRadioItem } from '@/Menu'\n\nconst props = defineProps<DropdownMenuRadioItemProps>()\nconst emits = defineEmits<DropdownMenuRadioItemEmits>()\n\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuRadioItem v-bind=\"forwarded\">\n    <slot />\n  </MenuRadioItem>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuSeparatorProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuSeparatorProps extends MenuSeparatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSeparator } from '@/Menu'\n\nconst props = defineProps<DropdownMenuSeparatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSeparator v-bind=\"props\">\n    <slot />\n  </MenuSeparator>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { MenuSubEmits, MenuSubProps } from '@/Menu'\n\nexport type DropdownMenuSubEmits = MenuSubEmits\nexport interface DropdownMenuSubProps extends MenuSubProps {\n  /** The open state of the dropdown menu when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { MenuSub } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = withDefaults(defineProps<DropdownMenuSubProps>(), {\n  open: undefined,\n})\nconst emit = defineEmits<DropdownMenuSubEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nconst open = useVModel(props, 'open', emit, {\n  passive: (props.open === undefined) as false,\n  defaultValue: props.defaultOpen ?? false,\n}) as Ref<boolean>\n\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSub v-model:open=\"open\">\n    <slot :open=\"open\" />\n  </MenuSub>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuSubContentEmits,\n  MenuSubContentProps,\n} from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport type DropdownMenuSubContentEmits = MenuSubContentEmits\n\nexport interface DropdownMenuSubContentProps extends MenuSubContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSubContent } from '@/Menu'\nimport { useForwardPropsEmits } from '..'\n\nconst props = defineProps<DropdownMenuSubContentProps>()\nconst emits = defineEmits<DropdownMenuSubContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSubContent\n    v-bind=\"forwarded\"\n    :style=\"{\n      '--reka-dropdown-menu-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-dropdown-menu-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-dropdown-menu-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-dropdown-menu-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-dropdown-menu-trigger-height':\n        'var(--reka-popper-anchor-height)',\n    }\"\n  >\n    <slot />\n  </MenuSubContent>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuSubTriggerProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DropdownMenuSubTriggerProps extends MenuSubTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSubTrigger } from '@/Menu'\n\nconst props = defineProps<DropdownMenuSubTriggerProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSubTrigger v-bind=\"props\">\n    <slot />\n  </MenuSubTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose, useId } from '@/shared'\n\nexport interface DropdownMenuTriggerProps extends PrimitiveProps {\n  /** When `true`, prevents the user from interacting with item */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, onMounted } from 'vue'\nimport { MenuAnchor } from '@/Menu'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectDropdownMenuRootContext } from './DropdownMenuRoot.vue'\n\nconst props = withDefaults(defineProps<DropdownMenuTriggerProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectDropdownMenuRootContext()\n\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\n\nonMounted(() => {\n  rootContext.triggerElement = triggerElement\n})\n\nrootContext.triggerId ||= useId(undefined, 'reka-dropdown-menu-trigger')\n</script>\n\n<template>\n  <MenuAnchor as-child>\n    <Primitive\n      :id=\"rootContext.triggerId\"\n      :ref=\"forwardRef\"\n      :type=\"as === 'button' ? 'button' : undefined\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n      aria-haspopup=\"menu\"\n      :aria-expanded=\"rootContext.open.value\"\n      :aria-controls=\"rootContext.open.value ? rootContext.contentId : undefined\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :disabled=\"disabled\"\n      :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n      @click=\"\n        async (event) => {\n          // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n          // but not when the control key is pressed (avoiding MacOS right click)\n          if (!disabled && event.button === 0 && event.ctrlKey === false) {\n            rootContext?.onOpenToggle();\n            await nextTick()\n            // prevent trigger focusing when opening\n            // this allows the content to be given focus without competition\n            if (rootContext.open.value) event.preventDefault();\n          }\n        }\n      \"\n      @keydown.enter.space.arrow-down=\"\n        (event) => {\n          if (disabled) return;\n          if (['Enter', ' '].includes(event.key)) rootContext.onOpenToggle();\n          if (event.key === 'ArrowDown') rootContext.onOpenChange(true);\n          // prevent keydown from scrolling window / first focused item to execute\n          // that keydown (inadvertently closing the menu)\n          if (['Enter', ' ', 'ArrowDown'].includes(event.key))\n            event.preventDefault();\n        }\n      \"\n    >\n      <slot />\n    </Primitive>\n  </MenuAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { Direction, FormFieldProps } from '@/shared/types'\nimport { useFocusOutside, usePointerDownOutside } from '@/DismissableLayer'\nimport { createContext, useDirection, useFormControl } from '@/shared'\n\ntype ActivationMode = 'focus' | 'dblclick' | 'none'\ntype SubmitMode = 'blur' | 'enter' | 'none' | 'both'\n\ntype EditableRootContext = {\n  id: Ref<string | undefined>\n  name: Ref<string | undefined>\n  maxLength: Ref<number | undefined>\n  disabled: Ref<boolean>\n  modelValue: Ref<string | null | undefined>\n  inputValue: Ref<string | null | undefined>\n  placeholder: Ref<{ edit: string, preview: string }>\n  isEditing: Ref<boolean>\n  submitMode: Ref<SubmitMode>\n  activationMode: Ref<ActivationMode>\n  selectOnFocus: Ref<boolean>\n  edit: () => void\n  cancel: () => void\n  submit: () => void\n  inputRef: Ref<HTMLInputElement | undefined>\n  startWithEditMode: Ref<boolean>\n  isEmpty: Ref<boolean>\n  readonly: Ref<boolean>\n  autoResize: Ref<boolean>\n}\n\nexport interface EditableRootProps extends PrimitiveProps, FormFieldProps {\n  /** The default value of the editable field */\n  defaultValue?: string\n  /** The value of the editable field */\n  modelValue?: string | null\n  /** The placeholder for the editable field */\n  placeholder?: string | { edit: string, preview: string }\n  /** The reading direction of the calendar when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** Whether the editable field is disabled */\n  disabled?: boolean\n  /** Whether the editable field is read-only */\n  readonly?: boolean\n  /** The activation event of the editable field */\n  activationMode?: ActivationMode\n  /** Whether to select the text in the input when it is focused. */\n  selectOnFocus?: boolean\n  /** The submit event of the editable field */\n  submitMode?: SubmitMode\n  /** Whether to start with the edit mode active */\n  startWithEditMode?: boolean\n  /** The maximum number of characters allowed */\n  maxLength?: number\n  /** Whether the editable field should auto resize */\n  autoResize?: boolean\n  /** The id of the field */\n  id?: string\n}\n\nexport type EditableRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [value: string]\n  /** Event handler called when a value is submitted */\n  'submit': [value: string | null | undefined]\n  /** Event handler called when the editable field changes state */\n  'update:state': [state: 'edit' | 'submit' | 'cancel']\n}\n\nexport const [injectEditableRootContext, provideEditableRootContext]\n  = createContext<EditableRootContext>('EditableRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { useVModel } from '@vueuse/core'\nimport { computed, ref, toRefs, watch } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<EditableRootProps>(), {\n  as: 'div',\n  disabled: false,\n  submitMode: 'blur',\n  activationMode: 'focus',\n  selectOnFocus: false,\n  placeholder: 'Enter text...',\n  autoResize: false,\n  required: false,\n})\n\nconst emits = defineEmits<EditableRootEmits>()\ndefineSlots<{\n  default?: (props: {\n    /** Whether the editable field is in edit mode */\n    isEditing: boolean\n    /** The value of the editable field */\n    modelValue: typeof modelValue.value\n    /** Whether the editable field is empty */\n    isEmpty: boolean\n    /** Function to submit the value of the editable */\n    submit: () => void\n    /** Function to cancel the value of the editable */\n    cancel: () => void\n    /** Function to set the editable in edit mode */\n    edit: () => void\n  }) => any\n}>()\n\nconst {\n  id,\n  name,\n  defaultValue,\n  startWithEditMode,\n  placeholder: propPlaceholder,\n  maxLength,\n  disabled,\n  dir: propDir,\n  submitMode,\n  activationMode,\n  selectOnFocus,\n  readonly,\n  autoResize,\n  required,\n} = toRefs(props)\n\nconst inputRef = ref<HTMLInputElement | undefined>()\nconst dir = useDirection(propDir)\nconst isEditing = ref(startWithEditMode.value ?? false)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: defaultValue.value ?? '',\n  passive: (props.modelValue === undefined) as false,\n})\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\n\nconst isFormControl = useFormControl(currentElement)\n\nconst placeholder = computed(() => {\n  return typeof propPlaceholder.value === 'string' ? { edit: propPlaceholder.value, preview: propPlaceholder.value } : propPlaceholder.value\n})\n\nconst inputValue = ref(modelValue.value)\n\nwatch(() => modelValue.value, () => {\n  inputValue.value = modelValue.value\n}, { immediate: true, deep: true })\n\nfunction cancel() {\n  isEditing.value = false\n  emits('update:state', 'cancel')\n}\n\nfunction edit() {\n  isEditing.value = true\n  inputValue.value = modelValue.value\n\n  emits('update:state', 'edit')\n}\n\nfunction submit() {\n  modelValue.value = inputValue.value\n  isEditing.value = false\n\n  emits('update:state', 'submit')\n  emits('submit', modelValue.value)\n}\n\nfunction handleDismiss() {\n  if (isEditing.value) {\n    if (submitMode.value === 'blur' || submitMode.value === 'both')\n      submit()\n    else\n      cancel()\n  }\n}\n\nconst pointerDownOutside = usePointerDownOutside(() => handleDismiss(), currentElement, isEditing)\nconst focusOutside = useFocusOutside(() => handleDismiss(), currentElement, isEditing)\n\nconst isEmpty = computed(() => modelValue.value === '')\n\ndefineExpose({\n  /** Function to submit the value of the editable */\n  submit,\n  /** Function to cancel the value of the editable */\n  cancel,\n  /** Function to set the editable in edit mode */\n  edit,\n})\n\nprovideEditableRootContext({\n  id,\n  name,\n  disabled,\n  isEditing,\n  maxLength,\n  modelValue,\n  inputValue,\n  placeholder,\n  edit,\n  cancel,\n  submit,\n  activationMode,\n  submitMode,\n  selectOnFocus,\n  inputRef,\n  startWithEditMode,\n  isEmpty,\n  readonly,\n  autoResize,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    ref=\"primitiveElement\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :dir=\"dir\"\n    data-dismissable-layer\n    @focus.capture=\"focusOutside.onFocusCapture\"\n    @blur.capture=\"focusOutside.onBlurCapture\"\n    @pointerdown.capture=\"pointerDownOutside.onPointerDownCapture\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :is-editing=\"isEditing\"\n      :is-empty=\"isEmpty\"\n      :submit=\"submit\"\n      :cancel=\"cancel\"\n      :edit=\"edit\"\n    />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name\"\n      type=\"text\"\n      :value=\"modelValue\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { injectEditableRootContext } from './EditableRoot.vue'\n\nexport interface EditableAreaProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<EditableAreaProps>(), { as: 'div' })\n\nconst context = injectEditableRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :data-placeholder-shown=\"context.isEditing.value ? undefined : ''\"\n    :data-focus=\"context.isEditing.value ? '' : undefined\"\n    :data-focused=\"context.isEditing.value ? '' : undefined\"\n    :data-empty=\"context.isEmpty.value ? '' : undefined\"\n    :data-readonly=\"context.readonly.value ? '' : undefined\"\n    :data-disabled=\"context.disabled.value ? '' : undefined\"\n    :style=\"context.autoResize.value ? { display: 'inline-grid' } : undefined\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface EditableCancelTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectEditableRootContext } from './EditableRoot.vue'\n\nconst props = withDefaults(defineProps<EditableCancelTriggerProps>(), { as: 'button' })\n\nconst context = injectEditableRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"cancel\"\n    :aria-disabled=\"context.disabled.value ? '' : undefined\"\n    :data-disabled=\"context.disabled.value ? '' : undefined\"\n    :disabled=\"context.disabled.value\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :hidden=\"context.isEditing.value ? undefined : ''\"\n    @click=\"context.cancel\"\n  >\n    <slot>Cancel</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface EditableEditTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectEditableRootContext } from './EditableRoot.vue'\n\nconst props = withDefaults(defineProps<EditableEditTriggerProps>(), { as: 'button' })\n\nconst context = injectEditableRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"edit\"\n    :aria-disabled=\"context.disabled.value ? '' : undefined\"\n    :data-disabled=\"context.disabled.value ? '' : undefined\"\n    :disabled=\"context.disabled.value\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :hidden=\"context.isEditing.value ? '' : undefined\"\n    @click=\"context.edit\"\n  >\n    <slot>Edit</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\n\nexport interface EditableInputProps extends PrimitiveProps {\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, nextTick, onMounted, watch } from 'vue'\nimport { useKbd } from '@/shared'\nimport { injectEditableRootContext } from './EditableRoot.vue'\n\nconst props = withDefaults(defineProps<EditableInputProps>(), {\n  as: 'input',\n})\n\nconst kbd = useKbd()\n\nconst context = injectEditableRootContext()\n\nconst disabled = computed(() => context.disabled.value)\n\nconst placeholder = computed(() => context.placeholder.value?.edit)\n\nconst { primitiveElement, currentElement: inputRef } = usePrimitiveElement()\n\nonMounted(() => {\n  context.inputRef.value = inputRef.value as HTMLInputElement\n  if (context.startWithEditMode.value) {\n    context.inputRef.value?.focus({ preventScroll: true })\n    if (context.selectOnFocus.value)\n      context.inputRef.value?.select()\n  }\n})\n\nwatch(context.isEditing, (value) => {\n  if (value) {\n    nextTick(() => {\n      context.inputRef.value?.focus({ preventScroll: true })\n      if (context.selectOnFocus.value)\n        context.inputRef.value?.select()\n    })\n  }\n})\n\nfunction handleSubmitKeyDown(event: KeyboardEvent) {\n  if ((context.submitMode.value === 'enter' || context.submitMode.value === 'both') && event.key === kbd.ENTER && !event.shiftKey && !event.metaKey)\n    context.submit()\n}\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    v-bind=\"props\"\n    :value=\"context.inputValue.value\"\n    :placeholder=\"placeholder\"\n    :disabled=\"disabled\"\n    :maxlength=\"context.maxLength.value\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-readonly=\"context.readonly.value ? '' : undefined\"\n    :readonly=\"context.readonly.value\"\n    aria-label=\"editable input\"\n    :hidden=\"context.autoResize.value ? undefined : !context.isEditing.value\"\n    :style=\"context.autoResize.value ? { all: 'unset', gridArea: '1 / 1 / auto / auto', visibility: !context.isEditing.value ? 'hidden' : undefined } : undefined\"\n    @input=\"context.inputValue.value = $event.target.value\"\n    @keydown.enter.space=\"handleSubmitKeyDown\"\n    @keydown.esc=\"context.cancel\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed } from 'vue'\nimport { injectEditableRootContext } from './EditableRoot.vue'\n\nexport interface EditablePreviewProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<EditablePreviewProps>(), { as: 'span' })\n\nconst context = injectEditableRootContext()\n\nconst placeholder = computed(() => context.placeholder.value?.preview)\n\nfunction handleFocus() {\n  if (context.activationMode.value === 'focus')\n    context.edit()\n}\nfunction handleDoubleClick() {\n  if (context.activationMode.value === 'dblclick')\n    context.edit()\n}\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    tabindex=\"0\"\n    :data-placeholder-shown=\"context.isEditing.value ? undefined : ''\"\n    :hidden=\"context.autoResize.value ? undefined : context.isEditing.value\"\n    :style=\"context.autoResize.value ? {\n      whiteSpace: 'pre',\n      userSelect: 'none',\n      gridArea: '1 / 1 / auto / auto',\n      visibility: context.isEditing.value ? 'hidden' : undefined,\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n    } : undefined\"\n    @focusin=\"handleFocus\"\n    @dblclick=\"handleDoubleClick\"\n  >\n    <slot>\n      {{ context.modelValue.value || placeholder }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface EditableSubmitTriggerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectEditableRootContext } from './EditableRoot.vue'\n\nconst props = withDefaults(defineProps<EditableSubmitTriggerProps>(), { as: 'button' })\n\nconst context = injectEditableRootContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"submit\"\n    :aria-disabled=\"context.disabled.value ? '' : undefined\"\n    :data-disabled=\"context.disabled.value ? '' : undefined\"\n    :disabled=\"context.disabled.value\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :hidden=\"context.isEditing.value ? undefined : ''\"\n    @click=\"context.submit\"\n  >\n    <slot>Submit</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperArrowProps } from '@/Popper'\nimport { useForwardExpose } from '@/shared'\n\nexport interface HoverCardArrowProps extends PopperArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperArrow } from '@/Popper'\n\nconst props = withDefaults(defineProps<HoverCardArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nuseForwardExpose()\n</script>\n\n<template>\n  <PopperArrow v-bind=\"props\">\n    <slot />\n  </PopperArrow>\n</template>\n", "export function excludeTouch(eventHandler: () => void) {\n  return (event: PointerEvent) => event.pointerType === 'touch' ? undefined : eventHandler()\n}\n\n/**\n * Returns a list of nodes that can be in the tab sequence.\n * @see: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n */\nexport function getTabbableNodes(container: HTMLElement) {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n  return nodes\n}\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface HoverCardRootProps {\n  /** The open state of the hover card when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n  /** The controlled open state of the hover card. Can be binded as `v-model:open`. */\n  open?: boolean\n  /** The duration from when the mouse enters the trigger until the hover card opens. */\n  openDelay?: number\n  /** The duration from when the mouse leaves the trigger or content until the hover card closes. */\n  closeDelay?: number\n}\nexport type HoverCardRootEmits = {\n  /** Event handler called when the open state of the hover card changes. */\n  'update:open': [value: boolean]\n}\n\nexport interface HoverCardRootContext {\n  open: Ref<boolean>\n  onOpenChange: (open: boolean) => void\n  onOpen: () => void\n  onClose: () => void\n  onDismiss: () => void\n  hasSelectionRef: Ref<boolean>\n  isPointerDownOnContentRef: Ref<boolean>\n  isPointerInTransitRef: Ref<boolean>\n  triggerElement: Ref<HTMLElement | undefined>\n}\n\nexport const [injectHoverCardRootContext, provideHoverCardRootContext]\n  = createContext<HoverCardRootContext>('HoverCardRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs } from 'vue'\nimport { PopperRoot } from '@/Popper'\n\nconst props = withDefaults(defineProps<HoverCardRootProps>(), {\n  defaultOpen: false,\n  open: undefined,\n  openDelay: 700,\n  closeDelay: 300,\n})\nconst emit = defineEmits<HoverCardRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nconst { openDelay, closeDelay } = toRefs(props)\n\nuseForwardExpose()\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst openTimerRef = ref(0)\nconst closeTimerRef = ref(0)\nconst hasSelectionRef = ref(false)\nconst isPointerDownOnContentRef = ref(false)\nconst isPointerInTransitRef = ref(false)\nconst triggerElement = ref<HTMLElement>()\n\nfunction handleOpen() {\n  clearTimeout(closeTimerRef.value)\n  openTimerRef.value = window.setTimeout(() => open.value = true, openDelay.value)\n}\n\nfunction handleClose() {\n  clearTimeout(openTimerRef.value)\n  if (!hasSelectionRef.value && !isPointerDownOnContentRef.value)\n    closeTimerRef.value = window.setTimeout(() => open.value = false, closeDelay.value)\n}\n\nfunction handleDismiss() {\n  open.value = false\n}\n\nprovideHoverCardRootContext({\n  open,\n  onOpenChange(value) {\n    open.value = value\n  },\n  onOpen: handleOpen,\n  onClose: handleClose,\n  onDismiss: handleDismiss,\n  hasSelectionRef,\n  isPointerDownOnContentRef,\n  isPointerInTransitRef,\n  triggerElement,\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <slot :open=\"open\" />\n  </PopperRoot>\n</template>\n", "import type { Ref } from 'vue'\nimport type { Side } from '@/Popper/utils'\nimport { createEventHook, refAutoReset } from '@vueuse/shared'\nimport { ref, watchEffect } from 'vue'\n\nexport function useGraceArea(triggerElement: Ref<HTMLElement | undefined>, containerElement: Ref<HTMLElement | undefined>) {\n// Reset the inTransit state if idle/scrolled.\n  const isPointerInTransit = refAutoReset(false, 300)\n\n  const pointerGraceArea = ref<Polygon | null>(null)\n  const pointerExit = createEventHook<void>()\n\n  function handleRemoveGraceArea() {\n    pointerGraceArea.value = null\n    isPointerInTransit.value = false\n  }\n\n  function handleCreateGraceArea(event: PointerEvent, hoverTarget: HTMLElement) {\n    const currentTarget = event.currentTarget as HTMLElement\n    const exitPoint = { x: event.clientX, y: event.clientY }\n    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect())\n    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide)\n    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect())\n    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints])\n    pointerGraceArea.value = graceArea\n    isPointerInTransit.value = true\n  }\n\n  watchEffect((cleanupFn) => {\n    if (triggerElement.value && containerElement.value) {\n      const handleTriggerLeave = (event: PointerEvent) => handleCreateGraceArea(event, containerElement.value!)\n      const handleContentLeave = (event: PointerEvent) => handleCreateGraceArea(event, triggerElement.value!)\n\n      triggerElement.value.addEventListener('pointerleave', handleTriggerLeave)\n      containerElement.value.addEventListener('pointerleave', handleContentLeave)\n\n      cleanupFn(() => {\n        triggerElement.value?.removeEventListener('pointerleave', handleTriggerLeave)\n        containerElement.value?.removeEventListener('pointerleave', handleContentLeave)\n      })\n    }\n  })\n\n  watchEffect((cleanupFn) => {\n    if (pointerGraceArea.value) {\n      const handleTrackPointerGrace = (event: PointerEvent) => {\n        if (!pointerGraceArea.value || !(event.target instanceof HTMLElement))\n          return\n\n        const target = event.target\n        const pointerPosition = { x: event.clientX, y: event.clientY }\n        const hasEnteredTarget = triggerElement.value?.contains(target) || containerElement.value?.contains(target)\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea.value)\n        const isAnotherGraceAreaTrigger = !!target.closest('[data-grace-area-trigger]')\n\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea()\n        }\n        else if (isPointerOutsideGraceArea || isAnotherGraceAreaTrigger) {\n          handleRemoveGraceArea()\n          pointerExit.trigger()\n        }\n      }\n      triggerElement.value?.ownerDocument.addEventListener('pointermove', handleTrackPointerGrace)\n\n      cleanupFn(() => triggerElement.value?.ownerDocument.removeEventListener('pointermove', handleTrackPointerGrace))\n    }\n  })\n\n  return {\n    isPointerInTransit,\n    onPointerExit: pointerExit.on,\n  }\n}\n\ninterface Point { x: number, y: number }\n  type Polygon = Point[]\n\nfunction getExitSideFromRect(point: Point, rect: DOMRect): Side {\n  const top = Math.abs(rect.top - point.y)\n  const bottom = Math.abs(rect.bottom - point.y)\n  const right = Math.abs(rect.right - point.x)\n  const left = Math.abs(rect.left - point.x)\n\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return 'left'\n    case right:\n      return 'right'\n    case top:\n      return 'top'\n    case bottom:\n      return 'bottom'\n    default:\n      throw new Error('unreachable')\n  }\n}\n\nfunction getPaddedExitPoints(exitPoint: Point, exitSide: Side, padding = 5) {\n  const paddedExitPoints: Point[] = []\n  switch (exitSide) {\n    case 'top':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y + padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding },\n      )\n      break\n    case 'bottom':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y - padding },\n      )\n      break\n    case 'left':\n      paddedExitPoints.push(\n        { x: exitPoint.x + padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding },\n      )\n      break\n    case 'right':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x - padding, y: exitPoint.y + padding },\n      )\n      break\n  }\n  return paddedExitPoints\n}\n\nfunction getPointsFromRect(rect: DOMRect) {\n  const { top, right, bottom, left } = rect\n  return [\n    { x: left, y: top },\n    { x: right, y: top },\n    { x: right, y: bottom },\n    { x: left, y: bottom },\n  ]\n}\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point\n  let inside = false\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n    if (intersect)\n      inside = !inside\n  }\n\n  return inside\n}\n\n// Returns a new array of points representing the convex hull of the given set of points.\n// https://www.nayuki.io/page/convex-hull-algorithm\nfunction getHull<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  const newPoints: Array<P> = points.slice()\n  newPoints.sort((a: Point, b: Point) => {\n    if (a.x < b.x)\n      return -1\n    else if (a.x > b.x)\n      return +1\n    else if (a.y < b.y)\n      return -1\n    else if (a.y > b.y)\n      return +1\n    else return 0\n  })\n  return getHullPresorted(newPoints)\n}\n\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nfunction getHullPresorted<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  if (points.length <= 1)\n    return points.slice()\n\n  const upperHull: Array<P> = []\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i]\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1]\n      const r = upperHull[upperHull.length - 2]\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n        upperHull.pop()\n      else break\n    }\n    upperHull.push(p)\n  }\n  upperHull.pop()\n\n  const lowerHull: Array<P> = []\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i]\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1]\n      const r = lowerHull[lowerHull.length - 2]\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n        lowerHull.pop()\n      else break\n    }\n    lowerHull.push(p)\n  }\n  lowerHull.pop()\n\n  if (\n    upperHull.length === 1\n    && lowerHull.length === 1\n    && upperHull[0].x === lowerHull[0].x\n    && upperHull[0].y === lowerHull[0].y\n  ) {\n    return upperHull\n  }\n\n  else {\n    return upperHull.concat(lowerHull)\n  }\n}\n", "<script lang=\"ts\">\nimport type { DismissableLayerEmits } from '@/DismissableLayer'\nimport type { PopperContentProps } from '@/Popper'\nimport { syncRef } from '@vueuse/shared'\nimport { useForwardExpose, useGraceArea } from '@/shared'\n\nexport type HoverCardContentImplEmits = DismissableLayerEmits\nexport interface HoverCardContentImplProps extends PopperContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, onMounted, onUnmounted, ref, watchEffect } from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { PopperContent } from '@/Popper'\nimport { useForwardProps } from '..'\nimport { injectHoverCardRootContext } from './HoverCardRoot.vue'\nimport { getTabbableNodes } from './utils'\n\nconst props = defineProps<HoverCardContentImplProps>()\nconst emits = defineEmits<HoverCardContentImplEmits>()\nconst forwarded = useForwardProps(props)\n\nconst { forwardRef, currentElement: contentElement } = useForwardExpose()\nconst rootContext = injectHoverCardRootContext()\nconst { isPointerInTransit, onPointerExit } = useGraceArea(rootContext.triggerElement, contentElement)\n\nsyncRef(rootContext.isPointerInTransitRef, isPointerInTransit, { direction: 'rtl' })\n\nonPointerExit(() => {\n  rootContext.onClose()\n})\n\nconst containSelection = ref(false)\n\nlet originalBodyUserSelect: string\nwatchEffect((cleanupFn) => {\n  if (containSelection.value) {\n    const body = document.body\n\n    // Safari requires prefix\n    originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect\n\n    body.style.userSelect = 'none'\n    body.style.webkitUserSelect = 'none'\n\n    cleanupFn(() => {\n      body.style.userSelect = originalBodyUserSelect\n      body.style.webkitUserSelect = originalBodyUserSelect\n    })\n  }\n})\n\nfunction handlePointerUp() {\n  containSelection.value = false\n  rootContext.isPointerDownOnContentRef.value = false\n\n  // Delay a frame to ensure we always access the latest selection\n  nextTick(() => {\n    const hasSelection = document.getSelection()?.toString() !== ''\n    if (hasSelection)\n      rootContext.hasSelectionRef.value = true\n  })\n}\nonMounted(() => {\n  if (contentElement.value) {\n    document.addEventListener('pointerup', handlePointerUp)\n\n    const tabbables = getTabbableNodes(contentElement.value)\n    tabbables.forEach(tabbable => tabbable.setAttribute('tabindex', '-1'))\n  }\n})\n\nonUnmounted(() => {\n  document.removeEventListener('pointerup', handlePointerUp)\n  rootContext.hasSelectionRef.value = false\n  rootContext.isPointerDownOnContentRef.value = false\n})\n</script>\n\n<template>\n  <DismissableLayer\n    as-child\n    :disable-outside-pointer-events=\"false\"\n    @escape-key-down=\"emits('escapeKeyDown', $event)\"\n    @pointer-down-outside=\"emits('pointerDownOutside', $event)\"\n    @focus-outside.prevent=\"emits('focusOutside', $event)\"\n    @dismiss=\"rootContext.onDismiss\"\n  >\n    <PopperContent\n      v-bind=\"{ ...forwarded, ...$attrs }\"\n      :ref=\"forwardRef\"\n      :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n      :style=\"{\n        'userSelect': containSelection ? 'text' : undefined,\n        // Safari requires prefix\n        'WebkitUserSelect': containSelection ? 'text' : undefined,\n        // re-namespace exposed content custom properties\n        '--reka-hover-card-content-transform-origin': 'var(--reka-popper-transform-origin)',\n        '--reka-hover-card-content-available-width': 'var(--reka-popper-available-width)',\n        '--reka-hover-card-content-available-height': 'var(--reka-popper-available-height)',\n        '--reka-hover-card-trigger-width': 'var(--reka-popper-anchor-width)',\n        '--reka-hover-card-trigger-height': 'var(--reka-popper-anchor-height)',\n      }\"\n      @pointerdown=\"(event: PointerEvent) => {\n        // Contain selection to current layer\n        if ((event.currentTarget as HTMLElement).contains(event.target as HTMLElement)) {\n          containSelection = true\n        }\n        rootContext.hasSelectionRef.value = false;\n        rootContext.isPointerDownOnContentRef.value = true;\n      }\"\n    >\n      <slot />\n    </PopperContent>\n  </DismissableLayer>\n</template>\n", "<script lang=\"ts\">\nimport type { HoverCardContentImplEmits, HoverCardContentImplProps } from './HoverCardContentImpl.vue'\n\nexport type HoverCardContentEmits = HoverCardContentImplEmits\n\nexport interface HoverCardContentProps extends HoverCardContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\nimport HoverCardContentImpl from './HoverCardContentImpl.vue'\nimport { injectHoverCardRootContext } from './HoverCardRoot.vue'\nimport { excludeTouch } from './utils'\n\nconst props = defineProps<HoverCardContentProps>()\nconst emits = defineEmits<HoverCardContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nconst { forwardRef } = useForwardExpose()\n\nconst rootContext = injectHoverCardRootContext()\n</script>\n\n<template>\n  <Presence\n    :present=\"forceMount || rootContext.open.value\"\n  >\n    <HoverCardContentImpl\n      v-bind=\"forwarded\"\n      :ref=\"forwardRef\"\n      @pointerenter=\"excludeTouch(rootContext.onOpen)($event)\"\n    >\n      <slot />\n    </HoverCardContentImpl>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface HoverCardPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<HoverCardPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script lang=\"ts\">\nexport interface HoverCardTriggerProps extends PopperAnchorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport type { PopperAnchorProps } from '@/Popper'\nimport { PopperAnchor } from '@/Popper'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectHoverCardRootContext } from './HoverCardRoot.vue'\nimport { excludeTouch } from './utils'\n\nwithDefaults(defineProps<HoverCardTriggerProps>(), {\n  as: 'a',\n})\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst rootContext = injectHoverCardRootContext()\nrootContext.triggerElement = currentElement\n\nfunction handleLeave() {\n  setTimeout(() => {\n    if (!rootContext.isPointerInTransitRef.value && !rootContext.open.value) {\n      rootContext.onClose()\n    }\n  }, 0)\n}\n</script>\n\n<template>\n  <PopperAnchor\n    as-child\n    :reference=\"reference\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n      data-grace-area-trigger\n      @pointerenter=\"excludeTouch(rootContext.onOpen)($event)\"\n      @pointerleave=\"excludeTouch(handleLeave)($event)\"\n      @focus=\"rootContext.onOpen()\"\n      @blur=\"rootContext.onClose()\"\n    >\n      <slot />\n    </Primitive>\n  </PopperAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface LabelProps extends PrimitiveProps {\n  /** The id of the element the label is associated with. */\n  for?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<LabelProps>(), {\n  as: 'label',\n})\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    @mousedown=\"(event) => {\n      // prevent text selection when double clicking label\n      if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n    }\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface ListboxGroupLabelProps extends PrimitiveProps {\n  for?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectListboxGroupContext } from './ListboxGroup.vue'\n\nconst props = withDefaults(defineProps<ListboxGroupLabelProps>(), {\n  as: 'div',\n})\n\nconst groupContext = injectListboxGroupContext({ id: '' })\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"groupContext.id\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuArrowProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface MenubarArrowProps extends MenuArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuArrow } from '@/Menu'\n\nconst props = withDefaults(defineProps<MenubarArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuArrow v-bind=\"props\">\n    <slot />\n  </MenuArrow>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuCheckboxItemEmits,\n  MenuCheckboxItemProps,\n} from '@/Menu'\n\nexport type MenubarCheckboxItemEmits = MenuCheckboxItemEmits\n\nexport interface MenubarCheckboxItemProps extends MenuCheckboxItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuCheckboxItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<MenubarCheckboxItemProps>()\nconst emits = defineEmits<MenubarCheckboxItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuCheckboxItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuCheckboxItem>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Direction } from '../shared/types'\nimport { useCollection } from '@/Collection'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\nexport interface MenubarRootProps {\n  /** The controlled value of the menu to open. Can be used as `v-model`. */\n  modelValue?: string\n  /** The value of the menu that should be open when initially rendered. Use when you do not need to control the value state. */\n  defaultValue?: string\n  /**\n   * The reading direction of the combobox when applicable.\n   *\n   *  If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode.\n   */\n  dir?: Direction\n  /** When `true`, keyboard navigation will loop from last item to first, and vice versa. */\n  loop?: boolean\n}\nexport type MenubarRootEmits = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [value: boolean]\n}\n\nexport interface MenubarRootContext {\n  modelValue: Ref<string>\n  dir: Ref<Direction>\n  loop: Ref<boolean>\n  onMenuOpen: (value: string) => void\n  onMenuClose: () => void\n  onMenuToggle: (value: string) => void\n}\n\nexport const [injectMenubarRootContext, provideMenubarRootContext]\n  = createContext<MenubarRootContext>('MenubarRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusGroup } from '@/RovingFocus'\n\nconst props = withDefaults(defineProps<MenubarRootProps>(), {\n  loop: false,\n})\nconst emit = defineEmits<MenubarRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { forwardRef } = useForwardExpose()\nconst { CollectionSlot } = useCollection({ key: 'Menubar', isProvider: true })\n\nconst modelValue = useVModel(props, 'modelValue', emit, {\n  defaultValue: props.defaultValue ?? '',\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<string>\n\nconst currentTabStopId = ref<string | null>(null)\n\nconst { dir: propDir, loop } = toRefs(props)\nconst dir = useDirection(propDir)\nprovideMenubarRootContext({\n  modelValue,\n  dir,\n  loop,\n  onMenuOpen: (value) => {\n    modelValue.value = value\n    currentTabStopId.value = value\n  },\n  onMenuClose: () => {\n    modelValue.value = ''\n  },\n  onMenuToggle: (value) => {\n    modelValue.value = modelValue.value ? '' : value\n    // `openMenuOpen` and `onMenuToggle` are called exclusively so we\n    // need to update the id in either case.\n    currentTabStopId.value = value\n  },\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <RovingFocusGroup\n      v-model:current-tab-stop-id=\"currentTabStopId\"\n      orientation=\"horizontal\"\n      :loop=\"loop\"\n      :dir=\"dir\"\n      as-child\n    >\n      <Primitive\n        :ref=\"forwardRef\"\n        role=\"menubar\"\n      >\n        <slot :model-value=\"modelValue\" />\n      </Primitive>\n    </RovingFocusGroup>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { createContext, useForwardExpose, useId } from '@/shared'\n\nexport interface MenubarMenuProps {\n  /**\n   * A unique value that associates the item with an active value when the navigation menu is controlled.\n   *\n   * This prop is managed automatically when uncontrolled.\n   */\n  value?: string\n}\n\ntype MenubarMenuContext = {\n  value: string\n  triggerId: string\n  triggerElement: Ref<HTMLElement | undefined>\n  contentId: string\n  wasKeyboardTriggerOpenRef: Ref<boolean>\n}\n\nexport const [injectMenubarMenuContext, provideMenubarMenuContext]\n  = createContext<MenubarMenuContext>('MenubarMenu')\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, ref, watch } from 'vue'\nimport { MenuRoot } from '@/Menu'\nimport { injectMenubarRootContext } from './MenubarRoot.vue'\n\nconst props = defineProps<MenubarMenuProps>()\n\nconst value = useId(props.value)\nconst rootContext = injectMenubarRootContext()\nuseForwardExpose()\n\nconst triggerElement = ref<HTMLElement>()\nconst wasKeyboardTriggerOpenRef = ref(false)\n\nconst open = computed(() => rootContext.modelValue.value === value)\n\nwatch(open, () => {\n  if (!open.value)\n    wasKeyboardTriggerOpenRef.value = false\n})\n\nprovideMenubarMenuContext({\n  value,\n  triggerElement,\n  triggerId: value,\n  contentId: '',\n  wasKeyboardTriggerOpenRef,\n})\n</script>\n\n<template>\n  <MenuRoot\n    :open=\"open\"\n    :modal=\"false\"\n    :dir=\"rootContext.dir.value\"\n    @update:open=\"\n      (value) => {\n        // Menu only calls `@update:open` when dismissing so we\n        // want to close our MenuBar based on the same events.\n        if (!value) rootContext.onMenuClose();\n      }\n    \"\n  >\n    <slot />\n  </MenuRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuContentEmits, MenuContentProps } from '@/Menu'\nimport { useCollection } from '@/Collection'\n\nexport type MenubarContentEmits = MenuContentEmits\n\nexport interface MenubarContentProps extends MenuContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { MenuContent } from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits, useId } from '@/shared'\nimport { wrapArray } from '@/shared/useTypeahead'\nimport { injectMenubarMenuContext } from './MenubarMenu.vue'\nimport { injectMenubarRootContext } from './MenubarRoot.vue'\n\nconst props = withDefaults(defineProps<MenubarContentProps>(), {\n  align: 'start',\n})\nconst emits = defineEmits<MenubarContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n\nconst rootContext = injectMenubarRootContext()\nconst menuContext = injectMenubarMenuContext()\n\nmenuContext.contentId ||= useId(undefined, 'reka-menubar-content')\n\nconst { getItems } = useCollection({ key: 'Menubar' })\n\nconst hasInteractedOutsideRef = ref(false)\n\nfunction handleArrowNavigation(event: KeyboardEvent) {\n  const target = event.target as HTMLElement\n  const targetIsSubTrigger = target.hasAttribute(\n    'data-reka-menubar-subtrigger',\n  )\n\n  const prevMenuKey = rootContext.dir.value === 'rtl' ? 'ArrowRight' : 'ArrowLeft'\n  const isPrevKey = prevMenuKey === event.key\n  const isNextKey = !isPrevKey\n\n  // Prevent navigation when we're opening a submenu\n  if (isNextKey && targetIsSubTrigger)\n    return\n\n  let candidateValues = getItems().filter(i => i.ref.dataset.disabled !== '').map(i => i.ref.dataset.value)\n  if (isPrevKey)\n    candidateValues.reverse()\n\n  const currentIndex = candidateValues.indexOf(menuContext.value)\n\n  candidateValues = rootContext.loop.value\n    ? wrapArray(candidateValues, currentIndex + 1)\n    : candidateValues.slice(currentIndex + 1)\n\n  const [nextValue] = candidateValues\n  if (nextValue)\n    rootContext.onMenuOpen(nextValue)\n}\n</script>\n\n<template>\n  <MenuContent\n    v-bind=\"forwarded\"\n    :id=\"menuContext.contentId\"\n    data-reka-menubar-content=\"\"\n    :aria-labelledby=\"menuContext.triggerId\"\n    :style=\"{\n      '--reka-menubar-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-menubar-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-menubar-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-menubar-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-menubar-trigger-height': 'var(--reka-popper-anchor-height)',\n    }\"\n    @close-auto-focus=\"(event) => {\n      const menubarOpen = Boolean(rootContext.modelValue.value);\n      if (!menubarOpen && !hasInteractedOutsideRef) {\n        menuContext.triggerElement.value?.focus();\n      }\n\n      hasInteractedOutsideRef = false;\n      // Always prevent auto focus because we either focus manually or want user agent focus\n      event.preventDefault();\n    }\"\n    @focus-outside=\"(event) => {\n      const target = event.target as HTMLElement;\n      const isMenubarTrigger = getItems().filter(i => i.ref.dataset.disabled !== '').some((i) => i.ref.contains(target));\n      if (isMenubarTrigger) event.preventDefault();\n    }\"\n    @interact-outside=\"\n      (event) => {\n        hasInteractedOutsideRef = true;\n      }\n    \"\n    @entry-focus=\"(event) => {\n      if (!menuContext.wasKeyboardTriggerOpenRef.value) event.preventDefault()\n    }\"\n    @keydown.arrow-right.arrow-left=\"handleArrowNavigation\"\n  >\n    <slot />\n  </MenuContent>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuGroupProps } from '@/Menu'\n\nexport interface MenubarGroupProps extends MenuGroupProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuGroup } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = defineProps<MenubarGroupProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuGroup v-bind=\"props\">\n    <slot />\n  </MenuGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemEmits, MenuItemProps } from '@/Menu'\n\nexport type MenubarItemEmits = MenuItemEmits\n\nexport interface MenubarItemProps extends MenuItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuItem } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<MenubarItemProps>()\nconst emits = defineEmits<MenubarItemEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuItem v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuItem>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuItemIndicatorProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface MenubarItemIndicatorProps extends MenuItemIndicatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuItemIndicator } from '@/Menu'\n\nconst props = defineProps<MenubarItemIndicatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuItemIndicator v-bind=\"props\">\n    <slot />\n  </MenuItemIndicator>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuLabelProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface MenubarLabelProps extends MenuLabelProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuLabel } from '@/Menu'\n\nconst props = defineProps<MenubarLabelProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuLabel v-bind=\"props\">\n    <slot />\n  </MenuLabel>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuPortalProps } from '@/Menu'\n\nexport interface MenubarPortalProps extends MenuPortalProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuPortal } from '@/Menu'\n\nconst props = defineProps<MenubarPortalProps>()\n</script>\n\n<template>\n  <MenuPortal v-bind=\"props\">\n    <slot />\n  </MenuPortal>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuRadioGroupEmits,\n  MenuRadioGroupProps,\n} from '@/Menu'\n\nexport type MenubarRadioGroupEmits = MenuRadioGroupEmits\n\nexport interface MenubarRadioGroupProps extends MenuRadioGroupProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuRadioGroup } from '@/Menu'\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\n\nconst props = defineProps<MenubarRadioGroupProps>()\nconst emits = defineEmits<MenubarRadioGroupEmits>()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuRadioGroup v-bind=\"{ ...props, ...emitsAsProps }\">\n    <slot />\n  </MenuRadioGroup>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuRadioItemEmits,\n  MenuRadioItemProps,\n} from '@/Menu'\n\nexport type MenubarRadioItemEmits = MenuRadioItemEmits\n\nexport interface MenubarRadioItemProps extends MenuRadioItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuRadioItem } from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\n\nconst props = defineProps<MenuRadioItemProps>()\nconst emits = defineEmits<MenuRadioItemEmits>()\n\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuRadioItem v-bind=\"forwarded\">\n    <slot />\n  </MenuRadioItem>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuSeparatorProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface MenubarSeparatorProps extends MenuSeparatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSeparator } from '@/Menu'\n\nconst props = defineProps<MenubarSeparatorProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSeparator v-bind=\"props\">\n    <slot />\n  </MenuSeparator>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { MenuSubEmits, MenuSubProps } from '@/Menu'\n\nexport type MenubarSubEmits = MenuSubEmits\nexport interface MenubarSubProps extends MenuSubProps {\n  /** The open state of the submenu when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { MenuSub } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nconst props = withDefaults(defineProps<MenubarSubProps>(), {\n  open: undefined,\n})\nconst emit = defineEmits<MenubarSubEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nuseForwardExpose()\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen ?? false,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n</script>\n\n<template>\n  <MenuSub v-model:open=\"open\">\n    <slot :open=\"open\" />\n  </MenuSub>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  MenuSubContentEmits,\n  MenuSubContentProps,\n} from '@/Menu'\nimport { useCollection } from '@/Collection'\n\nexport type MenubarSubContentEmits = MenuSubContentEmits\n\nexport interface MenubarSubContentProps extends MenuSubContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSubContent } from '@/Menu'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\nimport { wrapArray } from '@/shared/useTypeahead'\nimport { injectMenubarMenuContext } from './MenubarMenu.vue'\nimport { injectMenubarRootContext } from './MenubarRoot.vue'\n\nconst props = defineProps<MenubarSubContentProps>()\nconst emits = defineEmits<MenubarSubContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\nuseForwardExpose()\n\nconst { getItems } = useCollection({ key: 'Menubar' })\n\nconst rootContext = injectMenubarRootContext()\nconst menuContext = injectMenubarMenuContext()\n\nfunction handleArrowNavigation(event: KeyboardEvent) {\n  const target = event.target as HTMLElement\n  const targetIsSubTrigger = target.hasAttribute(\n    'data-reka-menubar-subtrigger',\n  )\n\n  // Prevent navigation when we're opening a submenu\n  if (targetIsSubTrigger)\n    return\n\n  let candidateValues = getItems().filter(i => i.ref.dataset.disabled !== '').map(i => i.ref.dataset.value)\n  const currentIndex = candidateValues.indexOf(menuContext.value)\n\n  candidateValues = rootContext.loop.value\n    ? wrapArray(candidateValues, currentIndex + 1)\n    : candidateValues.slice(currentIndex + 1)\n\n  const [nextValue] = candidateValues\n  if (nextValue)\n    rootContext.onMenuOpen(nextValue)\n}\n</script>\n\n<template>\n  <MenuSubContent\n    v-bind=\"forwarded\"\n    data-reka-menubar-content=\"\"\n    :style=\"{\n      '--reka-menubar-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-menubar-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-menubar-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-menubar-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-menubar-trigger-height': 'var(--reka-popper-anchor-height)',\n    }\"\n    @keydown.arrow-right=\"handleArrowNavigation\"\n  >\n    <slot />\n  </MenuSubContent>\n</template>\n", "<script lang=\"ts\">\nimport type { MenuSubTriggerProps } from '@/Menu'\nimport { useForwardExpose } from '@/shared'\n\nexport interface MenubarSubTriggerProps extends MenuSubTriggerProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { MenuSubTrigger } from '@/Menu'\n\nconst props = defineProps<MenubarSubTriggerProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <MenuSubTrigger\n    v-bind=\"props\"\n    data-reka-menubar-subtrigger=\"\"\n  >\n    <slot />\n  </MenuSubTrigger>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { useForwardExpose } from '@/shared'\n\nexport interface MenubarTriggerProps extends PrimitiveProps {\n  /** When `true`, prevents the user from interacting with item */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, ref } from 'vue'\nimport { MenuAnchor } from '@/Menu'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\nimport { injectMenubarMenuContext } from './MenubarMenu.vue'\nimport { injectMenubarRootContext } from './MenubarRoot.vue'\n\nwithDefaults(defineProps<MenubarTriggerProps>(), {\n  as: 'button',\n})\nconst rootContext = injectMenubarRootContext()\nconst menuContext = injectMenubarMenuContext()\n\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\nconst { CollectionItem } = useCollection({ key: 'Menubar' })\n\nconst isFocused = ref(false)\n\nconst open = computed(() => rootContext.modelValue.value === menuContext.value)\n\nonMounted(() => {\n  menuContext.triggerElement = triggerElement\n})\n</script>\n\n<template>\n  <RovingFocusItem\n    as-child\n    :focusable=\"!disabled\"\n    :tab-stop-id=\"menuContext.value\"\n  >\n    <CollectionItem>\n      <MenuAnchor as-child>\n        <Primitive\n          :id=\"menuContext.triggerId\"\n          :ref=\"forwardRef\"\n          :as=\"as\"\n          :type=\"as === 'button' ? 'button' : undefined\"\n          role=\"menuitem\"\n          aria-haspopup=\"menu\"\n          :aria-expanded=\"open\"\n          :aria-controls=\"open ? menuContext.contentId : undefined\"\n          :data-highlighted=\"isFocused ? '' : undefined\"\n          :data-state=\"open ? 'open' : 'closed'\"\n          :data-disabled=\"disabled ? '' : undefined\"\n          :disabled=\"disabled\"\n          :data-value=\"menuContext.value\"\n          @pointerdown=\"(event) => {\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click)\n            if (!disabled && event.button === 0 && event.ctrlKey === false) {\n              rootContext.onMenuOpen(menuContext.value);\n              // prevent trigger focusing when opening\n              // this allows the content to be given focus without competition\n              if (!open) event.preventDefault();\n            }\n          }\"\n          @pointerenter=\"() => {\n            const menubarOpen = Boolean(rootContext.modelValue.value);\n            if (menubarOpen && !open) {\n              rootContext.onMenuOpen(menuContext.value);\n              triggerElement?.focus()\n            }\n          }\"\n          @keydown.enter.space.arrow-down=\"(event) => {\n            if (disabled) return;\n            if (['Enter', ' '].includes(event.key)) rootContext.onMenuToggle(menuContext.value);\n            if (event.key === 'ArrowDown') rootContext.onMenuOpen(menuContext.value);\n            // prevent keydown from scrolling window / first focused item to execute\n            // that keydown (inadvertently closing the menu)\n            if (['Enter', ' ', 'ArrowDown'].includes(event.key)) {\n              menuContext.wasKeyboardTriggerOpenRef.value = true;\n              event.preventDefault();\n            }\n          }\"\n          @focus=\"isFocused = true\"\n          @blur=\"isFocused = false\"\n        >\n          <slot />\n        </Primitive>\n      </MenuAnchor>\n    </CollectionItem>\n  </RovingFocusItem>\n</template>\n", "import { getActiveElement } from '@/shared'\n\nexport type Orientation = 'vertical' | 'horizontal'\nexport type Direction = 'ltr' | 'rtl'\n\nexport function getOpenState(open: boolean) {\n  return open ? 'open' : 'closed'\n}\n\nexport function makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`\n}\n\nexport function makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`\n}\n\nexport const LINK_SELECT = 'navigationMenu.linkSelect'\nexport const EVENT_ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss'\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nexport function getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes\n}\n\nexport function focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = getActiveElement()\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement)\n      return true\n    candidate.focus()\n    return getActiveElement() !== previouslyFocusedElement\n  })\n}\n\nexport function removeFromTabOrder(candidates: HTMLElement[]) {\n  candidates.forEach((candidate) => {\n    candidate.dataset.tabindex = candidate.getAttribute('tabindex') || ''\n    candidate.setAttribute('tabindex', '-1')\n  })\n  return () => {\n    candidates.forEach((candidate) => {\n      const prevTabIndex = candidate.dataset.tabindex as string\n      candidate.setAttribute('tabindex', prevTabIndex)\n    })\n  }\n}\n\nexport function whenMouse<E extends PointerEvent>(handler: (event?: E) => void) {\n  return (event: E) => (event.pointerType === 'mouse' ? handler(event) : undefined)\n}\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\n\nimport type { Direction, Orientation } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { createContext, useDirection, useForwardExpose, useId } from '@/shared'\n\nexport interface NavigationMenuRootProps extends PrimitiveProps {\n  /** The controlled value of the menu item to activate. Can be used as `v-model`. */\n  modelValue?: string\n  /**\n   * The value of the menu item that should be active when initially rendered.\n   *\n   * Use when you do not need to control the value state.\n   */\n  defaultValue?: string\n  /**\n   * The reading direction of the combobox when applicable.\n   *\n   *  If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode.\n   */\n  dir?: Direction\n  /** The orientation of the menu. */\n  orientation?: Orientation\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 200\n   */\n  delayDuration?: number\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number\n\n  /**\n   * If `true`, menu cannot be open by click on trigger\n   * @defaultValue false\n   */\n  disableClickTrigger?: boolean\n  /**\n   * If `true`, menu cannot be open by hover on trigger\n   * @defaultValue false\n   */\n  disableHoverTrigger?: boolean\n  /**\n   * If `true`, menu will not close during pointer leave event\n   * @defaultValue false\n   */\n  disablePointerLeaveClose?: boolean\n\n  /**\n   * When `true`, the element will be unmounted on closed state.\n   *\n   * @defaultValue `true`\n   */\n  unmountOnHide?: boolean\n}\nexport type NavigationMenuRootEmits = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [value: string]\n}\n\nexport interface NavigationMenuContext {\n  isRootMenu: boolean\n  modelValue: Ref<string>\n  previousValue: Ref<string>\n  baseId: string\n  dir: Ref<Direction>\n  orientation: Orientation\n  disableClickTrigger: Ref<boolean>\n  disableHoverTrigger: Ref<boolean>\n  unmountOnHide: Ref<boolean>\n  rootNavigationMenu: Ref<HTMLElement | undefined>\n  activeTrigger: Ref<HTMLElement | undefined>\n  indicatorTrack: Ref<HTMLElement | undefined>\n  onIndicatorTrackChange: (indicatorTrack: HTMLElement | undefined) => void\n  viewport: Ref<HTMLElement | undefined>\n  onViewportChange: (viewport: HTMLElement | undefined) => void\n  onTriggerEnter: (itemValue: string) => void\n  onTriggerLeave: () => void\n  onContentEnter: (itemValue: string) => void\n  onContentLeave: () => void\n  onItemSelect: (itemValue: string) => void\n  onItemDismiss: () => void\n}\n\nexport const [injectNavigationMenuContext, provideNavigationMenuContext]\n  = createContext<NavigationMenuContext>(['NavigationMenuRoot', 'NavigationMenuSub'], 'NavigationMenuContext')\n</script>\n\n<script setup lang=\"ts\">\nimport { refAutoReset, useDebounceFn, useVModel } from '@vueuse/core'\nimport {\n  computed,\n  ref,\n  toRefs,\n  watchEffect,\n} from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\n\nconst props = withDefaults(defineProps<NavigationMenuRootProps>(), {\n  modelValue: undefined,\n  delayDuration: 200,\n  skipDelayDuration: 300,\n  orientation: 'horizontal',\n  disableClickTrigger: false,\n  disableHoverTrigger: false,\n  unmountOnHide: true,\n  as: 'nav',\n})\nconst emits = defineEmits<NavigationMenuRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? '',\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<string>\nconst previousValue = ref('')\n\nconst { forwardRef, currentElement: rootNavigationMenu } = useForwardExpose()\n\nconst indicatorTrack = ref<HTMLElement>()\nconst viewport = ref<HTMLElement>()\nconst activeTrigger = ref<HTMLElement>()\n\nconst { getItems, CollectionSlot } = useCollection({ key: 'NavigationMenu', isProvider: true })\n\nconst { delayDuration, skipDelayDuration, dir: propDir, disableClickTrigger, disableHoverTrigger, unmountOnHide } = toRefs(props)\nconst dir = useDirection(propDir)\n\nconst isDelaySkipped = refAutoReset(false, skipDelayDuration)\nconst computedDelay = computed(() => {\n  const isOpen = modelValue.value !== ''\n  if (isOpen || isDelaySkipped.value)\n    return 150 // 150ms for user to switch trigger or move into content view\n  else return delayDuration.value\n})\n\nconst debouncedFn = useDebounceFn((val?: string) => {\n  // passing `undefined` meant to reset the debounce timer\n  if (typeof val === 'string') {\n    previousValue.value = modelValue.value\n    modelValue.value = val\n  }\n}, computedDelay)\n\nwatchEffect(() => {\n  if (!modelValue.value)\n    return\n\n  const items = getItems().map(i => i.ref)\n  activeTrigger.value = items.find(item =>\n    item.id.includes(modelValue.value),\n  )\n})\n\nprovideNavigationMenuContext({\n  isRootMenu: true,\n  modelValue,\n  previousValue,\n  baseId: useId(undefined, 'reka-navigation-menu'),\n  disableClickTrigger,\n  disableHoverTrigger,\n  dir,\n  unmountOnHide,\n  orientation: props.orientation,\n  rootNavigationMenu,\n  indicatorTrack,\n  activeTrigger,\n  onIndicatorTrackChange: (val) => {\n    indicatorTrack.value = val\n  },\n  viewport,\n  onViewportChange: (val) => {\n    viewport.value = val\n  },\n  onTriggerEnter: (val) => {\n    debouncedFn(val)\n  },\n  onTriggerLeave: () => {\n    isDelaySkipped.value = true\n    debouncedFn('')\n  },\n  onContentEnter: () => {\n    debouncedFn()\n  },\n  onContentLeave: () => {\n    if (!props.disablePointerLeaveClose)\n      debouncedFn('')\n  },\n  onItemSelect: (val) => {\n    // When selecting item we trigger update immediately\n    previousValue.value = modelValue.value\n    modelValue.value = val\n  },\n  onItemDismiss: () => {\n    previousValue.value = modelValue.value\n    modelValue.value = ''\n  },\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <Primitive\n      :ref=\"forwardRef\"\n      aria-label=\"Main\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :data-orientation=\"orientation\"\n      :dir=\"dir\"\n      data-reka-navigation-menu\n    >\n      <slot :model-value=\"modelValue\" />\n    </Primitive>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { createContext, getActiveElement, useArrowNavigation, useForwardExpose, useId } from '@/shared'\n\nexport interface NavigationMenuItemProps extends PrimitiveProps {\n  /**\n   * A unique value that associates the item with an active value when the navigation menu is controlled.\n   *\n   *  This prop is managed automatically when uncontrolled.\n   */\n  value?: string\n}\n\nexport type NavigationMenuItemContext = {\n  value: string\n  contentId: string\n  triggerRef: Ref<HTMLElement | undefined>\n  focusProxyRef: Ref<HTMLElement | undefined>\n  wasEscapeCloseRef: Ref<boolean>\n  onEntryKeyDown: () => void\n  onFocusProxyEnter: (side: 'start' | 'end') => void\n  onContentFocusOutside: () => void\n  onRootContentClose: () => void\n}\n\nexport const [injectNavigationMenuItemContext, provideNavigationMenuItemContext]\n  = createContext<NavigationMenuItemContext>('NavigationMenuItem')\n</script>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\nimport {\n  focusFirst,\n  getTabbableCandidates,\n  makeContentId,\n  removeFromTabOrder,\n} from './utils'\n\nconst props = withDefaults(defineProps<NavigationMenuItemProps>(), {\n  as: 'li',\n})\n\nuseForwardExpose()\nconst { getItems } = useCollection({ key: 'NavigationMenu' })\n\nconst context = injectNavigationMenuContext()\n\nconst value = useId(props.value)\nconst triggerRef = ref<HTMLElement>()\nconst focusProxyRef = ref<HTMLElement>()\n\nconst contentId = makeContentId(context.baseId, value)\n\nlet restoreContentTabOrderRef: () => void = () => ({})\n\nconst wasEscapeCloseRef = ref(false)\nasync function handleContentEntry(side = 'start') {\n  const el = document.getElementById(contentId)\n  if (el) {\n    restoreContentTabOrderRef()\n    const candidates = getTabbableCandidates(el)\n    if (candidates.length)\n      focusFirst(side === 'start' ? candidates : candidates.reverse())\n  }\n}\n\nfunction handleContentExit() {\n  const el = document.getElementById(contentId)\n  if (el) {\n    const candidates = getTabbableCandidates(el)\n    if (candidates.length)\n      restoreContentTabOrderRef = removeFromTabOrder(candidates)\n  }\n}\n\nprovideNavigationMenuItemContext({\n  value,\n  contentId,\n  triggerRef,\n  focusProxyRef,\n  wasEscapeCloseRef,\n  onEntryKeyDown: handleContentEntry,\n  onFocusProxyEnter: handleContentEntry,\n  onContentFocusOutside: handleContentExit,\n  onRootContentClose: handleContentExit,\n})\n\nfunction handleClose() {\n  context.onItemDismiss()\n  triggerRef.value?.focus()\n}\n\nfunction handleKeydown(ev: KeyboardEvent) {\n  const currentFocus = getActiveElement() as HTMLElement\n  if (ev.keyCode === 32 || ev.key === 'Enter') {\n    if (context.modelValue.value === value) {\n      handleClose()\n      ev.preventDefault()\n      return\n    }\n    else {\n      (ev.target as HTMLElement).click()\n      ev.preventDefault()\n      return\n    }\n  }\n\n  const itemsArray = getItems().filter(i =>\n    i.ref.parentElement?.hasAttribute('data-menu-item'),\n  ).map(i => i.ref)\n\n  // prevent triggering when the focus is on link\n  if (!itemsArray.includes(currentFocus))\n    return\n\n  const newSelectedElement = useArrowNavigation(ev, currentFocus, undefined, {\n    itemsArray,\n    loop: false,\n  })\n\n  if (newSelectedElement)\n    newSelectedElement?.focus()\n\n  ev.preventDefault()\n  ev.stopPropagation()\n}\n</script>\n\n<template>\n  <Primitive\n    :as-child=\"asChild\"\n    :as=\"as\"\n    data-menu-item\n    @keydown.up.down.left.right.home.end.space=\"handleKeydown\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  DismissableLayerEmits,\n  DismissableLayerProps,\n  FocusOutsideEvent,\n} from '@/DismissableLayer'\nimport type { PointerDownOutsideEvent } from '@/DismissableLayer/utils'\nimport { useCollection } from '@/Collection'\n\ntype MotionAttribute = 'to-start' | 'to-end' | 'from-start' | 'from-end'\n\nexport type NavigationMenuContentImplEmits = DismissableLayerEmits\n\nexport interface NavigationMenuContentImplProps extends DismissableLayerProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, ref, watchEffect } from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { getActiveElement, useArrowNavigation, useForwardExpose } from '@/shared'\nimport { injectNavigationMenuItemContext } from './NavigationMenuItem.vue'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\nimport {\n  EVENT_ROOT_CONTENT_DISMISS,\n  focusFirst,\n  getOpenState,\n  getTabbableCandidates,\n  makeContentId,\n  makeTriggerId,\n} from './utils'\n\nconst props = defineProps<NavigationMenuContentImplProps>()\nconst emits = defineEmits<NavigationMenuContentImplEmits>()\n\nconst { getItems } = useCollection({ key: 'NavigationMenu' })\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst menuContext = injectNavigationMenuContext()\nconst itemContext = injectNavigationMenuItemContext()\n\nconst triggerId = makeTriggerId(menuContext.baseId, itemContext.value)\nconst contentId = makeContentId(menuContext.baseId, itemContext.value)\n\nconst prevMotionAttributeRef = ref<MotionAttribute | null>(null)\nconst motionAttribute = computed(() => {\n  const values = getItems().map(i => i.ref.id.split('trigger-')[1])\n  if (menuContext.dir.value === 'rtl')\n    values.reverse()\n  const index = values.indexOf(menuContext.modelValue.value)\n  const prevIndex = values.indexOf(menuContext.previousValue.value)\n  const isSelected = itemContext.value === menuContext.modelValue.value\n  const wasSelected = prevIndex === values.indexOf(itemContext.value)\n\n  // We only want to update selected and the last selected content\n  // this avoids animations being interrupted outside of that range\n  if (!isSelected && !wasSelected)\n    return prevMotionAttributeRef.value\n\n  const attribute = (() => {\n    // Don't provide a direction on the initial open\n    if (index !== prevIndex) {\n      // If we're moving to this item from another\n      if (isSelected && prevIndex !== -1)\n        return index > prevIndex ? 'from-end' : 'from-start'\n      // If we're leaving this item for another\n      if (wasSelected && index !== -1)\n        return index > prevIndex ? 'to-start' : 'to-end'\n    }\n    // Otherwise we're entering from closed or leaving the list\n    // entirely and should not animate in any direction\n    return null\n  })()\n\n  // eslint-disable-next-line vue/no-side-effects-in-computed-properties\n  prevMotionAttributeRef.value = attribute\n  return attribute\n})\n\nfunction handleFocusOutside(ev: FocusOutsideEvent) {\n  emits('focusOutside', ev)\n  emits('interactOutside', ev)\n\n  const target = ev.detail.originalEvent.target as HTMLElement\n  if (target.hasAttribute('data-navigation-menu-trigger'))\n    ev.preventDefault()\n\n  if (!ev.defaultPrevented) {\n    itemContext.onContentFocusOutside()\n\n    const target = ev.target as HTMLElement\n    // Only dismiss content when focus moves outside of the menu\n    if (menuContext.rootNavigationMenu?.value?.contains(target))\n      ev.preventDefault()\n  }\n}\n\nfunction handlePointerDownOutside(ev: PointerDownOutsideEvent) {\n  emits('pointerDownOutside', ev)\n\n  if (!ev.defaultPrevented) {\n    const target = ev.target as HTMLElement\n    const isTrigger = getItems().some(i =>\n      i.ref.contains(target),\n    )\n    const isRootViewport\n    = menuContext.isRootMenu && menuContext.viewport.value?.contains(target)\n\n    if (isTrigger || isRootViewport || !menuContext.isRootMenu)\n      ev.preventDefault()\n  }\n}\n\nwatchEffect((cleanupFn) => {\n  const content = currentElement.value\n  if (menuContext.isRootMenu && content) {\n    // Bubble dismiss to the root content node and focus its trigger\n    const handleClose = () => {\n      menuContext.onItemDismiss()\n      itemContext.onRootContentClose()\n      if (content.contains(getActiveElement()))\n        itemContext.triggerRef.value?.focus()\n    }\n    content.addEventListener(EVENT_ROOT_CONTENT_DISMISS, handleClose)\n\n    cleanupFn(() =>\n      content.removeEventListener(EVENT_ROOT_CONTENT_DISMISS, handleClose),\n    )\n  }\n})\n\nfunction handleEscapeKeyDown(ev: KeyboardEvent) {\n  emits('escapeKeyDown', ev)\n\n  if (!ev.defaultPrevented) {\n    menuContext.onItemDismiss()\n    itemContext.triggerRef?.value?.focus()\n    itemContext.wasEscapeCloseRef.value = true\n  }\n}\n\nfunction handleKeydown(ev: KeyboardEvent) {\n  // prevent parent menu triggering keydown event\n  if ((ev.target as HTMLElement).closest('[data-reka-navigation-menu]') !== menuContext.rootNavigationMenu.value)\n    return\n\n  const isMetaKey = ev.altKey || ev.ctrlKey || ev.metaKey\n  const isTabKey = ev.key === 'Tab' && !isMetaKey\n  const candidates = getTabbableCandidates(ev.currentTarget as HTMLElement)\n\n  if (isTabKey) {\n    const focusedElement = getActiveElement()\n    const index = candidates.findIndex(\n      candidate => candidate === focusedElement,\n    )\n    const isMovingBackwards = ev.shiftKey\n    const nextCandidates = isMovingBackwards\n      ? candidates.slice(0, index).reverse()\n      : candidates.slice(index + 1, candidates.length)\n\n    if (focusFirst(nextCandidates)) {\n      // prevent browser tab keydown because we've handled focus\n      ev.preventDefault()\n    }\n    else {\n      // If we can't focus that means we're at the edges\n      // so focus the proxy and let browser handle\n      // tab/shift+tab keypress on the proxy instead\n      itemContext.focusProxyRef.value?.focus()\n      return\n    }\n  }\n\n  const newSelectedElement = useArrowNavigation(\n    ev,\n    getActiveElement() as HTMLElement,\n    undefined,\n    { itemsArray: candidates, loop: false, enableIgnoredElement: true },\n  )\n  newSelectedElement?.focus()\n}\n\nfunction handleDismiss() {\n  const rootContentDismissEvent = new Event(EVENT_ROOT_CONTENT_DISMISS, {\n    bubbles: true,\n    cancelable: true,\n  })\n  currentElement.value?.dispatchEvent(rootContentDismissEvent)\n}\n</script>\n\n<template>\n  <DismissableLayer\n    :id=\"contentId\"\n    :ref=\"forwardRef\"\n    :aria-labelledby=\"triggerId\"\n    :data-motion=\"motionAttribute\"\n    :data-state=\"getOpenState(menuContext.modelValue.value === itemContext.value)\"\n    :data-orientation=\"menuContext.orientation\"\n    v-bind=\"props\"\n    @keydown=\"handleKeydown\"\n    @escape-key-down=\"handleEscapeKeyDown\"\n    @pointer-down-outside=\"handlePointerDownOutside\"\n    @focus-outside=\"handleFocusOutside\"\n    @dismiss=\"handleDismiss\"\n  >\n    <slot />\n  </DismissableLayer>\n</template>\n", "<script lang=\"ts\">\nimport type { NavigationMenuContentImplEmits, NavigationMenuContentImplProps } from './NavigationMenuContentImpl.vue'\n\nexport type NavigationMenuContentEmits = NavigationMenuContentImplEmits\n\nexport interface NavigationMenuContentProps extends NavigationMenuContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { isClient, reactiveOmit } from '@vueuse/shared'\nimport { computed } from 'vue'\nimport { Presence } from '@/Presence'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\nimport NavigationMenuContentImpl from './NavigationMenuContentImpl.vue'\nimport { injectNavigationMenuItemContext } from './NavigationMenuItem.vue'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\nimport { getOpenState, whenMouse } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<NavigationMenuContentProps>()\nconst emits = defineEmits<NavigationMenuContentEmits>()\n\nconst forwarded = useForwardPropsEmits(reactiveOmit(props, 'forceMount'), emits)\nconst { forwardRef } = useForwardExpose()\n\nconst menuContext = injectNavigationMenuContext()\nconst itemContext = injectNavigationMenuItemContext()\n\nconst open = computed(() => itemContext.value === menuContext.modelValue.value)\n\n// We persist the last active content value as the viewport may be animating out\n// and we want the content to remain mounted for the lifecycle of the viewport.\nconst isLastActiveValue = computed(() => {\n  if (menuContext.viewport.value) {\n    if (!menuContext.modelValue.value && menuContext.previousValue.value)\n      return (menuContext.previousValue.value === itemContext.value)\n  }\n  return false\n})\n</script>\n\n<template>\n  <Teleport\n    :to=\"isClient && menuContext.viewport.value ? menuContext.viewport.value : 'body'\"\n    :disabled=\"isClient && menuContext.viewport.value ? !menuContext.viewport.value : true\"\n  >\n    <Presence\n      v-slot=\"{ present }\"\n      :present=\"forceMount || open || isLastActiveValue\"\n      :force-mount=\"!menuContext.unmountOnHide.value\"\n    >\n      <NavigationMenuContentImpl\n        :ref=\"forwardRef\"\n        :data-state=\"getOpenState(open)\"\n        :style=\"{\n          pointerEvents: !open && menuContext.isRootMenu ? 'none' : undefined,\n        }\"\n        v-bind=\"{ ...$attrs, ...forwarded }\"\n        :hidden=\"!present\"\n        @pointerenter=\"menuContext.onContentEnter(itemContext.value)\"\n        @pointerleave=\"whenMouse(() => menuContext.onContentLeave())($event)\"\n        @pointer-down-outside=\"emits('pointerDownOutside', $event)\"\n        @focus-outside=\"emits('focusOutside', $event)\"\n        @interact-outside=\"emits('interactOutside', $event)\"\n      >\n        <slot />\n      </NavigationMenuContentImpl>\n    </Presence>\n  </Teleport>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface NavigationMenuIndicatorProps extends PrimitiveProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useResizeObserver } from '@vueuse/core'\nimport { computed, ref, watchEffect } from 'vue'\nimport { Presence } from '@/Presence'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<NavigationMenuIndicatorProps>()\n\nconst { forwardRef } = useForwardExpose()\nconst menuContext = injectNavigationMenuContext()\n\nconst indicatorStyle = ref<{ size: number, position: number }>()\nconst isHorizontal = computed(() => menuContext.orientation === 'horizontal')\nconst isVisible = computed(() => !!menuContext.modelValue.value)\nconst { activeTrigger } = menuContext\n\nfunction handlePositionChange() {\n  if (!activeTrigger.value) {\n    return\n  }\n\n  indicatorStyle.value = {\n    size: isHorizontal.value\n      ? activeTrigger.value.offsetWidth\n      : activeTrigger.value.offsetHeight,\n    position: isHorizontal.value\n      ? activeTrigger.value.offsetLeft\n      : activeTrigger.value.offsetTop,\n  }\n}\n\nwatchEffect(() => {\n  if (!menuContext.modelValue.value) {\n    return\n  }\n  handlePositionChange()\n})\n\nuseResizeObserver(activeTrigger, handlePositionChange)\nuseResizeObserver(menuContext.indicatorTrack, handlePositionChange)\n</script>\n\n<template>\n  <Teleport\n    v-if=\"menuContext.indicatorTrack.value\"\n    :to=\"menuContext.indicatorTrack.value\"\n  >\n    <Presence :present=\"forceMount || isVisible\">\n      <Primitive\n        :ref=\"forwardRef\"\n        aria-hidden=\"true\"\n        :data-state=\"isVisible ? 'visible' : 'hidden'\"\n        :data-orientation=\"menuContext.orientation\"\n        :as-child=\"props.asChild\"\n        :as=\"as\"\n        :style=\"{\n          ...(indicatorStyle ? {\n            '--reka-navigation-menu-indicator-size': `${indicatorStyle.size}px`,\n            '--reka-navigation-menu-indicator-position': `${indicatorStyle.position}px`,\n          } : {}),\n        }\"\n        v-bind=\"$attrs\"\n      >\n        <slot />\n      </Primitive>\n    </Presence>\n  </Teleport>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { useForwardExpose } from '@/shared'\n\nexport type NavigationMenuLinkEmits = {\n  /**\n   * Event handler called when the user selects a link (via mouse or keyboard).\n   *\n   * Calling `event.preventDefault` in this handler will prevent the navigation menu from closing when selecting that link.\n   */\n  select: [payload: CustomEvent<{ originalEvent: Event }>]\n}\nexport interface NavigationMenuLinkProps extends PrimitiveProps {\n  /** Used to identify the link as the currently active page. */\n  active?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { EVENT_ROOT_CONTENT_DISMISS, LINK_SELECT } from './utils'\n\nconst props = withDefaults(defineProps<NavigationMenuLinkProps>(), {\n  as: 'a',\n})\n\nconst emits = defineEmits<NavigationMenuLinkEmits>()\n\nconst { CollectionItem } = useCollection({ key: 'NavigationMenu' })\nuseForwardExpose()\n\nasync function handleClick(ev: MouseEvent) {\n  const linkSelectEvent = new CustomEvent(LINK_SELECT, {\n    bubbles: true,\n    cancelable: true,\n    detail: {\n      originalEvent: ev,\n    },\n  })\n  emits('select', linkSelectEvent)\n\n  if (!linkSelectEvent.defaultPrevented && !ev.metaKey) {\n    const rootContentDismissEvent = new CustomEvent(\n      EVENT_ROOT_CONTENT_DISMISS,\n      {\n        bubbles: true,\n        cancelable: true,\n      },\n    )\n    ev.target?.dispatchEvent(rootContentDismissEvent)\n  }\n}\n</script>\n\n<template>\n  <CollectionItem>\n    <Primitive\n      :as=\"as\"\n      :data-active=\"active ? '' : undefined\"\n      :aria-current=\"active ? 'page' : undefined\"\n      :as-child=\"props.asChild\"\n      @click=\"handleClick\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface NavigationMenuListProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<NavigationMenuListProps>(), {\n  as: 'ul',\n})\n\nconst menuContext = injectNavigationMenuContext()\nconst { forwardRef, currentElement } = useForwardExpose()\n\nonMounted(() => {\n  menuContext.onIndicatorTrackChange(currentElement.value)\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    style=\"position: relative\"\n  >\n    <Primitive\n      v-bind=\"$attrs\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n      :data-orientation=\"menuContext.orientation\"\n    >\n      <slot />\n    </Primitive>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Orientation } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\n\nexport type NavigationMenuSubEmits = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [value: string]\n}\n\nexport interface NavigationMenuSubProps extends PrimitiveProps {\n  /** The controlled value of the sub menu item to activate. Can be used as `v-model`. */\n  modelValue?: string\n  /**\n   * The value of the menu item that should be active when initially rendered.\n   *\n   * Use when you do not need to control the value state.\n   */\n  defaultValue?: string\n  /** The orientation of the menu. */\n  orientation?: Orientation\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { ref, watchEffect } from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectNavigationMenuContext, provideNavigationMenuContext } from './NavigationMenuRoot.vue'\n\nconst props = withDefaults(defineProps<NavigationMenuSubProps>(), {\n  orientation: 'horizontal',\n})\nconst emits = defineEmits<NavigationMenuSubEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? '',\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<string>\nconst previousValue = ref('')\n\nconst menuContext = injectNavigationMenuContext()\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst indicatorTrack = ref<HTMLElement>()\nconst viewport = ref<HTMLElement>()\nconst activeTrigger = ref<HTMLElement>()\n\nconst { getItems, CollectionSlot } = useCollection({ key: 'NavigationMenu', isProvider: true })\n\nwatchEffect(() => {\n  if (!modelValue.value)\n    return\n\n  const items = getItems().map(i => i.ref)\n  activeTrigger.value = items.find(item =>\n    item.id.includes(modelValue.value),\n  )\n})\n\nprovideNavigationMenuContext({\n  ...menuContext,\n  isRootMenu: false,\n  modelValue,\n  previousValue,\n  activeTrigger,\n  orientation: props.orientation,\n  rootNavigationMenu: currentElement,\n  indicatorTrack,\n  onIndicatorTrackChange: (val) => {\n    indicatorTrack.value = val\n  },\n  viewport,\n  onViewportChange: (val) => {\n    viewport.value = val\n  },\n\n  onTriggerEnter: (val) => {\n    modelValue.value = val\n  },\n  onTriggerLeave: () => {\n    // do nothing for submenu\n  },\n  onContentEnter: () => {\n    // do nothing for submenu\n  },\n  onContentLeave: () => {\n    // do nothing for submenu\n  },\n  onItemSelect: (val) => {\n    modelValue.value = val\n  },\n  onItemDismiss: () => {\n    modelValue.value = ''\n  },\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <Primitive\n      :ref=\"forwardRef\"\n      :data-orientation=\"orientation\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n      data-reka-navigation-menu\n    >\n      <slot :model-value=\"modelValue\" />\n    </Primitive>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { VNode } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { useForwardExpose } from '@/shared'\n\nexport interface NavigationMenuTriggerProps extends PrimitiveProps {\n  /** When `true`, prevents the user from interacting with item */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { refAutoReset, unrefElement } from '@vueuse/core'\nimport { computed, onMounted, ref } from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { VisuallyHidden } from '@/VisuallyHidden'\nimport { injectNavigationMenuItemContext } from './NavigationMenuItem.vue'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\nimport { getOpenState, makeContentId, makeTriggerId } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<NavigationMenuTriggerProps>(), {\n  as: 'button',\n})\n\nconst menuContext = injectNavigationMenuContext()\nconst itemContext = injectNavigationMenuItemContext()\n\nconst { CollectionItem } = useCollection({ key: 'NavigationMenu' })\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\nconst triggerId = ref('')\nconst contentId = ref('')\n\nconst hasPointerMoveOpenedRef = refAutoReset(false, 300)\nconst wasClickCloseRef = ref(false)\n\nconst open = computed(() => itemContext.value === menuContext.modelValue.value)\n\nonMounted(() => {\n  itemContext.triggerRef = triggerElement\n  triggerId.value = makeTriggerId(menuContext.baseId, itemContext.value)\n  contentId.value = makeContentId(menuContext.baseId, itemContext.value)\n})\n\nfunction handlePointerEnter() {\n  if (menuContext.disableHoverTrigger.value)\n    return\n\n  wasClickCloseRef.value = false\n  itemContext.wasEscapeCloseRef.value = false\n}\n\nfunction handlePointerMove(ev: PointerEvent) {\n  if (menuContext.disableHoverTrigger.value)\n    return\n\n  if (ev.pointerType === 'mouse') {\n    if (\n      props.disabled\n      || wasClickCloseRef.value\n      || itemContext.wasEscapeCloseRef.value\n      || hasPointerMoveOpenedRef.value\n    ) {\n      return\n    }\n\n    menuContext.onTriggerEnter(itemContext.value)\n    hasPointerMoveOpenedRef.value = true\n  }\n}\n\nfunction handlePointerLeave(ev: PointerEvent) {\n  if (menuContext.disableHoverTrigger.value)\n    return\n\n  if (ev.pointerType === 'mouse') {\n    if (props.disabled)\n      return\n    menuContext.onTriggerLeave()\n    hasPointerMoveOpenedRef.value = false\n  }\n}\n\nfunction handleClick(event: PointerEvent) {\n  if (event.pointerType === 'mouse' && menuContext.disableClickTrigger.value)\n    return\n\n  // if open via pointermove, we prevent click event\n  if (hasPointerMoveOpenedRef.value)\n    return\n\n  if (open.value)\n    menuContext.onItemSelect('')\n  else menuContext.onItemSelect(itemContext.value)\n\n  wasClickCloseRef.value = open.value\n}\n\nfunction handleKeydown(ev: KeyboardEvent) {\n  const verticalEntryKey = menuContext.dir.value === 'rtl' ? 'ArrowLeft' : 'ArrowRight'\n  const entryKey = { horizontal: 'ArrowDown', vertical: verticalEntryKey }[\n    menuContext.orientation\n  ]\n  if (open.value && ev.key === entryKey) {\n    itemContext.onEntryKeyDown()\n    // Prevent FocusGroupItem from handling the event\n    ev.preventDefault()\n    ev.stopPropagation()\n  }\n}\n\nfunction setFocusProxyRef(node: VNode) {\n  // @ts-expect-error unrefElement expect MaybeRef, but also support Vnode\n  itemContext.focusProxyRef.value = unrefElement(node)\n  return undefined\n}\n\nfunction handleVisuallyHiddenFocus(ev: FocusEvent) {\n  const content = document.getElementById(itemContext.contentId)\n  const prevFocusedElement = ev.relatedTarget as HTMLElement | null\n\n  const wasTriggerFocused = prevFocusedElement === triggerElement.value\n  const wasFocusFromContent = content?.contains(prevFocusedElement)\n\n  if (wasTriggerFocused || !wasFocusFromContent)\n    itemContext.onFocusProxyEnter(wasTriggerFocused ? 'start' : 'end')\n}\n</script>\n\n<template>\n  <CollectionItem>\n    <Primitive\n      :id=\"triggerId\"\n      :ref=\"forwardRef\"\n      :disabled=\"disabled\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :data-state=\"getOpenState(open)\"\n      data-navigation-menu-trigger\n      :aria-expanded=\"open\"\n      :aria-controls=\"contentId\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n      v-bind=\"$attrs\"\n      @pointerenter=\"handlePointerEnter\"\n      @pointermove=\"handlePointerMove\"\n      @pointerleave=\"handlePointerLeave\"\n      @click=\"handleClick\"\n      @keydown=\"handleKeydown\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n\n  <template v-if=\"open\">\n    <VisuallyHidden\n      :ref=\"setFocusProxyRef\"\n      aria-hidden=\"true\"\n      :tabindex=\"0\"\n      @focus=\"handleVisuallyHiddenFocus\"\n    />\n    <span\n      v-if=\"menuContext.viewport\"\n      :aria-owns=\"contentId\"\n    />\n  </template>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface NavigationMenuViewportProps extends PrimitiveProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n  /**\n   * Placement of the viewport for css variables `(--reka-navigation-menu-viewport-left, --reka-navigation-menu-viewport-top)`.\n   * @defaultValue 'center'\n   */\n  align?: 'start' | 'center' | 'end'\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useResizeObserver } from '@vueuse/core'\nimport { computed, ref, watch } from 'vue'\nimport { Presence } from '@/Presence'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectNavigationMenuContext } from './NavigationMenuRoot.vue'\nimport { getOpenState, whenMouse } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<NavigationMenuViewportProps>(), {\n  align: 'center',\n})\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst menuContext = injectNavigationMenuContext()\nconst { activeTrigger, rootNavigationMenu, modelValue } = menuContext\n\nconst size = ref<{ width: number, height: number }>()\nconst position = ref<{ left: number, top: number }>()\n\nconst open = computed(() => !!menuContext.modelValue.value)\n\nwatch(currentElement, () => {\n  menuContext.onViewportChange(currentElement.value)\n})\n\nconst content = ref<HTMLElement>()\n\nwatch([modelValue, open], () => {\n  if (!currentElement.value)\n    return\n\n  requestAnimationFrame(() => {\n    const el = (currentElement.value as HTMLElement)?.querySelector('[data-state=open]') as HTMLElement | undefined\n    content.value = el\n  })\n}, { immediate: true, flush: 'post' })\n\nfunction updatePosition() {\n  if (content.value && activeTrigger.value && rootNavigationMenu.value) {\n    const bodyWidth = document.documentElement.offsetWidth\n    const bodyHeight = document.documentElement.offsetHeight\n    const rootRect = rootNavigationMenu.value.getBoundingClientRect()\n    const rect = activeTrigger.value.getBoundingClientRect()\n    const { offsetWidth, offsetHeight } = content.value\n\n    // Find the beginning of the position of the menu item\n    const startPositionLeft = rect.left - rootRect.left\n    const startPositionTop = rect.top - rootRect.top\n\n    // Aligning to specified alignment\n    let posLeft = null\n    let posTop = null\n    switch (props.align) {\n      case 'start':\n        posLeft = startPositionLeft\n        posTop = startPositionTop\n        break\n      case 'end':\n        posLeft = startPositionLeft - offsetWidth + rect.width\n        posTop = startPositionTop - offsetHeight + rect.height\n        break\n      default:\n        // center\n        posLeft = startPositionLeft - offsetWidth / 2 + rect.width / 2\n        posTop = startPositionTop - offsetHeight / 2 + rect.height / 2\n    }\n\n    const screenOffset = 10\n\n    // Do not let go of the left side of the screen\n    if (posLeft + rootRect.left < screenOffset) {\n      posLeft = screenOffset - rootRect.left\n    }\n\n    // Now also check the right side of the screen\n    const rightOffset = posLeft + rootRect.left + offsetWidth\n    if (rightOffset > bodyWidth - screenOffset) {\n      posLeft -= rightOffset - bodyWidth + screenOffset\n\n      // Recheck the left side of the screen\n      if (posLeft < screenOffset - rootRect.left) {\n        // Just set the menu to the full width of the screen\n        posLeft = screenOffset - rootRect.left\n      }\n    }\n\n    // Do not let go of the top side of the screen\n    if (posTop + rootRect.top < screenOffset) {\n      posTop = screenOffset - rootRect.top\n    }\n\n    // Now also check the bottom side of the screen\n    const bottomOffset = posTop + rootRect.top + offsetHeight\n    if (bottomOffset > bodyHeight - screenOffset) {\n      posTop -= bottomOffset - bodyHeight + screenOffset\n\n      // Recheck the top side of the screen\n      if (posTop < screenOffset - rootRect.top) {\n        // Just set the menu to the full height of the screen\n        posTop = screenOffset - rootRect.top\n      }\n    }\n\n    // Possible blurring font with decimal values\n    posLeft = Math.round(posLeft)\n    posTop = Math.round(posTop)\n\n    position.value = {\n      left: posLeft,\n      top: posTop,\n    }\n  }\n}\n\nuseResizeObserver(content, () => {\n  if (content.value) {\n    size.value = {\n      width: content.value.offsetWidth,\n      height: content.value.offsetHeight,\n    }\n    updatePosition()\n  }\n})\n\nuseResizeObserver([globalThis.document?.body, rootNavigationMenu], () => {\n  updatePosition()\n})\n</script>\n\n<template>\n  <Presence\n    v-slot=\"{ present }\"\n    :present=\"forceMount || open\"\n    :force-mount=\"!menuContext.unmountOnHide.value\"\n    @after-leave=\"() => {\n      size = undefined\n      position = undefined\n    }\"\n  >\n    <Primitive\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :data-state=\"getOpenState(open)\"\n      :data-orientation=\"menuContext.orientation\"\n      :style=\"{\n        // Prevent interaction when animating out\n        pointerEvents: !open && menuContext.isRootMenu ? 'none' : undefined,\n        ['--reka-navigation-menu-viewport-width']: size ? `${size?.width}px` : undefined,\n        ['--reka-navigation-menu-viewport-height']: size ? `${size?.height}px` : undefined,\n        ['--reka-navigation-menu-viewport-left']: position ? `${position?.left}px` : undefined,\n        ['--reka-navigation-menu-viewport-top']: position ? `${position?.top}px` : undefined,\n      }\"\n      :hidden=\"!present\"\n      @pointerenter=\"menuContext.onContentEnter(menuContext.modelValue.value)\"\n      @pointerleave=\"whenMouse(() => menuContext.onContentLeave())($event)\"\n    >\n      <slot />\n    </Primitive>\n  </Presence>\n</template>\n", "import type { MaybeComputedElementRef } from '@vueuse/core'\nimport type { Ref } from 'vue'\nimport { NumberFormatter, NumberParser } from '@internationalized/number'\nimport { unrefElement, useEventListener } from '@vueuse/core'\nimport { createEventHook, isClient, reactiveComputed } from '@vueuse/shared'\nimport { computed, ref } from 'vue'\n\nexport function usePressedHold(options: { target?: MaybeComputedElementRef, disabled: Ref<boolean> }) {\n  const { disabled } = options\n  const timeout = ref<number>()\n  const triggerHook = createEventHook()\n  const resetTimeout = () => window.clearTimeout(timeout.value)\n\n  const onIncrementPressStart = (delay: number) => {\n    resetTimeout()\n    if (disabled.value)\n      return\n\n    triggerHook.trigger()\n\n    timeout.value = window.setTimeout(() => {\n      onIncrementPressStart(60)\n    }, delay)\n  }\n\n  const handlePressStart = () => {\n    onIncrementPressStart(400)\n  }\n\n  const handlePressEnd = () => {\n    resetTimeout()\n  }\n\n  // Handle press event, modified version of useMousePressed\n  const isPressed = ref(false)\n  const target = computed(() => unrefElement(options.target))\n\n  const onPressStart = (event: PointerEvent) => {\n    // Only handle left clicks, and ignore events that bubbled through portals.\n    if (event.button !== 0 || isPressed.value)\n      return\n\n    event.preventDefault()\n    isPressed.value = true\n    handlePressStart()\n  }\n\n  const onPressRelease = () => {\n    isPressed.value = false\n    handlePressEnd()\n  }\n\n  if (isClient) {\n    useEventListener(target || window, 'pointerdown', onPressStart)\n    useEventListener(window, 'pointerup', onPressRelease)\n    useEventListener(window, 'pointercancel', onPressRelease)\n  }\n\n  return {\n    isPressed,\n    onTrigger: triggerHook.on,\n  }\n}\n\nexport function useNumberFormatter(locale: Ref<string>, options: Ref<Intl.NumberFormatOptions | undefined> = ref({})) {\n  return reactiveComputed(() => new NumberFormatter(locale.value, options.value))\n}\n\nexport function useNumberParser(locale: Ref<string>, options: Ref<Intl.NumberFormatOptions | undefined> = ref({})) {\n  return reactiveComputed(() => new NumberParser(locale.value, options.value))\n}\n\nexport function handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.')\n    const value2Decimal = value2.toString().split('.')\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0\n    const multiplier = 10 ** Math.max(value1DecimalLength, value2DecimalLength)\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier)\n    value2 = Math.round(value2 * multiplier)\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2\n\n    // Transform the integer result back to decimal\n    result /= multiplier\n  }\n\n  return result\n}\n", "/**\n * The `clamp` function restricts a number within a specified range by returning the value itself if it\n * falls within the range, or the closest boundary value if it exceeds the range.\n * @param {number} value - The `value` parameter represents the number that you want to clamp within\n * the specified range defined by `min` and `max` values.\n * @param {number} min - If the `value` parameter is less than the `min` value, the\n * function will return the `min` value.\n * @param {number} max - If the `value` parameter is greater than the `max` value,\n * the function will return `max`.\n * @returns The `clamp` function returns the value of `value` constrained within the range defined by\n * `min` and `max`.\n */\nexport function clamp(value: number, min: number = Number.NEGATIVE_INFINITY, max: number = Number.POSITIVE_INFINITY): number {\n  return Math.min(max, Math.max(min, value))\n}\n\n/**\n * The function `roundToStepPrecision` rounds a number to a specified precision step.\n * @param {number} value - The `value` parameter is the number that you want to round to a specific\n * precision based on the `step` parameter.\n * @param {number} step - The `step` parameter in the `roundToStepPrecision` function represents the\n * interval at which you want to round the `value`. For example, if `step` is 0.5, the `value` will be\n * rounded to the nearest half.\n * @returns the `roundedValue` after rounding it to the precision specified by the `step`.\n */\nexport function roundToStepPrecision(value: number, step: number) {\n  let roundedValue = value\n  const stepString = step.toString()\n  const pointIndex = stepString.indexOf('.')\n  const precision = pointIndex >= 0 ? stepString.length - pointIndex : 0\n  if (precision > 0) {\n    const pow = 10 ** precision\n    roundedValue = Math.round(roundedValue * pow) / pow\n  }\n  return roundedValue\n}\n\n/**\n * The function `snapValueToStep` snaps a given value to the nearest step within a specified range.\n * @param {number} value - The `value` parameter represents the number that you want to snap to the\n * nearest step value.\n * @param {number | undefined} min - The `min` parameter represents the minimum value that the `value`\n * should be snapped to. If `value` is less than `min`, it will be snapped to `min`. If `min` is not\n * provided (undefined), then the snapping will not consider a minimum value.\n * @param {number | undefined} max - The `max` parameter represents the maximum value that the `value`\n * should be snapped to. It ensures that the snapped value does not exceed this maximum value.\n * @param {number} step - The `step` parameter in the `snapValueToStep` function represents the\n * interval at which the `value` should be snapped to. It determines the granularity of the snapping\n * operation. For example, if `step` is 5, the `value` will be snapped to the nearest multiple of\n * @returns a number that has been snapped to the nearest step value within the specified range of minimum and maximum values.\n */\nexport function snapValueToStep(value: number, min: number | undefined, max: number | undefined, step: number): number {\n  min = Number(min)\n  max = Number(max)\n  const remainder = ((value - (Number.isNaN(min) ? 0 : min)) % step)\n  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder, step)\n\n  if (!Number.isNaN(min)) {\n    if (snappedValue < min)\n      snappedValue = min\n    else if (!Number.isNaN(max) && snappedValue > max)\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step\n  }\n  else if (!Number.isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step\n  }\n\n  // correct floating point behavior by rounding to step precision\n  snappedValue = roundToStepPrecision(snappedValue, step)\n\n  return snappedValue\n}\n", "<script lang=\"ts\">\nimport type { HTMLAttributes, Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { FormFieldProps } from '@/shared/types'\nimport { useVModel } from '@vueuse/core'\nimport { computed, ref, toRefs } from 'vue'\nimport { clamp, createContext, isNullish, snapValueToStep, useFormControl, useLocale } from '@/shared'\n\nexport interface NumberFieldRootProps extends PrimitiveProps, FormFieldProps {\n  defaultValue?: number\n  modelValue?: number | null\n  /** The smallest value allowed for the input. */\n  min?: number\n  /** The largest value allowed for the input. */\n  max?: number\n  /** The amount that the input value changes with each increment or decrement \"tick\". */\n  step?: number\n  /** When `false`, prevents the value from snapping to the nearest increment of the step value */\n  stepSnapping?: boolean\n  /** Formatting options for the value displayed in the number field. This also affects what characters are allowed to be typed by the user. */\n  formatOptions?: Intl.NumberFormatOptions\n  /** The locale to use for formatting dates */\n  locale?: string\n  /** When `true`, prevents the user from interacting with the Number Field. */\n  disabled?: boolean\n  /** When `true`, prevents the value from changing on wheel scroll. */\n  disableWheelChange?: boolean\n  /** When `true`, inverts the direction of the wheel change. */\n  invertWheelChange?: boolean\n  /** Id of the element */\n  id?: string\n}\n\nexport type NumberFieldRootEmits = {\n  'update:modelValue': [val: number]\n}\n\ninterface NumberFieldRootContext {\n  modelValue: Ref<number | undefined>\n  handleIncrease: (multiplier?: number) => void\n  handleDecrease: (multiplier?: number) => void\n  handleMinMaxValue: (type: 'min' | 'max') => void\n  inputEl: Ref<HTMLInputElement | undefined>\n  onInputElement: (el: HTMLInputElement) => void\n  inputMode: Ref<HTMLAttributes['inputmode']>\n  textValue: Ref<string>\n  validate: (val: string) => boolean\n  applyInputValue: (val: string) => void\n  disabled: Ref<boolean>\n  disableWheelChange: Ref<boolean>\n  invertWheelChange: Ref<boolean>\n  max: Ref<number | undefined>\n  min: Ref<number | undefined>\n  isDecreaseDisabled: Ref<boolean>\n  isIncreaseDisabled: Ref<boolean>\n  id: Ref<string | undefined>\n}\n\nexport const [injectNumberFieldRootContext, provideNumberFieldRootContext] = createContext<NumberFieldRootContext>('NumberFieldRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\nimport { handleDecimalOperation, useNumberFormatter, useNumberParser } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<NumberFieldRootProps>(), {\n  as: 'div',\n  defaultValue: undefined,\n  step: 1,\n  stepSnapping: true,\n})\nconst emits = defineEmits<NumberFieldRootEmits>()\nconst { disabled, disableWheelChange, invertWheelChange, min, max, step, stepSnapping, formatOptions, id, locale: propLocale } = toRefs(props)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<number | undefined>\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\n\nconst locale = useLocale(propLocale)\nconst isFormControl = useFormControl(currentElement)\nconst inputEl = ref<HTMLInputElement>()\n\nconst isDecreaseDisabled = computed(() => (\n  !isNullish(modelValue.value) && (\n    clampInputValue(modelValue.value) === min.value\n    || (min.value && !isNaN(modelValue.value)\n    )\n      ? (handleDecimalOperation('-', modelValue.value, step.value) < min.value)\n      : false)),\n)\nconst isIncreaseDisabled = computed(() => (\n  !isNullish(modelValue.value) && (\n    clampInputValue(modelValue.value) === max.value\n    || (max.value && !isNaN(modelValue.value)\n    )\n      ? (handleDecimalOperation('+', modelValue.value, step.value) > max.value)\n      : false)),\n)\n\nfunction handleChangingValue(type: 'increase' | 'decrease', multiplier = 1) {\n  inputEl.value?.focus()\n  const currentInputValue = numberParser.parse(inputEl.value?.value ?? '')\n  if (props.disabled)\n    return\n  if (isNaN(currentInputValue)) {\n    modelValue.value = min.value ?? 0\n  }\n  else {\n    if (type === 'increase')\n      modelValue.value = clampInputValue(currentInputValue + ((step.value ?? 1) * multiplier))\n    else\n      modelValue.value = clampInputValue(currentInputValue - ((step.value ?? 1) * multiplier))\n  }\n}\n\nfunction handleIncrease(multiplier = 1) {\n  handleChangingValue('increase', multiplier)\n}\nfunction handleDecrease(multiplier = 1) {\n  handleChangingValue('decrease', multiplier)\n}\n\nfunction handleMinMaxValue(type: 'min' | 'max') {\n  if (type === 'min' && min.value !== undefined)\n    modelValue.value = clampInputValue(min.value)\n  else if (type === 'max' && max.value !== undefined)\n    modelValue.value = clampInputValue(max.value)\n}\n\n// Formatter\nconst numberFormatter = useNumberFormatter(locale, formatOptions)\nconst numberParser = useNumberParser(locale, formatOptions)\n\nconst inputMode = computed<HTMLAttributes['inputmode']>(() => {\n  // The inputMode attribute influences the software keyboard that is shown on touch devices.\n  // Browsers and operating systems are quite inconsistent about what keys are available, however.\n  // We choose between numeric and decimal based on whether we allow negative and fractional numbers,\n  // and based on testing on various devices to determine what keys are available in each inputMode.\n  const hasDecimals = numberFormatter.resolvedOptions().maximumFractionDigits! > 0\n\n  return hasDecimals ? 'decimal' : 'numeric'\n})\n// Replace negative textValue formatted using currencySign: 'accounting'\n// with a textValue that can be announced using a minus sign.\nconst textValueFormatter = useNumberFormatter(locale, formatOptions)\nconst textValue = computed(() => isNullish(modelValue.value) || isNaN(modelValue.value) ? '' : textValueFormatter.format(modelValue.value))\n\nfunction validate(val: string) {\n  return numberParser.isValidPartialNumber(val, min.value, max.value)\n}\n\nfunction setInputValue(val: string) {\n  if (inputEl.value)\n    inputEl.value.value = val\n}\n\nfunction clampInputValue(val: number) {\n  // Clamp to min and max, round to the nearest step, and round to specified number of digits\n  let clampedValue: number\n  if (step.value === undefined || isNaN(step.value) || !stepSnapping.value)\n    clampedValue = clamp(val, min.value, max.value)\n  else\n    clampedValue = snapValueToStep(val, min.value, max.value, step.value)\n\n  clampedValue = numberParser.parse(numberFormatter.format(clampedValue))\n  return clampedValue\n}\n\nfunction applyInputValue(val: string) {\n  const parsedValue = numberParser.parse(val)\n  modelValue.value = isNaN(parsedValue) ? undefined : clampInputValue(parsedValue)\n  // Set to empty state if input value is empty\n  if (!val.length)\n    return setInputValue(val)\n\n  // if it failed to parse, then reset input to formatted version of current number\n  if (isNaN(parsedValue))\n    return setInputValue(textValue.value)\n\n  return setInputValue(textValue.value)\n}\n\nprovideNumberFieldRootContext({\n  modelValue,\n  handleDecrease,\n  handleIncrease,\n  handleMinMaxValue,\n  inputMode,\n  inputEl,\n  onInputElement: el => inputEl.value = el,\n  textValue,\n  validate,\n  applyInputValue,\n  disabled,\n  disableWheelChange,\n  invertWheelChange,\n  max,\n  min,\n  isDecreaseDisabled,\n  isIncreaseDisabled,\n  id,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    ref=\"primitiveElement\"\n    role=\"group\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :data-disabled=\"disabled ? '' : undefined\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :text-value=\"textValue\"\n    />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name\"\n      type=\"text\"\n      :value=\"modelValue\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed } from 'vue'\nimport { injectNumberFieldRootContext } from './NumberFieldRoot.vue'\nimport { usePressedHold } from './utils'\n\nexport interface NumberFieldDecrementProps extends PrimitiveProps {\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\n\nconst props = withDefaults(defineProps<NumberFieldDecrementProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectNumberFieldRootContext()\nconst isDisabled = computed(() => rootContext.disabled?.value || props.disabled || rootContext.isDecreaseDisabled.value)\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst { isPressed, onTrigger } = usePressedHold({ target: currentElement, disabled: isDisabled })\n\nonTrigger(() => {\n  rootContext.handleDecrease()\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    ref=\"primitiveElement\"\n    tabindex=\"-1\"\n    aria-label=\"Decrease\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :style=\"{\n      userSelect: isPressed ? 'none' : undefined,\n    }\"\n    :disabled=\"isDisabled ? '' : undefined\"\n    :data-disabled=\"isDisabled ? '' : undefined\"\n    :data-pressed=\"isPressed ? 'true' : undefined\"\n    @contextmenu.prevent\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed } from 'vue'\nimport { injectNumberFieldRootContext } from './NumberFieldRoot.vue'\nimport { usePressedHold } from './utils'\n\nexport interface NumberFieldIncrementProps extends PrimitiveProps {\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\n\nconst props = withDefaults(defineProps<NumberFieldIncrementProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectNumberFieldRootContext()\nconst isDisabled = computed(() => rootContext.disabled?.value || props.disabled || rootContext.isIncreaseDisabled.value)\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst { isPressed, onTrigger } = usePressedHold({ target: currentElement, disabled: isDisabled })\n\nonTrigger(() => {\n  rootContext.handleIncrease()\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    ref=\"primitiveElement\"\n    tabindex=\"-1\"\n    aria-label=\"Increase\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :style=\"{\n      userSelect: isPressed ? 'none' : undefined,\n    }\"\n    :disabled=\"isDisabled ? '' : undefined\"\n    :data-disabled=\"isDisabled ? '' : undefined\"\n    :data-pressed=\"isPressed ? 'true' : undefined\"\n    @contextmenu.prevent\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { onMounted, ref, watch } from 'vue'\nimport { getActiveElement } from '@/shared'\nimport { injectNumberFieldRootContext } from './NumberFieldRoot.vue'\n\nexport interface NumberFieldInputProps extends PrimitiveProps {\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\n\nconst props = withDefaults(defineProps<NumberFieldInputProps>(), {\n  as: 'input',\n})\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nconst rootContext = injectNumberFieldRootContext()\n\nfunction handleWheelEvent(event: WheelEvent) {\n  if (rootContext.disableWheelChange.value)\n    return\n\n  // only handle when in focus\n  if (event.target !== getActiveElement())\n    return\n\n  // if on a trackpad, users can scroll in both X and Y at once, check the magnitude of the change\n  // if it's mostly in the X direction, then just return, the user probably doesn't mean to inc/dec\n  // this isn't perfect, events come in fast with small deltas and a part of the scroll may give a false indication\n  // especially if the user is scrolling near 45deg\n  if (Math.abs(event.deltaY) <= Math.abs(event.deltaX))\n    return\n\n  event.preventDefault()\n  if (event.deltaY > 0)\n    rootContext.invertWheelChange.value ? rootContext.handleDecrease() : rootContext.handleIncrease()\n  else if (event.deltaY < 0)\n    rootContext.invertWheelChange.value ? rootContext.handleIncrease() : rootContext.handleDecrease()\n}\n\nonMounted(() => {\n  rootContext.onInputElement(currentElement.value as HTMLInputElement)\n})\n\nconst inputValue = ref(rootContext.textValue.value)\nwatch(() => rootContext.textValue.value, () => {\n  inputValue.value = rootContext.textValue.value\n}, { immediate: true, deep: true })\n\nfunction handleChange() {\n  requestAnimationFrame(() => {\n    inputValue.value = rootContext.textValue.value\n  })\n}\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"rootContext.id.value\"\n    ref=\"primitiveElement\"\n    :value=\"inputValue\"\n    role=\"spinbutton\"\n    type=\"text\"\n    tabindex=\"0\"\n    :inputmode=\"rootContext.inputMode.value\"\n    :disabled=\"rootContext.disabled.value ? '' : undefined\"\n    :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n    autocomplete=\"off\"\n    autocorrect=\"off\"\n    spellcheck=\"false\"\n    aria-roledescription=\"Number field\"\n    :aria-valuenow=\"rootContext.modelValue.value\"\n    :aria-valuemin=\"rootContext.min.value\"\n    :aria-valuemax=\"rootContext.max.value\"\n    @keydown.up.prevent=\"rootContext.handleIncrease()\"\n    @keydown.down.prevent=\"rootContext.handleDecrease()\"\n    @keydown.page-up.prevent=\"rootContext.handleIncrease(10)\"\n    @keydown.page-down.prevent=\"rootContext.handleDecrease(10)\"\n    @keydown.home.prevent=\"rootContext.handleMinMaxValue('min')\"\n    @keydown.end.prevent=\"rootContext.handleMinMaxValue('max')\"\n    @wheel=\"handleWheelEvent\"\n    @beforeinput=\"(event: InputEvent) => {\n      const target = event.target as HTMLInputElement\n      let nextValue\n        = target.value.slice(0, target.selectionStart ?? undefined)\n          + (event.data ?? '')\n          + target.value.slice(target.selectionEnd ?? undefined);\n\n      // validate\n      if (!rootContext.validate(nextValue))\n        event.preventDefault()\n    }\"\n    @input=\"(event: InputEvent) => {\n      const target = event.target as HTMLInputElement\n      inputValue = target.value\n    }\"\n    @change=\"handleChange\"\n    @keydown.enter=\"rootContext.applyInputValue($event.target?.value)\"\n    @blur=\"rootContext.applyInputValue($event.target?.value)\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationEllipsisProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<PaginationEllipsisProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    data-type=\"ellipsis\"\n  >\n    <slot>&#8230;</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useForwardExpose } from '@/shared'\n\ntype PaginationRootContext = {\n  page: Ref<number>\n  onPageChange: (value: number) => void\n  pageCount: Ref<number>\n  siblingCount: Ref<number>\n  disabled: Ref<boolean>\n  showEdges: Ref<boolean>\n}\n\nexport interface PaginationRootProps extends PrimitiveProps {\n  /** The controlled value of the current page. Can be binded as `v-model:page`. */\n  page?: number\n  /**\n   * The value of the page that should be active when initially rendered.\n   *\n   * Use when you do not need to control the value state.\n   */\n  defaultPage?: number\n  /** Number of items per page */\n  itemsPerPage: number\n  /** Number of items in your list */\n  total?: number\n  /** Number of sibling should be shown around the current page */\n  siblingCount?: number\n  /** When `true`, prevents the user from interacting with item */\n  disabled?: boolean\n  /** When `true`, always show first page, last page, and ellipsis */\n  showEdges?: boolean\n}\n\nexport type PaginationRootEmits = {\n  /** Event handler called when the page value changes */\n  'update:page': [value: number]\n}\n\nexport const [injectPaginationRootContext, providePaginationRootContext]\n  = createContext<PaginationRootContext>('PaginationRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<PaginationRootProps>(), {\n  as: 'nav',\n  total: 0,\n  siblingCount: 2,\n  defaultPage: 1,\n  showEdges: false,\n})\nconst emits = defineEmits<PaginationRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current page state */\n    page: typeof page.value\n    /** Number of pages */\n    pageCount: typeof pageCount.value\n  }) => any\n}>()\n\nconst { siblingCount, disabled, showEdges } = toRefs(props)\n\nuseForwardExpose()\nconst page = useVModel(props, 'page', emits, {\n  defaultValue: props.defaultPage,\n  passive: (props.page === undefined) as false,\n}) as Ref<number>\n\nconst pageCount = computed(() => Math.max(1, Math.ceil(props.total / (props.itemsPerPage || 1))))\n\nprovidePaginationRootContext({\n  page,\n  onPageChange(value) {\n    page.value = value\n  },\n  pageCount,\n  siblingCount,\n  disabled,\n  showEdges,\n})\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n  >\n    <slot\n      :page=\"page\"\n      :page-count=\"pageCount\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationFirstProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPaginationRootContext } from './PaginationRoot.vue'\n\nconst props = withDefaults(defineProps<PaginationFirstProps>(), { as: 'button' })\n\nconst rootContext = injectPaginationRootContext()\nuseForwardExpose()\n\nconst disabled = computed((): boolean => rootContext.page.value === 1 || rootContext.disabled.value)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"First Page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :disabled\n    @click=\"!disabled && rootContext.onPageChange(1)\"\n  >\n    <slot>First page</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationLastProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPaginationRootContext } from './PaginationRoot.vue'\n\nconst props = withDefaults(defineProps<PaginationLastProps>(), { as: 'button' })\n\nconst rootContext = injectPaginationRootContext()\nuseForwardExpose()\n\nconst disabled = computed((): boolean => rootContext.page.value === rootContext.pageCount.value || rootContext.disabled.value)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"Last Page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :disabled\n    @click=\"!disabled && rootContext.onPageChange(rootContext.pageCount.value)\"\n  >\n    <slot>Last page</slot>\n  </Primitive>\n</template>\n", "// reference https://github.com/chakra-ui/zag/blob/main/packages/machines/pagination/src/pagination.utils.ts\n\ntype Pages = Array<{ type: 'ellipsis' } | { type: 'page', value: number }>\n\nfunction range(start: number, end: number) {\n  const length = end - start + 1\n  return Array.from({ length }, (_, idx) => idx + start)\n}\n\nexport function transform(items: (string | number)[]): Pages {\n  return items.map((value) => {\n    if (typeof value === 'number')\n      return { type: 'page', value }\n    return { type: 'ellipsis' }\n  })\n}\n\nconst ELLIPSIS = 'ellipsis'\n\nexport function getRange(currentPage: number, pageCount: number, siblingCount: number, showEdges: boolean) {\n  const firstPageIndex = 1\n  const lastPageIndex = pageCount\n\n  const leftSiblingIndex = Math.max(currentPage - siblingCount, firstPageIndex)\n  const rightSiblingIndex = Math.min(currentPage + siblingCount, lastPageIndex)\n\n  if (showEdges) {\n    /**\n     * `2 * siblingCount + 5` explanation:\n     * 2 * siblingCount for left/right siblings\n     * 5 for 2x left/right ellipsis, 2x first/last page + 1x current page\n     *\n     * For some page counts (e.g. totalPages: 8, siblingCount: 2),\n     * calculated max page is higher than total pages,\n     * so we need to take the minimum of both.\n     */\n    const totalPageNumbers = Math.min(2 * siblingCount + 5, pageCount)\n\n    const itemCount = totalPageNumbers - 2 // 2 stands for one ellipsis and either first or last page\n\n    const showLeftEllipsis\n      // default condition\n      = leftSiblingIndex > firstPageIndex + 2\n      // if the current page is towards the end of the list\n        && Math.abs(lastPageIndex - itemCount - firstPageIndex + 1) > 2\n      // if the current page is towards the middle of the list\n        && Math.abs(leftSiblingIndex - firstPageIndex) > 2\n\n    const showRightEllipsis\n      // default condition\n      = rightSiblingIndex < lastPageIndex - 2\n      // if the current page is towards the start of the list\n        && Math.abs(lastPageIndex - itemCount) > 2\n      // if the current page is towards the middle of the list\n        && Math.abs(lastPageIndex - rightSiblingIndex) > 2\n\n    if (!showLeftEllipsis && showRightEllipsis) {\n      const leftRange = range(1, itemCount)\n\n      return [...leftRange, ELLIPSIS, lastPageIndex]\n    }\n\n    if (showLeftEllipsis && !showRightEllipsis) {\n      const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex)\n\n      return [firstPageIndex, ELLIPSIS, ...rightRange]\n    }\n\n    if (showLeftEllipsis && showRightEllipsis) {\n      const middleRange = range(leftSiblingIndex, rightSiblingIndex)\n\n      return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex]\n    }\n\n    const fullRange = range(firstPageIndex, lastPageIndex)\n    return fullRange\n  }\n  else {\n    const itemCount = siblingCount * 2 + 1\n\n    if (pageCount < itemCount)\n      return range(1, lastPageIndex)\n\n    else if (currentPage <= (siblingCount + 1))\n      return range(firstPageIndex, itemCount)\n\n    else if ((pageCount - currentPage) <= siblingCount)\n      return range(pageCount - itemCount + 1, lastPageIndex)\n\n    else\n      return range(leftSiblingIndex, rightSiblingIndex)\n  }\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationListProps extends PrimitiveProps { }\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPaginationRootContext } from './PaginationRoot.vue'\nimport { getRange, transform } from './utils'\n\nconst props = defineProps<PaginationListProps>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Pages item */\n    items: typeof transformedRange.value\n  }) => any\n}>()\n\nuseForwardExpose()\nconst rootContext = injectPaginationRootContext()\n\nconst transformedRange = computed(() => {\n  return transform(\n    getRange(\n      rootContext.page.value,\n      rootContext.pageCount.value,\n      rootContext.siblingCount.value,\n      rootContext.showEdges.value,\n    ),\n  )\n})\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot :items=\"transformedRange\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationListItemProps extends PrimitiveProps {\n  /** Value for the page */\n  value: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPaginationRootContext } from './PaginationRoot.vue'\n\nconst props = withDefaults(defineProps<PaginationListItemProps>(), { as: 'button' })\nuseForwardExpose()\n\nconst rootContext = injectPaginationRootContext()\nconst isSelected = computed(() => rootContext.page.value === props.value)\n\nconst disabled = computed((): boolean => rootContext.disabled.value)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    data-type=\"page\"\n    :aria-label=\"`Page ${value}`\"\n    :aria-current=\"isSelected ? 'page' : undefined\"\n    :data-selected=\"isSelected ? 'true' : undefined\"\n    :disabled\n    :type=\"as === 'button' ? 'button' : undefined\"\n    @click=\"!disabled && rootContext.onPageChange(value)\"\n  >\n    <slot>{{ value }}</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationNextProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPaginationRootContext } from './PaginationRoot.vue'\n\nconst props = withDefaults(defineProps<PaginationNextProps>(), { as: 'button' })\n\nuseForwardExpose()\nconst rootContext = injectPaginationRootContext()\n\nconst disabled = computed((): boolean => rootContext.page.value === rootContext.pageCount.value || rootContext.disabled.value)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"Next Page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :disabled\n    @click=\"!disabled && rootContext.onPageChange(rootContext.page.value + 1)\"\n  >\n    <slot>Next page</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface PaginationPrevProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPaginationRootContext } from './PaginationRoot.vue'\n\nconst props = withDefaults(defineProps<PaginationPrevProps>(), { as: 'button' })\n\nuseForwardExpose()\nconst rootContext = injectPaginationRootContext()\n\nconst disabled = computed((): boolean => rootContext.page.value === 1 || rootContext.disabled.value)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    aria-label=\"Previous Page\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :disabled\n    @click=\"!disabled && rootContext.onPageChange(rootContext.page.value - 1)\"\n  >\n    <slot>Prev page</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { Direction, FormFieldProps } from '@/shared/types'\nimport { computed, ref, toRefs, watch } from 'vue'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\nimport VisuallyHiddenInput from '@/VisuallyHidden/VisuallyHiddenInput.vue'\n\nexport type PinInputType = 'text' | 'number'\n\n// Using this type to avoid mixed arrays (string | number)[].\nexport type PinInputValue<Type extends PinInputType = 'text'> = Type extends 'number' ? number[] : string[]\n\nexport type PinInputRootEmits<Type extends PinInputType = 'text'> = {\n  'update:modelValue': [value: PinInputValue<Type>]\n  'complete': [value: PinInputValue<Type>]\n}\n\nexport interface PinInputRootProps<Type extends PinInputType = 'text'> extends PrimitiveProps, FormFieldProps {\n  /** The controlled checked state of the pin input. Can be binded as `v-model`. */\n  modelValue?: PinInputValue<Type> | null\n  /** The default value of the pin inputs when it is initially rendered. Use when you do not need to control its checked state. */\n  defaultValue?: PinInputValue<Type>[]\n  /** The placeholder character to use for empty pin-inputs. */\n  placeholder?: string\n  /** When `true`, pin inputs will be treated as password. */\n  mask?: boolean\n  /** When `true`, mobile devices will autodetect the OTP from messages or clipboard, and enable the autocomplete field. */\n  otp?: boolean\n  /** Input type for the inputs. */\n  type?: Type\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** When `true`, prevents the user from interacting with the pin input */\n  disabled?: boolean\n  /** Id of the element */\n  id?: string\n}\n\nexport interface PinInputRootContext<Type extends PinInputType = 'text'> {\n  modelValue: Ref<PinInputValue<Type>>\n  currentModelValue: ComputedRef<PinInputValue<Type>>\n  mask: Ref<boolean>\n  otp: Ref<boolean>\n  placeholder: Ref<string>\n  type: Ref<PinInputType>\n  dir: Ref<Direction>\n  disabled: Ref<boolean>\n  isCompleted: ComputedRef<boolean>\n  inputElements?: Ref<Set<HTMLInputElement>>\n  onInputElementChange: (el: HTMLInputElement) => void\n  isNumericMode: ComputedRef<boolean>\n}\n\nexport const [injectPinInputRootContext, providePinInputRootContext]\n  = createContext<PinInputRootContext<PinInputType>>('PinInputRoot')\n</script>\n\n<script setup lang=\"ts\" generic=\"Type extends PinInputType = 'text'\">\nimport { useVModel } from '@vueuse/core'\nimport { Primitive } from '@/Primitive'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<PinInputRootProps<Type>>(), {\n  placeholder: '',\n  type: 'text' as any,\n})\nconst emits = defineEmits<PinInputRootEmits<Type>>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { mask, otp, placeholder, type, disabled, dir: propDir } = toRefs(props)\nconst { forwardRef } = useForwardExpose()\nconst dir = useDirection(propDir)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue ?? [] as any,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<PinInputValue<Type>>\n\nconst currentModelValue = computed(() => Array.isArray(modelValue.value) ? [...modelValue.value] : [])\n\nconst inputElements = ref<Set<HTMLInputElement>>(new Set())\nfunction onInputElementChange(el: HTMLInputElement) {\n  inputElements.value.add(el)\n}\n\nconst isNumericMode = computed(() => props.type === 'number')\nconst isCompleted = computed(() => {\n  const modelValues = currentModelValue.value.filter(i => !!i || (isNumericMode.value && i === 0))\n  return modelValues.length === inputElements.value.size\n})\n\nwatch(modelValue, () => {\n  if (isCompleted.value)\n    emits('complete', modelValue.value)\n}, { deep: true })\n\nprovidePinInputRootContext({\n  modelValue,\n  currentModelValue: currentModelValue as ComputedRef<PinInputValue<Type>>,\n  mask,\n  otp,\n  placeholder,\n  type,\n  dir,\n  disabled,\n  isCompleted,\n  inputElements,\n  onInputElementChange,\n  isNumericMode,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n    :dir=\"dir\"\n    :data-complete=\"isCompleted ? '' : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n  >\n    <slot :model-value=\"modelValue\" />\n\n    <VisuallyHiddenInput\n      :id=\"id\"\n      as=\"input\"\n      feature=\"focusable\"\n      tabindex=\"-1\"\n      :value=\"currentModelValue.join('')\"\n      :name=\"name ?? ''\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n      @focus=\"Array.from(inputElements)?.[0]?.focus()\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PinInputValue } from './PinInputRoot.vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { getActiveElement, useArrowNavigation } from '@/shared'\nimport { injectPinInputRootContext } from './PinInputRoot.vue'\n\nexport interface PinInputInputProps extends PrimitiveProps {\n  /** Position of the value this input binds to. */\n  index: number\n  /** When `true`, prevents the user from interacting with the pin input */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, nextTick, onMounted, onUnmounted, watch } from 'vue'\n\nconst props = withDefaults(defineProps<PinInputInputProps>(), {\n  as: 'input',\n})\n\nconst context = injectPinInputRootContext()\nconst inputElements = computed(() => Array.from(context.inputElements!.value))\nconst currentValue = computed(() => context.currentModelValue.value[props.index])\n\nconst disabled = computed(() => props.disabled || context.disabled.value)\nconst isOtpMode = computed(() => context.otp.value)\nconst isPasswordMode = computed(() => context.mask.value)\n\nconst { primitiveElement, currentElement } = usePrimitiveElement()\nfunction handleInput(event: InputEvent) {\n  const target = event.target as HTMLInputElement\n\n  if ((event.data?.length ?? 0) > 1) {\n    handleMultipleCharacter(target.value)\n    return\n  }\n\n  if (context.isNumericMode.value && !/^\\d*$/.test(target.value)) {\n    target.value = target.value.replace(/\\D/g, '')\n    return\n  }\n\n  target.value = target.value.slice(-1)\n  updateModelValueAt(props.index, target.value)\n\n  const nextEl = inputElements.value[props.index + 1]\n  if (nextEl)\n    nextEl.focus()\n}\n\nfunction resetPlaceholder() {\n  const target = currentElement.value as HTMLInputElement\n  nextTick(() => {\n    if (target && !target.value)\n      target.placeholder = context.placeholder.value\n  })\n}\n\nfunction handleKeydown(event: KeyboardEvent) {\n  useArrowNavigation(event, getActiveElement() as HTMLElement, undefined, {\n    itemsArray: inputElements.value,\n    focus: true,\n    loop: false,\n    arrowKeyOptions: 'horizontal',\n    dir: context.dir.value,\n  })\n}\n\nfunction handleBackspace(event: KeyboardEvent) {\n  event.preventDefault()\n  const target = event.target as HTMLInputElement\n  const value = target.value\n\n  if (value) {\n    updateModelValueAt(props.index, '')\n  }\n  else {\n    const prevEl = inputElements.value[props.index - 1]\n    if (prevEl) {\n      prevEl.focus()\n      updateModelValueAt(props.index - 1, '')\n    }\n  }\n}\n\nfunction handleDelete(event: KeyboardEvent) {\n  if (event.key === 'Delete') {\n    event.preventDefault()\n    updateModelValueAt(props.index, '')\n  }\n}\n\nfunction handleFocus(event: FocusEvent) {\n  const target = event.target as HTMLInputElement\n  target.setSelectionRange(1, 1)\n\n  if (!target.value)\n    target.placeholder = ''\n}\n\nfunction handleBlur(event: FocusEvent) {\n  resetPlaceholder()\n}\n\nfunction handlePaste(event: ClipboardEvent) {\n  event.preventDefault()\n  const clipboardData = event.clipboardData\n  if (!clipboardData)\n    return\n\n  const values = clipboardData.getData('text')\n  handleMultipleCharacter(values)\n}\n\nfunction handleMultipleCharacter(values: string) {\n  const tempModelValue = [...context.currentModelValue.value] as PinInputValue<typeof context.type.value>\n  const initialIndex = values.length >= inputElements.value.length ? 0 : props.index\n  const lastIndex = Math.min(initialIndex + values.length, inputElements.value.length)\n  for (let i = initialIndex; i < lastIndex; i++) {\n    const input = inputElements.value[i]\n    const value = values[i - initialIndex]\n    if (context.isNumericMode.value && !/^\\d*$/.test(value))\n      continue\n\n    tempModelValue[i] = value\n    input.focus()\n  }\n  context.modelValue.value = tempModelValue\n  inputElements.value[lastIndex]?.focus()\n}\n\nfunction removeTrailingEmptyStrings(input: PinInputValue<typeof context.type.value>) {\n  let i = input.length - 1\n\n  while (i >= 0 && input[i] === '') {\n    input.pop()\n    i--\n  }\n\n  return input\n}\n\nfunction updateModelValueAt(index: number, value: string) {\n  const tempModelValue = [...context.currentModelValue.value] as PinInputValue<typeof context.type.value>\n\n  if (context.isNumericMode.value) {\n    const num = +value\n\n    if (value === '' || isNaN(num)) {\n      delete tempModelValue[index]\n    }\n    else {\n      tempModelValue[index] = num\n    }\n  }\n  else {\n    tempModelValue[index] = value\n  }\n\n  context.modelValue.value = removeTrailingEmptyStrings(tempModelValue)\n}\n\nwatch(currentValue, () => {\n  if (!currentValue.value) {\n    resetPlaceholder()\n  }\n})\n\nonMounted(() => {\n  context.onInputElementChange(currentElement.value as HTMLInputElement)\n})\nonUnmounted(() => {\n  context.inputElements?.value.delete(currentElement.value as HTMLInputElement)\n})\n</script>\n\n<template>\n  <Primitive\n    ref=\"primitiveElement\"\n    autocapitalize=\"none\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :autocomplete=\"isOtpMode ? 'one-time-code' : 'false'\"\n    :type=\"isPasswordMode ? 'password' : 'text'\"\n    :inputmode=\"context.isNumericMode.value ? 'numeric' : 'text'\"\n    :pattern=\"context.isNumericMode.value ? '[0-9]*' : undefined\"\n    :placeholder=\"context.placeholder.value\"\n    :value=\"currentValue\"\n    :disabled=\"disabled\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-complete=\"context.isCompleted.value ? '' : undefined\"\n    :aria-label=\"`pin input ${index + 1} of ${inputElements.length}`\"\n    @input=\"handleInput($event as InputEvent)\"\n    @keydown.left.right.up.down.home.end=\"handleKeydown\"\n    @keydown.backspace=\"handleBackspace\"\n    @keydown.delete=\"handleDelete\"\n    @focus=\"handleFocus\"\n    @blur=\"handleBlur\"\n    @paste=\"handlePaste\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, isNullish, useForwardExpose } from '@/shared'\n\nexport type ProgressRootEmits = {\n  /** Event handler called when the progress value changes */\n  'update:modelValue': [value: string[] | undefined]\n  /** Event handler called when the max value changes */\n  'update:max': [value: number]\n}\n\nexport interface ProgressRootProps extends PrimitiveProps {\n  /** The progress value. Can be bind as `v-model`. */\n  modelValue?: number | null\n  /** The maximum progress value. */\n  max?: number\n  /**\n   * A function to get the accessible label text in a human-readable format.\n   *\n   *  If not provided, the value label will be read as the numeric value as a percentage of the max value.\n   */\n  getValueLabel?: (value: number | null | undefined, max: number) => string | undefined\n  /**\n   * A function to get the accessible value text representing the current value in a human-readable format.\n   */\n  getValueText?: (value: number | null | undefined, max: number) => string | undefined\n}\n\nconst DEFAULT_MAX = 100\n\ninterface ProgressRootContext {\n  modelValue?: Readonly<Ref<ProgressRootProps['modelValue']>>\n  max: Readonly<Ref<number>>\n  progressState: ComputedRef<ProgressState>\n}\n\nexport const [injectProgressRootContext, provideProgressRootContext]\n  = createContext<ProgressRootContext>('ProgressRoot')\n\nexport type ProgressState = 'indeterminate' | 'loading' | 'complete'\n\nconst isNumber = (v: any): v is number => typeof v === 'number'\n\nfunction validateValue(value: any, max: number): number | null {\n  const isValidValueError\n    = isNullish(value)\n      || (isNumber(value) && !Number.isNaN(value) && value <= max && value >= 0)\n\n  if (isValidValueError)\n    return value as null\n\n  console.error(`Invalid prop \\`value\\` of value \\`${value}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${DEFAULT_MAX} if no \\`max\\` prop is set)\n  - \\`null\\`  or \\`undefined\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`)\n  return null\n}\n\nfunction validateMax(max: number): number {\n  const isValidMaxError = isNumber(max) && !Number.isNaN(max) && max > 0\n\n  if (isValidMaxError)\n    return max\n\n  console.error(\n    `Invalid prop \\`max\\` of value \\`${max}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${DEFAULT_MAX}\\`.`,\n  )\n  return DEFAULT_MAX\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, nextTick, watch } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<ProgressRootProps>(), {\n  max: DEFAULT_MAX,\n  getValueLabel: (value: number | null | undefined, max: number) =>\n    isNumber(value) ? `${Math.round((value / max) * DEFAULT_MAX)}%` : undefined,\n})\n\nconst emit = defineEmits<ProgressRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nuseForwardExpose()\nconst modelValue = useVModel(props, 'modelValue', emit, {\n  passive: (props.modelValue === undefined) as false,\n})\n\nconst max = useVModel(props, 'max', emit, {\n  passive: (props.max === undefined) as false,\n})\n\n// ------- Watch for correct values -------\nwatch(\n  () => modelValue.value,\n  async (value) => {\n    const correctedValue = validateValue(value, props.max)\n    if (correctedValue !== value) {\n      await nextTick()\n      modelValue.value = correctedValue\n    }\n  },\n  { immediate: true },\n)\n\nwatch(\n  () => props.max,\n  (newMax) => {\n    const correctedMax = validateMax(props.max)\n    if (correctedMax !== newMax)\n      max.value = correctedMax\n  },\n  { immediate: true },\n)\n// ------- End of watch for correct values -------\n\nconst progressState = computed<ProgressState>(() => {\n  if (isNullish(modelValue.value))\n    return 'indeterminate'\n  if (modelValue.value === max.value)\n    return 'complete'\n  return 'loading'\n})\n\nprovideProgressRootContext({\n  modelValue,\n  max,\n  progressState,\n})\n</script>\n\n<template>\n  <Primitive\n    :as-child=\"asChild\"\n    :as=\"as\"\n    :aria-valuemax=\"max\"\n    :aria-valuemin=\"0\"\n    :aria-valuenow=\"isNumber(modelValue) ? modelValue : undefined\"\n    :aria-valuetext=\"getValueText?.(modelValue, max)\"\n    :aria-label=\"getValueLabel(modelValue, max)\"\n    role=\"progressbar\"\n    :data-state=\"progressState\"\n    :data-value=\"modelValue ?? undefined\"\n    :data-max=\"max\"\n  >\n    <slot :model-value=\"modelValue\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ProgressIndicatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectProgressRootContext } from './ProgressRoot.vue'\n\nconst props = defineProps<ProgressIndicatorProps>()\n\nconst rootContext = injectProgressRootContext()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :data-state=\"rootContext.progressState.value\"\n    :data-value=\"rootContext.modelValue?.value ?? undefined\"\n    :data-max=\"rootContext.max.value\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import type { AcceptableValue } from '@/shared/types'\nimport { handleAndDispatchCustomEvent } from '@/shared'\n\nexport type SelectEvent = CustomEvent<{ originalEvent: MouseEvent, value?: AcceptableValue }>\nexport const RADIO_SELECT = 'radio.select'\n\nexport function handleSelect(event: MouseEvent, value: AcceptableValue | undefined, callback: (event: SelectEvent) => void) {\n  const eventDetail = { originalEvent: event, value }\n  handleAndDispatchCustomEvent(RADIO_SELECT, callback, eventDetail)\n}\n", "<script lang=\"ts\">\nimport type { SelectEvent } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue, FormFieldProps } from '@/shared/types'\n\nexport type RadioEmits = {\n  'update:checked': [value: boolean]\n  'select': [SelectEvent]\n}\n\nexport interface RadioProps extends PrimitiveProps, FormFieldProps {\n  id?: string\n  /** The value given as data when submitted with a `name`. */\n  value?: AcceptableValue\n  /** When `true`, prevents the user from interacting with the radio item. */\n  disabled?: boolean\n  checked?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useFormControl, useForwardExpose } from '@/shared'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\nimport { handleSelect } from './utils'\n\nconst props = withDefaults(defineProps<RadioProps>(), {\n  disabled: false,\n  checked: undefined,\n  as: 'button',\n})\nconst emits = defineEmits<RadioEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current checked state */\n    checked: typeof checked.value\n  }) => any\n}>()\n\nconst checked = useVModel(props, 'checked', emits, {\n  passive: (props.checked === undefined) as false,\n})\n\nconst { value } = toRefs(props)\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\nconst isFormControl = useFormControl(triggerElement)\n\nconst ariaLabel = computed(() => props.id && triggerElement.value ? (document.querySelector(`[for=\"${props.id}\"]`) as HTMLLabelElement)?.innerText ?? props.value : undefined)\n\nfunction handleClick(event: MouseEvent) {\n  if (props.disabled)\n    return\n\n  handleSelect(event, props.value, (ev) => {\n    emits('select', ev)\n    if (ev?.defaultPrevented)\n      return\n\n    checked.value = true\n    if (isFormControl.value) {\n    // if radio is in a form, stop propagation from the button so that we only propagate\n    // one click event (from the input). We propagate changes from an input so that native\n    // form validation works and form events reflect radio updates.\n      ev.stopPropagation()\n    }\n  })\n}\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    :id=\"id\"\n    :ref=\"forwardRef\"\n    role=\"radio\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :as=\"as\"\n    :aria-checked=\"checked\"\n    :aria-label=\"ariaLabel\"\n    :as-child=\"asChild\"\n    :disabled=\"disabled ? '' : undefined\"\n    :data-state=\"checked ? 'checked' : 'unchecked'\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :value=\"value\"\n    :required=\"required\"\n    :name=\"name\"\n    @click.stop=\"handleClick\"\n  >\n    <slot :checked=\"checked\" />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name\"\n      type=\"radio\"\n      tabindex=\"-1\"\n      :value=\"value\"\n      :checked=\"!!checked\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue, DataOrientation, Direction, FormFieldProps } from '@/shared/types'\nimport { createContext, useDirection, useFormControl, useForwardExpose } from '@/shared'\n\nexport interface RadioGroupRootProps extends PrimitiveProps, FormFieldProps {\n  /** The controlled value of the radio item to check. Can be binded as `v-model`. */\n  modelValue?: AcceptableValue\n  /**\n   * The value of the radio item that should be checked when initially rendered.\n   *\n   * Use when you do not need to control the state of the radio items.\n   */\n  defaultValue?: AcceptableValue\n  /** When `true`, prevents the user from interacting with radio items. */\n  disabled?: boolean\n  /** The orientation of the component. */\n  orientation?: DataOrientation\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** When `true`, keyboard navigation will loop from last item to first, and vice versa. */\n  loop?: boolean\n}\nexport type RadioGroupRootEmits = {\n  /** Event handler called when the radio group value changes */\n  'update:modelValue': [payload: string]\n}\n\ninterface RadioGroupRootContext {\n  modelValue?: Readonly<Ref<AcceptableValue | undefined>>\n  changeModelValue: (value?: AcceptableValue) => void\n  disabled: Ref<boolean>\n  loop: Ref<boolean>\n  orientation: Ref<DataOrientation | undefined>\n  name?: string\n  required: Ref<boolean>\n}\n\nexport const [injectRadioGroupRootContext, provideRadioGroupRootContext]\n  = createContext<RadioGroupRootContext>('RadioGroupRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusGroup } from '@/RovingFocus'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\n\nconst props = withDefaults(defineProps<RadioGroupRootProps>(), {\n  disabled: false,\n  required: false,\n  orientation: undefined,\n  loop: true,\n})\n\nconst emits = defineEmits<RadioGroupRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n})\n\nconst { disabled, loop, orientation, name, required, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nconst isFormControl = useFormControl(currentElement)\n\nprovideRadioGroupRootContext({\n  modelValue,\n  changeModelValue: (value) => {\n    modelValue.value = value\n  },\n  disabled,\n  loop,\n  orientation,\n  name: name?.value,\n  required,\n})\n</script>\n\n<template>\n  <RovingFocusGroup\n    as-child\n    :orientation=\"orientation\"\n    :dir=\"dir\"\n    :loop=\"loop\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"radiogroup\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      :aria-orientation=\"orientation\"\n      :aria-required=\"required\"\n      :dir=\"dir\"\n    >\n      <slot :model-value=\"modelValue\" />\n\n      <VisuallyHiddenInput\n        v-if=\"isFormControl && name\"\n        :required=\"required\"\n        :disabled=\"disabled\"\n        :value=\"modelValue\"\n        :name=\"name\"\n      />\n    </Primitive>\n  </RovingFocusGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef } from 'vue'\nimport type { RadioProps } from './Radio.vue'\nimport type { SelectEvent } from './utils'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface RadioGroupItemProps extends Omit<RadioProps, 'checked'> {}\nexport type RadioGroupItemEmits = {\n  select: [event: SelectEvent]\n}\n\ninterface RadioGroupItemContext {\n  disabled: ComputedRef<boolean>\n  checked: ComputedRef<boolean>\n}\n\nexport const [injectRadioGroupItemContext, provideRadiogroupItemContext]\n  = createContext<RadioGroupItemContext>('RadioGroupItem')\n</script>\n\n<script setup lang=\"ts\">\nimport { useEventListener } from '@vueuse/core'\nimport { isEqual } from 'ohash'\nimport { computed, ref } from 'vue'\nimport { RovingFocusItem } from '@/RovingFocus'\nimport Radio from './Radio.vue'\nimport { injectRadioGroupRootContext } from './RadioGroupRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<RadioGroupItemProps>(), {\n  disabled: false,\n  as: 'button',\n})\n\nconst emits = defineEmits<RadioGroupItemEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current checked state */\n    checked: typeof checked.value\n    /** Required state */\n    required: typeof required.value\n    /** Disabled state */\n    disabled: typeof disabled.value\n  }) => any\n}>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst rootContext = injectRadioGroupRootContext()\n\nconst disabled = computed(() => rootContext.disabled.value || props.disabled)\nconst required = computed(() => rootContext.required.value || props.required)\nconst checked = computed(() => isEqual(rootContext.modelValue?.value, props.value))\n\nprovideRadiogroupItemContext({ disabled, checked })\n\nconst isArrowKeyPressed = ref(false)\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight']\n\nuseEventListener('keydown', (event) => {\n  if (ARROW_KEYS.includes(event.key))\n    isArrowKeyPressed.value = true\n})\nuseEventListener('keyup', () => {\n  isArrowKeyPressed.value = false\n})\n\nfunction handleFocus() {\n  setTimeout(() => {\n    /**\n     * Our `RovingFocusGroup` will focus the radio when navigating with arrow keys\n     * and we need to 'check' it in that case. We click it to 'check' it (instead\n     * of updating `context.value`) so that the radio change event fires.\n     */\n    if (isArrowKeyPressed.value)\n      currentElement.value?.click()\n  }, 0)\n}\n</script>\n\n<template>\n  <RovingFocusItem\n    :checked=\"checked\"\n    :disabled=\"disabled\"\n    as-child\n    :focusable=\"!disabled\"\n    :active=\"checked\"\n  >\n    <Radio\n      v-bind=\"{ ...$attrs, ...props }\"\n      :ref=\"forwardRef\"\n      :checked=\"checked\"\n      :required=\"required\"\n      :disabled=\"disabled\"\n      @update:checked=\"rootContext.changeModelValue(value)\"\n      @select=\"emits('select', $event)\"\n      @keydown.enter.prevent\n      @focus=\"handleFocus\"\n    >\n      <slot\n        :checked=\"checked\"\n        :required=\"required\"\n        :disabled=\"disabled\"\n      />\n    </Radio>\n  </RovingFocusItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface RadioGroupIndicatorProps extends PrimitiveProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { Primitive } from '@/Primitive'\nimport { injectRadioGroupItemContext } from './RadioGroupItem.vue'\n\nwithDefaults(defineProps<RadioGroupIndicatorProps>(), {\n  as: 'span',\n})\n\nconst { forwardRef } = useForwardExpose()\nconst itemContext = injectRadioGroupItemContext()\n</script>\n\n<template>\n  <Presence\n    :present=\"forceMount || itemContext.checked.value\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :data-state=\"itemContext.checked.value ? 'checked' : 'unchecked'\"\n      :data-disabled=\"itemContext.disabled.value ? '' : undefined\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      v-bind=\"$attrs\"\n    >\n      <slot />\n    </Primitive>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Direction, ScrollType } from './types'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\nexport interface ScrollAreaRootContext {\n  type: Ref<ScrollType>\n  dir: Ref<Direction>\n  scrollHideDelay: Ref<number>\n  scrollArea: Ref<HTMLElement | undefined>\n  viewport: Ref<HTMLElement | undefined>\n  onViewportChange: (viewport: HTMLElement | null) => void\n  content: Ref<HTMLElement | undefined>\n  onContentChange: (content: HTMLElement) => void\n  scrollbarX: Ref<HTMLElement | undefined>\n  onScrollbarXChange: (scrollbar: HTMLElement | null) => void\n  scrollbarXEnabled: Ref<boolean>\n  onScrollbarXEnabledChange: (rendered: boolean) => void\n  scrollbarY: Ref<HTMLElement | undefined>\n  onScrollbarYChange: (scrollbar: HTMLElement | null) => void\n  scrollbarYEnabled: Ref<boolean>\n  onScrollbarYEnabledChange: (rendered: boolean) => void\n  onCornerWidthChange: (width: number) => void\n  onCornerHeightChange: (height: number) => void\n}\n\nexport const [injectScrollAreaRootContext, provideScrollAreaRootContext]\n  = createContext<ScrollAreaRootContext>('ScrollAreaRoot')\n\nexport interface ScrollAreaRootProps extends PrimitiveProps {\n  /**\n   * Describes the nature of scrollbar visibility, similar to how the scrollbar preferences in MacOS control visibility of native scrollbars.\n   *\n   * `auto` - means that scrollbars are visible when content is overflowing on the corresponding orientation. <br>\n   * `always` - means that scrollbars are always visible regardless of whether the content is overflowing.<br>\n   * `scroll` - means that scrollbars are visible when the user is scrolling along its corresponding orientation.<br>\n   * `hover` - when the user is scrolling along its corresponding orientation and when the user is hovering over the scroll area.\n   */\n  type?: ScrollType\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** If type is set to either `scroll` or `hover`, this prop determines the length of time, in milliseconds, <br> before the scrollbars are hidden after the user stops interacting with scrollbars. */\n  scrollHideDelay?: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<ScrollAreaRootProps>(), {\n  type: 'hover',\n  scrollHideDelay: 600,\n})\n\nconst cornerWidth = ref(0)\nconst cornerHeight = ref(0)\nconst viewport = ref<HTMLElement>()\nconst content = ref<HTMLElement>()\nconst scrollbarX = ref<HTMLElement>()\nconst scrollbarY = ref<HTMLElement>()\nconst scrollbarXEnabled = ref(false)\nconst scrollbarYEnabled = ref(false)\n\nconst { type, dir: propDir, scrollHideDelay } = toRefs(props)\nconst dir = useDirection(propDir)\n\nfunction scrollTop() {\n  viewport.value?.scrollTo({\n    top: 0,\n  })\n}\nfunction scrollTopLeft() {\n  viewport.value?.scrollTo({\n    top: 0,\n    left: 0,\n  })\n}\n\ndefineExpose({\n  /** Viewport element within ScrollArea */\n  viewport,\n  /** Scroll viewport to top */\n  scrollTop,\n  /** Scroll viewport to top-left */\n  scrollTopLeft,\n})\n\nconst { forwardRef, currentElement: scrollArea } = useForwardExpose()\n\nprovideScrollAreaRootContext({\n  type,\n  dir,\n  scrollHideDelay,\n  scrollArea,\n  viewport,\n  onViewportChange: (el) => {\n    viewport.value = el || undefined\n  },\n  content,\n  onContentChange: (el) => {\n    content.value = el\n  },\n  scrollbarX,\n  scrollbarXEnabled,\n  scrollbarY,\n  scrollbarYEnabled,\n  onScrollbarXChange: (scrollbar) => {\n    scrollbarX.value = scrollbar || undefined\n  },\n  onScrollbarYChange: (scrollbar) => {\n    scrollbarY.value = scrollbar || undefined\n  },\n  onScrollbarXEnabledChange: (rendered) => {\n    scrollbarXEnabled.value = rendered\n  },\n  onScrollbarYEnabledChange: (rendered) => {\n    scrollbarYEnabled.value = rendered\n  },\n  onCornerWidthChange: (width) => {\n    cornerWidth.value = width\n  },\n  onCornerHeightChange: (height) => {\n    cornerHeight.value = height\n  },\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as-child=\"props.asChild\"\n    :as=\"as\"\n    :dir=\"dir\"\n    :style=\"{\n      position: 'relative',\n      // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n      ['--reka-scroll-area-corner-width' as any]: `${cornerWidth}px`,\n      ['--reka-scroll-area-corner-height' as any]: `${cornerHeight}px`,\n    }\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script setup lang=\"ts\">\nimport { useResizeObserver } from '@vueuse/core'\nimport { computed, ref, watch } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\n\nconst rootContext = injectScrollAreaRootContext()\n\nconst width = ref(0)\nconst height = ref(0)\n\nconst hasSize = computed(() => !!width.value && !!height.value)\n\nfunction setCornerHeight() {\n  const offsetHeight = rootContext.scrollbarX.value?.offsetHeight || 0\n  rootContext.onCornerHeightChange(offsetHeight)\n  height.value = offsetHeight\n}\nfunction setCornerWidth() {\n  const offsetWidth = rootContext.scrollbarY.value?.offsetWidth || 0\n  rootContext.onCornerWidthChange(offsetWidth)\n  width.value = offsetWidth\n}\n\nuseResizeObserver(rootContext.scrollbarX.value, setCornerHeight)\nuseResizeObserver(rootContext.scrollbarY.value, setCornerWidth)\n\n// because we are not remounting the component, useResizeObserver doesn't trigger, thus using watcher here\nwatch(() => rootContext.scrollbarX.value, setCornerHeight)\nwatch(() => rootContext.scrollbarY.value, setCornerWidth)\n</script>\n\n<template>\n  <Primitive\n    v-if=\"hasSize\"\n    :style=\"{\n      width: `${width}px`,\n      height: `${height}px`,\n      position: 'absolute',\n      right: rootContext.dir.value === 'ltr' ? 0 : undefined,\n      left: rootContext.dir.value === 'rtl' ? 0 : undefined,\n      bottom: 0,\n    }\"\n    v-bind=\"$parent?.$props\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ScrollAreaCornerProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport ScrollAreaCornerImpl from './ScrollAreaCornerImpl.vue'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\n\nconst props = defineProps<ScrollAreaCornerProps>()\n\nconst { forwardRef } = useForwardExpose()\nconst rootContext = injectScrollAreaRootContext()\n\nconst hasBothScrollbarsVisible = computed(\n  () => !!rootContext.scrollbarX.value && !!rootContext.scrollbarY.value,\n)\nconst hasCorner = computed(\n  () => rootContext.type.value !== 'scroll' && hasBothScrollbarsVisible.value,\n)\n</script>\n\n<template>\n  <ScrollAreaCornerImpl\n    v-if=\"hasCorner\"\n    v-bind=\"props\"\n    :ref=\"forwardRef\"\n  >\n    <slot />\n  </ScrollAreaCornerImpl>\n</template>\n", "import type { Direction, Sizes } from './types'\nimport { clamp } from '@/shared'\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(\n  input: readonly [number, number],\n  output: readonly [number, number],\n) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1])\n      return output[0]\n    const ratio = (output[1] - output[0]) / (input[1] - input[0])\n    return output[0] + ratio * (value - input[0])\n  }\n}\n\nexport function getThumbSize(sizes: Sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content)\n  const scrollbarPadding\n    = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio\n  // minimum of 18 matches macOS minimum\n  return Math.max(thumbSize, 18)\n}\n\nexport function getThumbRatio(viewportSize: number, contentSize: number) {\n  const ratio = viewportSize / contentSize\n  return Number.isNaN(ratio) ? 0 : ratio\n}\n\n// Custom scroll handler to avoid scroll-linked effects\n// https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\nexport function addUnlinkedScrollListener(\n  node: HTMLElement,\n  handler = () => {},\n) {\n  let prevPosition = { left: node.scrollLeft, top: node.scrollTop }\n  let rAF = 0;\n  (function loop() {\n    const position = { left: node.scrollLeft, top: node.scrollTop }\n    const isHorizontalScroll = prevPosition.left !== position.left\n    const isVerticalScroll = prevPosition.top !== position.top\n    if (isHorizontalScroll || isVerticalScroll)\n      handler()\n    prevPosition = position\n    rAF = window.requestAnimationFrame(loop)\n  })()\n  return () => window.cancelAnimationFrame(rAF)\n}\n\nexport function getThumbOffsetFromScroll(\n  scrollPos: number,\n  sizes: Sizes,\n  dir: Direction = 'ltr',\n) {\n  const thumbSizePx = getThumbSize(sizes)\n  const scrollbarPadding\n    = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding\n  const maxScrollPos = sizes.content - sizes.viewport\n  const maxThumbPos = scrollbar - thumbSizePx\n  const scrollClampRange\n    = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0]\n  const scrollWithoutMomentum = clamp(\n    scrollPos,\n    scrollClampRange[0],\n    scrollClampRange[1],\n  )\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos])\n  return interpolate(scrollWithoutMomentum)\n}\n\nexport function toInt(value?: string) {\n  return value ? Number.parseInt(value, 10) : 0\n}\n\nexport function getScrollPositionFromPointer(\n  pointerPos: number,\n  pointerOffset: number,\n  sizes: Sizes,\n  dir: Direction = 'ltr',\n) {\n  const thumbSizePx = getThumbSize(sizes)\n  const thumbCenter = thumbSizePx / 2\n  const offset = pointerOffset || thumbCenter\n  const thumbOffsetFromEnd = thumbSizePx - offset\n  const minPointerPos = sizes.scrollbar.paddingStart + offset\n  const maxPointerPos\n    = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd\n  const maxScrollPos = sizes.content - sizes.viewport\n  const scrollRange\n    = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0]\n  const interpolate = linearScale(\n    [minPointerPos, maxPointerPos],\n    scrollRange as [number, number],\n  )\n  return interpolate(pointerPos)\n}\n\nexport function isScrollingWithinScrollbarBounds(\n  scrollPos: number,\n  maxScrollPos: number,\n) {\n  return scrollPos > 0 && scrollPos < maxScrollPos\n}\n", "<script lang=\"ts\">\ntype ScrollbarAreaScrollbarImplEmits = {\n  onDragScroll: [payload: { x: number, y: number }]\n  onWheelScroll: [payload: { x: number, y: number }]\n  onThumbPointerDown: [payload: { x: number, y: number }]\n}\n\nexport interface ScrollAreaScrollbarImplProps {\n  isHorizontal: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useResizeObserver } from '@vueuse/core'\nimport { onMounted, onUnmounted, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport { injectScrollAreaScrollbarContext } from './ScrollAreaScrollbar.vue'\nimport { injectScrollAreaScrollbarVisibleContext } from './ScrollAreaScrollbarVisible.vue'\nimport { toInt } from './utils'\n\nconst props = defineProps<ScrollAreaScrollbarImplProps>()\nconst emit = defineEmits<ScrollbarAreaScrollbarImplEmits>()\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext()\nconst scrollbarContext = injectScrollAreaScrollbarContext()\n\nconst { forwardRef, currentElement: scrollbar } = useForwardExpose()\nconst prevWebkitUserSelectRef = ref('')\nconst rectRef = ref<DOMRect>()\n\nfunction handleDragScroll(event: MouseEvent) {\n  if (rectRef.value) {\n    const x = event.clientX - rectRef.value?.left\n    const y = event.clientY - rectRef.value?.top\n    emit('onDragScroll', { x, y })\n  }\n}\n\nfunction handlePointerDown(event: PointerEvent) {\n  const mainPointer = 0\n  if (event.button === mainPointer) {\n    const element = event.target as HTMLElement\n    element.setPointerCapture(event.pointerId)\n    rectRef.value = scrollbar.value!.getBoundingClientRect()\n\n    // pointer capture doesn't prevent text selection in Safari\n    // so we remove text selection manually when scrolling\n    prevWebkitUserSelectRef.value = document.body.style.webkitUserSelect\n    document.body.style.webkitUserSelect = 'none'\n    if (rootContext.viewport)\n      rootContext.viewport.value!.style.scrollBehavior = 'auto'\n\n    handleDragScroll(event)\n  }\n}\n\nfunction handlePointerMove(event: PointerEvent) {\n  handleDragScroll(event)\n}\n\nfunction handlePointerUp(event: PointerEvent) {\n  const element = event.target as HTMLElement\n  if (element.hasPointerCapture(event.pointerId))\n    element.releasePointerCapture(event.pointerId)\n\n  document.body.style.webkitUserSelect = prevWebkitUserSelectRef.value\n  if (rootContext.viewport)\n    rootContext.viewport.value!.style.scrollBehavior = ''\n\n  rectRef.value = undefined\n}\n\nfunction handleWheel(event: WheelEvent) {\n  const element = event.target as HTMLElement\n  const isScrollbarWheel = scrollbar.value?.contains(element)\n  const maxScrollPos\n    = scrollbarVisibleContext.sizes.value.content\n      - scrollbarVisibleContext.sizes.value.viewport\n  if (isScrollbarWheel)\n    scrollbarVisibleContext.handleWheelScroll(event, maxScrollPos)\n}\n\nonMounted(() => {\n  document.addEventListener('wheel', handleWheel, { passive: false })\n})\nonUnmounted(() => {\n  document.removeEventListener('wheel', handleWheel)\n})\n\nfunction handleSizeChange() {\n  if (!scrollbar.value)\n    return\n  if (props.isHorizontal) {\n    scrollbarVisibleContext.handleSizeChange({\n      content: rootContext.viewport.value?.scrollWidth ?? 0,\n      viewport: rootContext.viewport.value?.offsetWidth ?? 0,\n      scrollbar: {\n        size: scrollbar.value.clientWidth ?? 0,\n        paddingStart: toInt(getComputedStyle(scrollbar.value).paddingLeft),\n        paddingEnd: toInt(getComputedStyle(scrollbar.value).paddingRight),\n      },\n    })\n  }\n  else {\n    scrollbarVisibleContext.handleSizeChange({\n      content: rootContext.viewport.value?.scrollHeight ?? 0,\n      viewport: rootContext.viewport.value?.offsetHeight ?? 0,\n      scrollbar: {\n        size: scrollbar.value?.clientHeight ?? 0,\n        paddingStart: toInt(getComputedStyle(scrollbar.value!).paddingLeft),\n        paddingEnd: toInt(getComputedStyle(scrollbar.value!).paddingRight),\n      },\n    })\n  }\n}\n\nuseResizeObserver(scrollbar, handleSizeChange)\nuseResizeObserver(rootContext.content, handleSizeChange)\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    style=\"position: absolute\"\n    data-scrollbarimpl\n    :as=\"scrollbarContext.as.value\"\n    :as-child=\"scrollbarContext.asChild.value\"\n    @pointerdown=\"handlePointerDown\"\n    @pointermove=\"handlePointerMove\"\n    @pointerup=\"handlePointerUp\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script setup lang=\"ts\">\nimport { computed, onMounted } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport ScrollAreaScrollbarImpl from './ScrollAreaScrollbarImpl.vue'\nimport { injectScrollAreaScrollbarVisibleContext } from './ScrollAreaScrollbarVisible.vue'\nimport { getThumbSize } from './utils'\n\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext()\n\nconst { forwardRef, currentElement: scrollbarElement } = useForwardExpose()\n\nonMounted(() => {\n  if (scrollbarElement.value)\n    rootContext.onScrollbarXChange(scrollbarElement.value)\n})\nconst sizes = computed(() => scrollbarVisibleContext.sizes.value)\n</script>\n\n<template>\n  <ScrollAreaScrollbarImpl\n    :ref=\"forwardRef\"\n    :is-horizontal=\"true\"\n    data-orientation=\"horizontal\"\n    :style=\"{\n      bottom: 0,\n      left: rootContext.dir.value === 'rtl' ? 'var(--reka-scroll-area-corner-width)' : 0,\n      right: rootContext.dir.value === 'ltr' ? 'var(--reka-scroll-area-corner-width)' : 0,\n      ['--reka-scroll-area-thumb-width' as any]: sizes ? `${getThumbSize(sizes)}px` : undefined,\n    }\"\n    @on-drag-scroll=\"scrollbarVisibleContext.onDragScroll($event.x)\"\n  >\n    <slot />\n  </ScrollAreaScrollbarImpl>\n</template>\n", "<script setup lang=\"ts\">\nimport { computed, onMounted } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport ScrollAreaScrollbarImpl from './ScrollAreaScrollbarImpl.vue'\nimport { injectScrollAreaScrollbarVisibleContext } from './ScrollAreaScrollbarVisible.vue'\nimport { getThumbSize } from './utils'\n\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext()\n\nconst { forwardRef, currentElement: scrollbarElement } = useForwardExpose()\n\nonMounted(() => {\n  if (scrollbarElement.value)\n    rootContext.onScrollbarYChange(scrollbarElement.value)\n})\n\nconst sizes = computed(() => scrollbarVisibleContext.sizes.value)\n</script>\n\n<template>\n  <ScrollAreaScrollbarImpl\n    :ref=\"forwardRef\"\n    :is-horizontal=\"false\"\n    data-orientation=\"vertical\"\n    :style=\"{\n      top: 0,\n      right: rootContext.dir.value === 'ltr' ? 0 : undefined,\n      left: rootContext.dir.value === 'rtl' ? 0 : undefined,\n      bottom: 'var(--reka-scroll-area-corner-height)',\n      ['--reka-scroll-area-thumb-height' as any]: sizes ? `${getThumbSize(sizes)}px` : undefined,\n    }\"\n    @on-drag-scroll=\"scrollbarVisibleContext.onDragScroll($event.y)\"\n  >\n    <slot />\n  </ScrollAreaScrollbarImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { Direction, Sizes } from './types'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface ScrollAreaScrollbarVisibleContext {\n  sizes: Ref<Sizes>\n  hasThumb: Ref<boolean>\n  handleWheelScroll: (event: WheelEvent, payload: number) => void\n  handleThumbDown: (\n    event: MouseEvent,\n    payload: { x: number, y: number }\n  ) => void\n  handleThumbUp: (event: MouseEvent) => void\n  handleSizeChange: (payload: Sizes) => void\n  onThumbPositionChange: () => void\n  onDragScroll: (payload: number) => void\n  onThumbChange: (element: HTMLElement) => void\n}\n\nexport const [injectScrollAreaScrollbarVisibleContext, provideScrollAreaScrollbarVisibleContext]\n  = createContext<ScrollAreaScrollbarVisibleContext>('ScrollAreaScrollbarVisible')\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport { injectScrollAreaScrollbarContext } from './ScrollAreaScrollbar.vue'\nimport ScrollAreaScrollbarX from './ScrollAreaScrollbarX.vue'\nimport ScrollAreaScrollbarY from './ScrollAreaScrollbarY.vue'\nimport {\n  getScrollPositionFromPointer,\n  getThumbOffsetFromScroll,\n  getThumbRatio,\n  isScrollingWithinScrollbarBounds,\n} from './utils'\n\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarContext = injectScrollAreaScrollbarContext()\nconst { forwardRef } = useForwardExpose()\n\nconst sizes = ref<Sizes>({\n  content: 0,\n  viewport: 0,\n  scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },\n})\n\nconst hasThumb = computed(() => {\n  const thumbRatio = getThumbRatio(sizes.value.viewport, sizes.value.content)\n  return Boolean(thumbRatio > 0 && thumbRatio < 1)\n})\n\nconst thumbRef = ref<HTMLElement>()\nconst pointerOffset = ref(0)\n\nfunction handleWheelScroll(event: WheelEvent, payload: number) {\n  if (isShowingScrollbarX.value) {\n    const scrollPos = rootContext.viewport.value!.scrollLeft + event.deltaY\n\n    rootContext.viewport.value!.scrollLeft = scrollPos\n    // prevent window scroll when wheeling on scrollbar\n    if (isScrollingWithinScrollbarBounds(scrollPos, payload))\n      event.preventDefault()\n  }\n  else {\n    const scrollPos = rootContext.viewport.value!.scrollTop + event.deltaY\n\n    rootContext.viewport.value!.scrollTop = scrollPos\n    // prevent window scroll when wheeling on scrollbar\n    if (isScrollingWithinScrollbarBounds(scrollPos, payload))\n      event.preventDefault()\n  }\n}\n\nfunction handleThumbDown(event: MouseEvent, payload: { x: number, y: number }) {\n  if (isShowingScrollbarX.value)\n    pointerOffset.value = payload.x\n  else pointerOffset.value = payload.y\n}\nfunction handleThumbUp(event: MouseEvent) {\n  pointerOffset.value = 0\n}\n\nfunction handleSizeChange(payload: Sizes) {\n  sizes.value = payload\n}\n\nfunction getScrollPosition(pointerPos: number, dir?: Direction) {\n  return getScrollPositionFromPointer(\n    pointerPos,\n    pointerOffset.value,\n    sizes.value,\n    dir,\n  )\n}\n\nconst isShowingScrollbarX = computed(\n  () => scrollbarContext.isHorizontal.value,\n)\n\nfunction onDragScroll(payload: number) {\n  if (isShowingScrollbarX.value) {\n    rootContext.viewport.value!.scrollLeft = getScrollPosition(\n      payload,\n      rootContext.dir.value,\n    )\n  }\n  else {\n    rootContext.viewport.value!.scrollTop = getScrollPosition(payload)\n  }\n}\n\nfunction onThumbPositionChange() {\n  if (isShowingScrollbarX.value) {\n    if (rootContext.viewport.value && thumbRef.value) {\n      const scrollPos = rootContext.viewport.value.scrollLeft\n      const offset = getThumbOffsetFromScroll(\n        scrollPos,\n        sizes.value,\n        rootContext.dir.value,\n      )\n      thumbRef.value.style.transform = `translate3d(${offset}px, 0, 0)`\n    }\n  }\n  else {\n    if (rootContext.viewport.value && thumbRef.value) {\n      const scrollPos = rootContext.viewport.value.scrollTop\n      const offset = getThumbOffsetFromScroll(scrollPos, sizes.value)\n      thumbRef.value.style.transform = `translate3d(0, ${offset}px, 0)`\n    }\n  }\n}\nfunction onThumbChange(element: HTMLElement) {\n  thumbRef.value = element\n}\n\nprovideScrollAreaScrollbarVisibleContext({\n  sizes,\n  hasThumb,\n  handleWheelScroll,\n  handleThumbDown,\n  handleThumbUp,\n  handleSizeChange,\n  onThumbPositionChange,\n  onThumbChange,\n  onDragScroll,\n})\n</script>\n\n<template>\n  <ScrollAreaScrollbarX\n    v-if=\"isShowingScrollbarX\"\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n  >\n    <slot />\n  </ScrollAreaScrollbarX>\n  <ScrollAreaScrollbarY\n    v-else\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n  >\n    <slot />\n  </ScrollAreaScrollbarY>\n</template>\n", "<script lang=\"ts\">\nexport interface ScrollAreaScrollbarAutoProps {\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useDebounceFn, useResizeObserver } from '@vueuse/core'\nimport { onMounted, ref } from 'vue'\nimport { Presence } from '@/Presence'\nimport { useForwardExpose } from '@/shared'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport { injectScrollAreaScrollbarContext } from './ScrollAreaScrollbar.vue'\nimport ScrollAreaScrollbarVisible from './ScrollAreaScrollbarVisible.vue'\n\ndefineProps<ScrollAreaScrollbarAutoProps>()\n\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarContext = injectScrollAreaScrollbarContext()\n\nconst { forwardRef } = useForwardExpose()\n\nconst visible = ref(false)\n\nconst handleResize = useDebounceFn(() => {\n  if (rootContext.viewport.value) {\n    const isOverflowX\n      = rootContext.viewport.value.offsetWidth\n        < rootContext.viewport.value.scrollWidth\n    const isOverflowY\n      = rootContext.viewport.value.offsetHeight\n        < rootContext.viewport.value.scrollHeight\n\n    visible.value = scrollbarContext.isHorizontal.value\n      ? isOverflowX\n      : isOverflowY\n  }\n}, 10)\n\nonMounted(() => handleResize())\n\nuseResizeObserver(rootContext.viewport, handleResize)\nuseResizeObserver(rootContext.content, handleResize)\n</script>\n\n<template>\n  <Presence :present=\"forceMount || visible\">\n    <ScrollAreaScrollbarVisible\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      :data-state=\"visible ? 'visible' : 'hidden'\"\n    >\n      <slot />\n    </ScrollAreaScrollbarVisible>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { ScrollAreaScrollbarAutoProps } from './ScrollAreaScrollbarAuto.vue'\n\nexport interface ScrollAreaScrollbarHoverProps extends ScrollAreaScrollbarAutoProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted, onUnmounted, ref } from 'vue'\nimport { Presence } from '@/Presence'\nimport { useForwardExpose } from '@/shared'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport ScrollAreaScrollbarAuto from './ScrollAreaScrollbarAuto.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\ndefineProps<ScrollAreaScrollbarHoverProps>()\n\nconst rootContext = injectScrollAreaRootContext()\n\nconst { forwardRef } = useForwardExpose()\n\nlet timeout: ReturnType<typeof setTimeout> | undefined | number\nconst visible = ref(false)\n\nfunction handlePointerEnter() {\n  window.clearTimeout(timeout)\n  visible.value = true\n}\nfunction handlePointerLeave() {\n  timeout = window.setTimeout(() => {\n    visible.value = false\n  }, rootContext.scrollHideDelay.value)\n}\n\nonMounted(() => {\n  const scrollArea = rootContext.scrollArea.value\n\n  if (scrollArea) {\n    scrollArea.addEventListener('pointerenter', handlePointerEnter)\n    scrollArea.addEventListener('pointerleave', handlePointerLeave)\n  }\n})\n\nonUnmounted(() => {\n  const scrollArea = rootContext.scrollArea.value\n  if (scrollArea) {\n    window.clearTimeout(timeout)\n    scrollArea.removeEventListener('pointerenter', handlePointerEnter)\n    scrollArea.removeEventListener('pointerleave', handlePointerLeave)\n  }\n})\n</script>\n\n<template>\n  <Presence :present=\"forceMount || visible\">\n    <ScrollAreaScrollbarAuto\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      :data-state=\"visible ? 'visible' : 'hidden'\"\n    >\n      <slot />\n    </ScrollAreaScrollbarAuto>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nexport interface ScrollAreaScrollbarScrollProps {\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useDebounceFn } from '@vueuse/core'\nimport { watchEffect } from 'vue'\nimport { Presence } from '@/Presence'\nimport { useForwardExpose } from '@/shared'\nimport { useStateMachine } from '../shared/useStateMachine'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport { injectScrollAreaScrollbarContext } from './ScrollAreaScrollbar.vue'\nimport ScrollAreaScrollbarVisible from './ScrollAreaScrollbarVisible.vue'\n\ndefineProps<ScrollAreaScrollbarScrollProps>()\n\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarContext = injectScrollAreaScrollbarContext()\n\nconst { forwardRef } = useForwardExpose()\n\nconst { state, dispatch } = useStateMachine('hidden', {\n  hidden: {\n    SCROLL: 'scrolling',\n  },\n  scrolling: {\n    SCROLL_END: 'idle',\n    POINTER_ENTER: 'interacting',\n  },\n  interacting: {\n    SCROLL: 'interacting',\n    POINTER_LEAVE: 'idle',\n  },\n  idle: {\n    HIDE: 'hidden',\n    SCROLL: 'scrolling',\n    POINTER_ENTER: 'interacting',\n  },\n})\n\nwatchEffect((onCleanup) => {\n  if (state.value === 'idle') {\n    const timeId = window.setTimeout(\n      () => dispatch('HIDE'),\n      rootContext.scrollHideDelay.value,\n    )\n\n    onCleanup(() => {\n      window.clearTimeout(timeId)\n    })\n  }\n})\n\nconst debounceScrollEnd = useDebounceFn(() => dispatch('SCROLL_END'), 100)\n\nwatchEffect((onCleanup) => {\n  const viewport = rootContext.viewport.value\n  const scrollDirection = scrollbarContext.isHorizontal.value\n    ? 'scrollLeft'\n    : 'scrollTop'\n\n  if (viewport) {\n    let prevScrollPos = viewport[scrollDirection]\n    const handleScroll = () => {\n      const scrollPos = viewport[scrollDirection]\n      const hasScrollInDirectionChanged = prevScrollPos !== scrollPos\n      if (hasScrollInDirectionChanged) {\n        dispatch('SCROLL')\n        debounceScrollEnd()\n      }\n      prevScrollPos = scrollPos\n    }\n    viewport.addEventListener('scroll', handleScroll)\n\n    onCleanup(() => {\n      viewport.removeEventListener('scroll', handleScroll)\n    })\n  }\n})\n</script>\n\n<template>\n  <Presence :present=\"forceMount || state !== 'hidden'\">\n    <ScrollAreaScrollbarVisible\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n    >\n      <slot />\n    </ScrollAreaScrollbarVisible>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface ScrollAreaScrollbarProps extends PrimitiveProps {\n  /** The orientation of the scrollbar */\n  orientation?: 'vertical' | 'horizontal'\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n\nexport interface ScrollAreaScollbarContext {\n  as: Ref<PrimitiveProps['as']>\n  orientation: Ref<'vertical' | 'horizontal'>\n  forceMount?: Ref<boolean>\n  isHorizontal: Ref<boolean>\n  asChild: Ref<boolean>\n}\n\nexport const [injectScrollAreaScrollbarContext, provideScrollAreaScrollbarContext]\n  = createContext<ScrollAreaScollbarContext>('ScrollAreaScrollbar')\n</script>\n\n<script setup lang=\"ts\">\nimport {\n  computed,\n  onUnmounted,\n  toRefs,\n  watch,\n} from 'vue'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport ScrollAreaScrollbarAuto from './ScrollAreaScrollbarAuto.vue'\nimport ScrollAreaScrollbarHover from './ScrollAreaScrollbarHover.vue'\nimport ScrollAreaScrollbarScroll from './ScrollAreaScrollbarScroll.vue'\nimport ScrollAreaScrollbarVisible from './ScrollAreaScrollbarVisible.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ScrollAreaScrollbarProps>(), {\n  orientation: 'vertical',\n  as: 'div',\n})\n\nconst { forwardRef } = useForwardExpose()\nconst rootContext = injectScrollAreaRootContext()\n\nconst isHorizontal = computed(() => props.orientation === 'horizontal')\n\nwatch(\n  isHorizontal,\n  () => {\n    if (isHorizontal.value)\n      rootContext.onScrollbarXEnabledChange(true)\n    else rootContext.onScrollbarYEnabledChange(true)\n  },\n  { immediate: true },\n)\n\nonUnmounted(() => {\n  rootContext.onScrollbarXEnabledChange(false)\n  rootContext.onScrollbarYEnabledChange(false)\n})\n\nconst { orientation, forceMount, asChild, as } = toRefs(props)\nprovideScrollAreaScrollbarContext({\n  orientation,\n  forceMount,\n  isHorizontal,\n  as,\n  asChild,\n})\n</script>\n\n<template>\n  <ScrollAreaScrollbarHover\n    v-if=\"rootContext.type.value === 'hover'\"\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n    :force-mount=\"forceMount\"\n  >\n    <slot />\n  </ScrollAreaScrollbarHover>\n  <ScrollAreaScrollbarScroll\n    v-else-if=\"rootContext.type.value === 'scroll'\"\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n    :force-mount=\"forceMount\"\n  >\n    <slot />\n  </ScrollAreaScrollbarScroll>\n  <ScrollAreaScrollbarAuto\n    v-else-if=\"rootContext.type.value === 'auto'\"\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n    :force-mount=\"forceMount\"\n  >\n    <slot />\n  </ScrollAreaScrollbarAuto>\n  <ScrollAreaScrollbarVisible\n    v-else-if=\"rootContext.type.value === 'always'\"\n    v-bind=\"$attrs\"\n    :ref=\"forwardRef\"\n    data-state=\"visible\"\n  >\n    <slot />\n  </ScrollAreaScrollbarVisible>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ScrollAreaThumbProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { watchOnce } from '@vueuse/core'\nimport { computed, onUnmounted, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\nimport { injectScrollAreaScrollbarVisibleContext } from './ScrollAreaScrollbarVisible.vue'\nimport { addUnlinkedScrollListener } from './utils'\n\nconst props = defineProps<ScrollAreaThumbProps>()\n\nconst rootContext = injectScrollAreaRootContext()\nconst scrollbarContextVisible = injectScrollAreaScrollbarVisibleContext()\n\nfunction handlePointerDown(event: MouseEvent) {\n  const thumb = event.target as HTMLElement\n  const thumbRect = thumb.getBoundingClientRect()\n  const x = event.clientX - thumbRect.left\n  const y = event.clientY - thumbRect.top\n  scrollbarContextVisible.handleThumbDown(event, { x, y })\n}\n\nfunction handlePointerUp(event: MouseEvent) {\n  scrollbarContextVisible.handleThumbUp(event)\n}\n\nconst { forwardRef, currentElement: thumbElement } = useForwardExpose()\nconst removeUnlinkedScrollListenerRef = ref<() => void>()\nconst viewport = computed(() => rootContext.viewport.value)\n\nfunction handleScroll() {\n  if (!removeUnlinkedScrollListenerRef.value) {\n    const listener = addUnlinkedScrollListener(\n      viewport.value!,\n      scrollbarContextVisible.onThumbPositionChange,\n    )\n    removeUnlinkedScrollListenerRef.value = listener\n    scrollbarContextVisible.onThumbPositionChange()\n  }\n}\n\nconst sizes = computed(() => scrollbarContextVisible.sizes.value)\n\nwatchOnce(sizes, () => {\n  scrollbarContextVisible.onThumbChange(thumbElement.value!)\n  if (viewport.value) {\n    /**\n     * We only bind to native scroll event so we know when scroll starts and ends.\n     * When scroll starts we start a requestAnimationFrame loop that checks for\n     * changes to scroll position. That rAF loop triggers our thumb position change\n     * when relevant to avoid scroll-linked effects. We cancel the loop when scroll ends.\n     * https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\n     */\n    scrollbarContextVisible.onThumbPositionChange()\n    viewport.value.addEventListener('scroll', handleScroll)\n  }\n})\n\nonUnmounted(() => {\n  viewport.value!.removeEventListener('scroll', handleScroll)\n  rootContext.viewport.value?.removeEventListener('scroll', handleScroll)\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :data-state=\"scrollbarContextVisible.hasThumb ? 'visible' : 'hidden'\"\n    :style=\"{\n      width: 'var(--reka-scroll-area-thumb-width)',\n      height: 'var(--reka-scroll-area-thumb-height)',\n    }\"\n    :as-child=\"props.asChild\"\n    :as=\"as\"\n    @pointerdown=\"handlePointerDown\"\n    @pointerup=\"handlePointerUp\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { useNonce } from '@/shared/useNonce'\n\nexport interface ScrollAreaViewportProps extends PrimitiveProps {\n  /**\n   * Will add `nonce` attribute to the style tag which can be used by Content Security Policy. <br> If omitted, inherits globally from `ConfigProvider`.\n   */\n  nonce?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted, ref, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectScrollAreaRootContext } from './ScrollAreaRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<ScrollAreaViewportProps>()\n\nconst { nonce: propNonce } = toRefs(props)\nconst nonce = useNonce(propNonce)\n\nconst rootContext = injectScrollAreaRootContext()\n\nconst viewportElement = ref<HTMLElement>()\n\nonMounted(() => {\n  rootContext.onViewportChange(viewportElement.value!)\n  rootContext.onContentChange(contentElement.value!)\n})\n\ndefineExpose({\n  viewportElement,\n})\nconst { forwardRef, currentElement: contentElement } = useForwardExpose()\n</script>\n\n<template>\n  <div\n    ref=\"viewportElement\"\n    data-reka-scroll-area-viewport=\"\"\n    :style=\"{\n      /**\n       * We don't support `visible` because the intention is to have at least one scrollbar\n       * if this component is used and `visible` will behave like `auto` in that case\n       * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n       *\n       * We don't handle `auto` because the intention is for the native implementation\n       * to be hidden if using this component. We just want to ensure the node is scrollable\n       * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n       * the browser from having to work out whether to render native scrollbars or not,\n       * we tell it to with the intention of hiding them in CSS.\n       */\n      overflowX: rootContext.scrollbarXEnabled.value ? 'scroll' : 'hidden',\n      overflowY: rootContext.scrollbarYEnabled.value ? 'scroll' : 'hidden',\n    }\"\n    v-bind=\"$attrs\"\n    :tabindex=\"0\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :style=\"{\n        /**\n         * When horizontal scrollbar is visible: this element should be at least\n         * as wide as its children for size calculations to work correctly.\n         *\n         * When horizontal scrollbar is NOT visible: this element's width should\n         * be constrained by the parent container to enable `text-overflow: ellipsis`\n         */\n        minWidth: rootContext.scrollbarXEnabled.value ? 'fit-content' : undefined,\n      }\"\n      :as-child=\"props.asChild\"\n      :as=\"as\"\n    >\n      <slot />\n    </Primitive>\n  </div>\n  <Primitive\n    as=\"style\"\n    :nonce=\"nonce\"\n  >\n    /* Hide scrollbars cross-browser and enable momentum scroll for touch\n    devices */\n    [data-reka-scroll-area-viewport] {\n    scrollbar-width:none;\n    -ms-overflow-style:none;\n    -webkit-overflow-scrolling:touch;\n    }\n\n    [data-reka-scroll-area-viewport]::-webkit-scrollbar {\n    display:none;\n    }\n  </Primitive>\n</template>\n", "import type { AcceptableValue } from '@/shared/types'\nimport { isEqual } from 'ohash'\n\nexport const OPEN_KEYS = [' ', 'Enter', 'ArrowUp', 'ArrowDown']\nexport const SELECTION_KEYS = [' ', 'Enter']\nexport const CONTENT_MARGIN = 10\n\nexport function valueComparator<T>(value: T | T[] | undefined, currentValue: T, comparator?: string | ((a: T, b: T) => boolean)) {\n  if (value === undefined)\n    return false\n  else if (Array.isArray(value))\n    return value.some(val => compare(val, currentValue, comparator))\n  else\n    return compare(value, currentValue, comparator)\n}\n\nexport function compare<T>(value?: T, currentValue?: T, comparator?: string | ((a: T, b: T) => boolean)) {\n  if (value === undefined || currentValue === undefined)\n    return false\n\n  if (typeof value === 'string')\n    return value === currentValue\n\n  if (typeof comparator === 'function')\n    return comparator(value, currentValue)\n\n  if (typeof comparator === 'string')\n    return value?.[comparator as keyof T] === currentValue?.[comparator as keyof T]\n\n  return isEqual(value, currentValue)\n}\n\nexport function shouldShowPlaceholder(value?: AcceptableValue | AcceptableValue[]): boolean {\n  return value === undefined || value === null || value === '' || (Array.isArray(value) && value.length === 0)\n}\n", "<script setup lang=\"ts\">\nimport { ref, watch } from 'vue'\nimport { VisuallyHidden } from '@/VisuallyHidden'\n\ninterface BubbleSelectProps {\n  autocomplete?: string\n  autofocus?: boolean\n  disabled?: boolean\n  form?: string\n  multiple?: boolean\n  name?: string\n  required?: boolean\n  size?: number\n  value?: any\n}\n\nconst props = defineProps<BubbleSelectProps>()\nconst selectElement = ref<HTMLElement>()\n\n// This would bubble \"change\" event to form, with the target as Select element.\nwatch(() => props.value, (cur, prev) => {\n  const selectProto = window.HTMLSelectElement.prototype\n  const descriptor = Object.getOwnPropertyDescriptor(\n    selectProto,\n    'value',\n  ) as PropertyDescriptor\n  const setValue = descriptor.set\n  if (cur !== prev && setValue && selectElement.value) {\n    const event = new Event('change', { bubbles: true })\n    setValue.call(selectElement.value, cur)\n    selectElement.value.dispatchEvent(event)\n  }\n})\n\n/**\n * We purposefully use a `select` here to support form autofill as much\n * as possible.\n *\n * We purposefully do not add the `value` attribute here to allow the value\n * to be set programmatically and bubble to any parent form `onChange` event.\n *\n * We use `VisuallyHidden` rather than `display: \"none\"` because Safari autofill\n * won't work otherwise.\n */\n</script>\n\n<template>\n  <VisuallyHidden as-child>\n    <select\n      ref=\"selectElement\"\n      v-bind=\"props\"\n    >\n      <slot />\n    </select>\n  </VisuallyHidden>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { AcceptableValue, Direction, FormFieldProps } from '@/shared/types'\nimport { useCollection } from '@/Collection'\nimport { createContext, isNullish, useDirection, useFormControl } from '@/shared'\nimport { compare } from './utils'\n\nexport interface SelectRootProps<T = AcceptableValue> extends FormFieldProps {\n  /** The controlled open state of the Select. Can be bind as `v-model:open`. */\n  open?: boolean\n  /** The open state of the select when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n  /** The value of the select when initially rendered. Use when you do not need to control the state of the Select */\n  defaultValue?: T | Array<T>\n  /** The controlled value of the Select. Can be bind as `v-model`. */\n  modelValue?: T | Array<T>\n  /** Use this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared. */\n  by?: string | ((a: T, b: T) => boolean)\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** Whether multiple options can be selected or not. */\n  multiple?: boolean\n  /** Native html input `autocomplete` attribute. */\n  autocomplete?: string\n  /** When `true`, prevents the user from interacting with Select */\n  disabled?: boolean\n}\n\nexport type SelectRootEmits<T = AcceptableValue> = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [value: T]\n  /** Event handler called when the open state of the context menu changes. */\n  'update:open': [value: boolean]\n}\n\nexport interface SelectRootContext<T> {\n  triggerElement: Ref<HTMLElement | undefined>\n  onTriggerChange: (node: HTMLElement | undefined) => void\n  valueElement: Ref<HTMLElement | undefined>\n  onValueElementChange: (node: HTMLElement) => void\n  contentId: string\n  modelValue: Ref<T | Array<T> | undefined>\n  onValueChange: (value: T) => void\n  open: Ref<boolean>\n  multiple: Ref<boolean>\n  required?: Ref<boolean>\n  by?: string | ((a: T, b: T) => boolean)\n  onOpenChange: (open: boolean) => void\n  dir: Ref<Direction>\n  triggerPointerDownPosRef: Ref<{ x: number, y: number } | null>\n  isEmptyModelValue: Ref<boolean>\n  disabled?: Ref<boolean>\n\n  optionsSet: Ref<Set<SelectOption>>\n  onOptionAdd: (option: SelectOption) => void\n  onOptionRemove: (option: SelectOption) => void\n}\n\nexport const [injectSelectRootContext, provideSelectRootContext]\n  = createContext<SelectRootContext<AcceptableValue>>('SelectRoot')\n\ninterface SelectOption { value: any, disabled?: boolean, textContent: string }\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, ref, toRefs } from 'vue'\nimport { PopperRoot } from '@/Popper'\nimport BubbleSelect from './BubbleSelect.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<SelectRootProps<T>>(), {\n  modelValue: undefined,\n  open: undefined,\n})\nconst emits = defineEmits<SelectRootEmits<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nconst { required, disabled, multiple, dir: propDir } = toRefs(props)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  // @ts-expect-error Missing infer for AcceptableValue\n  defaultValue: props.defaultValue ?? (multiple.value ? [] : undefined),\n  passive: (props.modelValue === undefined) as false,\n  deep: true,\n}) as Ref<T | T[] | undefined>\n\nconst open = useVModel(props, 'open', emits, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nconst triggerElement = ref<HTMLElement>()\nconst valueElement = ref<HTMLElement>()\nconst triggerPointerDownPosRef = ref({\n  x: 0,\n  y: 0,\n})\n\nconst isEmptyModelValue = computed(() => {\n  if (multiple.value && Array.isArray(modelValue.value))\n    return modelValue.value?.length === 0\n  else\n    return isNullish(modelValue.value)\n})\n\nuseCollection({ isProvider: true })\nconst dir = useDirection(propDir)\n\nconst isFormControl = useFormControl(triggerElement)\nconst optionsSet = ref<Set<SelectOption>>(new Set())\n\n// The native `select` only associates the correct default value if the corresponding\n// `option` is rendered as a child **at the same time** as itself.\n// Because it might take a few renders for our items to gather the information to build\n// the native `option`(s), we generate a key on the `select` to make sure Vue re-builds it\n// each time the options change.\nconst nativeSelectKey = computed(() => {\n  return Array.from(optionsSet.value)\n    .map(option => option.value)\n    .join(';')\n})\n\nfunction handleValueChange(value: T) {\n  if (multiple.value) {\n    const array = Array.isArray(modelValue.value) ? [...modelValue.value] : []\n    const index = array.findIndex(i => compare(i, value, props.by))\n    index === -1 ? array.push(value) : array.splice(index, 1)\n    modelValue.value = [...array]\n  }\n  else {\n    modelValue.value = value\n  }\n}\n\nprovideSelectRootContext({\n  triggerElement,\n  onTriggerChange: (node) => {\n    triggerElement.value = node\n  },\n  valueElement,\n  onValueElementChange: (node) => {\n    valueElement.value = node\n  },\n  contentId: '',\n  modelValue,\n  // @ts-expect-error Missing infer for AcceptableValue\n  onValueChange: handleValueChange,\n  // @ts-expect-error Missing infer for AcceptableValue\n  by: props.by,\n  open,\n  multiple,\n  required,\n  onOpenChange: (value) => {\n    open.value = value\n  },\n  dir,\n  triggerPointerDownPosRef,\n  disabled,\n  isEmptyModelValue,\n\n  optionsSet,\n  onOptionAdd: option => optionsSet.value.add(option),\n  onOptionRemove: option => optionsSet.value.delete(option),\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <slot\n      :model-value=\"modelValue\"\n      :open=\"open\"\n    />\n\n    <BubbleSelect\n      v-if=\"isFormControl\"\n      :key=\"nativeSelectKey\"\n      aria-hidden=\"true\"\n      tabindex=\"-1\"\n      :multiple=\"multiple\"\n      :required=\"required\"\n      :name=\"name\"\n      :autocomplete=\"autocomplete\"\n      :disabled=\"disabled\"\n      :value=\"modelValue\"\n    >\n      <option\n        v-if=\"isNullish(modelValue)\"\n        value=\"\"\n      />\n      <option\n        v-for=\"option in Array.from(optionsSet)\"\n        :key=\"option.value ?? ''\"\n        v-bind=\"option\"\n      />\n    </BubbleSelect>\n  </PopperRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useResizeObserver } from '@vueuse/core'\nimport { useCollection } from '@/Collection'\nimport { clamp, createContext, useForwardExpose } from '@/shared'\n\ninterface SelectItemAlignedPositionContext {\n  contentWrapper?: Ref<HTMLElement | undefined>\n  shouldExpandOnScrollRef?: Ref<boolean>\n  onScrollButtonChange: (node: HTMLElement | undefined) => void\n}\n\nexport interface SelectItemAlignedPositionProps extends PrimitiveProps {}\n\nexport const [injectSelectItemAlignedPositionContext, provideSelectItemAlignedPositionContext]\n  = createContext<SelectItemAlignedPositionContext>('SelectItemAlignedPosition')\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, onMounted, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\nimport { injectSelectRootContext } from './SelectRoot.vue'\nimport { CONTENT_MARGIN } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<SelectItemAlignedPositionProps>()\nconst emits = defineEmits<{\n  placed: []\n}>()\n\nconst { getItems } = useCollection()\nconst rootContext = injectSelectRootContext()\nconst contentContext = injectSelectContentContext()\n\nconst shouldExpandOnScrollRef = ref(false)\nconst shouldRepositionRef = ref(true)\n\nconst contentWrapperElement = ref<HTMLElement>()\nconst { forwardRef, currentElement: contentElement } = useForwardExpose()\n\nconst { viewport, selectedItem, selectedItemText, focusSelectedItem }\n  = contentContext!\n\nfunction position() {\n  if (\n    rootContext.triggerElement.value\n    && rootContext.valueElement.value\n    && contentWrapperElement.value\n    && contentElement.value\n    && viewport?.value\n    && selectedItem?.value\n    && selectedItemText?.value\n  ) {\n    const triggerRect = rootContext.triggerElement.value.getBoundingClientRect()\n\n    // -----------------------------------------------------------------------------------------\n    //  Horizontal positioning\n    // -----------------------------------------------------------------------------------------\n    const contentRect = contentElement.value.getBoundingClientRect()\n    const valueNodeRect = rootContext.valueElement.value.getBoundingClientRect()\n    const itemTextRect = selectedItemText.value.getBoundingClientRect()\n\n    if (rootContext.dir.value !== 'rtl') {\n      const itemTextOffset = itemTextRect.left - contentRect.left\n      const left = valueNodeRect.left - itemTextOffset\n      const leftDelta = triggerRect.left - left\n      const minContentWidth = triggerRect.width + leftDelta\n      const contentWidth = Math.max(minContentWidth, contentRect.width)\n      const rightEdge = window.innerWidth - CONTENT_MARGIN\n      const clampedLeft = clamp(left, CONTENT_MARGIN, Math.max(CONTENT_MARGIN, rightEdge - contentWidth))\n\n      contentWrapperElement.value.style.minWidth = `${minContentWidth}px`\n      contentWrapperElement.value.style.left = `${clampedLeft}px`\n    }\n    else {\n      const itemTextOffset = contentRect.right - itemTextRect.right\n      const right = window.innerWidth - valueNodeRect.right - itemTextOffset\n      const rightDelta = window.innerWidth - triggerRect.right - right\n      const minContentWidth = triggerRect.width + rightDelta\n      const contentWidth = Math.max(minContentWidth, contentRect.width)\n      const leftEdge = window.innerWidth - CONTENT_MARGIN\n      const clampedRight = clamp(\n        right,\n        CONTENT_MARGIN,\n        Math.max(CONTENT_MARGIN, leftEdge - contentWidth),\n      )\n\n      contentWrapperElement.value.style.minWidth = `${minContentWidth}px`\n      contentWrapperElement.value.style.right = `${clampedRight}px`\n    }\n\n    // -----------------------------------------------------------------------------------------\n    // Vertical positioning\n    // -----------------------------------------------------------------------------------------\n    const items = getItems().map(i => i.ref)\n    const availableHeight = window.innerHeight - CONTENT_MARGIN * 2\n    const itemsHeight = viewport.value.scrollHeight\n\n    const contentStyles = window.getComputedStyle(contentElement.value)\n    const contentBorderTopWidth = Number.parseInt(\n      contentStyles.borderTopWidth,\n      10,\n    )\n    const contentPaddingTop = Number.parseInt(contentStyles.paddingTop, 10)\n    const contentBorderBottomWidth = Number.parseInt(\n      contentStyles.borderBottomWidth,\n      10,\n    )\n    const contentPaddingBottom = Number.parseInt(\n      contentStyles.paddingBottom,\n      10,\n    )\n\n    const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth\n    const minContentHeight = Math.min(\n      selectedItem.value.offsetHeight * 5,\n      fullContentHeight,\n    )\n\n    const viewportStyles = window.getComputedStyle(viewport.value)\n    const viewportPaddingTop = Number.parseInt(viewportStyles.paddingTop, 10)\n    const viewportPaddingBottom = Number.parseInt(\n      viewportStyles.paddingBottom,\n      10,\n    )\n\n    const topEdgeToTriggerMiddle\n      = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN\n    const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle\n\n    const selectedItemHalfHeight = selectedItem.value.offsetHeight / 2\n    const itemOffsetMiddle\n      = selectedItem.value.offsetTop + selectedItemHalfHeight\n    const contentTopToItemMiddle\n      = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle\n    const itemMiddleToContentBottom\n      = fullContentHeight - contentTopToItemMiddle\n\n    const willAlignWithoutTopOverflow\n      = contentTopToItemMiddle <= topEdgeToTriggerMiddle\n\n    if (willAlignWithoutTopOverflow) {\n      const isLastItem = selectedItem.value === items[items.length - 1]\n      contentWrapperElement.value.style.bottom = `${0}px`\n      const viewportOffsetBottom\n        = contentElement.value.clientHeight\n          - viewport.value.offsetTop\n          - viewport.value.offsetHeight\n      const clampedTriggerMiddleToBottomEdge = Math.max(\n        triggerMiddleToBottomEdge,\n        selectedItemHalfHeight\n        // viewport might have padding bottom, include it to avoid a scrollable viewport\n        + (isLastItem ? viewportPaddingBottom : 0)\n        + viewportOffsetBottom\n        + contentBorderBottomWidth,\n      )\n      const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge\n      contentWrapperElement.value.style.height = `${height}px`\n    }\n    else {\n      const isFirstItem = selectedItem.value === items[0]\n      contentWrapperElement.value.style.top = `${0}px`\n      const clampedTopEdgeToTriggerMiddle = Math.max(\n        topEdgeToTriggerMiddle,\n        contentBorderTopWidth\n        + viewport.value.offsetTop\n        // viewport might have padding top, include it to avoid a scrollable viewport\n        + (isFirstItem ? viewportPaddingTop : 0)\n        + selectedItemHalfHeight,\n      )\n      const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom\n      contentWrapperElement.value.style.height = `${height}px`\n      viewport.value.scrollTop\n        = contentTopToItemMiddle\n          - topEdgeToTriggerMiddle\n          + viewport.value.offsetTop\n    }\n\n    contentWrapperElement.value.style.margin = `${CONTENT_MARGIN}px 0`\n    contentWrapperElement.value.style.minHeight = `${minContentHeight}px`\n    contentWrapperElement.value.style.maxHeight = `${availableHeight}px`\n    // -----------------------------------------------------------------------------------------\n\n    emits('placed')\n\n    // we don't want the initial scroll position adjustment to trigger \"expand on scroll\"\n    // so we explicitly turn it on only after they've registered.\n    requestAnimationFrame(() => (shouldExpandOnScrollRef.value = true))\n  }\n}\n\n// copy z-index from content to wrapper\nconst contentZIndex = ref('')\n\nonMounted(async () => {\n  await nextTick()\n  position()\n  if (contentElement.value)\n    contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex\n})\n\n// When the viewport becomes scrollable at the top, the scroll up button will mount.\n// Because it is part of the normal flow, it will push down the viewport, thus throwing our\n// trigger => selectedItem alignment off by the amount the viewport was pushed down.\n// We wait for this to happen and then re-run the positining logic one more time to account for it.\nfunction handleScrollButtonChange(node: HTMLElement | undefined) {\n  if (node && shouldRepositionRef.value === true) {\n    position()\n    focusSelectedItem?.()\n    shouldRepositionRef.value = false\n  }\n}\n\n// Resize and position when trigger element changes\nuseResizeObserver(rootContext.triggerElement, () => {\n  position()\n})\n\nprovideSelectItemAlignedPositionContext({\n  contentWrapper: contentWrapperElement,\n  shouldExpandOnScrollRef,\n  onScrollButtonChange: handleScrollButtonChange,\n})\n</script>\n\n<template>\n  <div\n    ref=\"contentWrapperElement\"\n    :style=\"{\n      display: 'flex',\n      flexDirection: 'column',\n      position: 'fixed',\n      zIndex: contentZIndex,\n    }\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :style=\"{\n        // When we get the height of the content, it includes borders. If we were to set\n        // the height without having `boxSizing: 'border-box'` it would be too big.\n        boxSizing: 'border-box',\n        // We need to ensure the content doesn't get taller than the wrapper\n        maxHeight: '100%',\n      }\"\n      v-bind=\"{ ...$attrs, ...props }\"\n    >\n      <slot />\n    </Primitive>\n  </div>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperContentProps } from '@/Popper'\n\nexport interface SelectPopperPositionProps extends PopperContentProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperContent } from '@/Popper'\nimport { useForwardProps } from '..'\nimport { CONTENT_MARGIN } from './utils'\n\nconst props = withDefaults(defineProps<SelectPopperPositionProps>(), {\n  align: 'start',\n  collisionPadding: CONTENT_MARGIN,\n})\nconst forwarded = useForwardProps(props)\n</script>\n\n<template>\n  <PopperContent\n    v-bind=\"forwarded\"\n    :style=\"{\n      // Ensure border-box for floating-ui calculations\n      'boxSizing': 'border-box',\n      '--reka-select-content-transform-origin':\n        'var(--reka-popper-transform-origin)',\n      '--reka-select-content-available-width':\n        'var(--reka-popper-available-width)',\n      '--reka-select-content-available-height':\n        'var(--reka-popper-available-height)',\n      '--reka-select-trigger-width': 'var(--reka-popper-anchor-width)',\n      '--reka-select-trigger-height': 'var(--reka-popper-anchor-height)',\n    }\"\n  >\n    <slot />\n  </PopperContent>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  ComponentPublicInstance,\n  Ref,\n} from 'vue'\nimport type { PointerDownOutsideEvent } from '@/DismissableLayer'\nimport type { PopperContentProps } from '@/Popper'\nimport type { AcceptableValue } from '@/shared/types'\nimport { useCollection } from '@/Collection'\nimport {\n  createContext,\n  useFocusGuards,\n  useForwardProps,\n  useHideOthers,\n  useTypeahead,\n} from '@/shared'\nimport { useBodyScrollLock } from '@/shared/useBodyScrollLock'\nimport { valueComparator } from './utils'\n\nexport interface SelectContentContext {\n  content?: Ref<HTMLElement | undefined>\n  viewport?: Ref<HTMLElement | undefined>\n  onViewportChange: (node: HTMLElement | undefined) => void\n  itemRefCallback: (\n    node: HTMLElement | undefined,\n    value: AcceptableValue,\n    disabled: boolean\n  ) => void\n  selectedItem?: Ref<HTMLElement | undefined>\n  onItemLeave?: () => void\n  itemTextRefCallback: (\n    node: HTMLElement | undefined,\n    value: AcceptableValue,\n    disabled: boolean\n  ) => void\n  focusSelectedItem?: () => void\n  selectedItemText?: Ref<HTMLElement | undefined>\n  position?: 'item-aligned' | 'popper'\n  isPositioned?: Ref<boolean>\n  searchRef?: Ref<string>\n}\n\nexport const SelectContentDefaultContextValue: SelectContentContext = {\n  onViewportChange: () => {},\n  itemTextRefCallback: () => {},\n  itemRefCallback: () => {},\n}\n\nexport type SelectContentImplEmits = {\n  closeAutoFocus: [event: Event]\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  escapeKeyDown: [event: KeyboardEvent]\n  /**\n   * Event handler called when a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  pointerDownOutside: [event: PointerDownOutsideEvent]\n}\n\nexport interface SelectContentImplProps extends PopperContentProps {\n  /**\n   *  The positioning mode to use\n   *\n   *  `item-aligned (default)` - behaves similarly to a native MacOS menu by positioning content relative to the active item. <br>\n   *  `popper` - positions content in the same way as our other primitives, for example `Popover` or `DropdownMenu`.\n   */\n  position?: 'item-aligned' | 'popper'\n  /**\n   * The document.body will be lock, and scrolling will be disabled.\n   *\n   * @defaultValue true\n   */\n  bodyLock?: boolean\n}\n\nexport const [injectSelectContentContext, provideSelectContentContext]\n  = createContext<SelectContentContext>('SelectContent')\n</script>\n\n<script setup lang=\"ts\">\nimport { unrefElement } from '@vueuse/core'\nimport {\n  computed,\n  ref,\n  watch,\n  watchEffect,\n} from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { FocusScope } from '@/FocusScope'\nimport { focusFirst } from '@/Menu/utils'\nimport SelectItemAlignedPosition from './SelectItemAlignedPosition.vue'\nimport SelectPopperPosition from './SelectPopperPosition.vue'\nimport { injectSelectRootContext } from './SelectRoot.vue'\n\nconst props = withDefaults(defineProps<SelectContentImplProps>(), {\n  align: 'start',\n  position: 'item-aligned',\n  bodyLock: true,\n})\nconst emits = defineEmits<SelectContentImplEmits>()\n\nconst rootContext = injectSelectRootContext()\n\nuseFocusGuards()\nuseBodyScrollLock(props.bodyLock)\nconst { CollectionSlot, getItems } = useCollection()\n\nconst content = ref<HTMLElement>()\nuseHideOthers(content)\n\nconst { search, handleTypeaheadSearch } = useTypeahead()\n\nconst viewport = ref<HTMLElement>()\nconst selectedItem = ref<HTMLElement>()\nconst selectedItemText = ref<HTMLElement>()\nconst isPositioned = ref(false)\nconst firstValidItemFoundRef = ref(false)\nconst firstSelectedItemInArrayFoundRef = ref(false)\n\nfunction focusSelectedItem() {\n  if (selectedItem.value && content.value)\n    focusFirst([selectedItem.value, content.value])\n}\n\nwatch(isPositioned, () => {\n  focusSelectedItem()\n})\n\n// prevent selecting items on `pointerup` in some cases after opening from `pointerdown`\n// and close on `pointerup` outside.\nconst { onOpenChange, triggerPointerDownPosRef } = rootContext\nwatchEffect((cleanupFn) => {\n  if (!content.value)\n    return\n  let pointerMoveDelta = { x: 0, y: 0 }\n\n  const handlePointerMove = (event: PointerEvent) => {\n    pointerMoveDelta = {\n      x: Math.abs(\n        Math.round(event.pageX) - (triggerPointerDownPosRef.value?.x ?? 0),\n      ),\n      y: Math.abs(\n        Math.round(event.pageY) - (triggerPointerDownPosRef.value?.y ?? 0),\n      ),\n    }\n  }\n  const handlePointerUp = (event: PointerEvent) => {\n    // Prevent options from being untappable on touch devices\n    // https://github.com/unovue/reka-ui/issues/804\n    if (event.pointerType === 'touch')\n      return\n\n    // If the pointer hasn't moved by a certain threshold then we prevent selecting item on `pointerup`.\n    if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {\n      event.preventDefault()\n    }\n    else {\n      // otherwise, if the event was outside the content, close.\n      if (!content.value?.contains(event.target as HTMLElement))\n        onOpenChange(false)\n    }\n    document.removeEventListener('pointermove', handlePointerMove)\n    triggerPointerDownPosRef.value = null\n  }\n\n  if (triggerPointerDownPosRef.value !== null) {\n    document.addEventListener('pointermove', handlePointerMove)\n    document.addEventListener('pointerup', handlePointerUp, {\n      capture: true,\n      once: true,\n    })\n  }\n\n  cleanupFn(() => {\n    document.removeEventListener('pointermove', handlePointerMove)\n    document.removeEventListener('pointerup', handlePointerUp, {\n      capture: true,\n    })\n  })\n})\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey\n\n  // select should not be navigated using tab key so we prevent it\n  if (event.key === 'Tab')\n    event.preventDefault()\n\n  if (!isModifierKey && event.key.length === 1)\n    handleTypeaheadSearch(event.key, getItems())\n\n  if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {\n    const collectionItems = getItems().map(i => i.ref)\n    let candidateNodes = [...collectionItems]\n\n    if (['ArrowUp', 'End'].includes(event.key))\n      candidateNodes = candidateNodes.slice().reverse()\n\n    if (['ArrowUp', 'ArrowDown'].includes(event.key)) {\n      const currentElement = event.target as HTMLElement\n      const currentIndex = candidateNodes.indexOf(currentElement)\n      candidateNodes = candidateNodes.slice(currentIndex + 1)\n    }\n    setTimeout(() => focusFirst(candidateNodes))\n    event.preventDefault()\n  }\n}\n\nconst pickedProps = computed(() => {\n  if (props.position === 'popper')\n    return props\n  else return {}\n})\n\nconst forwardedProps = useForwardProps(pickedProps.value)\n\nprovideSelectContentContext({\n  content,\n  viewport,\n  onViewportChange: (node) => {\n    viewport.value = node\n  },\n  itemRefCallback: (node, value, disabled) => {\n    const isFirstValidItem = !firstValidItemFoundRef.value && !disabled\n    const isSelectedItem = valueComparator(rootContext.modelValue.value, value, rootContext.by)\n\n    if (rootContext.multiple.value) {\n      if (firstSelectedItemInArrayFoundRef.value) {\n        return\n      }\n      if (isSelectedItem || isFirstValidItem) {\n        selectedItem.value = node\n\n        // make sure to keep the first item highlighted when `multiple`\n        if (isSelectedItem) {\n          firstSelectedItemInArrayFoundRef.value = true\n        }\n      }\n    }\n    else {\n      if (isSelectedItem || isFirstValidItem) {\n        selectedItem.value = node\n      }\n    }\n\n    if (isFirstValidItem) {\n      firstValidItemFoundRef.value = true\n    }\n  },\n  selectedItem,\n  selectedItemText,\n  onItemLeave: () => {\n    content.value?.focus()\n  },\n  itemTextRefCallback: (node, value, disabled) => {\n    const isFirstValidItem = !firstValidItemFoundRef.value && !disabled\n    const isSelectedItem = valueComparator(rootContext.modelValue.value, value, rootContext.by)\n\n    if (isSelectedItem || isFirstValidItem)\n      selectedItemText.value = node\n  },\n  focusSelectedItem,\n  position: props.position,\n  isPositioned,\n  searchRef: search,\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <FocusScope\n      as-child\n      @mount-auto-focus.prevent\n      @unmount-auto-focus=\"\n        (event) => {\n          emits('closeAutoFocus', event);\n          if (event.defaultPrevented) return;\n          rootContext.triggerElement.value?.focus({ preventScroll: true });\n          event.preventDefault();\n        }\n      \"\n    >\n      <DismissableLayer\n        as-child\n        disable-outside-pointer-events\n        @focus-outside.prevent\n        @dismiss=\"rootContext.onOpenChange(false)\"\n        @escape-key-down=\"emits('escapeKeyDown', $event)\"\n        @pointer-down-outside=\"emits('pointerDownOutside', $event)\"\n      >\n        <component\n          :is=\"\n            position === 'popper'\n              ? SelectPopperPosition\n              : SelectItemAlignedPosition\n          \"\n          v-bind=\"{ ...$attrs, ...forwardedProps }\"\n          :id=\"rootContext.contentId\"\n          :ref=\"\n            (vnode: ComponentPublicInstance) => {\n              content = unrefElement(vnode) as HTMLElement\n              return undefined\n            }\n          \"\n          role=\"listbox\"\n          :data-state=\"rootContext.open.value ? 'open' : 'closed'\"\n          :dir=\"rootContext.dir.value\"\n          :style=\"{\n            // flex layout so we can place the scroll buttons properly\n            display: 'flex',\n            flexDirection: 'column',\n            // reset the outline by default as the content MAY get focused\n            outline: 'none',\n          }\"\n          @contextmenu.prevent\n          @placed=\"isPositioned = true\"\n          @keydown=\"(handleKeyDown as any)\"\n        >\n          <slot />\n        </component>\n      </DismissableLayer>\n    </FocusScope>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { PopperArrowProps } from '@/Popper'\n\nexport interface SelectArrowProps extends PopperArrowProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperArrow } from '@/Popper'\nimport { injectSelectContentContext, SelectContentDefaultContextValue } from './SelectContentImpl.vue'\nimport { injectSelectRootContext } from './SelectRoot.vue'\n\nconst props = withDefaults(defineProps<SelectArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nconst rootContext = injectSelectRootContext()\nconst contentContext = injectSelectContentContext(SelectContentDefaultContextValue)\n</script>\n\n<template>\n  <PopperArrow\n    v-if=\"rootContext.open.value && contentContext.position === 'popper'\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </PopperArrow>\n</template>\n", "<script setup lang=\"ts\">\nimport type { SelectRootContext } from './SelectRoot.vue'\nimport type { AcceptableValue } from '@/shared/types'\nimport { provideSelectContentContext, SelectContentDefaultContextValue } from './SelectContentImpl.vue'\nimport { provideSelectRootContext } from './SelectRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<{\n  context: SelectRootContext<AcceptableValue>\n}>()\n\nprovideSelectRootContext(props.context)\nprovideSelectContentContext(SelectContentDefaultContextValue)\n</script>\n\n<template>\n  <slot />\n</template>\n", "<script lang=\"ts\">\nimport type {\n  SelectContentImplEmits,\n  SelectContentImplProps,\n} from './SelectContentImpl.vue'\nimport { computed, onMounted, ref, watch } from 'vue'\n\nexport type SelectContentEmits = SelectContentImplEmits\n\nexport interface SelectContentProps extends SelectContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardPropsEmits } from '@/shared'\nimport SelectContentImpl from './SelectContentImpl.vue'\nimport SelectProvider from './SelectProvider.vue'\nimport { injectSelectRootContext } from './SelectRoot.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<SelectContentProps>()\n\nconst emits = defineEmits<SelectContentEmits>()\nconst forwarded = useForwardPropsEmits(props, emits)\n\nconst rootContext = injectSelectRootContext()\n\nconst fragment = ref<DocumentFragment>()\nonMounted(() => {\n  fragment.value = new DocumentFragment()\n})\n\nconst presenceRef = ref<InstanceType<typeof Presence>>()\n\nconst present = computed(() => props.forceMount || rootContext.open.value)\nconst renderPresence = ref(present.value)\n\nwatch(present, () => {\n  // Toggle render presence after a delay (nextTick is not enough)\n  // to allow children to re-render with the latest state.\n  // Otherwise, they would remain in the old state during the transition,\n  // which would prevent the animation that depend on state (e.g., data-[state=closed])\n  // from being applied accurately.\n  // @see https://github.com/unovue/reka-ui/issues/1865\n  setTimeout(() => renderPresence.value = present.value)\n})\n</script>\n\n<template>\n  <Presence\n    v-if=\"present || renderPresence || presenceRef?.present\"\n    ref=\"presenceRef\"\n    :present=\"present\"\n  >\n    <SelectContentImpl v-bind=\"{ ...forwarded, ...$attrs }\">\n      <slot />\n    </SelectContentImpl>\n  </Presence>\n\n  <div v-else-if=\"fragment\">\n    <Teleport :to=\"fragment\">\n      <SelectProvider :context=\"rootContext\">\n        <slot />\n      </SelectProvider>\n    </Teleport>\n  </div>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useId } from '@/shared'\n\nexport interface SelectGroupProps extends PrimitiveProps {}\n\ninterface SelectGroupContext {\n  id: string\n}\n\nexport const [injectSelectGroupContext, provideSelectGroupContext]\n  = createContext<SelectGroupContext>('SelectGroup')\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<SelectGroupProps>()\n\nconst id = useId(undefined, 'reka-select-group')\nprovideSelectGroupContext({ id })\n</script>\n\n<template>\n  <Primitive\n    role=\"group\"\n    v-bind=\"props\"\n    :aria-labelledby=\"id\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import { defineComponent, createBlock, openBlock, unref, withCtx, renderSlot, createTextVNode } from 'vue';\nimport { P as Primitive } from '../Primitive/Primitive.js';\n\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(__props) {\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(unref(Primitive), {\n        \"aria-hidden\": \"true\",\n        as: _ctx.as,\n        \"as-child\": _ctx.asChild\n      }, {\n        default: withCtx(() => [\n          renderSlot(_ctx.$slots, \"default\", {}, () => [\n            _cache[0] || (_cache[0] = createTextVNode(\"\"))\n          ])\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\"]);\n    };\n  }\n});\n\nexport { _sfc_main as _ };\n//# sourceMappingURL=SelectIcon.js.map\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue } from '@/shared/types'\nimport { useCollection } from '@/Collection'\nimport { createContext, getActiveElement, handleAndDispatchCustomEvent, useForwardExpose, useId } from '@/shared'\n\ninterface SelectItemContext<T = AcceptableValue> {\n  value: T\n  textId: string\n  disabled: Ref<boolean>\n  isSelected: Ref<boolean>\n  onItemTextChange: (node: HTMLElement | undefined) => void\n}\n\nexport const [injectSelectItemContext, provideSelectItemContext]\n    = createContext<SelectItemContext>('SelectItem')\n\nexport type SelectEvent<T> = CustomEvent<{ originalEvent: PointerEvent | KeyboardEvent, value?: T }>\n\nexport type SelectItemEmits<T = AcceptableValue> = {\n  /** Event handler called when the selecting item. <br> It can be prevented by calling `event.preventDefault`. */\n  select: [event: SelectEvent<T>]\n}\n\nexport interface SelectItemProps<T = AcceptableValue> extends PrimitiveProps {\n  /** The value given as data when submitted with a `name`. */\n  value: T\n  /** When `true`, prevents the user from interacting with the item. */\n  disabled?: boolean\n  /**\n   * Optional text used for typeahead purposes.\n   *\n   * By default the typeahead behavior will use the `.textContent` of the `SelectItemText` part.\n   *\n   * Use this when the content is complex, or you have non-textual content inside.\n   */\n  textValue?: string\n}\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableValue = AcceptableValue\">\nimport {\n  computed,\n  nextTick,\n  onMounted,\n  ref,\n  toRefs,\n} from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\nimport { injectSelectRootContext } from './SelectRoot.vue'\nimport { SELECTION_KEYS, valueComparator } from './utils'\n\nconst props = defineProps<SelectItemProps>()\nconst emits = defineEmits<SelectItemEmits<T>>()\nconst { disabled } = toRefs(props)\n\nconst rootContext = injectSelectRootContext()\nconst contentContext = injectSelectContentContext()\nconst { forwardRef, currentElement } = useForwardExpose()\nconst { CollectionItem } = useCollection()\n\nconst isSelected = computed(() => valueComparator(rootContext.modelValue?.value, props.value, rootContext.by))\nconst isFocused = ref(false)\nconst textValue = ref(props.textValue ?? '')\nconst textId = useId(undefined, 'reka-select-item-text')\n\nconst SELECT_SELECT = 'select.select'\n\nasync function handleSelectCustomEvent(ev: PointerEvent | KeyboardEvent) {\n  if (ev.defaultPrevented)\n    return\n\n  const eventDetail = { originalEvent: ev, value: props.value as T }\n  handleAndDispatchCustomEvent(SELECT_SELECT, handleSelect, eventDetail)\n}\n\nasync function handleSelect(ev: SelectEvent<T>) {\n  await nextTick()\n  emits('select', ev)\n  if (ev.defaultPrevented)\n    return\n\n  if (!disabled.value) {\n    rootContext.onValueChange(props.value)\n    if (!rootContext.multiple.value)\n      rootContext.onOpenChange(false)\n  }\n}\n\nasync function handlePointerMove(event: PointerEvent) {\n  await nextTick()\n  if (event.defaultPrevented)\n    return\n  if (disabled.value) {\n    contentContext.onItemLeave?.()\n  }\n  else {\n    // even though safari doesn't support this option, it's acceptable\n    // as it only means it might scroll a few pixels when using the pointer.\n    (event.currentTarget as HTMLElement | null)?.focus({ preventScroll: true })\n  }\n}\n\nasync function handlePointerLeave(event: PointerEvent) {\n  await nextTick()\n  if (event.defaultPrevented)\n    return\n  if (event.currentTarget === getActiveElement())\n    contentContext.onItemLeave?.()\n}\n\nasync function handleKeyDown(event: KeyboardEvent) {\n  await nextTick()\n  if (event.defaultPrevented)\n    return\n  const isTypingAhead = contentContext.searchRef?.value !== ''\n  if (isTypingAhead && event.key === ' ')\n    return\n  if (SELECTION_KEYS.includes(event.key))\n    handleSelectCustomEvent(event)\n  // prevent page scroll if using the space key to select an item\n  if (event.key === ' ')\n    event.preventDefault()\n}\n\nif (props.value === '') {\n  throw new Error(\n    'A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.',\n  )\n}\n\nonMounted(() => {\n  if (!currentElement.value)\n    return\n  contentContext.itemRefCallback(\n    currentElement.value,\n    props.value,\n    props.disabled,\n  )\n})\n\nprovideSelectItemContext({\n  value: props.value,\n  disabled,\n  textId,\n  isSelected,\n  onItemTextChange: (node) => {\n    textValue.value = ((textValue.value || node?.textContent) ?? '').trim()\n  },\n})\n</script>\n\n<template>\n  <CollectionItem :value=\"{ textValue }\">\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"option\"\n      :aria-labelledby=\"textId\"\n      :data-highlighted=\"isFocused ? '' : undefined\"\n      :aria-selected=\"isSelected\"\n      :data-state=\"isSelected ? 'checked' : 'unchecked'\"\n      :aria-disabled=\"disabled || undefined\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :tabindex=\"disabled ? undefined : -1\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      @focus=\"isFocused = true\"\n      @blur=\"isFocused = false\"\n      @pointerup=\"handleSelectCustomEvent\"\n      @pointerdown=\"(event) => {\n        (event.currentTarget as HTMLElement).focus({ preventScroll: true })\n      }\"\n      @touchend.prevent.stop\n      @pointermove=\"handlePointerMove\"\n      @pointerleave=\"handlePointerLeave\"\n      @keydown=\"handleKeyDown\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface SelectItemIndicatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectSelectItemContext } from './SelectItem.vue'\n\nconst props = withDefaults(defineProps<SelectItemIndicatorProps>(), {\n  as: 'span',\n})\n\nconst itemContext = injectSelectItemContext()\n</script>\n\n<template>\n  <Primitive\n    v-if=\"itemContext.isSelected.value\"\n    aria-hidden=\"true\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectSelectRootContext } from './SelectRoot.vue'\n\nexport interface SelectItemTextProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, onUnmounted } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\nimport { injectSelectItemContext } from './SelectItem.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<SelectItemTextProps>(), {\n  as: 'span',\n})\n\nconst rootContext = injectSelectRootContext()\nconst contentContext = injectSelectContentContext()\nconst itemContext = injectSelectItemContext()\n\nconst { forwardRef, currentElement: itemTextElement } = useForwardExpose()\n\nconst optionProps = computed(() => {\n  return {\n    value: itemContext.value,\n    disabled: itemContext.disabled.value,\n    textContent: itemTextElement.value?.textContent ?? itemContext.value?.toString() ?? '',\n  }\n})\n\nonMounted(() => {\n  if (!itemTextElement.value)\n    return\n  itemContext.onItemTextChange(itemTextElement.value)\n  contentContext.itemTextRefCallback(\n    itemTextElement.value,\n    itemContext.value,\n    itemContext.disabled.value,\n  )\n  rootContext.onOptionAdd(optionProps.value)\n})\n\nonUnmounted(() => {\n  rootContext.onOptionRemove(optionProps.value)\n})\n</script>\n\n<template>\n  <Primitive\n    :id=\"itemContext.textId\"\n    :ref=\"forwardRef\"\n    v-bind=\"{ ...props, ...$attrs }\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface SelectLabelProps extends PrimitiveProps {\n  for?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectSelectGroupContext } from './SelectGroup.vue'\n\nconst props = withDefaults(defineProps<SelectLabelProps>(), {\n  as: 'div',\n})\n\nconst groupContext = injectSelectGroupContext({ id: '' })\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"groupContext.id\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface SelectPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<SelectPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script setup lang=\"ts\">\nimport { onBeforeUnmount, ref, watchEffect } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\nimport { getActiveElement } from '@/shared'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\n\nexport type SelectScrollButtonImplEmits = {\n  autoScroll: []\n}\n\nconst emits = defineEmits<SelectScrollButtonImplEmits>()\nconst { getItems } = useCollection()\n\nconst contentContext = injectSelectContentContext()\nconst autoScrollTimerRef = ref<number | null>(null)\n\nfunction clearAutoScrollTimer() {\n  if (autoScrollTimerRef.value !== null) {\n    window.clearInterval(autoScrollTimerRef.value)\n    autoScrollTimerRef.value = null\n  }\n}\n\nwatchEffect(() => {\n  const activeItem = getItems().map(i => i.ref).find(\n    item => item === getActiveElement(),\n  )\n  activeItem?.scrollIntoView({ block: 'nearest' })\n})\n\nfunction handlePointerDown() {\n  if (autoScrollTimerRef.value === null) {\n    autoScrollTimerRef.value = window.setInterval(() => {\n      emits('autoScroll')\n    }, 50)\n  }\n}\n\nfunction handlePointerMove() {\n  contentContext.onItemLeave?.()\n  if (autoScrollTimerRef.value === null) {\n    autoScrollTimerRef.value = window.setInterval(() => {\n      emits('autoScroll')\n    }, 50)\n  }\n}\n\nonBeforeUnmount(() => clearAutoScrollTimer())\n</script>\n\n<template>\n  <Primitive\n    aria-hidden=\"true\"\n    :style=\"{\n      flexShrink: 0,\n    }\"\n    v-bind=\"$parent?.$props\"\n    @pointerdown=\"handlePointerDown\"\n    @pointermove=\"handlePointerMove\"\n    @pointerleave=\"\n      () => {\n        clearAutoScrollTimer();\n      }\n    \"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface SelectScrollDownButtonProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref, watch, watchEffect } from 'vue'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\nimport { injectSelectItemAlignedPositionContext } from './SelectItemAlignedPosition.vue'\nimport SelectScrollButtonImpl from './SelectScrollButtonImpl.vue'\n\ndefineProps<SelectScrollDownButtonProps>()\n\nconst contentContext = injectSelectContentContext()\nconst alignedPositionContext\n  = contentContext.position === 'item-aligned'\n    ? injectSelectItemAlignedPositionContext()\n    : undefined\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst canScrollDown = ref(false)\n\nwatchEffect((cleanupFn) => {\n  if (contentContext.viewport?.value && contentContext.isPositioned?.value) {\n    const viewport = contentContext.viewport.value\n\n    function handleScroll() {\n      const maxScroll = viewport.scrollHeight - viewport.clientHeight\n      // we use Math.ceil here because if the UI is zoomed-in\n      // `scrollTop` is not always reported as an integer\n      canScrollDown.value = Math.ceil(viewport.scrollTop) < maxScroll\n    }\n    handleScroll()\n    viewport.addEventListener('scroll', handleScroll)\n\n    cleanupFn(() => viewport.removeEventListener('scroll', handleScroll))\n  }\n})\n\nwatch(currentElement, () => {\n  if (currentElement.value)\n    alignedPositionContext?.onScrollButtonChange(currentElement.value)\n})\n</script>\n\n<template>\n  <SelectScrollButtonImpl\n    v-if=\"canScrollDown\"\n    :ref=\"forwardRef\"\n    @auto-scroll=\"\n      () => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport?.value && selectedItem?.value) {\n          viewport.value.scrollTop = viewport.value.scrollTop + selectedItem.value.offsetHeight;\n        }\n      }\n    \"\n  >\n    <slot />\n  </SelectScrollButtonImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface SelectScrollUpButtonProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ref, watch, watchEffect } from 'vue'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\nimport { injectSelectItemAlignedPositionContext } from './SelectItemAlignedPosition.vue'\nimport SelectScrollButtonImpl from './SelectScrollButtonImpl.vue'\n\ndefineProps<SelectScrollUpButtonProps>()\n\nconst contentContext = injectSelectContentContext()\nconst alignedPositionContext\n  = contentContext.position === 'item-aligned'\n    ? injectSelectItemAlignedPositionContext()\n    : undefined\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst canScrollUp = ref(false)\n\nwatchEffect((cleanupFn) => {\n  if (contentContext.viewport?.value && contentContext.isPositioned?.value) {\n    const viewport = contentContext.viewport.value\n\n    function handleScroll() {\n      canScrollUp.value = viewport.scrollTop > 0\n    }\n    handleScroll()\n    viewport.addEventListener('scroll', handleScroll)\n\n    cleanupFn(() => viewport.removeEventListener('scroll', handleScroll))\n  }\n})\n\nwatch(currentElement, () => {\n  if (currentElement.value)\n    alignedPositionContext?.onScrollButtonChange(currentElement.value)\n})\n</script>\n\n<template>\n  <SelectScrollButtonImpl\n    v-if=\"canScrollUp\"\n    :ref=\"forwardRef\"\n    @auto-scroll=\"() => {\n      const { viewport, selectedItem } = contentContext;\n      if (viewport?.value && selectedItem?.value) {\n        viewport.value.scrollTop = viewport.value.scrollTop - selectedItem.value.offsetHeight;\n      }\n    }\"\n  >\n    <slot />\n  </SelectScrollButtonImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface SelectSeparatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<SelectSeparatorProps>()\n</script>\n\n<template>\n  <Primitive\n    aria-hidden=\"true\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport { useCollection } from '@/Collection'\n\nexport interface SelectTriggerProps extends PopperAnchorProps {\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport type { PopperAnchorProps } from '@/Popper'\nimport { computed, onMounted } from 'vue'\nimport { PopperAnchor } from '@/Popper'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose, useId, useTypeahead } from '@/shared'\nimport {\n  injectSelectRootContext,\n} from './SelectRoot.vue'\nimport { OPEN_KEYS, shouldShowPlaceholder } from './utils'\n\nconst props = withDefaults(defineProps<SelectTriggerProps>(), {\n  as: 'button',\n})\nconst rootContext = injectSelectRootContext()\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\n\nconst isDisabled = computed(() => rootContext.disabled?.value || props.disabled)\n\nrootContext.contentId ||= useId(undefined, 'reka-select-content')\nonMounted(() => {\n  rootContext.onTriggerChange(triggerElement.value)\n})\n\nconst { getItems } = useCollection()\nconst { search, handleTypeaheadSearch, resetTypeahead } = useTypeahead()\nfunction handleOpen() {\n  if (!isDisabled.value) {\n    rootContext.onOpenChange(true)\n    // reset typeahead when we open\n    resetTypeahead()\n  }\n}\n\nfunction handlePointerOpen(event: PointerEvent) {\n  handleOpen()\n  rootContext.triggerPointerDownPosRef.value = {\n    x: Math.round(event.pageX),\n    y: Math.round(event.pageY),\n  }\n}\n</script>\n\n<template>\n  <PopperAnchor\n    as-child\n    :reference=\"reference\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"combobox\"\n      :type=\"as === 'button' ? 'button' : undefined\"\n      :aria-controls=\"rootContext.contentId\"\n      :aria-expanded=\"rootContext.open.value || false\"\n      :aria-required=\"rootContext.required?.value\"\n      aria-autocomplete=\"none\"\n      :disabled=\"isDisabled\"\n      :dir=\"rootContext?.dir.value\"\n      :data-state=\"rootContext?.open.value ? 'open' : 'closed'\"\n      :data-disabled=\"isDisabled ? '' : undefined\"\n      :data-placeholder=\"shouldShowPlaceholder(rootContext.modelValue?.value) ? '' : undefined\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      @click=\"\n        (event: MouseEvent) => {\n          // Whilst browsers generally have no issue focusing the trigger when clicking\n          // on a label, Safari seems to struggle with the fact that there's no `onClick`.\n          // We force `focus` in this case. Note: this doesn't create any other side-effect\n          // because we are preventing default in `onPointerDown` so effectively\n          // this only runs for a label 'click'\n          (event?.currentTarget as HTMLElement)?.focus();\n        }\n      \"\n      @pointerdown=\"\n        (event: PointerEvent) => {\n          // Prevent opening on touch down.\n          // https://github.com/unovue/reka-ui/issues/804\n          if (event.pointerType === 'touch')\n            return event.preventDefault();\n\n          // prevent implicit pointer capture\n          // https://www.w3.org/TR/pointerevents3/#implicit-pointer-capture\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n          }\n\n          // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n          // but not when the control key is pressed (avoiding MacOS right click)\n          if (event.button === 0 && event.ctrlKey === false) {\n            handlePointerOpen(event)\n            // prevent trigger from stealing focus from the active item after opening.\n            event.preventDefault();\n          }\n        }\n      \"\n      @pointerup.prevent=\"\n        (event: PointerEvent) => {\n          // Only open on pointer up when using touch devices\n          // https://github.com/unovue/reka-ui/issues/804\n          if (event.pointerType === 'touch')\n            handlePointerOpen(event)\n        }\n      \"\n      @keydown=\"\n        (event) => {\n          const isTypingAhead = search !== '';\n          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n          if (!isModifierKey && event.key.length === 1)\n            if (isTypingAhead && event.key === ' ') return;\n\n          handleTypeaheadSearch(event.key, getItems());\n          if (OPEN_KEYS.includes(event.key)) {\n            handleOpen();\n            event.preventDefault();\n          }\n        }\n      \"\n    >\n      <slot />\n    </Primitive>\n  </PopperAnchor>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { AcceptableValue } from '@/shared/types'\nimport { valueComparator } from './utils'\n\nexport interface SelectValueProps extends PrimitiveProps {\n  /** The content that will be rendered inside the `SelectValue` when no `value` or `defaultValue` is set. */\n  placeholder?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectSelectRootContext } from './SelectRoot.vue'\n\nconst props = withDefaults(defineProps<SelectValueProps>(), {\n  as: 'span',\n  placeholder: '',\n})\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst rootContext = injectSelectRootContext()\n\nonMounted(() => {\n  rootContext.valueElement = currentElement\n})\n\nconst selectedLabel = computed(() => {\n  let list: string[] = []\n  const options = Array.from(rootContext.optionsSet.value)\n  const getOption = (value?: AcceptableValue) => options.find(option => valueComparator(value, option.value, rootContext.by))\n  if (Array.isArray(rootContext.modelValue.value)) {\n    list = rootContext.modelValue.value.map(value => getOption(value)?.textContent ?? '')\n  }\n  else {\n    list = [getOption(rootContext.modelValue.value)?.textContent ?? '']\n  }\n  return list.filter(Boolean)\n})\n\nconst slotText = computed(() => {\n  return selectedLabel.value.length ? selectedLabel.value.join(', ') : props.placeholder\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :style=\"{ pointerEvents: 'none' }\"\n    :data-placeholder=\"selectedLabel.length ? undefined : props.placeholder\"\n  >\n    <slot\n      :selected-label=\"selectedLabel\"\n      :model-value=\"rootContext.modelValue.value\"\n    >\n      {{ slotText }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { useNonce } from '@/shared/useNonce'\n\nexport interface SelectViewportProps extends PrimitiveProps {\n  /**\n   * Will add `nonce` attribute to the style tag which can be used by Content Security Policy. <br> If omitted, inherits globally from `ConfigProvider`.\n   */\n  nonce?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted, ref, toRefs } from 'vue'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectSelectContentContext } from './SelectContentImpl.vue'\nimport { injectSelectItemAlignedPositionContext } from './SelectItemAlignedPosition.vue'\nimport { CONTENT_MARGIN } from './utils'\n\nconst props = defineProps<SelectViewportProps>()\nconst { nonce: propNonce } = toRefs(props)\nconst nonce = useNonce(propNonce)\n\nconst contentContext = injectSelectContentContext()\nconst alignedPositionContext\n  = contentContext.position === 'item-aligned'\n    ? injectSelectItemAlignedPositionContext()\n    : undefined\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nonMounted(() => {\n  contentContext?.onViewportChange(currentElement.value)\n})\n\nconst prevScrollTopRef = ref(0)\n\nfunction handleScroll(event: WheelEvent) {\n  const viewport = event.currentTarget as HTMLElement\n  const { shouldExpandOnScrollRef, contentWrapper } = alignedPositionContext ?? {}\n  if (shouldExpandOnScrollRef?.value && contentWrapper?.value) {\n    const scrolledBy = Math.abs(prevScrollTopRef.value - viewport.scrollTop)\n    if (scrolledBy > 0) {\n      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2\n      const cssMinHeight = Number.parseFloat(\n        contentWrapper.value.style.minHeight,\n      )\n      const cssHeight = Number.parseFloat(contentWrapper.value.style.height)\n      const prevHeight = Math.max(cssMinHeight, cssHeight)\n\n      if (prevHeight < availableHeight) {\n        const nextHeight = prevHeight + scrolledBy\n        const clampedNextHeight = Math.min(availableHeight, nextHeight)\n        const heightDiff = nextHeight - clampedNextHeight\n\n        contentWrapper.value.style.height = `${clampedNextHeight}px`\n        if (contentWrapper.value.style.bottom === '0px') {\n          viewport.scrollTop = heightDiff > 0 ? heightDiff : 0\n          // ensure the content stays pinned to the bottom\n          contentWrapper.value.style.justifyContent = 'flex-end'\n        }\n      }\n    }\n  }\n  prevScrollTopRef.value = viewport.scrollTop\n}\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    data-reka-select-viewport\n    role=\"presentation\"\n    v-bind=\"{ ...$attrs, ...props }\"\n    :style=\"{\n      // we use position: 'relative' here on the `viewport` so that when we call\n      // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n      // (independent of the scrollUpButton).\n      position: 'relative',\n      flex: 1,\n      overflow: 'hidden auto',\n    }\"\n    @scroll=\"handleScroll\"\n  >\n    <slot />\n  </Primitive>\n  <Primitive\n    as=\"style\"\n    :nonce=\"nonce\"\n  >\n    /* Hide scrollbars cross-browser and enable momentum scroll for touch\n    devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none;\n    -webkit-overflow-scrolling: touch; }\n    [data-reka-select-viewport]::-webkit-scrollbar { display: none; }\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DataOrientation } from '../types'\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface BaseSeparatorProps extends PrimitiveProps {\n  /**\n   * Orientation of the component.\n   *\n   * Either `vertical` or `horizontal`. Defaults to `horizontal`.\n   */\n  orientation?: DataOrientation\n  /**\n   * Whether or not the component is purely decorative. <br>When `true`, accessibility-related attributes\n   * are updated so that that the rendered element is removed from the accessibility tree.\n   */\n  decorative?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<BaseSeparatorProps>(), {\n  orientation: 'horizontal',\n})\n\nconst ORIENTATIONS = ['horizontal', 'vertical'] as const\nfunction isValidOrientation(orientation: any): orientation is DataOrientation {\n  return ORIENTATIONS.includes(orientation)\n}\n\nconst computedOrientation = computed(() =>\n  isValidOrientation(props.orientation) ? props.orientation : 'horizontal',\n)\n// `aria-orientation` defaults to `horizontal` so we only need it if `orientation` is vertical\nconst ariaOrientation = computed(() =>\n  computedOrientation.value === 'vertical' ? props.orientation : undefined,\n)\n\nconst semanticProps = computed(() =>\n  props.decorative\n    ? { role: 'none' }\n    : { 'aria-orientation': ariaOrientation.value, 'role': 'separator' },\n)\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :data-orientation=\"computedOrientation\"\n    v-bind=\"semanticProps\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { BaseSeparatorProps } from '@/shared/component/BaseSeparator.vue'\n\nexport interface SeparatorProps extends BaseSeparatorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport BaseSeparator from '@/shared/component/BaseSeparator.vue'\n\nconst props = withDefaults(defineProps<SeparatorProps>(), {\n  orientation: 'horizontal',\n})\n</script>\n\n<template>\n  <BaseSeparator v-bind=\"props\">\n    <slot />\n  </BaseSeparator>\n</template>\n", "import type { ComputedRef } from 'vue'\nimport { clamp, createContext } from '@/shared'\n\nexport interface SliderOrientationPrivateProps {\n  min: number\n  max: number\n  inverted: boolean\n}\n\nexport type SliderOrientationPrivateEmits = {\n  slideEnd: []\n  slideStart: [value: number]\n  slideMove: [value: number]\n  homeKeyDown: [event: KeyboardEvent]\n  endKeyDown: [event: KeyboardEvent]\n  stepKeyDown: [event: KeyboardEvent, direction: number]\n}\n\nexport function getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues]\n  nextValues[atIndex] = nextValue\n  return nextValues.sort((a, b) => a - b)\n}\n\nexport function convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min\n  const percentPerStep = 100 / maxSteps\n  const percentage = percentPerStep * (value - min)\n  return clamp(percentage, 0, 100)\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nexport function getLabel(index: number, totalValues: number) {\n  if (totalValues > 2)\n    return `Value ${index + 1} of ${totalValues}`\n\n  else if (totalValues === 2)\n    return ['Minimum', 'Maximum'][index]\n\n  else\n    return undefined\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nexport function getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1)\n    return 0\n  const distances = values.map(value => Math.abs(value - nextValue))\n  const closestDistance = Math.min(...distances)\n  return distances.indexOf(closestDistance)\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nexport function getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2\n  const halfPercent = 50\n  const offset = linearScale([0, halfPercent], [0, halfWidth])\n  return (halfWidth - offset(left) * direction) * direction\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nexport function getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value)\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nexport function hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values)\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues)\n    return actualMinStepsBetweenValues >= minStepsBetweenValues\n  }\n  return true\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nexport function linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1])\n      return output[0]\n    const ratio = (output[1] - output[0]) / (input[1] - input[0])\n    return output[0] + ratio * (value - input[0])\n  }\n}\n\nexport function getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length\n}\n\nexport function roundValue(value: number, decimalCount: number) {\n  const rounder = 10 ** decimalCount\n  return Math.round(value * rounder) / rounder\n}\n\nexport type Direction = 'ltr' | 'rtl'\n\nexport const PAGE_KEYS = ['PageUp', 'PageDown']\nexport const ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight']\n\ntype SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top'\nexport const BACK_KEYS: Record<SlideDirection, string[]> = {\n  'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],\n  'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-top': ['Home', 'PageUp', 'ArrowUp', 'ArrowLeft'],\n}\n\ntype Side = 'top' | 'right' | 'bottom' | 'left'\ninterface SliderOrientation {\n  startEdge: ComputedRef<Side>\n  endEdge: ComputedRef<Side>\n  direction: ComputedRef<1 | -1>\n  size: 'width' | 'height'\n}\n\nexport const [injectSliderOrientationContext, provideSliderOrientationContext]\n  = createContext<SliderOrientation>(['SliderVertical', 'SliderHorizontal'])\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport type SliderImplEmits = {\n  slideStart: [event: PointerEvent]\n  slideMove: [event: PointerEvent]\n  slideEnd: [event: PointerEvent]\n  homeKeyDown: [event: KeyboardEvent]\n  endKeyDown: [event: KeyboardEvent]\n  stepKeyDown: [event: KeyboardEvent]\n}\n\nexport interface SliderImplProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectSliderRootContext } from './SliderRoot.vue'\nimport { ARROW_KEYS, PAGE_KEYS } from './utils'\n\nconst props = withDefaults(defineProps<SliderImplProps>(), {\n  as: 'span',\n})\nconst emits = defineEmits<SliderImplEmits>()\nconst rootContext = injectSliderRootContext()\n</script>\n\n<template>\n  <Primitive\n    data-slider-impl\n    v-bind=\"props\"\n    @keydown=\"(event) => {\n      if (event.key === 'Home') {\n        emits('homeKeyDown', event)\n        // Prevent scrolling to page start\n        event.preventDefault();\n      }\n      else if (event.key === 'End') {\n        emits('endKeyDown', event)\n        // Prevent scrolling to page end\n        event.preventDefault();\n      }\n      else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n        emits('stepKeyDown', event)\n        // Prevent scrolling for directional key presses\n        event.preventDefault();\n      }\n    }\"\n    @pointerdown=\"(event) => {\n      const target = event.target as HTMLElement;\n      target.setPointerCapture(event.pointerId);\n      // Prevent browser focus behaviour because we focus a thumb manually when values change.\n      event.preventDefault();\n      // Touch devices have a delay before focusing so won't focus if touch immediately moves\n      // away from target (sliding). We want thumb to focus regardless.\n      if (rootContext.thumbElements.value.includes(target)) {\n        target.focus();\n      }\n      else {\n        emits('slideStart', event)\n      }\n    }\"\n    @pointermove=\"(event) => {\n      const target = event.target as HTMLElement;\n      if (target.hasPointerCapture(event.pointerId)) emits('slideMove', event);\n    }\"\n    @pointerup=\"(event) => {\n      const target = event.target as HTMLElement;\n      if (target.hasPointerCapture(event.pointerId)) {\n        target.releasePointerCapture(event.pointerId);\n        emits('slideEnd', event)\n      }\n    }\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script setup lang=\"ts\">\nimport type { Direction, SliderOrientationPrivateEmits, SliderOrientationPrivateProps } from './utils'\nimport { computed, ref, toRefs } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport SliderImpl from './SliderImpl.vue'\nimport { injectSliderRootContext } from './SliderRoot.vue'\nimport { BACK_KEYS, linearScale, provideSliderOrientationContext } from './utils'\n\ninterface SliderHorizontalProps extends SliderOrientationPrivateProps {\n  dir?: Direction\n}\n\nconst props = defineProps<SliderHorizontalProps>()\nconst emits = defineEmits<SliderOrientationPrivateEmits>()\nconst { max, min, dir, inverted } = toRefs(props)\n\nconst { forwardRef, currentElement: sliderElement } = useForwardExpose()\nconst rootContext = injectSliderRootContext()\n\nconst offsetPosition = ref<number>()\nconst rectRef = ref<DOMRect>()\nconst isSlidingFromLeft = computed(() => (dir?.value !== 'rtl' && !inverted.value) || (dir?.value !== 'ltr' && inverted.value))\n\nfunction getValueFromPointerEvent(event: PointerEvent, slideStart?: boolean) {\n  const rect = rectRef.value || sliderElement.value!.getBoundingClientRect()\n\n  // Get the currently active thumb element\n  const thumb = [...rootContext.thumbElements.value][rootContext.valueIndexToChangeRef.value]\n  const thumbWidth = rootContext.thumbAlignment.value === 'contain' ? thumb.clientWidth : 0\n\n  // Calculate offset for dragging, but only when needed\n  if (!offsetPosition.value && !slideStart && rootContext.thumbAlignment.value === 'contain') {\n    offsetPosition.value = event.clientX - thumb.getBoundingClientRect().left\n  }\n\n  // Define the input range (slider track width minus thumb width)\n  const input: [number, number] = [0, rect.width - thumbWidth]\n  const output: [number, number] = isSlidingFromLeft.value ? [min.value, max.value] : [max.value, min.value]\n  const value = linearScale(input, output)\n\n  rectRef.value = rect\n  const position = slideStart\n    ? event.clientX - rect.left - thumbWidth / 2\n    : event.clientX - rect.left - (offsetPosition.value ?? 0)\n\n  return value(position)\n}\n\nconst startEdge = computed(() => isSlidingFromLeft.value ? 'left' : 'right')\nconst endEdge = computed(() => isSlidingFromLeft.value ? 'right' : 'left')\nconst direction = computed(() => isSlidingFromLeft.value ? 1 : -1)\n\nprovideSliderOrientationContext({\n  startEdge,\n  endEdge,\n  direction,\n  size: 'width',\n})\n</script>\n\n<template>\n  <SliderImpl\n    :ref=\"forwardRef\"\n    :dir=\"dir\"\n    data-orientation=\"horizontal\"\n    :style=\"{\n      ['--reka-slider-thumb-transform' as any]:\n        !isSlidingFromLeft && rootContext.thumbAlignment.value === 'overflow' ? 'translateX(50%)' : 'translateX(-50%)',\n    }\"\n    @slide-start=\"(event) => {\n      const value = getValueFromPointerEvent(event, true);\n      emits('slideStart', value)\n    }\"\n    @slide-move=\"(event) => {\n      const value = getValueFromPointerEvent(event);\n      emits('slideMove', value)\n    }\"\n    @slide-end=\"() => {\n      rectRef = undefined;\n      offsetPosition = undefined\n      emits('slideEnd')\n    }\"\n    @step-key-down=\"(event) => {\n      const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right';\n      const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n      emits('stepKeyDown', event, isBackKey ? -1 : 1)\n    }\"\n    @end-key-down=\"emits('endKeyDown', $event)\"\n    @home-key-down=\"emits('homeKeyDown', $event)\"\n  >\n    <slot />\n  </SliderImpl>\n</template>\n", "<script setup lang=\"ts\">\nimport type { SliderOrientationPrivateEmits, SliderOrientationPrivateProps } from './utils'\nimport { computed, ref, toRefs } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport SliderImpl from './SliderImpl.vue'\nimport { injectSliderRootContext } from './SliderRoot.vue'\nimport { BACK_KEYS, linearScale, provideSliderOrientationContext } from './utils'\n\ninterface SliderVerticalProps extends SliderOrientationPrivateProps {}\nconst props = defineProps<SliderVerticalProps>()\nconst emits = defineEmits<SliderOrientationPrivateEmits>()\nconst { max, min, inverted } = toRefs(props)\n\nconst rootContext = injectSliderRootContext()\nconst { forwardRef, currentElement: sliderElement } = useForwardExpose()\n\nconst offsetPosition = ref<number>()\nconst rectRef = ref<DOMRect>()\nconst isSlidingFromBottom = computed(() => !inverted.value)\n\nfunction getValueFromPointerEvent(event: PointerEvent, slideStart?: boolean) {\n  const rect = rectRef.value || sliderElement.value!.getBoundingClientRect()\n\n  // Get the currently active thumb element\n  const thumb = [...rootContext.thumbElements.value][rootContext.valueIndexToChangeRef.value]\n  const thumbHeight = rootContext.thumbAlignment.value === 'contain' ? thumb.clientHeight : 0\n\n  // Calculate offset for dragging, but only when needed\n  if (!offsetPosition.value && !slideStart && rootContext.thumbAlignment.value === 'contain') {\n    offsetPosition.value = event.clientY - thumb.getBoundingClientRect().top\n  }\n\n  // Define the input range (slider track width minus thumb width)\n  const input: [number, number] = [0, rect.height - thumbHeight]\n  const output: [number, number] = isSlidingFromBottom.value ? [max.value, min.value] : [min.value, max.value]\n  const value = linearScale(input, output)\n\n  const position = slideStart\n    ? event.clientY - rect.top - thumbHeight / 2\n    : event.clientY - rect.top - (offsetPosition.value ?? 0)\n\n  rectRef.value = rect\n  return value(position)\n}\n\nconst startEdge = computed(() => isSlidingFromBottom.value ? 'bottom' : 'top')\nconst endEdge = computed(() => isSlidingFromBottom.value ? 'top' : 'bottom')\nconst direction = computed(() => isSlidingFromBottom.value ? 1 : -1)\n\nprovideSliderOrientationContext({\n  startEdge,\n  endEdge,\n  direction,\n  size: 'height',\n})\n</script>\n\n<template>\n  <SliderImpl\n    :ref=\"forwardRef\"\n    data-orientation=\"vertical\"\n    :style=\"{\n      ['--reka-slider-thumb-transform' as any]:\n        !isSlidingFromBottom && rootContext.thumbAlignment.value === 'overflow' ? 'translateY(-50%)' : 'translateY(50%)',\n    }\"\n    @slide-start=\"(event) => {\n      const value = getValueFromPointerEvent(event, true);\n      emits('slideStart', value)\n    }\"\n    @slide-move=\"(event) => {\n      const value = getValueFromPointerEvent(event);\n      emits('slideMove', value)\n    }\"\n    @slide-end=\"() => {\n      rectRef = undefined;\n      offsetPosition = undefined\n      emits('slideEnd')\n    }\"\n    @step-key-down=\"(event) => {\n      const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top';\n      const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n      emits('stepKeyDown', event, isBackKey ? -1 : 1)\n    }\"\n    @end-key-down=\"emits('endKeyDown', $event)\"\n    @home-key-down=\"emits('homeKeyDown', $event)\"\n  >\n    <slot />\n  </SliderImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { DataOrientation, Direction, FormFieldProps } from '../shared/types'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { clamp, createContext, useDirection, useFormControl, useForwardExpose } from '@/shared'\n\ntype ThumbAlignment = 'contain' | 'overflow'\n\nexport interface SliderRootProps extends PrimitiveProps, FormFieldProps {\n  /** The value of the slider when initially rendered. Use when you do not need to control the state of the slider. */\n  defaultValue?: number[]\n  /** The controlled value of the slider. Can be bind as `v-model`. */\n  modelValue?: number[] | null\n  /** When `true`, prevents the user from interacting with the slider. */\n  disabled?: boolean\n  /** The orientation of the slider. */\n  orientation?: DataOrientation\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** Whether the slider is visually inverted. */\n  inverted?: boolean\n  /** The minimum value for the range. */\n  min?: number\n  /** The maximum value for the range. */\n  max?: number\n  /** The stepping interval. */\n  step?: number\n  /** The minimum permitted steps between multiple thumbs. */\n  minStepsBetweenThumbs?: number\n  /**\n   * The alignment of the slider thumb.\n   * - `contain`: thumbs will be contained within the bounds of the track.\n   * - `overflow`: thumbs will not be bound by the track. No extra offset will be added.\n   * @defaultValue 'contain'\n   */\n  thumbAlignment?: ThumbAlignment\n}\n\nexport type SliderRootEmits = {\n  /**\n   * Event handler called when the slider value changes\n   */\n  'update:modelValue': [payload: number[] | undefined]\n  /**\n   * Event handler called when the value changes at the end of an interaction.\n   *\n   * Useful when you only need to capture a final value e.g. to update a backend service.\n   */\n  'valueCommit': [payload: number[]]\n}\n\nexport interface SliderRootContext {\n  orientation: Ref<DataOrientation>\n  disabled: Ref<boolean>\n  min: Ref<number>\n  max: Ref<number>\n  modelValue?: Readonly<Ref<number[] | null | undefined>>\n  currentModelValue: ComputedRef<number[]>\n  valueIndexToChangeRef: Ref<number>\n  thumbElements: Ref<HTMLElement[]>\n  thumbAlignment: Ref<ThumbAlignment>\n}\n\nexport const [injectSliderRootContext, provideSliderRootContext]\n  = createContext<SliderRootContext>('SliderRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, ref, toRaw, toRefs } from 'vue'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\nimport SliderHorizontal from './SliderHorizontal.vue'\nimport SliderVertical from './SliderVertical.vue'\nimport { ARROW_KEYS, getClosestValueIndex, getDecimalCount, getNextSortedValues, hasMinStepsBetweenValues, PAGE_KEYS, roundValue } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<SliderRootProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  orientation: 'horizontal',\n  disabled: false,\n  minStepsBetweenThumbs: 0,\n  defaultValue: () => [0],\n  inverted: false,\n  thumbAlignment: 'contain',\n  as: 'span',\n})\nconst emits = defineEmits<SliderRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current slider values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { min, max, step, minStepsBetweenThumbs, orientation, disabled, thumbAlignment, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nconst { forwardRef, currentElement } = useForwardExpose()\nconst isFormControl = useFormControl(currentElement)\n\nconst { CollectionSlot } = useCollection({ isProvider: true })\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<number[] | null>\n\nconst currentModelValue = computed(() => Array.isArray(modelValue.value) ? [...modelValue.value] : [])\n\nconst valueIndexToChangeRef = ref(0)\nconst valuesBeforeSlideStartRef = ref(currentModelValue.value)\n\nfunction handleSlideStart(value: number) {\n  const closestIndex = getClosestValueIndex(currentModelValue.value, value)\n  updateValues(value, closestIndex)\n}\n\nfunction handleSlideMove(value: number) {\n  updateValues(value, valueIndexToChangeRef.value)\n}\n\nfunction handleSlideEnd() {\n  const prevValue = valuesBeforeSlideStartRef.value[valueIndexToChangeRef.value]\n  const nextValue = currentModelValue.value[valueIndexToChangeRef.value]\n  const hasChanged = nextValue !== prevValue\n  if (hasChanged)\n    emits('valueCommit', toRaw(currentModelValue.value))\n}\n\nfunction updateValues(value: number, atIndex: number, { commit } = { commit: false }) {\n  const decimalCount = getDecimalCount(step.value)\n  const snapToStep = roundValue(Math.round((value - min.value) / step.value) * step.value + min.value, decimalCount)\n  const nextValue = clamp(snapToStep, min.value, max.value)\n\n  const nextValues = getNextSortedValues(currentModelValue.value, nextValue, atIndex)\n\n  if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs.value * step.value)) {\n    valueIndexToChangeRef.value = nextValues.indexOf(nextValue)\n    const hasChanged = String(nextValues) !== String(modelValue.value)\n    if (hasChanged && commit)\n      emits('valueCommit', nextValues)\n\n    if (hasChanged) {\n      thumbElements.value[valueIndexToChangeRef.value]?.focus()\n      modelValue.value = nextValues\n    }\n  }\n}\n\nconst thumbElements = ref<HTMLElement[]>([])\nprovideSliderRootContext({\n  modelValue,\n  currentModelValue,\n  valueIndexToChangeRef,\n  thumbElements,\n  orientation,\n  min,\n  max,\n  disabled,\n  thumbAlignment,\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <component\n      :is=\"orientation === 'horizontal' ? SliderHorizontal : SliderVertical\"\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      :min=\"min\"\n      :max=\"max\"\n      :dir=\"dir\"\n      :inverted=\"inverted\"\n      :aria-disabled=\"disabled\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      @pointerdown=\"() => {\n        if (!disabled) valuesBeforeSlideStartRef = currentModelValue\n      }\"\n      @slide-start=\"!disabled && handleSlideStart($event)\"\n      @slide-move=\"!disabled && handleSlideMove($event)\"\n      @slide-end=\"!disabled && handleSlideEnd()\"\n      @home-key-down=\"!disabled && updateValues(min, 0, { commit: true })\"\n      @end-key-down=\"!disabled && updateValues(max, currentModelValue.length - 1, { commit: true })\"\n      @step-key-down=\"(event, direction) => {\n        if (!disabled) {\n          const isPageKey = PAGE_KEYS.includes(event.key);\n          const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n          const multiplier = isSkipKey ? 10 : 1;\n          const atIndex = valueIndexToChangeRef;\n          const value = currentModelValue[atIndex];\n          const stepInDirection = step * multiplier * direction;\n          updateValues(value + stepInDirection, atIndex, { commit: true });\n        }\n      }\"\n    >\n      <slot :model-value=\"modelValue\" />\n\n      <VisuallyHiddenInput\n        v-if=\"isFormControl && name\"\n        type=\"number\"\n        :value=\"modelValue\"\n        :name=\"name\"\n        :required=\"required\"\n        :disabled=\"disabled\"\n        :step=\"step\"\n      />\n    </component>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface SliderRangeProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectSliderRootContext } from './SliderRoot.vue'\nimport { convertValueToPercentage, injectSliderOrientationContext } from './utils'\n\nwithDefaults(defineProps<SliderRangeProps>(), { as: 'span' })\nconst rootContext = injectSliderRootContext()\nconst orientation = injectSliderOrientationContext()\n\nuseForwardExpose()\nconst percentages = computed(() => rootContext.currentModelValue.value.map(value =>\n  convertValueToPercentage(value, rootContext.min.value, rootContext.max.value),\n))\n\nconst offsetStart = computed(() => rootContext.currentModelValue.value.length > 1 ? Math.min(...percentages.value!) : 0)\nconst offsetEnd = computed(() => 100 - Math.max(...percentages.value, 0))\n</script>\n\n<template>\n  <Primitive\n    :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n    :data-orientation=\"rootContext.orientation.value\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n    :style=\"{\n      [orientation!.startEdge.value]: `${offsetStart}%`,\n      [orientation!.endEdge.value]: `${offsetEnd}%`,\n    }\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface SliderThumbImplProps extends PrimitiveProps {\n  index: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useMounted } from '@vueuse/core'\nimport { computed, onMounted, onUnmounted } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\nimport { useForwardExpose, useSize } from '@/shared'\nimport { injectSliderRootContext } from './SliderRoot.vue'\nimport { convertValueToPercentage, getLabel, getThumbInBoundsOffset, injectSliderOrientationContext } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = defineProps<SliderThumbImplProps>()\n\nconst rootContext = injectSliderRootContext()\nconst orientation = injectSliderOrientationContext()\n\nconst { forwardRef, currentElement: thumbElement } = useForwardExpose()\nconst { CollectionItem } = useCollection()\n\nconst value = computed(() => rootContext.modelValue?.value?.[props.index])\nconst percent = computed(() => value.value === undefined ? 0 : convertValueToPercentage(value.value, rootContext.min.value ?? 0, rootContext.max.value ?? 100))\nconst label = computed(() => getLabel(props.index, rootContext.modelValue?.value?.length ?? 0))\nconst size = useSize(thumbElement)\nconst orientationSize = computed(() => size[orientation!.size].value)\nconst thumbInBoundsOffset = computed(() => {\n  if (rootContext.thumbAlignment.value === 'overflow' || !orientationSize.value) {\n    return 0\n  }\n  else {\n    return getThumbInBoundsOffset(orientationSize.value, percent.value, orientation!.direction.value)\n  }\n})\n\nconst isMounted = useMounted()\nonMounted(() => {\n  rootContext.thumbElements.value.push(thumbElement.value)\n})\nonUnmounted(() => {\n  const i = rootContext.thumbElements.value.findIndex(i => i === thumbElement.value) ?? -1\n  rootContext.thumbElements.value.splice(i, 1)\n})\n</script>\n\n<template>\n  <CollectionItem>\n    <Primitive\n      v-bind=\"$attrs\"\n      :ref=\"forwardRef\"\n      role=\"slider\"\n      :tabindex=\"rootContext.disabled.value ? undefined : 0\"\n      :aria-label=\"$attrs['aria-label'] || label\"\n      :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n      :data-orientation=\"rootContext.orientation.value\"\n      :aria-valuenow=\"value\"\n      :aria-valuemin=\"rootContext.min.value\"\n      :aria-valuemax=\"rootContext.max.value\"\n      :aria-orientation=\"rootContext.orientation.value\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      :style=\"{\n        transform: 'var(--reka-slider-thumb-transform)',\n        position: 'absolute',\n        [orientation!.startEdge.value]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        /**\n         * There will be no value on initial render while we work out the index so we hide thumbs\n         * without a value, otherwise SSR will render them in the wrong position before they\n         * snap into the correct position during hydration which would be visually jarring for\n         * slower connections.\n         */\n        display: !isMounted && value === undefined ? 'none' : undefined,\n      }\"\n      @focus=\"() => {\n        rootContext.valueIndexToChangeRef.value = index\n      }\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface SliderThumbProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { useCollection } from '@/Collection'\nimport SliderThumbImpl from './SliderThumbImpl.vue'\n\nconst props = withDefaults(defineProps<SliderThumbProps>(), {\n  as: 'span',\n})\nconst { getItems } = useCollection()\n\nconst { forwardRef, currentElement: thumbElement } = useForwardExpose()\n\nconst index = computed(() => thumbElement.value ? getItems(true).findIndex(i => i.ref === thumbElement.value) : -1)\n</script>\n\n<template>\n  <SliderThumbImpl\n    :ref=\"forwardRef\"\n    v-bind=\"props\"\n    :index=\"index\"\n  >\n    <slot />\n  </SliderThumbImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface SliderTrackProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectSliderRootContext } from './SliderRoot.vue'\n\nwithDefaults(defineProps<SliderTrackProps>(), { as: 'span' })\n\nconst rootContext = injectSliderRootContext()\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    :as-child=\"asChild\"\n    :as=\"as\"\n    :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n    :data-orientation=\"rootContext.orientation.value\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "export function assert(\n  expectedCondition: any,\n  message = 'Assertion failed!',\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message)\n\n    throw new Error(message)\n  }\n}\n", "export const isBrowser = typeof document !== 'undefined'\n", "import type { PanelData } from '../SplitterPanel.vue'\nimport { isBrowser } from '@/shared'\n\nexport function getPanelElement(\n  id: string,\n  scope: ParentNode | HTMLElement = document,\n): HTMLElement | null {\n  if (!isBrowser)\n    return null\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`)\n  if (element)\n    return element as HTMLElement\n\n  return null\n}\n\nexport function getPanelElementsForGroup(\n  groupId: string,\n  scope: ParentNode | HTMLElement = document,\n): HTMLElement[] {\n  if (!isBrowser)\n    return []\n  return Array.from(\n    scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`),\n  )\n}\n\nexport function getPanelGroupElement(\n  id: string,\n  rootElement: ParentNode | HTMLElement = document,\n): HTMLElement | null {\n  if (!isBrowser)\n    return null\n  // If the root element is the PanelGroup\n  if (\n    rootElement instanceof HTMLElement\n    && (rootElement as HTMLElement)?.dataset?.panelGroupId === id\n  ) {\n    return rootElement as HTMLElement\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(\n    `[data-panel-group][data-panel-group-id=\"${id}\"]`,\n  )\n  if (element)\n    return element as HTMLElement\n\n  return null\n}\n\nexport function getResizeHandleElement(\n  id: string,\n  scope: ParentNode | HTMLElement = document,\n): HTMLElement | null {\n  if (!isBrowser)\n    return null\n  const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`)\n  if (element)\n    return element as HTMLElement\n\n  return null\n}\n\nexport function getResizeHandleElementIndex(\n  groupId: string,\n  id: string,\n  scope: ParentNode | HTMLElement = document,\n): number | null {\n  if (!isBrowser)\n    return null\n  const handles = getResizeHandleElementsForGroup(groupId, scope)\n  const index = handles.findIndex(\n    handle => handle.getAttribute('data-panel-resize-handle-id') === id,\n  )\n  return index ?? null\n}\n\nexport function getResizeHandleElementsForGroup(\n  groupId: string,\n  scope: ParentNode | HTMLElement = document,\n): HTMLElement[] {\n  if (!isBrowser)\n    return []\n  return Array.from(\n    scope.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`,\n    ),\n  )\n}\n\nexport function getResizeHandlePanelIds(\n  groupId: string,\n  handleId: string,\n  panelsArray: PanelData[],\n  scope: ParentNode | HTMLElement = document,\n): [idBefore: string | null, idAfter: string | null] {\n  const handle = getResizeHandleElement(handleId, scope)\n  const handles = getResizeHandleElementsForGroup(groupId, scope)\n  const index = handle ? handles.indexOf(handle) : -1\n\n  const idBefore: string | null = panelsArray[index]?.id ?? null\n  const idAfter: string | null = panelsArray[index + 1]?.id ?? null\n\n  return [idBefore, idAfter]\n}\n", "import type { Direction, ResizeEvent } from './types'\n\nexport function isKeyDown(event: ResizeEvent): event is KeyboardEvent {\n  return event.type === 'keydown'\n}\n\nexport function isMouseEvent(event: ResizeEvent): event is MouseEvent {\n  return event.type.startsWith('mouse')\n}\n\nexport function isTouchEvent(event: ResizeEvent): event is TouchEvent {\n  return event.type.startsWith('touch')\n}\n\nexport function getResizeEventCoordinates(event: ResizeEvent) {\n  if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    }\n  }\n  else if (isTouchEvent(event)) {\n    const touch = event.touches[0]\n    if (touch && touch.clientX && touch.clientY) {\n      return {\n        x: touch.clientX,\n        y: touch.clientY,\n      }\n    }\n  }\n\n  return {\n    x: Number.POSITIVE_INFINITY,\n    y: Number.POSITIVE_INFINITY,\n  }\n}\n\nexport function getResizeEventCursorPosition(\n  direction: Direction,\n  event: ResizeEvent,\n): number {\n  const isHorizontal = direction === 'horizontal'\n\n  const { x, y } = getResizeEventCoordinates(event)\n\n  return isHorizontal ? x : y\n}\n", "import type { PanelData } from '../SplitterPanel.vue'\nimport type { Direction, DragState, ResizeEvent } from './types'\nimport { assert } from './assert'\nimport { getPanelGroupElement, getResizeHandleElement } from './dom'\nimport { getResizeEventCursorPosition, isKeyDown } from './events'\n\nexport function calculateDragOffsetPercentage(\n  event: ResizeEvent,\n  dragHandleId: string,\n  direction: Direction,\n  initialDragState: DragState,\n  panelGroupElement: HTMLElement,\n): number {\n  const isHorizontal = direction === 'horizontal'\n\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement)\n  assert(handleElement)\n\n  const groupId = handleElement.getAttribute('data-panel-group-id')\n  assert(groupId)\n\n  const { initialCursorPosition } = initialDragState\n\n  const cursorPosition = getResizeEventCursorPosition(direction, event)\n\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement)\n  assert(groupElement)\n\n  const groupRect = groupElement.getBoundingClientRect()\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height\n\n  const offsetPixels = cursorPosition - initialCursorPosition\n  const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100\n\n  return offsetPercentage\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nexport function calculateDeltaPercentage(\n  event: ResizeEvent,\n  dragHandleId: string,\n  direction: Direction,\n  initialDragState: DragState | null,\n  keyboardResizeBy: number | null,\n  panelGroupElement: HTMLElement,\n): number {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === 'horizontal'\n\n    let delta = 0\n    if (event.shiftKey)\n      delta = 100\n    else\n      delta = keyboardResizeBy ?? 10\n\n    let movement = 0\n    switch (event.key) {\n      case 'ArrowDown':\n        movement = isHorizontal ? 0 : delta\n        break\n      case 'ArrowLeft':\n        movement = isHorizontal ? -delta : 0\n        break\n      case 'ArrowRight':\n        movement = isHorizontal ? delta : 0\n        break\n      case 'ArrowUp':\n        movement = isHorizontal ? 0 : -delta\n        break\n      case 'End':\n        movement = 100\n        break\n      case 'Home':\n        movement = -100\n        break\n    }\n\n    return movement\n  }\n  else {\n    if (initialDragState == null)\n      return 0\n\n    return calculateDragOffsetPercentage(\n      event,\n      dragHandleId,\n      direction,\n      initialDragState,\n      panelGroupElement,\n    )\n  }\n}\n\nexport function calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices,\n}: {\n  layout: number[]\n  panelsArray: PanelData[]\n  pivotIndices: number[]\n}) {\n  let currentMinSize = 0\n  let currentMaxSize = 100\n  let totalMinSize = 0\n  let totalMaxSize = 0\n\n  const firstIndex = pivotIndices[0]\n  assert(firstIndex != null)\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const { constraints } = panelData\n    const { maxSize = 100, minSize = 0 } = constraints\n\n    if (index === firstIndex) {\n      currentMinSize = minSize\n      currentMaxSize = maxSize\n    }\n    else {\n      totalMinSize += minSize\n      totalMaxSize += maxSize\n    }\n  })\n\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize)\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize)\n\n  const valueNow = layout[firstIndex]\n\n  return {\n    valueMax,\n    valueMin,\n    valueNow,\n  }\n}\n\nexport function calculateUnsafeDefaultLayout({\n  panelDataArray,\n}: {\n  panelDataArray: PanelData[]\n}): number[] {\n  const layout: number[] = Array.from({ length: panelDataArray.length })\n\n  const panelConstraintsArray = panelDataArray.map(\n    panelData => panelData.constraints,\n  )\n\n  let numPanelsWithSizes = 0\n  let remainingSize = 100\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index]\n    assert(panelConstraints)\n    const { defaultSize } = panelConstraints\n\n    if (defaultSize != null) {\n      numPanelsWithSizes++\n      layout[index] = defaultSize\n      remainingSize -= defaultSize\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index]\n    assert(panelConstraints)\n    const { defaultSize } = panelConstraints\n\n    if (defaultSize != null)\n      continue\n\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes\n    const size = remainingSize / numRemainingPanels\n\n    numPanelsWithSizes++\n    layout[index] = size\n    remainingSize -= size\n  }\n\n  return layout\n}\n", "import type { PanelData } from '../SplitterPanel.vue'\nimport { assert } from './assert'\n\n// Layout should be pre-converted into percentages\nexport function callPanelCallbacks(\n  panelsArray: PanelData[],\n  layout: number[],\n  panelIdToLastNotifiedSizeMap: Record<string, number>,\n) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index]\n    assert(panelData)\n\n    const { callbacks, constraints, id: panelId } = panelData\n    const { collapsedSize = 0, collapsible } = constraints\n\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId]\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size\n\n      const { onCollapse, onExpand, onResize } = callbacks\n\n      if (onResize)\n        onResize(size, lastNotifiedSize)\n\n      if (collapsible && (onCollapse || onExpand)) {\n        if (\n          onExpand\n          && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize)\n          && size !== collapsedSize\n        ) {\n          onExpand()\n        }\n\n        if (\n          onCollapse\n          && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize)\n          && size === collapsedSize\n        ) {\n          onCollapse()\n        }\n      }\n    }\n  })\n}\n", "export default function debounce<T extends Function>(\n  callback: T,\n  durationMs = 10,\n) {\n  let timeoutId: NodeJS.Timeout | null = null\n\n  const callable = (...args: any) => {\n    if (timeoutId !== null)\n      clearTimeout(timeoutId)\n\n    timeoutId = setTimeout(() => {\n      callback(...args)\n    }, durationMs)\n  }\n\n  return callable as unknown as T\n}\n", "export const PRECISION = 10\n", "import { PRECISION } from './constants'\n\nexport function fuzzyCompareNumbers(\n  actual: number,\n  expected: number,\n  fractionDigits: number = PRECISION,\n): number {\n  actual = Number.parseFloat(actual.toFixed(fractionDigits))\n  expected = Number.parseFloat(expected.toFixed(fractionDigits))\n\n  const delta = actual - expected\n  if (delta === 0)\n    return 0\n  else\n    return delta > 0 ? 1 : -1\n}\n\nexport function fuzzyNumbersEqual(\n  actual: number,\n  expected: number,\n  fractionDigits?: number,\n): boolean {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0\n}\n", "import type { PanelConstraints } from '../SplitterPanel.vue'\nimport { assert } from './assert'\nimport { fuzzyCompareNumbers } from './compare'\nimport { PRECISION } from './constants'\n\n// Panel size must be in percentages; pixel values should be pre-converted\nexport function resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size,\n}: {\n  panelConstraints: PanelConstraints[]\n  panelIndex: number\n  size: number\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex]\n  assert(panelConstraints != null)\n\n  const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints\n\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0)\n        size = collapsedSize\n      else\n        size = minSize\n    }\n    else {\n      size = minSize\n    }\n  }\n\n  size = Math.min(maxSize, size)\n  size = Number.parseFloat(size.toFixed(PRECISION))\n\n  return size\n}\n", "/* eslint-disable no-lone-blocks */\nimport type { PanelConstraints } from '../SplitterPanel.vue'\nimport { assert } from './assert'\nimport { fuzzyCompareNumbers, fuzzyNumbersEqual } from './compare'\nimport { resizePanel } from './resizePanel'\n\nexport function compareLayouts(a: number[], b: number[]) {\n  if (a.length !== b.length) {\n    return false\n  }\n  else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] !== b[index])\n        return false\n    }\n  }\n  return true\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function adjustLayoutByDelta({\n  delta,\n  layout: prevLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  trigger,\n}: {\n  delta: number\n  layout: number[]\n  panelConstraints: PanelConstraints[]\n  pivotIndices: number[]\n  trigger: 'imperative-api' | 'keyboard' | 'mouse-or-touch'\n}): number[] {\n  if (fuzzyNumbersEqual(delta, 0))\n    return prevLayout\n\n  const nextLayout = [...prevLayout]\n\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices\n  assert(firstPivotIndex != null)\n  assert(secondPivotIndex != null)\n\n  let deltaApplied = 0\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta() ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === 'keyboard') {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex\n        const panelConstraints = panelConstraintsArray[index]\n        assert(panelConstraints)\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n        if (panelConstraints.collapsible) {\n          const prevSize = prevLayout[index]\n          assert(prevSize != null)\n\n          const panelConstraints = panelConstraintsArray[index]\n          assert(panelConstraints)\n          const { collapsedSize = 0, minSize = 0 } = panelConstraints\n\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0)\n              delta = delta < 0 ? 0 - localDelta : localDelta\n              // DEBUG.push(`  -> delta: ${delta}`);\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex\n        const panelConstraints = panelConstraintsArray[index]\n        assert(panelConstraints)\n        const { collapsible } = panelConstraints\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = prevLayout[index]\n          assert(prevSize != null)\n\n          const panelConstraints = panelConstraintsArray[index]\n          assert(panelConstraints)\n          const { collapsedSize = 0, minSize = 0 } = panelConstraints\n\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0)\n              delta = delta < 0 ? 0 - localDelta : localDelta\n              // DEBUG.push(`  -> delta: ${delta}`);\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1\n\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex\n    let maxAvailableDelta = 0\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = prevLayout[index]\n      assert(prevSize != null)\n\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100,\n      })\n      const delta = maxSafeSize - prevSize\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta\n      index += increment\n\n      if (index < 0 || index >= panelConstraintsArray.length)\n        break\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta))\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex\n    let index = pivotIndex\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied)\n\n      const prevSize = prevLayout[index]\n      assert(prevSize != null)\n\n      const unsafeSize = prevSize - deltaRemaining\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize,\n      })\n\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize\n\n        nextLayout[index] = safeSize\n\n        if (\n          deltaApplied\n            .toPrecision(3)\n            .localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n              numeric: true,\n            }) >= 0\n        ) {\n          break\n        }\n      }\n\n      if (delta < 0)\n        index--\n      else\n        index++\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyNumbersEqual(deltaApplied, 0)) {\n    // console.log(DEBUG.join(\"\\n\"));\n    return prevLayout\n  }\n\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex\n\n    const prevSize = prevLayout[pivotIndex]\n    assert(prevSize != null)\n\n    const unsafeSize = prevSize + deltaApplied\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize,\n    })\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize\n\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex\n      let index = pivotIndex\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index]\n        assert(prevSize != null)\n\n        const unsafeSize = prevSize + deltaRemaining\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize,\n        })\n\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize\n\n          nextLayout[index] = safeSize\n        }\n\n        if (fuzzyNumbersEqual(deltaRemaining, 0))\n          break\n\n        if (delta > 0)\n          index--\n        else\n          index++\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0)\n  // DEBUG.push(`total size: ${totalSize}`);\n  // console.log(DEBUG.join(\"\\n\"));\n\n  if (!fuzzyNumbersEqual(totalSize, 100))\n    return prevLayout\n\n  return nextLayout\n}\n", "import { getResizeHandleElementIndex } from './dom'\n\nexport function determinePivotIndices(\n  groupId: string,\n  dragHandleId: string,\n  panelGroupElement: ParentNode,\n): [indexBefore: number, indexAfter: number] {\n  const index = getResizeHandleElementIndex(\n    groupId,\n    dragHandleId,\n    panelGroupElement,\n  )\n\n  return index != null ? [index, index + 1] : [-1, -1]\n}\n", "export interface Rectangle {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\nexport function intersects(\n  rectOne: Rectangle,\n  rectTwo: Rectangle,\n  strict: boolean,\n): boolean {\n  if (strict) {\n    return (\n      rectOne.x < rectTwo.x + rectTwo.width\n      && rectOne.x + rectOne.width > rectTwo.x\n      && rectOne.y < rectTwo.y + rectTwo.height\n      && rectOne.y + rectOne.height > rectTwo.y\n    )\n  }\n  else {\n    return (\n      rectOne.x <= rectTwo.x + rectTwo.width\n      && rectOne.x + rectOne.width >= rectTwo.x\n      && rectOne.y <= rectTwo.y + rectTwo.height\n      && rectOne.y + rectOne.height >= rectTwo.y\n    )\n  }\n}\n\nexport function getIntersectingRectangle(\n  rectOne: Rectangle,\n  rectTwo: Rectangle,\n  strict: boolean,\n): Rectangle {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    }\n  }\n\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width:\n      Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width)\n      - Math.max(rectOne.x, rectTwo.x),\n    height:\n      Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height)\n      - Math.max(rectOne.y, rectTwo.y),\n  }\n}\n", "// Forked from NPM stacking-order@2.0.0\n// Background at https://github.com/Rich-Harris/stacking-order/issues/3\n\nimport { assert } from './assert'\n\n/**\n * Determine which of two nodes appears in front of the other \n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n */\nexport function compare(a: HTMLElement, b: HTMLElement): number {\n  if (a === b)\n    throw new Error('Cannot compare node with itself')\n\n  const ancestors = {\n    a: getAncestors(a),\n    b: getAncestors(b),\n  }\n\n  let common_ancestor\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop() as HTMLElement\n    b = ancestors.b.pop() as HTMLElement\n\n    common_ancestor = a\n  }\n\n  assert(common_ancestor)\n\n  const z_indexes = {\n    a: getZIndex(findStackingContext(ancestors.a)),\n    b: getZIndex(findStackingContext(ancestors.b)),\n  }\n\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes\n\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1),\n    }\n\n    let i = children.length\n    while (i--) {\n      const child = children[i]\n      if (child === furthest_ancestors.a)\n        return 1\n      if (child === furthest_ancestors.b)\n        return -1\n    }\n  }\n\n  return Math.sign(z_indexes.a - z_indexes.b)\n}\n\nconst props\n  = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/\n\n/** @param {HTMLElement} node */\nfunction isFlexItem(node: HTMLElement) {\n  const display = getComputedStyle(getParent(node)).display\n  return display === 'flex' || display === 'inline-flex'\n}\n\n/** @param {HTMLElement} node */\nfunction createsStackingContext(node: HTMLElement) {\n  const style = getComputedStyle(node)\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === 'fixed')\n    return true\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   isFlexItem(node)\n  // )\n  if (\n    style.zIndex !== 'auto'\n    && (style.position !== 'static' || isFlexItem(node))\n  ) {\n    return true\n  }\n  if (+style.opacity < 1)\n    return true\n  if ('transform' in style && style.transform !== 'none')\n    return true\n  if ('webkitTransform' in style && style.webkitTransform !== 'none')\n    return true\n  if ('mixBlendMode' in style && style.mixBlendMode !== 'normal')\n    return true\n  if ('filter' in style && style.filter !== 'none')\n    return true\n  if ('webkitFilter' in style && style.webkitFilter !== 'none')\n    return true\n  if ('isolation' in style && style.isolation === 'isolate')\n    return true\n  if (props.test(style.willChange))\n    return true\n  // @ts-expect-error non-standard styling https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-overflow-scrolling\n  if (style.webkitOverflowScrolling === 'touch')\n    return true\n\n  return false\n}\n\n/** @param {HTMLElement[]} nodes */\nfunction findStackingContext(nodes: HTMLElement[]) {\n  let i = nodes.length\n\n  while (i--) {\n    const node = nodes[i]\n    assert(node)\n    if (createsStackingContext(node))\n      return node\n  }\n\n  return null\n}\n\n/** @param {HTMLElement} node */\nfunction getZIndex(node: HTMLElement | null) {\n  return (node && Number(getComputedStyle(node).zIndex)) || 0\n}\n\n/** @param {HTMLElement} node */\nfunction getAncestors(node: HTMLElement) {\n  const ancestors = []\n\n  while (node) {\n    ancestors.push(node)\n    node = getParent(node)\n  }\n\n  return ancestors // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction getParent(node: HTMLElement) {\n  // @ts-expect-error host should exist\n  return (node.parentNode instanceof DocumentFragment && node.parentNode?.host) || node.parentNode\n}\n", "import type { CSSProperties } from 'vue'\nimport type { PanelData } from '../SplitterPanel.vue'\nimport type { DragState } from './types'\nimport {\n  EXCEEDED_HORIZONTAL_MAX,\n  EXCEEDED_HORIZONTAL_MIN,\n  EXCEEDED_VERTICAL_MAX,\n  EXCEEDED_VERTICAL_MIN,\n} from './registry'\n\ntype CursorState = 'horizontal' | 'intersection' | 'vertical'\n\nlet currentCursorStyle: string | null = null\nlet styleElement: HTMLStyleElement | null = null\n\nexport function getCursorStyle(\n  state: CursorState,\n  constraintFlags: number,\n): string {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0\n\n    if (horizontalMin) {\n      if (verticalMin)\n        return 'se-resize'\n      else if (verticalMax)\n        return 'ne-resize'\n      else\n        return 'e-resize'\n    }\n    else if (horizontalMax) {\n      if (verticalMin)\n        return 'sw-resize'\n      else if (verticalMax)\n        return 'nw-resize'\n      else\n        return 'w-resize'\n    }\n    else if (verticalMin) {\n      return 's-resize'\n    }\n    else if (verticalMax) {\n      return 'n-resize'\n    }\n  }\n\n  switch (state) {\n    case 'horizontal':\n      return 'ew-resize'\n    case 'intersection':\n      return 'move'\n    case 'vertical':\n      return 'ns-resize'\n  }\n}\n\nexport function resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement)\n\n    currentCursorStyle = null\n    styleElement = null\n  }\n}\n\nexport function setGlobalCursorStyle(\n  state: CursorState,\n  constraintFlags: number,\n) {\n  const style = getCursorStyle(state, constraintFlags)\n\n  if (currentCursorStyle === style)\n    return\n\n  currentCursorStyle = style\n\n  if (styleElement === null) {\n    styleElement = document.createElement('style')\n\n    document.head.appendChild(styleElement)\n  }\n\n  styleElement.innerHTML = `*{cursor: ${style}!important;}`\n}\n\n// the % of the group's overall space this panel should occupy.\nexport function computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3,\n}: {\n  defaultSize: number | undefined\n  layout: number[]\n  dragState: DragState | null\n  panelData: PanelData[]\n  panelIndex: number\n  precision?: number\n}): CSSProperties {\n  const size = layout[panelIndex]\n\n  let flexGrow\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow\n      = defaultSize !== undefined ? defaultSize.toPrecision(precision) : '1'\n  }\n  else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = '1'\n  }\n  else {\n    flexGrow = size.toPrecision(precision)\n  }\n\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: 'hidden',\n\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? 'none' : undefined,\n  }\n}\n", "import type { Ref } from 'vue'\nimport type { Direction, ResizeEvent } from './types'\nimport { getResizeEventCoordinates } from './events'\nimport { intersects } from './rects'\nimport { compare } from './stackingOrder'\nimport { resetGlobalCursorStyle, setGlobalCursorStyle } from './style'\n\nexport type ResizeHandlerAction = 'down' | 'move' | 'up'\nexport type SetResizeHandlerState = (\n  action: ResizeHandlerAction,\n  isActive: boolean,\n  event: ResizeEvent\n) => void\n\nexport type PointerHitAreaMargins = {\n  coarse: number\n  fine: number\n}\n\nexport type ResizeHandlerData = {\n  direction: Ref<Direction>\n  element: HTMLElement\n  hitAreaMargins: PointerHitAreaMargins\n  setResizeHandlerState: SetResizeHandlerState\n}\n\nexport const EXCEEDED_HORIZONTAL_MIN = 0b0001\nexport const EXCEEDED_HORIZONTAL_MAX = 0b0010\nexport const EXCEEDED_VERTICAL_MIN = 0b0100\nexport const EXCEEDED_VERTICAL_MAX = 0b1000\n\nfunction getInputType(): 'coarse' | 'fine' | undefined {\n  if (typeof matchMedia === 'function')\n    return matchMedia('(pointer:coarse)').matches ? 'coarse' : 'fine'\n}\n\nconst isCoarsePointer = getInputType() === 'coarse'\n\nconst intersectingHandles: ResizeHandlerData[] = []\nlet isPointerDown = false\nconst ownerDocumentCounts: Map<Document, number> = new Map()\nconst panelConstraintFlags: Map<string, number> = new Map()\n\nconst registeredResizeHandlers = new Set<ResizeHandlerData>()\n\nexport function registerResizeHandle(\n  resizeHandleId: string,\n  element: HTMLElement,\n  direction: Ref<Direction>,\n  hitAreaMargins: PointerHitAreaMargins,\n  setResizeHandlerState: SetResizeHandlerState,\n) {\n  const { ownerDocument } = element\n\n  const data: ResizeHandlerData = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState,\n  }\n\n  const count = ownerDocumentCounts.get(ownerDocument) ?? 0\n  ownerDocumentCounts.set(ownerDocument, count + 1)\n\n  registeredResizeHandlers.add(data)\n\n  updateListeners()\n\n  return function unregisterResizeHandle() {\n    panelConstraintFlags.delete(resizeHandleId)\n    registeredResizeHandlers.delete(data)\n\n    const count = ownerDocumentCounts.get(ownerDocument) ?? 1\n    ownerDocumentCounts.set(ownerDocument, count - 1)\n\n    updateListeners()\n    resetGlobalCursorStyle()\n\n    if (count === 1)\n      ownerDocumentCounts.delete(ownerDocument)\n  }\n}\n\nfunction handlePointerDown(event: ResizeEvent) {\n  const { target } = event\n  const { x, y } = getResizeEventCoordinates(event)\n\n  isPointerDown = true\n\n  recalculateIntersectingHandles({ target, x, y })\n  updateListeners()\n\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates('down', event)\n\n    event.preventDefault()\n  }\n}\n\nfunction handlePointerMove(event: ResizeEvent) {\n  const { x, y } = getResizeEventCoordinates(event)\n\n  if (!isPointerDown) {\n    const { target } = event\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({ target, x, y })\n  }\n\n  updateResizeHandlerStates('move', event)\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor()\n\n  if (intersectingHandles.length > 0)\n    event.preventDefault()\n}\n\nfunction handlePointerUp(event: ResizeEvent) {\n  const { target } = event\n  const { x, y } = getResizeEventCoordinates(event)\n\n  panelConstraintFlags.clear()\n  isPointerDown = false\n\n  if (intersectingHandles.length > 0)\n    event.preventDefault()\n\n  updateResizeHandlerStates('up', event)\n  recalculateIntersectingHandles({ target, x, y })\n  updateCursor()\n\n  updateListeners()\n}\n\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y,\n}: {\n  target: EventTarget | null\n  x: number\n  y: number\n}) {\n  intersectingHandles.splice(0)\n\n  let targetElement: HTMLElement | null = null\n  if (target instanceof HTMLElement)\n    targetElement = target\n\n  registeredResizeHandlers.forEach((data) => {\n    const { element: dragHandleElement, hitAreaMargins } = data\n\n    const dragHandleRect = dragHandleElement.getBoundingClientRect()\n    const { bottom, left, right, top } = dragHandleRect\n\n    const margin = isCoarsePointer\n      ? hitAreaMargins.coarse\n      : hitAreaMargins.fine\n\n    const eventIntersects\n      = x >= left - margin\n        && x <= right + margin\n        && y >= top - margin\n        && y <= bottom + margin\n\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (\n        targetElement !== null\n        && dragHandleElement !== targetElement\n        && !dragHandleElement.contains(targetElement)\n        && !targetElement.contains(dragHandleElement)\n        // Calculating stacking order has a cost, so we should avoid it if possible\n        // That is why we only check potentially intersecting handles,\n        // and why we skip if the event target is within the handle's DOM\n        && compare(targetElement, dragHandleElement) > 0\n      ) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement: HTMLElement | null = targetElement\n        let didIntersect = false\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break\n          }\n          else if (\n            intersects(\n              currentElement.getBoundingClientRect(),\n              dragHandleRect,\n              true,\n            )\n          ) {\n            didIntersect = true\n            break\n          }\n\n          currentElement = currentElement.parentElement\n        }\n\n        if (didIntersect)\n          return\n      }\n\n      intersectingHandles.push(data)\n    }\n  })\n}\n\nexport function reportConstraintsViolation(\n  resizeHandleId: string,\n  flag: number,\n) {\n  panelConstraintFlags.set(resizeHandleId, flag)\n}\n\nfunction updateCursor() {\n  let intersectsHorizontal = false\n  let intersectsVertical = false\n\n  intersectingHandles.forEach((data) => {\n    const { direction } = data\n\n    if (direction.value === 'horizontal')\n      intersectsHorizontal = true\n    else\n      intersectsVertical = true\n  })\n\n  let constraintFlags = 0\n  panelConstraintFlags.forEach((flag) => {\n    constraintFlags |= flag\n  })\n\n  if (intersectsHorizontal && intersectsVertical)\n    setGlobalCursorStyle('intersection', constraintFlags)\n  else if (intersectsHorizontal)\n    setGlobalCursorStyle('horizontal', constraintFlags)\n  else if (intersectsVertical)\n    setGlobalCursorStyle('vertical', constraintFlags)\n  else\n    resetGlobalCursorStyle()\n}\n\nfunction updateListeners() {\n  ownerDocumentCounts.forEach((_, ownerDocument) => {\n    const { body } = ownerDocument\n\n    body.removeEventListener('contextmenu', handlePointerUp)\n    body.removeEventListener('mousedown', handlePointerDown)\n    body.removeEventListener('mouseleave', handlePointerMove)\n    body.removeEventListener('mousemove', handlePointerMove)\n    body.removeEventListener('touchmove', handlePointerMove)\n    body.removeEventListener('touchstart', handlePointerDown)\n  })\n\n  window.removeEventListener('mouseup', handlePointerUp)\n  window.removeEventListener('touchcancel', handlePointerUp)\n  window.removeEventListener('touchend', handlePointerUp)\n\n  if (registeredResizeHandlers.size > 0) {\n    if (isPointerDown) {\n      if (intersectingHandles.length > 0) {\n        ownerDocumentCounts.forEach((count, ownerDocument) => {\n          const { body } = ownerDocument\n\n          if (count > 0) {\n            body.addEventListener('contextmenu', handlePointerUp)\n            body.addEventListener('mouseleave', handlePointerMove)\n            body.addEventListener('mousemove', handlePointerMove)\n            body.addEventListener('touchmove', handlePointerMove, {\n              passive: false,\n            })\n          }\n        })\n      }\n\n      window.addEventListener('mouseup', handlePointerUp)\n      window.addEventListener('touchcancel', handlePointerUp)\n      window.addEventListener('touchend', handlePointerUp)\n    }\n    else {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const { body } = ownerDocument\n\n        if (count > 0) {\n          body.addEventListener('mousedown', handlePointerDown)\n          body.addEventListener('mousemove', handlePointerMove)\n          body.addEventListener('touchmove', handlePointerMove, {\n            passive: false,\n          })\n          body.addEventListener('touchstart', handlePointerDown)\n        }\n      })\n    }\n  }\n}\n\nfunction updateResizeHandlerStates(\n  action: ResizeHandlerAction,\n  event: ResizeEvent,\n) {\n  registeredResizeHandlers.forEach((data) => {\n    const { setResizeHandlerState } = data\n\n    const isActive = intersectingHandles.includes(data)\n\n    setResizeHandlerState(action, isActive, event)\n  })\n}\n", "import type { PanelConstraints } from '../SplitterPanel.vue'\nimport { assert } from './assert'\nimport { fuzzyNumbersEqual } from './compare'\nimport { resizePanel } from './resizePanel'\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints,\n}: {\n  layout: number[]\n  panelConstraints: PanelConstraints[]\n}): number[] {\n  const nextLayout = [...prevLayout]\n  const nextLayoutTotalSize = nextLayout.reduce(\n    (accumulated, current) => accumulated + current,\n    0,\n  )\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw new Error(\n      `Invalid ${panelConstraints.length} panel layout: ${nextLayout\n        .map(size => `${size}%`)\n        .join(', ')}`,\n    )\n  }\n  else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n    // This is not ideal so we should warn about it, but it may be recoverable in some cases\n    // (especially if the amount is small)\n\n    if (true) {\n      console.warn(\n        `WARNING: Invalid layout total size: ${nextLayout\n          .map(size => `${size}%`)\n          .join(', ')}. Layout normalization will be applied.`,\n      )\n    }\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index]\n      assert(unsafeSize != null)\n      const safeSize = (100 / nextLayoutTotalSize) * unsafeSize\n      nextLayout[index] = safeSize\n    }\n  }\n\n  let remainingSize = 0\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index]\n    assert(unsafeSize != null)\n\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize,\n    })\n\n    if (unsafeSize !== safeSize) {\n      remainingSize += unsafeSize - safeSize\n\n      nextLayout[index] = safeSize\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index]\n      assert(prevSize != null)\n      const unsafeSize = prevSize + remainingSize\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize,\n      })\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize\n        nextLayout[index] = safeSize\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0))\n          break\n      }\n    }\n  }\n\n  return nextLayout\n}\n\nexport function validatePanelConstraints({\n  panelConstraints: panelConstraintsArray,\n  panelId,\n  panelIndex,\n}: {\n  panelConstraints: PanelConstraints[]\n  panelId: string | undefined\n  panelIndex: number\n}): boolean {\n  if (import.meta.env.DEV) {\n    const warnings = []\n\n    const panelConstraints = panelConstraintsArray[panelIndex]\n    assert(panelConstraints)\n\n    const {\n      collapsedSize = 0,\n      collapsible = false,\n      defaultSize,\n      maxSize = 100,\n      minSize = 0,\n    } = panelConstraints\n\n    if (minSize > maxSize) {\n      warnings.push(\n        `min size (${minSize}%) should not be greater than max size (${maxSize}%)`,\n      )\n    }\n\n    if (defaultSize != null) {\n      if (defaultSize < 0) {\n        warnings.push('default size should not be less than 0')\n      }\n      else if (\n        defaultSize < minSize\n        && (!collapsible || defaultSize !== collapsedSize)\n      ) {\n        warnings.push('default size should not be less than min size')\n      }\n\n      if (defaultSize > 100)\n        warnings.push('default size should not be greater than 100')\n      else if (defaultSize > maxSize)\n        warnings.push('default size should not be greater than max size')\n    }\n\n    if (collapsedSize > minSize)\n      warnings.push('collapsed size should not be greater than min size')\n\n    if (warnings.length > 0) {\n      const name = panelId != null ? `Panel \"${panelId}\"` : 'Panel'\n      console.warn(\n        `${name} has an invalid configuration:\\n\\n${warnings.join('\\n')}`,\n      )\n\n      return false\n    }\n  }\n\n  return true\n}\n", "import type { Ref } from 'vue'\nimport type { PanelData } from '../../SplitterPanel.vue'\nimport { watchEffect } from 'vue'\nimport { assert } from '../assert'\nimport { calculateAriaValues } from '../calculate'\nimport { fuzzyNumbersEqual } from '../compare'\nimport { getPanelGroupElement, getResizeHandleElementsForGroup, getResizeHandlePanelIds } from '../dom'\nimport { adjustLayoutByDelta } from '../layout'\nimport { determinePivotIndices } from '../pivot'\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nexport function useWindowSplitterPanelGroupBehavior({\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout,\n}: {\n  eagerValuesRef: Ref<{\n    panelDataArray: PanelData[]\n  }>\n  groupId: string\n  layout: Ref<number[]>\n  panelDataArray: PanelData[]\n  panelGroupElement: Ref<ParentNode | null>\n  setLayout: (sizes: number[]) => void\n}): void {\n  watchEffect((onCleanup) => {\n    const _panelGroupElement = panelGroupElement.value\n    if (!_panelGroupElement)\n      return\n\n    const resizeHandleElements = getResizeHandleElementsForGroup(\n      groupId,\n      _panelGroupElement,\n    )\n\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const { valueMax, valueMin, valueNow } = calculateAriaValues({\n        layout: layout.value,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1],\n      })\n\n      const resizeHandleElement = resizeHandleElements[index]\n      if (resizeHandleElement == null) {\n        if (import.meta.env.DEV)\n          console.warn(`WARNING: Missing resize handle for PanelGroup \"${groupId}\"`)\n      }\n      else {\n        const panelData = panelDataArray[index]\n        assert(panelData)\n\n        resizeHandleElement.setAttribute('aria-controls', panelData.id)\n        resizeHandleElement.setAttribute(\n          'aria-valuemax',\n          `${Math.round(valueMax)}`,\n        )\n        resizeHandleElement.setAttribute(\n          'aria-valuemin',\n          `${Math.round(valueMin)}`,\n        )\n        resizeHandleElement.setAttribute(\n          'aria-valuenow',\n          valueNow != null ? `${Math.round(valueNow)}` : '',\n        )\n      }\n    }\n\n    onCleanup(() => {\n      resizeHandleElements.forEach((resizeHandleElement) => {\n        resizeHandleElement.removeAttribute('aria-controls')\n        resizeHandleElement.removeAttribute('aria-valuemax')\n        resizeHandleElement.removeAttribute('aria-valuemin')\n        resizeHandleElement.removeAttribute('aria-valuenow')\n      })\n    })\n  })\n\n  watchEffect((onCleanup) => {\n    const _panelGroupElement = panelGroupElement.value\n    if (!_panelGroupElement)\n      return\n\n    const eagerValues = eagerValuesRef.value\n    assert(eagerValues)\n\n    const { panelDataArray } = eagerValues\n    const groupElement = getPanelGroupElement(groupId, _panelGroupElement)\n    assert(groupElement != null, `No group found for id \"${groupId}\"`)\n\n    const handles = getResizeHandleElementsForGroup(groupId, _panelGroupElement)\n    assert(handles)\n\n    const cleanupFunctions = handles.map((handle) => {\n      const handleId = handle.getAttribute('data-panel-resize-handle-id')\n      assert(handleId)\n\n      const [idBefore, idAfter] = getResizeHandlePanelIds(\n        groupId,\n        handleId,\n        panelDataArray,\n        _panelGroupElement,\n      )\n      if (idBefore == null || idAfter == null)\n        return () => {}\n\n      const onKeyDown = (event: KeyboardEvent) => {\n        if (event.defaultPrevented)\n          return\n\n        switch (event.key) {\n          case 'Enter': {\n            event.preventDefault()\n\n            const index = panelDataArray.findIndex(\n              panelData => panelData.id === idBefore,\n            )\n            if (index >= 0) {\n              const panelData = panelDataArray[index]\n              assert(panelData)\n\n              const size = layout.value[index]\n\n              const {\n                collapsedSize = 0,\n                collapsible,\n                minSize = 0,\n              } = panelData.constraints\n\n              if (size != null && collapsible) {\n                const nextLayout = adjustLayoutByDelta({\n                  delta: fuzzyNumbersEqual(size, collapsedSize)\n                    ? minSize - collapsedSize\n                    : collapsedSize - size,\n                  layout: layout.value,\n                  panelConstraints: panelDataArray.map(\n                    panelData => panelData.constraints,\n                  ),\n                  pivotIndices: determinePivotIndices(\n                    groupId,\n                    handleId,\n                    _panelGroupElement,\n                  ),\n                  trigger: 'keyboard',\n                })\n                if (layout.value !== nextLayout)\n                  setLayout(nextLayout)\n              }\n            }\n            break\n          }\n        }\n      }\n\n      handle.addEventListener('keydown', onKeyDown)\n      return () => {\n        handle.removeEventListener('keydown', onKeyDown)\n      }\n    })\n\n    onCleanup(() => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction())\n    })\n  })\n}\n", "import type { PanelGroupStorage } from '../SplitterGroup.vue'\nimport type { PanelData } from '../SplitterPanel.vue'\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nexport function initializeDefaultStorage(storageObject: PanelGroupStorage) {\n  try {\n    if (typeof localStorage !== 'undefined') {\n      // Bypass this check for future calls\n      storageObject.getItem = (name: string) => {\n        return localStorage.getItem(name)\n      }\n      storageObject.setItem = (name: string, value: string) => {\n        localStorage.setItem(name, value)\n      }\n    }\n    else {\n      throw new TypeError('localStorage not supported in this environment')\n    }\n  }\n  catch (error) {\n    console.error(error)\n\n    storageObject.getItem = () => null\n    storageObject.setItem = () => {}\n  }\n}\n\nexport type PanelConfigurationState = {\n  expandToSizes: {\n    [panelId: string]: number\n  }\n  layout: number[]\n}\n\nexport type SerializedPanelGroupState = {\n  [panelIds: string]: PanelConfigurationState\n}\n\nfunction getPanelGroupKey(autoSaveId: string): string {\n  return `reka:${autoSaveId}`\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels: PanelData[]): string {\n  return panels\n    .map((panel) => {\n      const { constraints, id, idIsFromProps, order } = panel\n      if (idIsFromProps) {\n        return id\n      }\n      else {\n        return order\n          ? `${order}:${JSON.stringify(constraints)}`\n          : JSON.stringify(constraints)\n      }\n    })\n    .sort((a, b) => a.localeCompare(b))\n    .join(',')\n}\n\nfunction loadSerializedPanelGroupState(\n  autoSaveId: string,\n  storage: PanelGroupStorage,\n): SerializedPanelGroupState | null {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId)\n    const serialized = storage.getItem(panelGroupKey)\n    if (serialized) {\n      const parsed = JSON.parse(serialized)\n      if (typeof parsed === 'object' && parsed != null)\n        return parsed as SerializedPanelGroupState\n    }\n  }\n  catch (error) {}\n\n  return null\n}\n\nexport function loadPanelGroupState(\n  autoSaveId: string,\n  panels: PanelData[],\n  storage: PanelGroupStorage,\n): PanelConfigurationState | null {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {}\n  const panelKey = getPanelKey(panels)\n  return state[panelKey] ?? null\n}\n\nexport function savePanelGroupState(\n  autoSaveId: string,\n  panels: PanelData[],\n  panelSizesBeforeCollapse: Map<string, number>,\n  sizes: number[],\n  storage: PanelGroupStorage,\n): void {\n  const panelGroupKey = getPanelGroupKey(autoSaveId)\n  const panelKey = getPanelKey(panels)\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {}\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes,\n  }\n\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state))\n  }\n  catch (error) {\n    console.error(error)\n  }\n}\n", "<script lang=\"ts\">\nimport type { CSSProperties, Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed, ref, toRefs, watch, watchEffect } from 'vue'\nimport { areEqual, createContext, useDirection, useForwardExpose, useId } from '@/shared'\nimport { useWindowSplitterPanelGroupBehavior } from './utils/composables/useWindowSplitterPanelGroupBehavior'\nimport {\n  initializeDefaultStorage,\n  loadPanelGroupState,\n  savePanelGroupState,\n} from './utils/storage'\n\nexport interface SplitterGroupProps extends PrimitiveProps {\n  /** Group id; falls back to `useId` when not provided. */\n  id?: string | null\n  /** Unique id used to auto-save group arrangement via `localStorage`. */\n  autoSaveId?: string | null\n  /** The group orientation of splitter. */\n  direction: Direction\n  /** Step size when arrow key was pressed. */\n  keyboardResizeBy?: number | null\n  /** Custom storage API; defaults to localStorage */\n  storage?: PanelGroupStorage\n}\n\nexport type SplitterGroupEmits = {\n  /** Event handler called when group layout changes */\n  layout: [val: number[]]\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100\n\nexport type PanelGroupStorage = {\n  getItem: (name: string) => string | null\n  setItem: (name: string, value: string) => void\n}\n\nconst defaultStorage: PanelGroupStorage = {\n  getItem: (name: string) => {\n    initializeDefaultStorage(defaultStorage)\n    return defaultStorage.getItem(name)\n  },\n  setItem: (name: string, value: string) => {\n    initializeDefaultStorage(defaultStorage)\n    defaultStorage.setItem(name, value)\n  },\n}\n\nexport type PanelGroupContext = {\n  direction: Ref<Direction>\n  dragState: DragState | null\n  groupId: string\n  reevaluatePanelConstraints: (panelData: PanelData, prevConstraints: PanelConstraints) => void\n  registerPanel: (panelData: PanelData) => void\n  registerResizeHandle: (dragHandleId: string) => ResizeHandler\n  resizePanel: (panelData: PanelData, size: number) => void\n  startDragging: (dragHandleId: string, event: ResizeEvent) => void\n  stopDragging: () => void\n  unregisterPanel: (panelData: PanelData) => void\n  panelGroupElement: Ref<ParentNode | null>\n\n  // Exposed function for child component\n  collapsePanel: (panelData: PanelData) => void\n  expandPanel: (panelData: PanelData) => void\n  isPanelCollapsed: (panelData: PanelData) => boolean\n  isPanelExpanded: (panelData: PanelData) => boolean\n  getPanelSize: (panelData: PanelData) => number\n  getPanelStyle: (panelData: PanelData, defaultSize: number | undefined) => CSSProperties\n}\n\nexport const [injectPanelGroupContext, providePanelGroupContext] = createContext<PanelGroupContext>('PanelGroup')\n</script>\n\n<script setup lang=\"ts\">\nimport type { PanelConstraints, PanelData } from './SplitterPanel.vue'\n\nimport type { Direction, DragState, ResizeEvent, ResizeHandler } from './utils/types'\nimport { Primitive } from '@/Primitive'\nimport { assert } from './utils/assert'\nimport { calculateDeltaPercentage, calculateUnsafeDefaultLayout } from './utils/calculate'\nimport { callPanelCallbacks } from './utils/callPanelCallbacks'\nimport debounce from './utils/debounce'\nimport { getResizeHandleElement } from './utils/dom'\nimport { getResizeEventCursorPosition, isKeyDown, isMouseEvent, isTouchEvent } from './utils/events'\nimport { adjustLayoutByDelta, compareLayouts } from './utils/layout'\nimport { determinePivotIndices } from './utils/pivot'\nimport {\n  EXCEEDED_HORIZONTAL_MAX,\n  EXCEEDED_HORIZONTAL_MIN,\n  EXCEEDED_VERTICAL_MAX,\n  EXCEEDED_VERTICAL_MIN,\n  reportConstraintsViolation,\n} from './utils/registry'\nimport { computePanelFlexBoxStyle } from './utils/style'\nimport { validatePanelGroupLayout } from './utils/validation'\n\nconst props = withDefaults(defineProps<SplitterGroupProps>(), {\n  autoSaveId: null,\n  keyboardResizeBy: 10,\n  storage: () => defaultStorage,\n})\nconst emits = defineEmits<SplitterGroupEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current size of layout */\n    layout: typeof layout.value\n  }) => any\n}>()\n\nconst debounceMap: {\n  [key: string]: typeof savePanelGroupState\n} = {}\n\nconst { direction } = toRefs(props)\nconst groupId = useId(props.id, 'reka-splitter-group')\nconst dir = useDirection()\nconst { forwardRef, currentElement: panelGroupElementRef } = useForwardExpose()\n\nconst dragState = ref<DragState | null>(null)\nconst layout = ref<number[]>([])\nconst panelIdToLastNotifiedSizeMapRef = ref<Record<string, number>>({})\nconst panelSizeBeforeCollapseRef = ref<Map<string, number>>(new Map())\nconst prevDeltaRef = ref<number>(0)\n\nconst committedValuesRef = computed(() => ({\n  autoSaveId: props.autoSaveId,\n  direction: props.direction,\n  dragState: dragState.value,\n  id: groupId,\n  keyboardResizeBy: props.keyboardResizeBy,\n  storage: props.storage,\n}) satisfies {\n  autoSaveId: string | null\n  direction: Direction\n  dragState: DragState | null\n  id: string\n  keyboardResizeBy: number | null\n  storage: PanelGroupStorage\n})\n\nconst eagerValuesRef = ref<{\n  layout: number[]\n  panelDataArray: PanelData[]\n  panelDataArrayChanged: boolean\n}>({\n  layout: layout.value,\n  panelDataArray: [],\n  panelDataArrayChanged: false,\n})\n\nconst setLayout = (val: number[]) => layout.value = val\n\nuseWindowSplitterPanelGroupBehavior({\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray: eagerValuesRef.value.panelDataArray,\n  setLayout,\n  panelGroupElement: panelGroupElementRef,\n})\n\nwatchEffect(() => {\n  const { panelDataArray } = eagerValuesRef.value\n  const { autoSaveId } = props\n  // If this panel has been configured to persist sizing information, save sizes to local storage.\n  if (autoSaveId) {\n    if (layout.value.length === 0 || layout.value.length !== panelDataArray.length)\n      return\n\n    let debouncedSave = debounceMap[autoSaveId]\n\n    // Limit the frequency of localStorage updates.\n    if (!debouncedSave) {\n      debouncedSave = debounce(\n        savePanelGroupState,\n        LOCAL_STORAGE_DEBOUNCE_INTERVAL,\n      )\n\n      debounceMap[autoSaveId] = debouncedSave\n    }\n\n    // Clone mutable data before passing to the debounced function,\n    // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n    const clonedPanelDataArray = [...panelDataArray]\n    const clonedPanelSizesBeforeCollapse = new Map(\n      panelSizeBeforeCollapseRef.value,\n    )\n\n    debouncedSave(\n      autoSaveId,\n      clonedPanelDataArray,\n      clonedPanelSizesBeforeCollapse,\n      layout.value,\n      props.storage,\n    )\n  }\n})\n\nfunction getPanelStyle(panelData: PanelData, defaultSize: number | undefined) {\n  const { panelDataArray } = eagerValuesRef.value\n\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData)\n\n  return computePanelFlexBoxStyle({\n    defaultSize,\n    dragState: dragState.value,\n    layout: layout.value,\n    panelData: panelDataArray,\n    panelIndex,\n  })\n}\n\nfunction registerPanel(panelData: PanelData) {\n  const { panelDataArray } = eagerValuesRef.value\n\n  panelDataArray.push(panelData)\n  panelDataArray.sort((panelA, panelB) => {\n    const orderA = panelA.order\n    const orderB = panelB.order\n    if (orderA == null && orderB == null)\n      return 0\n    else if (orderA == null)\n      return -1\n    else if (orderB == null)\n      return 1\n    else\n      return orderA - orderB\n  })\n\n  eagerValuesRef.value.panelDataArrayChanged = true\n}\n\n// (Re)calculate group layout whenever panels are registered or unregistered.\n// useIsomorphicLayoutEffect\nwatch(() => eagerValuesRef.value.panelDataArrayChanged, () => {\n  if (eagerValuesRef.value.panelDataArrayChanged) {\n    eagerValuesRef.value.panelDataArrayChanged = false\n\n    const { autoSaveId, storage } = committedValuesRef.value\n    const { layout: prevLayout, panelDataArray } = eagerValuesRef.value\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let unsafeLayout: number[] | null = null\n    if (autoSaveId) {\n      const state = loadPanelGroupState(autoSaveId, panelDataArray, storage)\n      if (state) {\n        panelSizeBeforeCollapseRef.value = new Map(\n          Object.entries(state.expandToSizes),\n        )\n        unsafeLayout = state.layout\n      }\n    }\n\n    if (unsafeLayout === null) {\n      unsafeLayout = calculateUnsafeDefaultLayout({\n        panelDataArray,\n      })\n    }\n\n    // Validate even saved layouts in case something has changed since last render\n    // e.g. for pixel groups, this could be the size of the window\n    const nextLayout = validatePanelGroupLayout({\n      layout: unsafeLayout,\n      panelConstraints: panelDataArray.map(\n        panelData => panelData.constraints,\n      ),\n    })\n\n    if (!areEqual(prevLayout, nextLayout)) {\n      setLayout(nextLayout)\n\n      eagerValuesRef.value.layout = nextLayout\n      emits('layout', nextLayout)\n\n      callPanelCallbacks(\n        panelDataArray,\n        nextLayout,\n        panelIdToLastNotifiedSizeMapRef.value,\n      )\n    }\n  }\n})\n\nfunction registerResizeHandle(dragHandleId: string) {\n  return function resizeHandler(event: ResizeEvent) {\n    event.preventDefault()\n    const panelGroupElement = panelGroupElementRef.value\n    if (!panelGroupElement)\n      return () => null\n\n    const { direction, dragState, id: groupId, keyboardResizeBy } = committedValuesRef.value\n    const { layout: prevLayout, panelDataArray } = eagerValuesRef.value\n\n    const { initialLayout } = dragState ?? {}\n\n    const pivotIndices = determinePivotIndices(\n      groupId,\n      dragHandleId,\n      panelGroupElement,\n    )\n\n    let delta = calculateDeltaPercentage(\n      event,\n      dragHandleId,\n      direction,\n      dragState,\n      keyboardResizeBy,\n      panelGroupElement,\n    )\n    if (delta === 0)\n      return\n\n    // Support RTL layouts\n    const isHorizontal = direction === 'horizontal'\n    if (dir.value === 'rtl' && isHorizontal)\n      delta = -delta\n\n    const panelConstraints = panelDataArray.map(panelData => panelData.constraints)\n\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      layout: initialLayout ?? prevLayout,\n      panelConstraints,\n      pivotIndices,\n      trigger: isKeyDown(event) ? 'keyboard' : 'mouse-or-touch',\n    })\n\n    const layoutChanged = !compareLayouts(prevLayout, nextLayout)\n\n    // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n    // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n    if (isMouseEvent(event) || isTouchEvent(event)) {\n      // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n      // In this case, Panel sizes might not change\n      // but updating cursor in this scenario would cause a flicker.\n      if (prevDeltaRef.value !== delta) {\n        prevDeltaRef.value = delta\n\n        if (!layoutChanged) {\n          // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n          // This mimics VS Code behavior.\n          if (isHorizontal) {\n            reportConstraintsViolation(\n              dragHandleId,\n              delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX,\n            )\n          }\n          else {\n            reportConstraintsViolation(\n              dragHandleId,\n              delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX,\n            )\n          }\n        }\n        else {\n          reportConstraintsViolation(dragHandleId, 0)\n        }\n      }\n    }\n\n    if (layoutChanged) {\n      setLayout(nextLayout)\n\n      eagerValuesRef.value.layout = nextLayout\n      emits('layout', nextLayout)\n\n      callPanelCallbacks(\n        panelDataArray,\n        nextLayout,\n        panelIdToLastNotifiedSizeMapRef.value,\n      )\n    }\n  }\n}\n\nfunction resizePanel(panelData: PanelData, unsafePanelSize: number) {\n  const { layout: prevLayout, panelDataArray } = eagerValuesRef.value\n\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints)\n\n  const { panelSize, pivotIndices } = panelDataHelper(\n    panelDataArray,\n    panelData,\n    prevLayout,\n  )\n\n  assert(panelSize != null)\n\n  const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1\n  const delta = isLastPanel\n    ? panelSize - unsafePanelSize\n    : unsafePanelSize - panelSize\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: prevLayout,\n    panelConstraints: panelConstraintsArray,\n    pivotIndices,\n    trigger: 'imperative-api',\n  })\n\n  if (!compareLayouts(prevLayout, nextLayout)) {\n    setLayout(nextLayout)\n\n    eagerValuesRef.value.layout = nextLayout\n    emits('layout', nextLayout)\n\n    callPanelCallbacks(\n      panelDataArray,\n      nextLayout,\n      panelIdToLastNotifiedSizeMapRef.value,\n    )\n  }\n}\n\nfunction reevaluatePanelConstraints(panelData: PanelData, prevConstraints: PanelConstraints) {\n  const { layout, panelDataArray } = eagerValuesRef.value\n  const index = findPanelDataIndex(panelDataArray, panelData)\n  panelDataArray[index] = panelData\n  eagerValuesRef.value.panelDataArrayChanged = true\n  const {\n    collapsedSize: prevCollapsedSize = 0,\n    collapsible: prevCollapsible,\n  } = prevConstraints\n\n  const {\n    collapsedSize: nextCollapsedSize = 0,\n    collapsible: nextCollapsible,\n    maxSize: nextMaxSize = 100,\n    minSize: nextMinSize = 0,\n  } = panelData.constraints\n\n  const { panelSize: prevPanelSize } = panelDataHelper(\n    panelDataArray,\n    panelData,\n    layout,\n  )\n  if (prevPanelSize === null) {\n    // It's possible that the panels in this group have changed since the last render\n    return\n  }\n\n  if (\n    prevCollapsible\n    && nextCollapsible\n    && prevPanelSize === prevCollapsedSize\n  ) {\n    if (prevCollapsedSize !== nextCollapsedSize) {\n      resizePanel(panelData, nextCollapsedSize)\n    }\n    else {\n      // Stay collapsed\n    }\n  }\n  else if (prevPanelSize < nextMinSize) {\n    resizePanel(panelData, nextMinSize)\n  }\n  else if (prevPanelSize > nextMaxSize) {\n    resizePanel(panelData, nextMaxSize)\n  }\n}\n\nfunction startDragging(dragHandleId: string, event: ResizeEvent) {\n  const { direction } = committedValuesRef.value\n  const { layout } = eagerValuesRef.value\n  if (!panelGroupElementRef.value)\n    return\n\n  const handleElement = getResizeHandleElement(\n    dragHandleId,\n    panelGroupElementRef.value,\n  )\n  assert(handleElement)\n\n  const initialCursorPosition = getResizeEventCursorPosition(\n    direction,\n    event,\n  )\n\n  dragState.value = {\n    dragHandleId,\n    dragHandleRect: handleElement.getBoundingClientRect(),\n    initialCursorPosition,\n    initialLayout: layout,\n  }\n}\nfunction stopDragging() {\n  dragState.value = null\n}\n\nfunction unregisterPanel(panelData: PanelData) {\n  const { panelDataArray } = eagerValuesRef.value\n\n  const index = findPanelDataIndex(panelDataArray, panelData)\n  if (index >= 0) {\n    panelDataArray.splice(index, 1)\n\n    // TRICKY\n    // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n    // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n    // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n    delete panelIdToLastNotifiedSizeMapRef.value[panelData.id]\n\n    eagerValuesRef.value.panelDataArrayChanged = true\n  }\n}\n\nfunction collapsePanel(panelData: PanelData) {\n  const { layout: prevLayout, panelDataArray } = eagerValuesRef.value\n\n  if (panelData.constraints.collapsible) {\n    const panelConstraintsArray = panelDataArray.map(\n      panelData => panelData.constraints,\n    )\n\n    const {\n      collapsedSize = 0,\n      panelSize,\n      pivotIndices,\n    } = panelDataHelper(panelDataArray, panelData, prevLayout)\n\n    assert(\n      panelSize != null,\n      `Panel size not found for panel \"${panelData.id}\"`,\n    )\n\n    if (panelSize !== collapsedSize) {\n      // Store size before collapse;\n      // This is the size that gets restored if the expand() API is used.\n      panelSizeBeforeCollapseRef.value.set(panelData.id, panelSize)\n\n      const isLastPanel\n          = findPanelDataIndex(panelDataArray, panelData)\n            === panelDataArray.length - 1\n      const delta = isLastPanel\n        ? panelSize - collapsedSize\n        : collapsedSize - panelSize\n\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        layout: prevLayout,\n        panelConstraints: panelConstraintsArray,\n        pivotIndices,\n        trigger: 'imperative-api',\n      })\n\n      if (!compareLayouts(prevLayout, nextLayout)) {\n        setLayout(nextLayout)\n\n        eagerValuesRef.value.layout = nextLayout\n\n        emits('layout', nextLayout)\n\n        callPanelCallbacks(\n          panelDataArray,\n          nextLayout,\n          panelIdToLastNotifiedSizeMapRef.value,\n        )\n      }\n    }\n  }\n}\n\nfunction expandPanel(panelData: PanelData) {\n  const { layout: prevLayout, panelDataArray } = eagerValuesRef.value\n\n  if (panelData.constraints.collapsible) {\n    const panelConstraintsArray = panelDataArray.map(\n      panelData => panelData.constraints,\n    )\n\n    const {\n      collapsedSize = 0,\n      panelSize,\n      minSize = 0,\n      pivotIndices,\n    } = panelDataHelper(panelDataArray, panelData, prevLayout)\n\n    if (panelSize === collapsedSize) {\n      // Restore this panel to the size it was before it was collapsed, if possible.\n      const prevPanelSize = panelSizeBeforeCollapseRef.value.get(\n        panelData.id,\n      )\n\n      const baseSize\n          = prevPanelSize != null && prevPanelSize >= minSize\n            ? prevPanelSize\n            : minSize\n\n      const isLastPanel\n          = findPanelDataIndex(panelDataArray, panelData)\n            === panelDataArray.length - 1\n      const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize\n\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        layout: prevLayout,\n        panelConstraints: panelConstraintsArray,\n        pivotIndices,\n        trigger: 'imperative-api',\n      })\n\n      if (!compareLayouts(prevLayout, nextLayout)) {\n        setLayout(nextLayout)\n\n        eagerValuesRef.value.layout = nextLayout\n\n        emits('layout', nextLayout)\n\n        callPanelCallbacks(\n          panelDataArray,\n          nextLayout,\n          panelIdToLastNotifiedSizeMapRef.value,\n        )\n      }\n    }\n  }\n}\n\nfunction getPanelSize(panelData: PanelData) {\n  const { layout, panelDataArray } = eagerValuesRef.value\n\n  const { panelSize } = panelDataHelper(panelDataArray, panelData, layout)\n\n  assert(\n    panelSize != null,\n    `Panel size not found for panel \"${panelData.id}\"`,\n  )\n\n  return panelSize\n}\n\nfunction isPanelCollapsed(panelData: PanelData) {\n  const { layout, panelDataArray } = eagerValuesRef.value\n\n  const {\n    collapsedSize = 0,\n    collapsible,\n    panelSize,\n  } = panelDataHelper(panelDataArray, panelData, layout)\n\n  if (!collapsible)\n    return false\n\n  // panelSize is undefined during ssr due to vue ssr reactivity limitation.\n  if (panelSize === undefined) {\n    return panelData.constraints.defaultSize === panelData.constraints.collapsedSize\n  }\n  else {\n    return panelSize === collapsedSize\n  }\n}\n\nfunction isPanelExpanded(panelData: PanelData) {\n  const { layout, panelDataArray } = eagerValuesRef.value\n\n  const {\n    collapsedSize = 0,\n    collapsible,\n    panelSize,\n  } = panelDataHelper(panelDataArray, panelData, layout)\n\n  assert(\n    panelSize != null,\n    `Panel size not found for panel \"${panelData.id}\"`,\n  )\n\n  return !collapsible || panelSize > collapsedSize\n}\n\nprovidePanelGroupContext({\n  direction,\n  dragState: dragState.value,\n  groupId,\n  reevaluatePanelConstraints,\n  registerPanel,\n  registerResizeHandle,\n  resizePanel,\n  startDragging,\n  stopDragging,\n  unregisterPanel,\n  panelGroupElement: panelGroupElementRef,\n\n  collapsePanel,\n  expandPanel,\n  isPanelCollapsed,\n  isPanelExpanded,\n  getPanelSize,\n  getPanelStyle,\n})\n\nfunction findPanelDataIndex(panelDataArray: PanelData[], panelData: PanelData) {\n  return panelDataArray.findIndex(\n    prevPanelData =>\n      prevPanelData === panelData || prevPanelData.id === panelData.id,\n  )\n}\n\nfunction panelDataHelper(\n  panelDataArray: PanelData[],\n  panelData: PanelData,\n  layout: number[],\n) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData)\n\n  const isLastPanel = panelIndex === panelDataArray.length - 1\n  const pivotIndices = isLastPanel\n    ? [panelIndex - 1, panelIndex]\n    : [panelIndex, panelIndex + 1]\n\n  const panelSize = layout[panelIndex]\n\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices,\n  }\n}\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :style=\"{\n      display: 'flex',\n      flexDirection: direction === 'horizontal' ? 'row' : 'column',\n      height: '100%',\n      overflow: 'hidden',\n      width: '100%',\n    }\"\n    data-panel-group=\"\"\n    :data-orientation=\"direction\"\n    :data-panel-group-id=\"groupId\"\n  >\n    <slot :layout=\"layout\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useId } from '@/shared'\nimport { PRECISION } from './utils/constants'\n\nexport interface SplitterPanelProps extends PrimitiveProps {\n  /** The size of panel when it is collapsed. */\n  collapsedSize?: number\n  /** Should panel collapse when resized beyond its `minSize`. When `true`, it will be collapsed to `collapsedSize`. */\n  collapsible?: boolean\n  /** Initial size of panel (numeric value between 1-100) */\n  defaultSize?: number\n  /** Panel id (unique within group); falls back to `useId` when not provided */\n  id?: string\n  /** The maximum allowable size of panel (numeric value between 1-100); defaults to `100` */\n  maxSize?: number\n  /** The minimum allowable size of panel (numeric value between 1-100); defaults to `10` */\n  minSize?: number\n  /** The order of panel within group; required for groups with conditionally rendered panels */\n  order?: number\n}\n\nexport type SplitterPanelEmits = {\n  /** Event handler called when panel is collapsed. */\n  collapse: []\n  /** Event handler called when panel is expanded. */\n  expand: []\n  /** Event handler called when panel is resized; size parameter is a numeric value between 1-100.  */\n  resize: [size: number, prevSize: number | undefined]\n}\n\nexport type PanelOnCollapse = () => void\nexport type PanelOnExpand = () => void\nexport type PanelOnResize = (\n  size: number,\n  prevSize: number | undefined\n) => void\n\nexport type PanelCallbacks = {\n  onCollapse?: PanelOnCollapse\n  onExpand?: PanelOnExpand\n  onResize?: PanelOnResize\n}\n\nexport type PanelConstraints = {\n  collapsedSize?: number | undefined\n  collapsible?: boolean | undefined\n  defaultSize?: number | undefined\n  /** Panel id (unique within group); falls back to useId when not provided */\n  maxSize?: number | undefined\n  minSize?: number | undefined\n}\n\nexport type PanelData = {\n  callbacks: PanelCallbacks\n  constraints: PanelConstraints\n  id: string\n  idIsFromProps: boolean\n  order: number | undefined\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, onUnmounted, watch } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectPanelGroupContext } from './SplitterGroup.vue'\n\nconst props = defineProps<SplitterPanelProps>()\nconst emits = defineEmits<SplitterPanelEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Is the panel collapsed */\n    isCollapsed: typeof isCollapsed.value\n    /** Is the panel expanded */\n    isExpanded: typeof isExpanded.value\n    /** If panel is `collapsible`, collapse it fully. */\n    collapse: typeof collapse\n    /** If panel is currently collapsed, expand it to its most recent size. */\n    expand: typeof expand\n    /** Resize panel to the specified percentage (1 - 100). */\n    resize: typeof resize\n  }) => any\n}>()\n\nconst panelGroupContext = injectPanelGroupContext()\nif (panelGroupContext === null) {\n  throw new Error(\n    'SplitterPanel components must be rendered within a SplitterGroup container',\n  )\n}\n\nconst { collapsePanel, expandPanel, getPanelSize, getPanelStyle, isPanelCollapsed, resizePanel, groupId, reevaluatePanelConstraints, registerPanel, unregisterPanel } = panelGroupContext\nconst panelId = useId(props.id, 'reka-splitter-panel')\n\nconst panelDataRef = computed(() => ({\n  callbacks: {\n    onCollapse: () => emits('collapse'),\n    onExpand: () => emits('expand'),\n    onResize: (...args) => emits('resize', ...args),\n  },\n  constraints: {\n    collapsedSize: props.collapsedSize && Number.parseFloat(props.collapsedSize.toFixed(PRECISION)),\n    collapsible: props.collapsible,\n    defaultSize: props.defaultSize,\n    /** Panel id (unique within group); falls back to useId when not provided */\n    /** Panel id (unique within group); falls back to useId when not provided */\n    maxSize: props.maxSize,\n    minSize: props.minSize,\n  },\n  id: panelId,\n  idIsFromProps: props.id !== undefined,\n  order: props.order,\n}) satisfies PanelData)\n\nwatch(() => panelDataRef.value.constraints, (constraints, prevConstraints) => {\n  // If constraints have changed, we should revisit panel sizes.\n  // This is uncommon but may happen if people are trying to implement pixel based constraints.\n  if (\n    prevConstraints.collapsedSize !== constraints.collapsedSize\n    || prevConstraints.collapsible !== constraints.collapsible\n    || prevConstraints.maxSize !== constraints.maxSize\n    || prevConstraints.minSize !== constraints.minSize\n  ) {\n    reevaluatePanelConstraints(panelDataRef.value, prevConstraints)\n  }\n}, { deep: true })\n\nonMounted(() => {\n  const panelData = panelDataRef.value\n  registerPanel(panelData)\n  onUnmounted(() => {\n    unregisterPanel(panelData)\n  })\n})\n\nconst style = computed(() => getPanelStyle(panelDataRef.value, props.defaultSize))\n/** Panel id (unique within group); falls back to useId when not provided */\n\nconst isCollapsed = computed(() => isPanelCollapsed(panelDataRef.value))\nconst isExpanded = computed(() => !isCollapsed.value)\n\nfunction collapse() {\n  collapsePanel(panelDataRef.value)\n}\n\nfunction expand() {\n  expandPanel(panelDataRef.value)\n}\n\nfunction resize(size: number) {\n  resizePanel(panelDataRef.value, size)\n}\n\ndefineExpose({\n  /** If panel is `collapsible`, collapse it fully. */\n  collapse,\n  /** If panel is currently collapsed, expand it to its most recent size. */\n  expand,\n  /** Gets the current size of the panel as a percentage (1 - 100). */\n  getSize() {\n    return getPanelSize(panelDataRef.value)\n  },\n  /** Resize panel to the specified percentage (1 - 100). */\n  resize,\n  /** Returns `true` if the panel is currently collapsed */\n  isCollapsed,\n  /** Returns `true` if the panel is currently not collapsed */\n  isExpanded,\n})\n</script>\n\n<template>\n  <Primitive\n    :id=\"panelId\"\n    :style=\"style\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    data-panel=\"\"\n    :data-panel-collapsible=\"collapsible || undefined\"\n    :data-panel-group-id=\"groupId\"\n    :data-panel-id=\"panelId\"\n    :data-panel-size=\" Number.parseFloat(`${style.flexGrow}`).toFixed(1)\"\n    :data-state=\"collapsible ? isCollapsed ? 'collapsed' : 'expanded' : undefined\"\n  >\n    <slot\n      :is-collapsed=\"isCollapsed\"\n      :is-expanded=\"isExpanded\"\n      :expand=\"expand\"\n      :collapse=\"collapse\"\n      :resize=\"resize\"\n    />\n  </Primitive>\n</template>\n", "import type { Ref } from 'vue'\nimport type { ResizeHandler } from '../types'\nimport { watchEffect } from 'vue'\nimport { assert } from '../assert'\nimport { getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup } from '../dom'\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nexport function useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement,\n}: {\n  disabled: Ref<boolean>\n  handleId: string\n  resizeHandler: Ref<ResizeHandler | null>\n  panelGroupElement: Ref<ParentNode | null>\n}): void {\n  watchEffect((onCleanup) => {\n    const _panelGroupElement = panelGroupElement.value\n    if (disabled.value || resizeHandler.value === null || _panelGroupElement === null)\n      return\n\n    const handleElement = getResizeHandleElement(handleId, _panelGroupElement)\n    if (handleElement == null)\n      return\n\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.defaultPrevented)\n        return\n\n      switch (event.key) {\n        case 'ArrowDown':\n        case 'ArrowLeft':\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'End':\n        case 'Home': {\n          event.preventDefault()\n\n          resizeHandler.value?.(event)\n          break\n        }\n        case 'F6': {\n          event.preventDefault()\n\n          const groupId = handleElement.getAttribute('data-panel-group-id')\n          assert(groupId)\n\n          const handles = getResizeHandleElementsForGroup(\n            groupId,\n            _panelGroupElement,\n          )\n          const index = getResizeHandleElementIndex(\n            groupId,\n            handleId,\n            _panelGroupElement,\n          )\n\n          assert(index !== null)\n\n          const nextIndex = event.shiftKey\n            ? index > 0\n              ? index - 1\n              : handles.length - 1\n            : index + 1 < handles.length\n              ? index + 1\n              : 0\n\n          const nextHandle = handles[nextIndex] as HTMLElement\n          nextHandle.focus()\n\n          break\n        }\n      }\n    }\n\n    handleElement.addEventListener('keydown', onKeyDown)\n    onCleanup(() => {\n      handleElement.removeEventListener('keydown', onKeyDown)\n    })\n  })\n}\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { ref, toRefs, watch, watchEffect } from 'vue'\nimport { useWindowSplitterResizeHandlerBehavior } from './utils/composables/useWindowSplitterBehavior'\n\nexport interface SplitterResizeHandleProps extends PrimitiveProps {\n  /** Resize handle id (unique within group); falls back to `useId` when not provided */\n  id?: string\n  /** Allow this much margin when determining resizable handle hit detection */\n  hitAreaMargins?: PointerHitAreaMargins\n  /** Tabindex for the handle */\n  tabindex?: number\n  /** Disable drag handle */\n  disabled?: boolean\n}\n\nexport type PanelResizeHandleOnDragging = (isDragging: boolean) => void\nexport type ResizeHandlerState = 'drag' | 'hover' | 'inactive'\n\nexport type SplitterResizeHandleEmits = {\n  /** Event handler called when dragging the handler. */\n  dragging: [isDragging: boolean]\n}\n</script>\n\n<script setup lang=\"ts\">\nimport type { PointerHitAreaMargins, ResizeHandlerAction } from './utils/registry'\nimport type { ResizeEvent, ResizeHandler } from './utils/types'\nimport { Primitive } from '@/Primitive'\nimport { isBrowser, useForwardExpose, useId } from '@/shared'\nimport { injectPanelGroupContext } from './SplitterGroup.vue'\nimport { assert } from './utils/assert'\nimport { registerResizeHandle } from './utils/registry'\n\nconst props = withDefaults(defineProps<SplitterResizeHandleProps>(), {\n  tabindex: 0,\n})\nconst emits = defineEmits<SplitterResizeHandleEmits>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst { disabled } = toRefs(props)\n\nconst panelGroupContext = injectPanelGroupContext()\nif (panelGroupContext === null) {\n  throw new Error(\n    'PanelResizeHandle components must be rendered within a PanelGroup container',\n  )\n}\n\nconst {\n  direction,\n  groupId,\n  registerResizeHandle: registerResizeHandleWithParentGroup,\n  startDragging,\n  stopDragging,\n  panelGroupElement,\n} = panelGroupContext\n\nconst resizeHandleId = useId(props.id, 'reka-splitter-resize-handle')\nconst state = ref<ResizeHandlerState>('inactive')\nconst isFocused = ref(false)\nconst resizeHandler = ref<ResizeHandler | null>(null)\n\nwatch(disabled, () => {\n  if (!isBrowser)\n    return\n  if (disabled.value)\n    resizeHandler.value = null\n  else\n    resizeHandler.value = registerResizeHandleWithParentGroup(resizeHandleId)\n}, { immediate: true })\n\nwatchEffect((onCleanup) => {\n  if (disabled.value || resizeHandler.value === null)\n    return\n\n  const element = currentElement.value\n  if (!element)\n    return\n\n  assert(element)\n\n  const setResizeHandlerState = (\n    action: ResizeHandlerAction,\n    isActive: boolean,\n    event: ResizeEvent,\n  ) => {\n    if (isActive) {\n      switch (action) {\n        case 'down': {\n          state.value = 'drag'\n\n          startDragging(resizeHandleId, event)\n          emits('dragging', true)\n          break\n        }\n        case 'move': {\n          if (state.value !== 'drag')\n            state.value = 'hover'\n\n          resizeHandler.value?.(event)\n          break\n        }\n        case 'up': {\n          state.value = 'hover'\n\n          stopDragging()\n          emits('dragging', false)\n          break\n        }\n      }\n    }\n    else {\n      state.value = 'inactive'\n    }\n  }\n\n  onCleanup(registerResizeHandle(\n    resizeHandleId,\n    element,\n    direction,\n    {\n      // Coarse inputs (e.g. finger/touch)\n      coarse: props.hitAreaMargins?.coarse ?? 15,\n      // Fine inputs (e.g. mouse)\n      fine: props.hitAreaMargins?.fine ?? 5,\n    },\n    setResizeHandlerState,\n  ))\n})\n\nuseWindowSplitterResizeHandlerBehavior({\n  disabled,\n  resizeHandler,\n  handleId: resizeHandleId,\n  panelGroupElement,\n})\n</script>\n\n<template>\n  <Primitive\n    :id=\"resizeHandleId\"\n    :ref=\"forwardRef\"\n    :style=\"{\n      touchAction: 'none',\n      userSelect: 'none',\n    }\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    role=\"separator\"\n    data-resize-handle=\"\"\n    :tabindex=\"tabindex\"\n    :data-state=\"state\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-orientation=\"direction\"\n    :data-panel-group-id=\"groupId\"\n    :data-resize-handle-active=\"state === 'drag' ? 'pointer' : isFocused ? 'keyboard' : undefined\"\n    :data-resize-handle-state=\"state\"\n    :data-panel-resize-handle-enabled=\"!disabled\"\n    :data-panel-resize-handle-id=\" resizeHandleId\"\n    @blur=\"isFocused = false\"\n    @focus=\"isFocused = false\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { DataOrientation, Direction } from '../shared/types'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useVModel } from '@vueuse/core'\nimport { computed, nextTick, ref, toRefs, watch } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\nexport interface StepperRootContext {\n  modelValue: Ref<number | undefined>\n  changeModelValue: (value: number) => void\n  orientation: Ref<DataOrientation>\n  dir: Ref<Direction>\n  linear: Ref<boolean>\n  totalStepperItems: Ref<Set<HTMLElement>>\n}\n\nexport interface StepperRootProps extends PrimitiveProps {\n  /**\n   * The value of the step that should be active when initially rendered. Use when you do not need to control the state of the steps.\n   */\n  defaultValue?: number\n  /**\n   * The orientation the steps are laid out.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down).\n   * @defaultValue horizontal\n   */\n  orientation?: DataOrientation\n  /**\n   * The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode.\n   */\n  dir?: Direction\n  /** The controlled value of the step to activate. Can be bound as `v-model`. */\n  modelValue?: number\n  /** Whether or not the steps must be completed in order. */\n  linear?: boolean\n}\nexport type StepperRootEmits = {\n  /** Event handler called when the value changes */\n  'update:modelValue': [payload: number | undefined]\n}\n\nexport const [injectStepperRootContext, provideStepperRootContext]\n  = createContext<StepperRootContext>('StepperRoot')\n</script>\n\n<script setup lang=\"ts\">\nconst props = withDefaults(defineProps<StepperRootProps>(), {\n  orientation: 'horizontal',\n  linear: true,\n  defaultValue: 1,\n})\nconst emits = defineEmits<StepperRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current step */\n    modelValue: number | undefined\n    /** Total number of steps */\n    totalSteps: number\n    /** Whether or not the next step is disabled */\n    isNextDisabled: boolean\n    /** Whether or not the previous step is disabled */\n    isPrevDisabled: boolean\n    /** Whether or not the first step is active */\n    isFirstStep: boolean\n    /** Whether or not the last step is active */\n    isLastStep: boolean\n    /** Go to a specific step */\n    goToStep: (step: number) => void\n    /** Go to the next step */\n    nextStep: () => void\n    /** Go to the previous step */\n    prevStep: () => void\n    /** Whether or not there is a next step */\n    hasNext: () => boolean\n    /** Whether or not there is a previous step */\n    hasPrev: () => boolean\n  }) => any\n}>()\n\nconst { dir: propDir, orientation: propOrientation, linear } = toRefs(props)\nconst dir = useDirection(propDir)\n\nconst totalStepperItems = ref<Set<HTMLElement>>(new Set())\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n})\n\nconst totalStepperItemsArray = computed(() => Array.from(totalStepperItems.value))\n\nconst isFirstStep = computed(() => modelValue.value === 1)\nconst isLastStep = computed(() => modelValue.value === totalStepperItemsArray.value.length)\n\nconst totalSteps = computed(() => totalStepperItems.value.size)\n\nfunction goToStep(step: number) {\n  if (step > totalSteps.value)\n    return\n\n  if (step < 1)\n    return\n\n  if (totalStepperItems.value.size && !!totalStepperItemsArray.value[step] && !!totalStepperItemsArray.value[step].getAttribute('disabled'))\n    return\n\n  if (linear.value) {\n    if (step > (modelValue.value ?? 1) + 1)\n      return\n  }\n\n  modelValue.value = step\n}\n\nfunction nextStep() {\n  goToStep((modelValue.value ?? 1) + 1)\n}\n\nfunction prevStep() {\n  goToStep((modelValue.value ?? 1) - 1)\n}\n\nfunction hasNext() {\n  return (modelValue.value ?? 1) < totalSteps.value\n}\n\nfunction hasPrev() {\n  return (modelValue.value ?? 1) > 1\n}\n\nconst nextStepperItem = ref<HTMLElement | null>(null)\nconst prevStepperItem = ref<HTMLElement | null>(null)\nconst isNextDisabled = computed(() => nextStepperItem.value ? nextStepperItem.value.getAttribute('disabled') === '' : true)\nconst isPrevDisabled = computed(() => prevStepperItem.value ? prevStepperItem.value.getAttribute('disabled') === '' : true)\n\nwatch(modelValue, async () => {\n  await nextTick(() => {\n    nextStepperItem.value = totalStepperItemsArray.value.length && modelValue.value! < totalStepperItemsArray.value.length ? totalStepperItemsArray.value[modelValue.value!] : null\n    prevStepperItem.value = totalStepperItemsArray.value.length && modelValue.value! > 1 ? totalStepperItemsArray.value[modelValue.value! - 2] : null\n  })\n})\nwatch(totalStepperItemsArray, async () => {\n  await nextTick(() => {\n    nextStepperItem.value = totalStepperItemsArray.value.length && modelValue.value! < totalStepperItemsArray.value.length ? totalStepperItemsArray.value[modelValue.value!] : null\n    prevStepperItem.value = totalStepperItemsArray.value.length && modelValue.value! > 1 ? totalStepperItemsArray.value[modelValue.value! - 2] : null\n  })\n})\n\nprovideStepperRootContext({\n  modelValue,\n  changeModelValue: (value: number) => {\n    modelValue.value = value\n  },\n  orientation: propOrientation,\n  dir,\n  linear,\n  totalStepperItems,\n})\n\ndefineExpose({\n  goToStep,\n  nextStep,\n  prevStep,\n  modelValue,\n  totalSteps,\n  isNextDisabled,\n  isPrevDisabled,\n  isFirstStep,\n  isLastStep,\n  hasNext,\n  hasPrev,\n})\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    role=\"group\"\n    aria-label=\"progress\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :data-linear=\"linear ? '' : undefined\"\n    :data-orientation=\"orientation\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :total-steps=\"totalStepperItems.size\"\n      :is-next-disabled=\"isNextDisabled\"\n      :is-prev-disabled=\"isPrevDisabled\"\n      :is-first-step=\"isFirstStep\"\n      :is-last-step=\"isLastStep\"\n      :go-to-step=\"goToStep\"\n      :next-step=\"nextStep\"\n      :prev-step=\"prevStep\"\n      :has-next=\"hasNext\"\n      :has-prev=\"hasPrev\"\n    />\n\n    <div\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      role=\"status\"\n      :style=\"{\n        transform: 'translateX(-100%)',\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }\"\n    >\n      Step {{ modelValue }} of {{ totalStepperItems.size }}\n    </div>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\n\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { createContext, useForwardExpose, useId } from '@/shared'\nimport { injectStepperRootContext } from './StepperRoot.vue'\n\nexport const [injectStepperItemContext, provideStepperItemContext] = createContext<StepperItemContext>('StepperItem')\n\nexport type StepperState = 'completed' | 'active' | 'inactive'\n\nexport interface StepperItemContext {\n  titleId: string\n  descriptionId: string\n  step: Ref<number>\n  state: Ref<StepperState>\n  disabled: Ref<boolean>\n  isFocusable: Ref<boolean>\n}\n\nexport interface StepperItemProps extends PrimitiveProps {\n  /** A unique value that associates the stepper item with an index */\n  step: number\n  /** When `true`, prevents the user from interacting with the step. */\n  disabled?: boolean\n  /** Shows whether the step is completed. */\n  completed?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nconst props = withDefaults(defineProps<StepperItemProps>(), {\n  completed: false,\n  disabled: false,\n})\n\ndefineSlots<{\n  default?: (props: {\n    /** The current state of the stepper item */\n    state: StepperState\n  }) => any\n}>()\n\nconst { disabled, step, completed } = toRefs(props)\n\nconst { forwardRef } = useForwardExpose()\n\nconst rootContext = injectStepperRootContext()\n\nconst titleId = useId(undefined, 'reka-stepper-item-title')\nconst descriptionId = useId(undefined, 'reka-stepper-item-description')\n\nconst itemState = computed(() => {\n  if (completed.value)\n    return 'completed'\n  if (rootContext.modelValue.value === step.value)\n    return 'active'\n  if (rootContext.modelValue.value! > step.value)\n    return 'completed'\n  return 'inactive'\n})\n\nconst isFocusable = computed(() => {\n  if (disabled.value)\n    return false\n  if (rootContext.linear.value)\n    return step.value <= rootContext.modelValue.value! || step.value === rootContext.modelValue.value! + 1\n\n  return true\n})\n\nprovideStepperItemContext({\n  titleId,\n  descriptionId,\n  state: itemState,\n  disabled,\n  step,\n  isFocusable,\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :aria-current=\"itemState === 'active' ? 'true' : undefined\"\n    :data-state=\"itemState\"\n    :disabled=\"disabled || !isFocusable ? '' : undefined\"\n    :data-disabled=\"disabled || !isFocusable ? '' : undefined\"\n    :data-orientation=\"rootContext.orientation.value\"\n  >\n    <slot :state=\"itemState\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectStepperItemContext } from './StepperItem.vue'\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nexport interface StepperDescriptionProps extends PrimitiveProps { }\n\nconst props = withDefaults(defineProps<StepperDescriptionProps>(), { as: 'p' })\n\nuseForwardExpose()\nconst itemContext = injectStepperItemContext()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"itemContext.descriptionId\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectStepperItemContext } from './StepperItem.vue'\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nexport interface StepperIndicatorProps extends PrimitiveProps { }\n\nconst props = defineProps<StepperIndicatorProps>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current step */\n    step: number\n  }) => any\n}>()\n\nconst itemContext = injectStepperItemContext()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n  >\n    <slot :step=\"itemContext.step.value\">\n      Step {{ itemContext.step.value }}\n    </slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { SeparatorProps } from '@/Separator'\nimport { Separator } from '@/Separator'\nimport { useForwardExpose } from '@/shared'\nimport { injectStepperItemContext } from './StepperItem.vue'\nimport { injectStepperRootContext } from './StepperRoot.vue'\n</script>\n\n<script setup lang=\"ts\">\nexport interface StepperSeparatorProps extends SeparatorProps { }\n\nconst props = withDefaults(defineProps<StepperSeparatorProps>(), {})\n\nconst rootContext = injectStepperRootContext()\nconst itemContext = injectStepperItemContext()\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Separator\n    v-bind=\"props\"\n    decorative\n    :orientation=\"rootContext.orientation.value\"\n    :data-state=\"itemContext.state.value\"\n  >\n    <slot />\n  </Separator>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectStepperItemContext } from './StepperItem.vue'\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nexport interface StepperTitleProps extends PrimitiveProps { }\n\nconst props = withDefaults(defineProps<StepperTitleProps>(), { as: 'h4' })\nconst itemContext = injectStepperItemContext()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"itemContext.titleId\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed, onMounted, onUnmounted } from 'vue'\nimport { getActiveElement, useArrowNavigation, useForwardExpose, useKbd } from '@/shared'\n\nexport interface StepperTriggerProps extends PrimitiveProps {\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectStepperItemContext } from './StepperItem.vue'\nimport { injectStepperRootContext } from './StepperRoot.vue'\n\nwithDefaults(defineProps<StepperTriggerProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectStepperRootContext()\nconst itemContext = injectStepperItemContext()\n\nconst kbd = useKbd()\nconst stepperItems = computed(() => Array.from(rootContext.totalStepperItems.value))\n\nfunction handleMouseDown(event: MouseEvent) {\n  if (itemContext.disabled.value)\n    return\n  if (rootContext.linear.value) {\n    if (itemContext.step.value <= rootContext.modelValue.value! || itemContext.step.value === rootContext.modelValue.value! + 1) {\n      if (event.ctrlKey === false) {\n        rootContext.changeModelValue(itemContext.step.value)\n        return\n      }\n    }\n  }\n  else {\n    if (event.ctrlKey === false) {\n      rootContext.changeModelValue(itemContext.step.value)\n      return\n    }\n  }\n\n  // prevent focus to avoid accidental activation\n  event.preventDefault()\n}\n\nfunction handleKeyDown(event: KeyboardEvent) {\n  event.preventDefault()\n\n  if (itemContext.disabled.value)\n    return\n\n  if ((event.key === kbd.ENTER || event.key === kbd.SPACE) && !event.ctrlKey && !event.shiftKey)\n    rootContext.changeModelValue(itemContext.step.value)\n\n  if ([kbd.ARROW_LEFT, kbd.ARROW_RIGHT, kbd.ARROW_UP, kbd.ARROW_DOWN].includes(event.key)) {\n    useArrowNavigation(event, getActiveElement() as HTMLElement, undefined, {\n      itemsArray: stepperItems.value,\n      focus: true,\n      loop: false,\n      arrowKeyOptions: rootContext.orientation.value,\n      dir: rootContext.dir.value,\n    })\n  }\n}\n\nconst { forwardRef, currentElement } = useForwardExpose()\n\nonMounted(() => {\n  rootContext.totalStepperItems.value.add(currentElement.value)\n})\n\nonUnmounted(() => {\n  rootContext.totalStepperItems.value.delete(currentElement.value)\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :data-state=\"itemContext.state.value\"\n    :disabled=\"itemContext.disabled.value || !itemContext.isFocusable.value ? '' : undefined\"\n    :data-disabled=\"itemContext.disabled.value || !itemContext.isFocusable.value ? '' : undefined\"\n    :data-orientation=\"rootContext.orientation.value\"\n    :tabindex=\"itemContext.isFocusable.value ? 0 : -1\"\n    :aria-describedby=\"itemContext.descriptionId\"\n    :aria-labelledby=\"itemContext.titleId\"\n    @mousedown.left=\"handleMouseDown\"\n    @keydown.enter.space.left.right.up.down=\"handleKeyDown\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { FormFieldProps } from '@/shared/types'\nimport { createContext, useFormControl, useForwardExpose } from '@/shared'\n\nexport interface SwitchRootProps extends PrimitiveProps, FormFieldProps {\n  /** The state of the switch when it is initially rendered. Use when you do not need to control its state. */\n  defaultValue?: boolean\n  /** The controlled state of the switch. Can be bind as `v-model`. */\n  modelValue?: boolean | null\n  /** When `true`, prevents the user from interacting with the switch. */\n  disabled?: boolean\n  id?: string\n  /** The value given as data when submitted with a `name`. */\n  value?: string\n}\n\nexport type SwitchRootEmits = {\n  /** Event handler called when the value of the switch changes. */\n  'update:modelValue': [payload: boolean]\n}\n\nexport interface SwitchRootContext {\n  modelValue?: Ref<boolean>\n  toggleCheck: () => void\n  disabled: Ref<boolean>\n}\n\nexport const [injectSwitchRootContext, provideSwitchRootContext]\n  = createContext<SwitchRootContext>('SwitchRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\n\nconst props = withDefaults(defineProps<SwitchRootProps>(), {\n  as: 'button',\n  modelValue: undefined,\n  value: 'on',\n})\nconst emit = defineEmits<SwitchRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current value */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { disabled } = toRefs(props)\n\nconst modelValue = useVModel(props, 'modelValue', emit, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<boolean>\n\nfunction toggleCheck() {\n  if (disabled.value)\n    return\n\n  modelValue.value = !modelValue.value\n}\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst isFormControl = useFormControl(currentElement)\nconst ariaLabel = computed(() => props.id && currentElement.value ? (document.querySelector(`[for=\"${props.id}\"]`) as HTMLLabelElement)?.innerText : undefined)\n\nprovideSwitchRootContext({\n  modelValue,\n  toggleCheck,\n  disabled,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    :id=\"id\"\n    :ref=\"forwardRef\"\n    role=\"switch\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :value=\"value\"\n    :aria-label=\"$attrs['aria-label'] || ariaLabel\"\n    :aria-checked=\"modelValue\"\n    :aria-required=\"required\"\n    :data-state=\"modelValue ? 'checked' : 'unchecked'\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n    :disabled=\"disabled\"\n    @click=\"toggleCheck\"\n    @keydown.enter.prevent=\"toggleCheck\"\n  >\n    <slot :model-value=\"modelValue\" />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name\"\n      type=\"checkbox\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n      :value=\"value\"\n      :checked=\"!!modelValue\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface SwitchThumbProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { injectSwitchRootContext } from './SwitchRoot.vue'\n\nwithDefaults(defineProps<SwitchThumbProps>(), { as: 'span' })\n\nconst rootContext = injectSwitchRootContext()\n\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive\n    :data-state=\"rootContext.modelValue?.value ? 'checked' : 'unchecked'\"\n    :data-disabled=\"rootContext.disabled.value ? '' : undefined\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import type { StringOrNumber } from '@/shared/types'\n\nexport function makeTriggerId(baseId: string, value: StringOrNumber) {\n  return `${baseId}-trigger-${value}`\n}\n\nexport function makeContentId(baseId: string, value: StringOrNumber) {\n  return `${baseId}-content-${value}`\n}\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { DataOrientation, Direction, StringOrNumber } from '../shared/types'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useVModel } from '@vueuse/core'\nimport { createContext, useDirection, useForwardExpose, useId } from '@/shared'\n\nexport interface TabsRootContext {\n  modelValue: Ref<StringOrNumber | undefined>\n  changeModelValue: (value: StringOrNumber) => void\n  orientation: Ref<DataOrientation>\n  dir: Ref<Direction>\n  unmountOnHide: Ref<boolean>\n  activationMode: 'automatic' | 'manual'\n  baseId: string\n  tabsList: Ref<HTMLElement | undefined>\n}\n\nexport interface TabsRootProps<T extends StringOrNumber = StringOrNumber> extends PrimitiveProps {\n  /**\n   * The value of the tab that should be active when initially rendered. Use when you do not need to control the state of the tabs\n   */\n  defaultValue?: T\n  /**\n   * The orientation the tabs are laid out.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   * @defaultValue horizontal\n   */\n  orientation?: DataOrientation\n  /**\n   * The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode.\n   */\n  dir?: Direction\n  /**\n   * Whether a tab is activated automatically (on focus) or manually (on click).\n   * @defaultValue automatic\n   */\n  activationMode?: 'automatic' | 'manual'\n  /** The controlled value of the tab to activate. Can be bind as `v-model`. */\n  modelValue?: T\n  /**\n   * When `true`, the element will be unmounted on closed state.\n   *\n   * @defaultValue `true`\n   */\n  unmountOnHide?: boolean\n}\nexport type TabsRootEmits<T extends StringOrNumber = StringOrNumber> = {\n  /** Event handler called when the value changes */\n  'update:modelValue': [payload: T]\n}\n\nexport const [injectTabsRootContext, provideTabsRootContext]\n  = createContext<TabsRootContext>('TabsRoot')\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends StringOrNumber = StringOrNumber\">\nimport { ref, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<TabsRootProps<T>>(), {\n  orientation: 'horizontal',\n  activationMode: 'automatic',\n  unmountOnHide: true,\n})\nconst emits = defineEmits<TabsRootEmits<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { orientation, unmountOnHide, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nuseForwardExpose()\n\nconst modelValue = useVModel<TabsRootProps<T>, 'modelValue', 'update:modelValue'>(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n})\n\nconst tabsList = ref<HTMLElement>()\n\nprovideTabsRootContext({\n  modelValue,\n  changeModelValue: (value: StringOrNumber) => {\n    modelValue.value = value as T\n  },\n  orientation,\n  dir,\n  unmountOnHide,\n  activationMode: props.activationMode,\n  baseId: useId(undefined, 'reka-tabs'),\n  tabsList,\n})\n</script>\n\n<template>\n  <Primitive\n    :dir=\"dir\"\n    :data-orientation=\"orientation\"\n    :as-child=\"asChild\"\n    :as=\"as\"\n  >\n    <slot :model-value=\"modelValue\" />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { StringOrNumber } from '@/shared/types'\nimport { useForwardExpose } from '@/shared'\n\nexport interface TabsContentProps extends PrimitiveProps {\n  /** A unique value that associates the content with a trigger. */\n  value: StringOrNumber\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, ref } from 'vue'\nimport { Presence } from '@/Presence'\nimport { Primitive } from '@/Primitive'\nimport { injectTabsRootContext } from './TabsRoot.vue'\nimport { makeContentId, makeTriggerId } from './utils'\n\nconst props = defineProps<TabsContentProps>()\n\nconst { forwardRef } = useForwardExpose()\nconst rootContext = injectTabsRootContext()\nconst triggerId = computed(() => makeTriggerId(rootContext.baseId, props.value))\nconst contentId = computed(() => makeContentId(rootContext.baseId, props.value))\n\nconst isSelected = computed(() => props.value === rootContext.modelValue.value)\n\nconst isMountAnimationPreventedRef = ref(isSelected.value)\n\nonMounted(() => {\n  requestAnimationFrame(() => {\n    isMountAnimationPreventedRef.value = false\n  })\n})\n</script>\n\n<template>\n  <Presence\n    v-slot=\"{ present }\"\n    :present=\"forceMount || isSelected\"\n    force-mount\n  >\n    <Primitive\n      :id=\"contentId\"\n      :ref=\"forwardRef\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      role=\"tabpanel\"\n      :data-state=\"isSelected ? 'active' : 'inactive'\"\n      :data-orientation=\"rootContext.orientation.value\"\n      :aria-labelledby=\"triggerId\"\n      :hidden=\"!present\"\n      tabindex=\"0\"\n      :style=\"{\n        animationDuration: isMountAnimationPreventedRef ? '0s' : undefined,\n      }\"\n    >\n      <slot v-if=\"rootContext.unmountOnHide.value ? present : true\" />\n    </Primitive>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { nextTick, ref, watch } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport { injectTabsRootContext } from './TabsRoot.vue'\n\nexport interface TabsIndicatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { useResizeObserver } from '@vueuse/core'\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<TabsIndicatorProps>()\nconst context = injectTabsRootContext()\nuseForwardExpose()\n\ninterface IndicatorStyle {\n  size: number | null\n  position: number | null\n}\nconst activeTab = ref<HTMLElement | null>()\nconst indicatorStyle = ref<IndicatorStyle>({\n  size: null,\n  position: null,\n})\n\nwatch(() => [context.modelValue.value, context?.dir.value], async () => {\n  await nextTick()\n  updateIndicatorStyle()\n}, { immediate: true })\n\nuseResizeObserver([context.tabsList, activeTab], updateIndicatorStyle)\n\nfunction updateIndicatorStyle() {\n  activeTab.value = context.tabsList.value?.querySelector<HTMLButtonElement>('[role=\"tab\"][data-state=\"active\"]')\n\n  if (!activeTab.value)\n    return\n\n  if (context.orientation.value === 'horizontal') {\n    indicatorStyle.value = {\n      size: activeTab.value.offsetWidth,\n      position: activeTab.value.offsetLeft,\n    }\n  }\n  else {\n    indicatorStyle.value = {\n      size: activeTab.value.offsetHeight,\n      position: activeTab.value.offsetTop,\n    }\n  }\n}\n</script>\n\n<template>\n  <Primitive\n    v-if=\"typeof indicatorStyle.size === 'number'\"\n    v-bind=\"props\"\n    :style=\"{\n      '--reka-tabs-indicator-size': `${indicatorStyle.size}px`,\n      '--reka-tabs-indicator-position': `${indicatorStyle.position}px`,\n    }\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface TabsListProps extends PrimitiveProps {\n  /** When `true`, keyboard navigation will loop from last tab to first, and vice versa. */\n  loop?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusGroup } from '@/RovingFocus'\nimport { injectTabsRootContext } from './TabsRoot.vue'\n\nconst props = withDefaults(defineProps<TabsListProps>(), {\n  loop: true,\n})\nconst { loop } = toRefs(props)\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst context = injectTabsRootContext()\n\ncontext.tabsList = currentElement\n</script>\n\n<template>\n  <RovingFocusGroup\n    as-child\n    :orientation=\"context.orientation.value\"\n    :dir=\"context.dir.value\"\n    :loop=\"loop\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"tablist\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n      :aria-orientation=\"context.orientation.value\"\n    >\n      <slot />\n    </Primitive>\n  </RovingFocusGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { StringOrNumber } from '@/shared/types'\nimport { useForwardExpose } from '@/shared'\n\nexport interface TabsTriggerProps extends PrimitiveProps {\n  /** A unique value that associates the trigger with a content. */\n  value: StringOrNumber\n  /** When `true`, prevents the user from interacting with the tab. */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\nimport { injectTabsRootContext } from './TabsRoot.vue'\nimport { makeContentId, makeTriggerId } from './utils'\n\nconst props = withDefaults(defineProps<TabsTriggerProps>(), {\n  disabled: false,\n  as: 'button',\n})\n\nconst { forwardRef } = useForwardExpose()\nconst rootContext = injectTabsRootContext()\n\nconst triggerId = computed(() => makeTriggerId(rootContext.baseId, props.value))\nconst contentId = computed(() => makeContentId(rootContext.baseId, props.value))\n\nconst isSelected = computed(() => props.value === rootContext.modelValue.value)\n</script>\n\n<template>\n  <RovingFocusItem\n    as-child\n    :focusable=\"!disabled\"\n    :active=\"isSelected\"\n  >\n    <Primitive\n      :id=\"triggerId\"\n      :ref=\"forwardRef\"\n      role=\"tab\"\n      :type=\"as === 'button' ? 'button' : undefined\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :aria-selected=\"isSelected ? 'true' : 'false'\"\n      :aria-controls=\"contentId\"\n      :data-state=\"isSelected ? 'active' : 'inactive'\"\n      :disabled=\"disabled\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :data-orientation=\"rootContext.orientation.value\"\n      @mousedown.left=\"(event) => {\n        // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n        // but not when the control key is pressed (avoiding MacOS right click)\n        if (!disabled && event.ctrlKey === false) {\n          rootContext.changeModelValue(value);\n        }\n        else {\n          // prevent focus to avoid accidental activation\n          event.preventDefault();\n        }\n      }\"\n      @keydown.enter.space=\"rootContext.changeModelValue(value)\"\n      @focus=\"() => {\n        // handle 'automatic' activation if necessary\n        // ie. activate tab following focus\n        const isAutomaticActivation = rootContext.activationMode !== 'manual';\n        if (!isSelected && !disabled && isAutomaticActivation) {\n          rootContext.changeModelValue(value);\n        }\n      }\"\n    >\n      <slot />\n    </Primitive>\n  </RovingFocusItem>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { Direction, FormFieldProps } from '@/shared/types'\nimport { computed, ref, toRefs } from 'vue'\nimport { createContext, useArrowNavigation, useDirection, useFormControl, useForwardExpose } from '@/shared'\n\nexport type AcceptableInputValue = string | Record<string, any>\n\nexport interface TagsInputRootProps<T = AcceptableInputValue> extends PrimitiveProps, FormFieldProps {\n  /** The controlled value of the tags input. Can be bind as `v-model`. */\n  modelValue?: Array<T> | null\n  /** The value of the tags that should be added. Use when you do not need to control the state of the tags input */\n  defaultValue?: Array<T>\n  /** When `true`, allow adding tags on paste. Work in conjunction with delimiter prop. */\n  addOnPaste?: boolean\n  /** When `true` allow adding tags on tab keydown */\n  addOnTab?: boolean\n  /** When `true` allow adding tags blur input */\n  addOnBlur?: boolean\n  /** When `true`, allow duplicated tags. */\n  duplicate?: boolean\n  /** When `true`, prevents the user from interacting with the tags input. */\n  disabled?: boolean\n  /** The character or regular expression to trigger the addition of a new tag. Also used to split tags for `@paste` event */\n  delimiter?: string | RegExp\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** Maximum number of tags. */\n  max?: number\n  id?: string\n  /** Convert the input value to the desired type. Mandatory when using objects as values and using `TagsInputInput` */\n  convertValue?: (value: string) => T\n  /** Display the value of the tag. Useful when you want to apply modifications to the value like adding a suffix or when using object as values */\n  displayValue?: (value: T) => string\n}\n\nexport type TagsInputRootEmits<T = AcceptableInputValue> = {\n  /** Event handler called when the value changes */\n  'update:modelValue': [payload: Array<T>]\n  /** Event handler called when the value is invalid */\n  'invalid': [payload: T]\n  /** Event handler called when tag is added */\n  'addTag': [payload: T]\n  /** Event handler called when tag is removed */\n  'removeTag': [payload: T]\n}\n\nexport interface TagsInputRootContext<T = AcceptableInputValue> {\n  modelValue: Ref<Array<T>>\n  onAddValue: (payload: string) => boolean\n  onRemoveValue: (index: number) => void\n  onInputKeydown: (event: KeyboardEvent) => void\n  selectedElement: Ref<HTMLElement | undefined>\n  isInvalidInput: Ref<boolean>\n  addOnPaste: Ref<boolean>\n  addOnTab: Ref<boolean>\n  addOnBlur: Ref<boolean>\n  disabled: Ref<boolean>\n  delimiter: Ref<string | RegExp>\n  dir: Ref<Direction>\n  max: Ref<number>\n  id: Ref<string | undefined> | undefined\n  displayValue: (value: T) => string\n}\n\nexport const [injectTagsInputRootContext, provideTagsInputRootContext]\n  = createContext<TagsInputRootContext>('TagsInputRoot')\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends AcceptableInputValue = string\">\nimport { useFocusWithin, useVModel } from '@vueuse/core'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\nimport { VisuallyHiddenInput } from '@/VisuallyHidden'\n\nconst props = withDefaults(defineProps<TagsInputRootProps<T>>(), {\n  defaultValue: () => [],\n  delimiter: ',',\n  max: 0,\n  displayValue: (value: T) => value.toString(),\n})\nconst emits = defineEmits<TagsInputRootEmits<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current input values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { addOnPaste, disabled, delimiter, max, id, dir: propDir, addOnBlur, addOnTab } = toRefs(props)\nconst dir = useDirection(propDir)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: true,\n  deep: true,\n}) as Ref<Array<AcceptableInputValue>>\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst { focused } = useFocusWithin(currentElement)\nconst isFormControl = useFormControl(currentElement)\n\nconst { getItems, CollectionSlot } = useCollection({ isProvider: true })\n\nconst selectedElement = ref<HTMLElement>()\nconst isInvalidInput = ref(false)\n\nconst currentModelValue = computed(() => Array.isArray(modelValue.value) ? [...modelValue.value] : [])\n\nfunction handleRemoveTag(index: number) {\n  if (index !== -1) {\n    const collection = getItems().filter(i => i.ref.dataset.disabled !== '')\n    modelValue.value = modelValue.value.filter((_, i) => i !== index)\n    emits('removeTag', collection[index].value)\n  }\n}\n\nprovideTagsInputRootContext({\n  modelValue,\n  onAddValue: (_payload) => {\n    const array = [...currentModelValue.value]\n    const modelValueIsObject = array.length > 0 && typeof array[0] === 'object'\n    const defaultValueIsObject = array.length > 0 && typeof props.defaultValue[0] === 'object'\n\n    // Check if the value is an object and if the convertValue function is provided. We don't check this a type level because the use\n    // of `TagsInputInput` is optional.\n    if ((modelValueIsObject || defaultValueIsObject) && typeof props.convertValue !== 'function')\n      throw new Error('You must provide a `convertValue` function when using objects as values.')\n    const payload = props.convertValue ? props.convertValue(_payload) : _payload as T\n\n    if ((array.length >= max.value) && !!max.value) {\n      emits('invalid', payload)\n      return false\n    }\n\n    if (props.duplicate) {\n      modelValue.value = [...array, payload]\n      emits('addTag', payload)\n      return true\n    }\n    else {\n      const exist = array.includes(payload)\n      if (!exist) {\n        modelValue.value = [...array, payload]\n        emits('addTag', payload)\n        return true\n      }\n      else {\n        isInvalidInput.value = true\n      }\n    }\n    emits('invalid', payload)\n    return false\n  },\n  onRemoveValue: handleRemoveTag,\n  onInputKeydown: (event) => {\n    const target = event.target as HTMLInputElement\n    const collection = getItems().map(i => i.ref).filter(i => i.dataset.disabled !== '')\n    if (!collection.length)\n      return\n    const lastTag = collection.at(-1)\n    switch (event.key) {\n      case 'Delete':\n      case 'Backspace': {\n        if (target.selectionStart !== 0 || target.selectionEnd !== 0)\n          break\n\n        if (selectedElement.value) {\n          const index = collection.findIndex(i => i === selectedElement.value)\n          handleRemoveTag(index)\n          selectedElement.value = selectedElement.value === lastTag ? collection.at(index - 1) : collection.at(index + 1)\n          event.preventDefault()\n        }\n        else if (event.key === 'Backspace') {\n          selectedElement.value = lastTag\n          event.preventDefault()\n        }\n        break\n      }\n      case 'Home':\n      case 'End':\n      case 'ArrowRight':\n      case 'ArrowLeft': {\n        const isArrowRight = (event.key === 'ArrowRight' && dir.value === 'ltr') || (event.key === 'ArrowLeft' && dir.value === 'rtl')\n        const isArrowLeft = !isArrowRight\n        // only focus on tags when cursor is at the first position\n        if (target.selectionStart !== 0 || target.selectionEnd !== 0)\n          break\n\n        // if you press ArrowLeft, then we last tag\n        if (isArrowLeft && !selectedElement.value) {\n          selectedElement.value = lastTag\n          event.preventDefault()\n        }\n        // if you press ArrowRight on last tag, you deselect\n        else if (isArrowRight && lastTag && selectedElement.value === lastTag) {\n          selectedElement.value = undefined\n          event.preventDefault()\n        }\n        else if (selectedElement.value) {\n          const el = useArrowNavigation(event, selectedElement.value, undefined, {\n            itemsArray: collection,\n            loop: false,\n            dir: dir.value,\n          })\n          if (el)\n            selectedElement.value = el\n          event.preventDefault()\n        }\n        break\n      }\n      case 'ArrowUp':\n      case 'ArrowDown': {\n        if (selectedElement.value)\n          event.preventDefault()\n        break\n      }\n      default: {\n        selectedElement.value = undefined\n      }\n    }\n  },\n  selectedElement,\n  isInvalidInput,\n  addOnPaste,\n  addOnBlur,\n  addOnTab,\n  dir,\n  disabled,\n  delimiter,\n  max,\n  id,\n  displayValue: props.displayValue as (value: AcceptableInputValue) => string,\n})\n</script>\n\n<template>\n  <CollectionSlot>\n    <Primitive\n      :ref=\"forwardRef\"\n      :dir=\"dir\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :data-invalid=\"isInvalidInput ? '' : undefined\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :data-focused=\"focused ? '' : undefined\"\n    >\n      <slot :model-value=\"modelValue\" />\n\n      <VisuallyHiddenInput\n        v-if=\"isFormControl && name\"\n        :name=\"name\"\n        :value=\"modelValue\"\n        :required=\"required\"\n        :disabled=\"disabled\"\n      />\n    </Primitive>\n  </CollectionSlot>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\nimport { injectTagsInputRootContext } from './TagsInputRoot.vue'\n\nexport interface TagsInputClearProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<TagsInputClearProps>(), {\n  as: 'button',\n})\n\nuseForwardExpose()\nconst context = injectTagsInputRootContext()\n\nfunction handleCancel() {\n  if (context.disabled.value)\n    return\n  context.modelValue.value = []\n}\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :data-disabled=\"context.disabled.value ? '' : undefined\"\n    @click=\"handleCancel\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface TagsInputInputProps extends PrimitiveProps {\n  /** The placeholder character to use for empty tags input. */\n  placeholder?: string\n  /** Focus on element when mounted. */\n  autoFocus?: boolean\n  /** Maximum number of character allowed. */\n  maxLength?: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { nextTick, onMounted, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { injectTagsInputRootContext } from './TagsInputRoot.vue'\n\nconst props = withDefaults(defineProps<TagsInputInputProps>(), {\n  as: 'input',\n})\n\nconst context = injectTagsInputRootContext()\nconst { forwardRef, currentElement } = useForwardExpose()\n\nfunction handleBlur(event: Event) {\n  context.selectedElement.value = undefined\n\n  if (!context.addOnBlur.value)\n    return\n\n  const target = event.target as HTMLInputElement\n  if (!target.value)\n    return\n\n  const isAdded = context.onAddValue(target.value)\n  if (isAdded)\n    target.value = ''\n}\n\nfunction handleTab(event: Event) {\n  if (!context.addOnTab.value)\n    return\n\n  handleCustomKeydown(event)\n}\n\nconst isComposing = ref(false)\nfunction onCompositionStart() {\n  isComposing.value = true\n}\nfunction onCompositionEnd() {\n  requestAnimationFrame(() => {\n    isComposing.value = false\n  })\n}\nasync function handleCustomKeydown(event: Event) {\n  if (isComposing.value)\n    return\n  await nextTick()\n  // if keydown 'Enter' or `Tab` was prevented, we let user handle updating the value themselves\n  if (event.defaultPrevented)\n    return\n\n  const target = event.target as HTMLInputElement\n  if (!target.value)\n    return\n\n  const isAdded = context.onAddValue(target.value)\n  if (isAdded)\n    target.value = ''\n\n  // prevent reloading when using inside of form\n  event.preventDefault()\n}\n\nfunction handleInput(event: InputEvent) {\n  context.isInvalidInput.value = false\n  if (event.data === null)\n    return\n\n  const delimiter = context.delimiter.value\n  const matchesDelimiter = delimiter === event.data || (delimiter instanceof RegExp && delimiter.test(event.data))\n  if (matchesDelimiter) {\n    const target = event.target as HTMLInputElement\n    target.value = target.value.replace(delimiter, '')\n\n    const isAdded = context.onAddValue(target.value)\n    if (isAdded)\n      target.value = ''\n  }\n}\n\nfunction handlePaste(event: ClipboardEvent) {\n  if (context.addOnPaste.value) {\n    event.preventDefault()\n    const clipboardData = event.clipboardData\n    if (!clipboardData)\n      return\n\n    const value = clipboardData.getData('text')\n    if (context.delimiter.value) {\n      const splitValue = value.split(context.delimiter.value)\n      splitValue.forEach((v) => {\n        context.onAddValue(v)\n      })\n    }\n    else {\n      context.onAddValue(value)\n    }\n  }\n}\n\nonMounted(() => {\n  const inputEl = currentElement.value.nodeName === 'INPUT'\n    ? currentElement.value\n    : currentElement.value.querySelector('input')\n\n  if (!inputEl)\n    return\n\n  setTimeout(() => {\n    // make sure all DOM was flush then only capture the focus\n    if (props.autoFocus)\n      inputEl?.focus()\n  }, 1)\n})\n</script>\n\n<template>\n  <Primitive\n    :id=\"context.id?.value\"\n    :ref=\"forwardRef\"\n    type=\"text\"\n    autocomplete=\"off\"\n    autocorrect=\"off\"\n    autocapitalize=\"off\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :maxlength=\"maxLength\"\n    :placeholder=\"placeholder\"\n    :disabled=\"context.disabled.value\"\n    :data-invalid=\"context.isInvalidInput.value ? '' : undefined\"\n    @input=\"handleInput\"\n    @keydown.enter=\"handleCustomKeydown\"\n    @keydown.tab=\"handleTab\"\n    @blur=\"handleBlur\"\n    @keydown=\"context.onInputKeydown\"\n    @compositionstart=\"onCompositionStart\"\n    @compositionend=\"onCompositionEnd\"\n    @paste=\"handlePaste\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { AcceptableInputValue } from './TagsInputRoot.vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed, toRefs } from 'vue'\nimport { createContext, useForwardExpose } from '@/shared'\nimport { injectTagsInputRootContext } from './TagsInputRoot.vue'\n\nexport interface TagsInputItemProps extends PrimitiveProps {\n  /** Value associated with the tags */\n  value: AcceptableInputValue\n  /** When `true`, prevents the user from interacting with the tags input. */\n  disabled?: boolean\n}\n\nexport interface TagsInputItemContext {\n  value: Ref<AcceptableInputValue>\n  displayValue: ComputedRef<string>\n  isSelected: Ref<boolean>\n  disabled?: Ref<boolean>\n  textId: string\n}\n\nexport const [injectTagsInputItemContext, provideTagsInputItemContext]\n  = createContext<TagsInputItemContext>('TagsInputItem')\n</script>\n\n<script setup lang=\"ts\">\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<TagsInputItemProps>()\nconst { value } = toRefs(props)\n\nconst context = injectTagsInputRootContext()\nconst { forwardRef, currentElement } = useForwardExpose()\nconst { CollectionItem } = useCollection()\n\nconst isSelected = computed(() => context.selectedElement.value === currentElement.value)\n\nconst disabled = computed(() => props.disabled || context.disabled.value)\n\nconst itemContext = provideTagsInputItemContext({\n  value,\n  isSelected,\n  disabled,\n  textId: '',\n  displayValue: computed(() => context.displayValue(value.value)),\n})\n</script>\n\n<template>\n  <CollectionItem :value=\"value\">\n    <Primitive\n      :ref=\"forwardRef\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :aria-labelledby=\"itemContext.textId\"\n      :aria-current=\"isSelected\"\n      :data-disabled=\"disabled ? '' : undefined\"\n      :data-state=\"isSelected ? 'active' : 'inactive'\"\n    >\n      <slot />\n    </Primitive>\n  </CollectionItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { isEqual } from 'ohash'\nimport { computed } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport { injectTagsInputItemContext } from './TagsInputItem.vue'\nimport { injectTagsInputRootContext } from './TagsInputRoot.vue'\n\nexport interface TagsInputItemDeleteProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<TagsInputItemDeleteProps>(), {\n  as: 'button',\n})\n\nuseForwardExpose()\nconst context = injectTagsInputRootContext()\nconst itemContext = injectTagsInputItemContext()\n\nconst disabled = computed(() => itemContext.disabled?.value || context.disabled.value)\n\nfunction handleDelete() {\n  if (disabled.value)\n    return\n  const index = context.modelValue.value.findIndex(i => isEqual(i, itemContext.value.value))\n  context.onRemoveValue(index)\n}\n</script>\n\n<template>\n  <Primitive\n    tabindex=\"-1\"\n    v-bind=\"props\"\n    :aria-labelledby=\"itemContext.textId\"\n    :aria-current=\"itemContext.isSelected.value\"\n    :data-state=\"itemContext.isSelected.value ? 'active' : 'inactive'\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    @click=\"handleDelete\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose, useId } from '@/shared'\nimport { injectTagsInputItemContext } from './TagsInputItem.vue'\n\nexport interface TagsInputItemTextProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<TagsInputItemTextProps>(), {\n  as: 'span',\n})\n\nconst itemContext = injectTagsInputItemContext()\nuseForwardExpose()\n\nitemContext.textId ||= useId(undefined, 'reka-tags-input-item-text')\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"props\"\n    :id=\"itemContext.textId\"\n  >\n    <slot>{{ itemContext.displayValue.value }}</slot>\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { DateValue } from '@internationalized/date'\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { Formatter } from '@/shared'\nimport type { DateStep, HourCycle, SegmentPart, SegmentValueObj, TimeValue } from '@/shared/date'\nimport type { Direction, FormFieldProps } from '@/shared/types'\nimport { getLocalTimeZone, isEqualDay, Time, toCalendarDateTime, today } from '@internationalized/date'\nimport { isBefore } from '@/date'\nimport { createContext, isNullish, useDateFormatter, useDirection, useKbd, useLocale } from '@/shared'\nimport {\n  createContent,\n  getDefaultTime,\n  getTimeFieldSegmentElements,\n\n  initializeTimeSegmentValues,\n  isSegmentNavigationKey,\n  normalizeDateStep,\n  normalizeHourCycle,\n\n  syncTimeSegmentValues,\n\n} from '@/shared/date'\n\ntype TimeFieldRootContext = {\n  locale: Ref<string>\n  modelValue: Ref<DateValue | undefined>\n  placeholder: Ref<DateValue>\n  isInvalid: Ref<boolean>\n  disabled: Ref<boolean>\n  readonly: Ref<boolean>\n  formatter: Formatter\n  hourCycle: HourCycle\n  step: Ref<DateStep>\n  segmentValues: Ref<SegmentValueObj>\n  segmentContents: Ref<{ part: SegmentPart, value: string }[]>\n  elements: Ref<Set<HTMLElement>>\n  focusNext: () => void\n  setFocusedElement: (el: HTMLElement) => void\n}\n\nexport interface TimeFieldRootProps extends PrimitiveProps, FormFieldProps {\n  /** The default value for the calendar */\n  defaultValue?: TimeValue\n  /** The default placeholder date */\n  defaultPlaceholder?: TimeValue\n  /** The placeholder date, which is used to determine what time to display when no time is selected. This updates as the user navigates the field */\n  placeholder?: TimeValue\n  /** The controlled checked state of the field. Can be bound as `v-model`. */\n  modelValue?: TimeValue | null\n  /** The hour cycle used for formatting times. Defaults to the local preference */\n  hourCycle?: HourCycle\n  /** The stepping interval for the time fields. Defaults to `1`. */\n  step?: DateStep\n  /** The granularity to use for formatting times. Defaults to minute if a Time is provided, otherwise defaults to minute. The field will render segments for each part of the date up to and including the specified granularity */\n  granularity?: 'hour' | 'minute' | 'second'\n  /** Whether or not to hide the time zone segment of the field */\n  hideTimeZone?: boolean\n  /** The maximum date that can be selected */\n  maxValue?: TimeValue\n  /** The minimum date that can be selected */\n  minValue?: TimeValue\n  /** The locale to use for formatting dates */\n  locale?: string\n  /** Whether or not the time field is disabled */\n  disabled?: boolean\n  /** Whether or not the time field is readonly */\n  readonly?: boolean\n  /** Id of the element */\n  id?: string\n  /** The reading direction of the time field when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n}\n\nexport type TimeFieldRootEmits = {\n  /** Event handler called whenever the model value changes */\n  'update:modelValue': [date: TimeValue | undefined]\n  /** Event handler called whenever the placeholder value changes */\n  'update:placeholder': [date: TimeValue]\n}\n\nexport const [injectTimeFieldRootContext, provideTimeFieldRootContext]\n  = createContext<TimeFieldRootContext>('TimeFieldRoot')\n\nfunction convertValue(value: TimeValue, date: DateValue = today(getLocalTimeZone())) {\n  if (value && 'day' in value) {\n    return value\n  }\n\n  return toCalendarDateTime(date, value)\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { computed, nextTick, onMounted, ref, toRefs, watch } from 'vue'\nimport { Primitive, usePrimitiveElement } from '@/Primitive'\nimport { VisuallyHidden } from '@/VisuallyHidden'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<TimeFieldRootProps>(), {\n  defaultValue: undefined,\n  disabled: false,\n  readonly: false,\n  placeholder: undefined,\n  isDateUnavailable: undefined,\n})\nconst emits = defineEmits<TimeFieldRootEmits>()\ndefineSlots<{\n  default?: (props: {\n    /** The current time of the field */\n    modelValue: TimeValue | undefined\n    /** The time field segment contents */\n    segments: { part: SegmentPart, value: string }[]\n    /** Value if the input is invalid */\n    isInvalid: boolean\n  }) => any\n}>()\n\nconst { disabled, readonly, granularity, defaultValue, minValue, maxValue, dir: propDir, locale: propLocale } = toRefs(props)\nconst locale = useLocale(propLocale)\nconst dir = useDirection(propDir)\n\nconst formatter = useDateFormatter(locale.value, {\n  hourCycle: normalizeHourCycle(props.hourCycle),\n})\nconst { primitiveElement, currentElement: parentElement }\n  = usePrimitiveElement()\nconst segmentElements = ref<Set<HTMLElement>>(new Set())\n\nconst step = computed(() => normalizeDateStep(props))\n\nconst convertedMinValue = computed(() => minValue.value ? convertValue(minValue.value) : undefined)\nconst convertedMaxValue = computed(() => maxValue.value ? convertValue(maxValue.value) : undefined)\n\nonMounted(() => {\n  getTimeFieldSegmentElements(parentElement.value).forEach(item => segmentElements.value.add(item as HTMLElement))\n})\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: defaultValue.value,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<TimeValue>\n\nconst convertedModelValue = computed({\n  get() {\n    if (isNullish(modelValue.value))\n      return modelValue.value\n    return convertValue(modelValue.value)\n  },\n  set(newValue) {\n    if (newValue) {\n      modelValue.value = modelValue.value && 'day' in modelValue.value ? newValue : new Time(newValue.hour, newValue.minute, newValue.second, modelValue.value?.millisecond)\n    }\n    else {\n      modelValue.value = newValue\n    }\n    return newValue\n  },\n})\n\nconst defaultDate = getDefaultTime({\n  defaultPlaceholder: props.placeholder,\n  defaultValue: modelValue.value,\n})\n\nconst placeholder = useVModel(props, 'placeholder', emits, {\n  defaultValue: props.defaultPlaceholder ?? defaultDate.copy(),\n  passive: (props.placeholder === undefined) as false,\n}) as Ref<TimeValue>\n\nconst convertedPlaceholder = computed({\n  get() {\n    return convertValue(placeholder.value)\n  },\n  set(newValue) {\n    if (newValue)\n      placeholder.value = 'day' in placeholder.value ? newValue.copy() : new Time(newValue.hour, newValue.minute, newValue.second, placeholder.value?.millisecond)\n    return newValue\n  },\n})\n\nconst inferredGranularity = computed(() => {\n  if (granularity.value)\n    return granularity.value\n\n  return 'minute'\n})\n\nconst isInvalid = computed(() => {\n  if (!modelValue.value)\n    return false\n\n  if (convertedMinValue.value && isBefore(convertedModelValue.value, convertedMinValue.value))\n    return true\n\n  if (convertedMaxValue.value && isBefore(convertedMaxValue.value, convertedModelValue.value))\n    return true\n\n  return false\n})\n\nconst initialSegments = initializeTimeSegmentValues(inferredGranularity.value)\n\nconst segmentValues = ref<SegmentValueObj>(modelValue.value ? { ...syncTimeSegmentValues({ value: convertedModelValue.value, formatter }) } : { ...initialSegments })\n\nconst allSegmentContent = computed(() => createContent({\n  granularity: inferredGranularity.value,\n  dateRef: convertedPlaceholder.value,\n  formatter,\n  hideTimeZone: props.hideTimeZone,\n  hourCycle: props.hourCycle,\n  segmentValues: segmentValues.value,\n  locale,\n  isTimeValue: true,\n}))\n\nconst segmentContents = computed(() => allSegmentContent.value.arr)\n\nconst editableSegmentContents = computed(() => segmentContents.value.filter(({ part }) => part !== 'literal'))\n\nwatch(locale, (value) => {\n  if (formatter.getLocale() !== value) {\n    formatter.setLocale(value)\n    // Locale changed, so we need to clear the segment elements and re-get them (different order)\n    // Get the focusable elements again on the next tick\n    nextTick(() => {\n      segmentElements.value.clear()\n      getTimeFieldSegmentElements(parentElement.value).forEach(item => segmentElements.value.add(item as HTMLElement))\n    })\n  }\n})\n\nwatch(convertedModelValue, (_modelValue) => {\n  if (!isNullish(_modelValue) && (!isEqualDay(convertedPlaceholder.value, _modelValue) || convertedPlaceholder.value.compare(_modelValue) !== 0))\n    placeholder.value = _modelValue.copy()\n})\n\nwatch([convertedModelValue, locale], ([_modelValue]) => {\n  if (!isNullish(_modelValue)) {\n    segmentValues.value = { ...syncTimeSegmentValues({ value: _modelValue, formatter }) }\n  }\n  // If segment has null value, means that user modified it, thus do not reset the segmentValues\n  else if (Object.values(segmentValues.value).every(value => value !== null) && isNullish(_modelValue)) {\n    segmentValues.value = { ...initialSegments }\n  }\n})\n\nconst currentFocusedElement = ref<HTMLElement | null>(null)\n\nconst currentSegmentIndex = computed(() =>\n  Array.from(segmentElements.value).findIndex(el =>\n    el.getAttribute('data-reka-time-field-segment')\n    === currentFocusedElement.value?.getAttribute('data-reka-time-field-segment')))\n\nconst nextFocusableSegment = computed(() => {\n  const sign = dir.value === 'rtl' ? -1 : 1\n  const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1\n  if (nextCondition)\n    return null\n  const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign]\n  return segmentToFocus\n})\n\nconst prevFocusableSegment = computed(() => {\n  const sign = dir.value === 'rtl' ? -1 : 1\n  const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1\n  if (prevCondition)\n    return null\n\n  const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign]\n  return segmentToFocus\n})\n\nconst kbd = useKbd()\n\nfunction handleKeydown(e: KeyboardEvent) {\n  if (!isSegmentNavigationKey(e.key))\n    return\n  if (e.key === kbd.ARROW_LEFT)\n    prevFocusableSegment.value?.focus()\n  if (e.key === kbd.ARROW_RIGHT)\n    nextFocusableSegment.value?.focus()\n}\n\nfunction setFocusedElement(el: HTMLElement) {\n  currentFocusedElement.value = el\n}\n\nprovideTimeFieldRootContext({\n  locale,\n  modelValue: convertedModelValue,\n  placeholder: convertedPlaceholder,\n  disabled,\n  formatter,\n  hourCycle: props.hourCycle,\n  step,\n  readonly,\n  segmentValues,\n  isInvalid,\n  segmentContents: editableSegmentContents,\n  elements: segmentElements,\n  setFocusedElement,\n  focusNext() {\n    nextFocusableSegment.value?.focus()\n  },\n})\n\ndefineExpose({\n  /** Helper to set the focused element inside the DateField */\n  setFocusedElement,\n})\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"$attrs\"\n    ref=\"primitiveElement\"\n    role=\"group\"\n    :aria-disabled=\"disabled ? true : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-readonly=\"readonly ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :dir=\"dir\"\n    @keydown.left.right=\"handleKeydown\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :segments=\"segmentContents\"\n      :is-invalid=\"isInvalid\"\n    />\n\n    <VisuallyHidden\n      :id=\"id\"\n      as=\"input\"\n      feature=\"focusable\"\n      tabindex=\"-1\"\n      :value=\"modelValue ? modelValue.toString() : ''\"\n      :name=\"name\"\n      :disabled=\"disabled\"\n      :required=\"required\"\n      @focus=\"Array.from(segmentElements)?.[0]?.focus()\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { SegmentPart } from '@/shared/date'\nimport { computed, ref } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { useDateField } from '@/shared/date/useDateField'\nimport { injectTimeFieldRootContext } from './TimeFieldRoot.vue'\n\nexport interface TimeFieldInputProps extends PrimitiveProps {\n  /** The part of the date to render */\n  part: SegmentPart\n}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<TimeFieldInputProps>()\n\nconst rootContext = injectTimeFieldRootContext()\n\nconst hasLeftFocus = ref(true)\nconst lastKeyZero = ref(false)\n\nconst {\n  handleSegmentClick,\n  handleSegmentKeydown,\n  attributes,\n} = useDateField({\n  hasLeftFocus,\n  lastKeyZero,\n  placeholder: rootContext.placeholder,\n  hourCycle: rootContext.hourCycle,\n  step: rootContext.step,\n  segmentValues: rootContext.segmentValues,\n  formatter: rootContext.formatter,\n  part: props.part,\n  disabled: rootContext.disabled,\n  readonly: rootContext.readonly,\n  focusNext: rootContext.focusNext,\n  modelValue: rootContext.modelValue,\n})\n\nconst disabled = computed(() => rootContext.disabled.value)\nconst readonly = computed(() => rootContext.readonly.value)\nconst isInvalid = computed(() => rootContext.isInvalid.value)\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    v-bind=\"attributes\"\n    :contenteditable=\"disabled || readonly ? false : part !== 'literal'\"\n    :data-reka-time-field-segment=\"part\"\n    :aria-disabled=\"disabled ? true : undefined\"\n    :aria-readonly=\"readonly ? true : undefined\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :data-invalid=\"isInvalid ? '' : undefined\"\n    :aria-invalid=\"isInvalid ? true : undefined\"\n    v-on=\"part !== 'literal' ? {\n      mousedown: handleSegmentClick,\n      keydown: handleSegmentKeydown,\n      focusout: () => { hasLeftFocus = true },\n      focusin: (e: FocusEvent) => {\n        rootContext.setFocusedElement(e.target as HTMLElement)\n      },\n    } : {}\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "import { defineComponent, createBlock, openBlock, unref, withCtx, renderSlot } from 'vue';\nimport { P as Primitive } from '../Primitive/Primitive.js';\n\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(__props) {\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(unref(Primitive), {\n        as: _ctx.as,\n        \"as-child\": _ctx.asChild,\n        \"data-reka-toast-announce-exclude\": \"\",\n        \"data-reka-toast-announce-alt\": _ctx.altText || void 0\n      }, {\n        default: withCtx(() => [\n          renderSlot(_ctx.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"data-reka-toast-announce-alt\"]);\n    };\n  }\n});\n\nexport { _sfc_main as _ };\n//# sourceMappingURL=ToastAnnounceExclude.js.map\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { SwipeDirection } from './utils'\nimport { useCollection } from '@/Collection'\nimport { createContext } from '@/shared'\n\ntype ToastProviderContext = {\n  label: Ref<string>\n  duration: Ref<number>\n  swipeDirection: Ref<SwipeDirection>\n  swipeThreshold: Ref<number>\n  toastCount: Ref<number>\n  viewport: Ref<HTMLElement | undefined>\n  onViewportChange: (viewport: HTMLElement) => void\n  onToastAdd: () => void\n  onToastRemove: () => void\n  isFocusedToastEscapeKeyDownRef: Ref<boolean>\n  isClosePausedRef: Ref<boolean>\n}\n\nexport interface ToastProviderProps {\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number\n}\n\nexport const [injectToastProviderContext, provideToastProviderContext]\n  = createContext<ToastProviderContext>('ToastProvider')\n</script>\n\n<script setup lang=\"ts\">\nimport { ref, toRefs } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ToastProviderProps>(), {\n  label: 'Notification',\n  duration: 5000,\n  swipeDirection: 'right',\n  swipeThreshold: 50,\n})\nconst { label, duration, swipeDirection, swipeThreshold } = toRefs(props)\nuseCollection({ isProvider: true })\n\nconst viewport = ref<HTMLElement>()\nconst toastCount = ref(0)\nconst isFocusedToastEscapeKeyDownRef = ref(false)\nconst isClosePausedRef = ref(false)\n\nif (props.label && typeof props.label === 'string' && !props.label.trim()) {\n  const error = 'Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.'\n  throw new Error(error)\n}\n\nprovideToastProviderContext({\n  label,\n  duration,\n  swipeDirection,\n  swipeThreshold,\n  toastCount,\n  viewport,\n  onViewportChange(el) {\n    viewport.value = el\n  },\n  onToastAdd() {\n    toastCount.value++\n  },\n  onToastRemove() {\n    toastCount.value--\n  },\n  isFocusedToastEscapeKeyDownRef,\n  isClosePausedRef,\n\n})\n</script>\n\n<template>\n  <slot />\n</template>\n", "<script setup lang=\"ts\">\nimport { useRafFn } from '@vueuse/core'\nimport { useTimeout } from '@vueuse/shared'\nimport { ref } from 'vue'\nimport { VisuallyHidden } from '@/VisuallyHidden'\nimport { injectToastProviderContext } from './ToastProvider.vue'\n\nconst providerContext = injectToastProviderContext()\n\nconst isAnnounced = useTimeout(1000)\nconst renderAnnounceText = ref(false)\n\nuseRafFn(() => {\n  renderAnnounceText.value = true\n})\n</script>\n\n<template>\n  <VisuallyHidden v-if=\"isAnnounced || renderAnnounceText\">\n    {{ providerContext.label.value }}\n    <slot />\n  </VisuallyHidden>\n</template>\n", "export const TOAST_SWIPE_START = 'toast.swipeStart'\nexport const TOAST_SWIPE_MOVE = 'toast.swipeMove'\nexport const TOAST_SWIPE_CANCEL = 'toast.swipeCancel'\nexport const TOAST_SWIPE_END = 'toast.swipeEnd'\n\nexport const VIEWPORT_NAME = 'ToastViewport'\nexport const VIEWPORT_DEFAULT_HOTKEY = ['F8']\nexport const VIEWPORT_PAUSE = 'toast.viewportPause'\nexport const VIEWPORT_RESUME = 'toast.viewportResume'\n\nexport type SwipeDirection = 'up' | 'down' | 'left' | 'right'\n\nexport type SwipeEvent = { currentTarget: EventTarget & HTMLElement } & Omit<\n  CustomEvent<{ originalEvent: PointerEvent, delta: { x: number, y: number } }>,\n  'currentTarget'\n>\n\nexport function handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  OriginalEvent extends Event,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D>\n    ? D\n    : never),\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail,\n  })\n  if (handler)\n    currentTarget.addEventListener(name, handler as EventListener, { once: true })\n\n  currentTarget.dispatchEvent(event)\n}\n\nexport function isDeltaInDirection(delta: { x: number, y: number }, direction: SwipeDirection, threshold = 0) {\n  const deltaX = Math.abs(delta.x)\n  const deltaY = Math.abs(delta.y)\n  const isDeltaX = deltaX > deltaY\n  if (direction === 'left' || direction === 'right')\n    return isDeltaX && deltaX > threshold\n  else\n    return !isDeltaX && deltaY > threshold\n}\n\nexport function isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE\n}\n\nexport function getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = []\n  const childNodes = Array.from(container.childNodes)\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent)\n      textContent.push(node.textContent)\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none'\n      const isExcluded = node.dataset.rekaToastAnnounceExclude === ''\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.rekaToastAnnounceAlt\n          if (altText)\n            textContent.push(altText)\n        }\n        else {\n          textContent.push(...getAnnounceTextContent(node))\n        }\n      }\n    }\n  })\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent\n}\n", "<script lang=\"ts\">\nimport type { SwipeEvent } from './utils'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { isClient } from '@vueuse/shared'\nimport { useCollection } from '@/Collection'\nimport { createContext, getActiveElement, useForwardExpose } from '@/shared'\n\nexport type ToastRootImplEmits = {\n  close: []\n  /** Event handler called when the escape key is down. It can be prevented by calling `event.preventDefault`. */\n  escapeKeyDown: [event: KeyboardEvent]\n  /** Event handler called when the dismiss timer is paused. This occurs when the pointer is moved over the viewport, the viewport is focused or when the window is blurred. */\n  pause: []\n  /** Event handler called when the dismiss timer is resumed. This occurs when the pointer is moved away from the viewport, the viewport is blurred or when the window is focused. */\n  resume: []\n  /** Event handler called when starting a swipe interaction. It can be prevented by calling `event.preventDefault`. */\n  swipeStart: [event: SwipeEvent]\n  /** Event handler called during a swipe interaction. It can be prevented by calling `event.preventDefault`. */\n  swipeMove: [event: SwipeEvent]\n  /** Event handler called when swipe interaction is cancelled. It can be prevented by calling `event.preventDefault`. */\n  swipeCancel: [event: SwipeEvent]\n  /** Event handler called at the end of a swipe interaction. It can be prevented by calling `event.preventDefault`. */\n  swipeEnd: [event: SwipeEvent]\n}\n\nexport interface ToastRootImplProps extends PrimitiveProps {\n  /**\n   * Control the sensitivity of the toast for accessibility purposes.\n   *\n   * For toasts that are the result of a user action, choose `foreground`. Toasts generated from background tasks should use `background`.\n   */\n  type?: 'foreground' | 'background'\n  /**\n   * The controlled open state of the dialog. Can be bind as `v-model:open`.\n   */\n  open?: boolean\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number\n}\n\nexport const [injectToastRootContext, provideToastRootContext]\n  = createContext<{ onClose: () => void }>('ToastRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { onKeyStroke, useRafFn } from '@vueuse/core'\nimport { computed, onMounted, onUnmounted, ref, watch, watchEffect } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport ToastAnnounce from './ToastAnnounce.vue'\nimport { injectToastProviderContext } from './ToastProvider.vue'\nimport { getAnnounceTextContent, handleAndDispatchCustomEvent, isDeltaInDirection, TOAST_SWIPE_CANCEL, TOAST_SWIPE_END, TOAST_SWIPE_MOVE, TOAST_SWIPE_START, VIEWPORT_PAUSE, VIEWPORT_RESUME } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ToastRootImplProps>(), {\n  open: false,\n  as: 'li',\n})\n\nconst emits = defineEmits<ToastRootImplEmits>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst { CollectionItem } = useCollection()\n\nconst providerContext = injectToastProviderContext()\nconst pointerStartRef = ref<{ x: number, y: number } | null>(null)\nconst swipeDeltaRef = ref<{ x: number, y: number } | null>(null)\nconst duration = computed(\n  () => typeof props.duration === 'number'\n    ? props.duration\n    : providerContext.duration.value,\n)\n\nconst closeTimerStartTimeRef = ref(0)\nconst closeTimerRemainingTimeRef = ref(duration.value)\nconst closeTimerRef = ref(0)\nconst remainingTime = ref(duration.value)\n\nconst remainingRaf = useRafFn(() => {\n  const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.value\n  remainingTime.value = Math.max(closeTimerRemainingTimeRef.value - elapsedTime, 0)\n}, { fpsLimit: 60 })\n\nfunction startTimer(duration: number) {\n  if (duration <= 0 || duration === Number.POSITIVE_INFINITY)\n    return\n  // startTimer is used inside a watch with immediate set to true.\n  // This results in code execution during SSR.\n  // Ensure this code only runs in a browser environment\n  if (!isClient)\n    return\n  window.clearTimeout(closeTimerRef.value)\n  closeTimerStartTimeRef.value = new Date().getTime()\n  closeTimerRef.value = window.setTimeout(handleClose, duration)\n}\n\nfunction handleClose(event?: PointerEvent) {\n  const isNonPointerEvent = event?.pointerType === ''\n\n  // reka: update to only perform focus when user focus via keyboard\n  // focus viewport if focus is within toast to read the remaining toast\n  // count to SR users and ensure focus isn't lost\n  const isFocusInToast = currentElement.value?.contains(getActiveElement())\n  if (isFocusInToast && isNonPointerEvent)\n    providerContext.viewport.value?.focus()\n\n  if (isNonPointerEvent) {\n    // when manually close the toast, we reset isClosePausedRef\n    providerContext.isClosePausedRef.value = false\n  }\n\n  emits('close')\n}\n\nconst announceTextContent = computed(() => currentElement.value ? getAnnounceTextContent(currentElement.value) : null)\n\nif (props.type && !['foreground', 'background'].includes(props.type)) {\n  const error = 'Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.'\n  throw new Error(error)\n}\n\nwatchEffect((cleanupFn) => {\n  const viewport = providerContext.viewport.value\n  if (viewport) {\n    const handleResume = () => {\n      startTimer(closeTimerRemainingTimeRef.value)\n      remainingRaf.resume()\n      emits('resume')\n    }\n    const handlePause = () => {\n      const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.value\n      closeTimerRemainingTimeRef.value = closeTimerRemainingTimeRef.value - elapsedTime\n      window.clearTimeout(closeTimerRef.value)\n      remainingRaf.pause()\n      emits('pause')\n    }\n    viewport.addEventListener(VIEWPORT_PAUSE, handlePause)\n    viewport.addEventListener(VIEWPORT_RESUME, handleResume)\n    return () => {\n      viewport.removeEventListener(VIEWPORT_PAUSE, handlePause)\n      viewport.removeEventListener(VIEWPORT_RESUME, handleResume)\n    }\n  }\n})\n\n// start timer when toast opens or duration changes.\n// we include `open` in deps because closed !== unmounted when animating\n// so it could reopen before being completely unmounted\nwatch(() => [props.open, duration.value], () => {\n  // Reset the timer when the toast is rerendered with the new duration\n  closeTimerRemainingTimeRef.value = duration.value\n\n  if (props.open && !providerContext.isClosePausedRef.value)\n    startTimer(duration.value)\n}, { immediate: true })\n\nonKeyStroke('Escape', (event) => {\n  emits('escapeKeyDown', event)\n  if (!event.defaultPrevented) {\n    providerContext.isFocusedToastEscapeKeyDownRef.value = true\n    handleClose()\n  }\n})\n\nonMounted(() => {\n  providerContext.onToastAdd()\n})\nonUnmounted(() => {\n  providerContext.onToastRemove()\n})\n\nprovideToastRootContext({ onClose: handleClose })\n</script>\n\n<template>\n  <ToastAnnounce\n    v-if=\"announceTextContent\"\n    role=\"alert\"\n    :aria-live=\"type === 'foreground' ? 'assertive' : 'polite'\"\n    aria-atomic=\"true\"\n  >\n    {{ announceTextContent }}\n  </ToastAnnounce>\n\n  <Teleport\n    v-if=\"providerContext.viewport.value\"\n    :to=\"providerContext.viewport.value\"\n  >\n    <CollectionItem>\n      <Primitive\n        :ref=\"forwardRef\"\n        role=\"alert\"\n        aria-live=\"off\"\n        aria-atomic=\"true\"\n        tabindex=\"0\"\n        v-bind=\"$attrs\"\n        :as=\"as\"\n        :as-child=\"asChild\"\n        :data-state=\"open ? 'open' : 'closed'\"\n        :data-swipe-direction=\"providerContext.swipeDirection.value\"\n        :style=\"{ userSelect: 'none', touchAction: 'none' }\"\n        @pointerdown.left=\"(event: PointerEvent) => {\n          pointerStartRef = { x: event.clientX, y: event.clientY };\n        }\"\n        @pointermove=\"(event: PointerEvent) => {\n          if (!pointerStartRef) return;\n          const x = event.clientX - pointerStartRef.x;\n          const y = event.clientY - pointerStartRef.y;\n          const hasSwipeMoveStarted = Boolean(swipeDeltaRef);\n          const isHorizontalSwipe = ['left', 'right'].includes(providerContext.swipeDirection.value);\n          const clamp = ['left', 'up'].includes(providerContext.swipeDirection.value)\n            ? Math.min\n            : Math.max;\n          const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n          const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n          const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n          const delta = { x: clampedX, y: clampedY };\n          const eventDetail = { originalEvent: event, delta };\n          if (hasSwipeMoveStarted) {\n            swipeDeltaRef = delta;\n            handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, (ev: SwipeEvent) => emits('swipeMove', ev), eventDetail);\n          }\n          else if (isDeltaInDirection(delta, providerContext.swipeDirection.value, moveStartBuffer)) {\n            swipeDeltaRef = delta;\n            handleAndDispatchCustomEvent(TOAST_SWIPE_START, (ev: SwipeEvent) => emits('swipeStart', ev), eventDetail);\n            (event.target as HTMLElement).setPointerCapture(event.pointerId);\n          }\n          else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n            // User is swiping in wrong direction so we disable swipe gesture\n            // for the current pointer down interaction\n            pointerStartRef = null;\n          }\n        }\"\n        @pointerup=\"(event: PointerEvent) => {\n          const delta = swipeDeltaRef;\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n          }\n          swipeDeltaRef = null;\n          pointerStartRef = null;\n          if (delta) {\n            const toast = event.currentTarget;\n            const eventDetail = { originalEvent: event, delta };\n            if (\n              isDeltaInDirection(delta, providerContext.swipeDirection.value, providerContext.swipeThreshold.value)\n            ) {\n              handleAndDispatchCustomEvent(TOAST_SWIPE_END, (ev: SwipeEvent) => emits('swipeEnd', ev), eventDetail);\n            }\n            else {\n              handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, (ev: SwipeEvent) => emits('swipeCancel', ev), eventDetail);\n            }\n            // Prevent click event from triggering on items within the toast when\n            // pointer up is part of a swipe gesture\n            toast?.addEventListener('click', (event) => event.preventDefault(), {\n              once: true,\n            });\n          }\n        }\"\n      >\n        <slot\n          :remaining=\"remainingTime\"\n          :duration=\"duration\"\n        />\n      </Primitive>\n    </CollectionItem>\n  </Teleport>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ToastCloseProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport ToastAnnounceExclude from './ToastAnnounceExclude.vue'\nimport { injectToastRootContext } from './ToastRootImpl.vue'\n\nconst props = withDefaults(defineProps<ToastCloseProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectToastRootContext()\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <ToastAnnounceExclude as-child>\n    <Primitive\n      v-bind=\"props\"\n      :ref=\"forwardRef\"\n      :type=\"as === 'button' ? 'button' : undefined \"\n      @click=\"rootContext.onClose\"\n    >\n      <slot />\n    </Primitive>\n  </ToastAnnounceExclude>\n</template>\n", "<script lang=\"ts\">\nimport type { ToastCloseProps } from './ToastClose.vue'\n\nexport interface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useForwardExpose } from '@/shared'\nimport ToastAnnounceExclude from './ToastAnnounceExclude.vue'\nimport ToastClose from './ToastClose.vue'\n\nconst props = defineProps<ToastActionProps>()\n\nif (!props.altText)\n  throw new Error('Missing prop `altText` expected on `ToastAction`')\n\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <ToastAnnounceExclude\n    v-if=\"altText\"\n    :alt-text=\"altText\"\n    as-child\n  >\n    <ToastClose\n      :ref=\"forwardRef\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n    >\n      <slot />\n    </ToastClose>\n  </ToastAnnounceExclude>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ToastDescriptionProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<ToastDescriptionProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface ToastPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<ToastPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { ToastRootImplEmits, ToastRootImplProps } from './ToastRootImpl.vue'\nimport { useForwardExpose } from '@/shared'\n\nexport type ToastRootEmits = Omit<ToastRootImplEmits, 'close'> & {\n  /** Event handler called when the open state changes */\n  'update:open': [value: boolean]\n}\n\nexport interface ToastRootProps extends ToastRootImplProps {\n  /** The open state of the dialog when it is initially rendered. Use when you do not need to control its open state. */\n  defaultOpen?: boolean\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useVModel } from '@vueuse/core'\nimport { Presence } from '@/Presence'\nimport ToastRootImpl from './ToastRootImpl.vue'\n\nconst props = withDefaults(defineProps<ToastRootProps>(), {\n  type: 'foreground',\n  open: undefined,\n  defaultOpen: true,\n  as: 'li',\n})\n\nconst emits = defineEmits<ToastRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n    /** Remaining time (in ms) */\n    remaining: number\n    /** Total time the toast will remain visible for (in ms) */\n    duration: number\n  }) => any\n}>()\n\nconst { forwardRef } = useForwardExpose()\nconst open = useVModel(props, 'open', emits, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n</script>\n\n<template>\n  <Presence :present=\"forceMount || open\">\n    <ToastRootImpl\n      :ref=\"forwardRef\"\n      v-slot=\"{ remaining, duration: _duration }\"\n      :open=\"open\"\n      :type=\"type\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :duration=\"duration\"\n      v-bind=\"$attrs\"\n      @close=\"open = false\"\n      @pause=\"emits('pause')\"\n      @resume=\"emits('resume')\"\n      @escape-key-down=\"emits('escapeKeyDown', $event)\"\n      @swipe-start=\"(event) => {\n        emits('swipeStart', event);\n        if (!event.defaultPrevented) {\n          (event.currentTarget as HTMLElement).setAttribute('data-swipe', 'start');\n        }\n      }\"\n      @swipe-move=\"(event) => {\n        emits('swipeMove', event);\n        if (!event.defaultPrevented) {\n          const { x, y } = event.detail.delta;\n          const target = event.currentTarget as HTMLElement\n          target.setAttribute('data-swipe', 'move');\n          target.style.setProperty('--reka-toast-swipe-move-x', `${x}px`);\n          target.style.setProperty('--reka-toast-swipe-move-y', `${y}px`);\n        }\n      }\"\n      @swipe-cancel=\"(event) => {\n        emits('swipeCancel', event);\n        if (!event.defaultPrevented) {\n          const target = event.currentTarget as HTMLElement\n          target.setAttribute('data-swipe', 'cancel');\n          target.style.removeProperty('--reka-toast-swipe-move-x');\n          target.style.removeProperty('--reka-toast-swipe-move-y');\n          target.style.removeProperty('--reka-toast-swipe-end-x');\n          target.style.removeProperty('--reka-toast-swipe-end-y');\n        }\n      }\"\n      @swipe-end=\"(event) => {\n        emits('swipeEnd', event);\n        if (!event.defaultPrevented) {\n          const { x, y } = event.detail.delta;\n          const target = event.currentTarget as HTMLElement\n          target.setAttribute('data-swipe', 'end');\n          target.style.removeProperty('--reka-toast-swipe-move-x');\n          target.style.removeProperty('--reka-toast-swipe-move-y');\n          target.style.setProperty('--reka-toast-swipe-end-x', `${x}px`);\n          target.style.setProperty('--reka-toast-swipe-end-y', `${y}px`);\n          open = false;\n        }\n      }\"\n    >\n      <slot\n        :remaining=\"remaining\"\n        :duration=\"_duration\"\n        :open=\"open\"\n      />\n    </ToastRootImpl>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ToastTitleProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<ToastTitleProps>()\nuseForwardExpose()\n</script>\n\n<template>\n  <Primitive v-bind=\"props\">\n    <slot />\n  </Primitive>\n</template>\n", "<script setup lang=\"ts\">\nimport { VisuallyHidden } from '@/VisuallyHidden'\nimport { injectToastProviderContext } from './ToastProvider.vue'\n\nconst emits = defineEmits<{\n  focusFromOutsideViewport: [void]\n}>()\n\nconst providerContext = injectToastProviderContext()\n</script>\n\n<template>\n  <VisuallyHidden\n    aria-hidden=\"true\"\n    tabindex=\"0\"\n    style=\"position: fixed\"\n    @focus=\"(event: FocusEvent) => {\n      const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n      const isFocusFromOutsideViewport = !providerContext.viewport.value?.contains(prevFocusedElement);\n      if (isFocusFromOutsideViewport) emits('focusFromOutsideViewport');\n    }\"\n  >\n    <slot />\n  </VisuallyHidden>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface DismissableLayerBranchProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted, onUnmounted } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { context } from './DismissableLayer.vue'\n\nconst props = defineProps<DismissableLayerBranchProps>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nonMounted(() => {\n  context.branches.add(currentElement.value)\n})\nonUnmounted(() => {\n  context.branches.delete(currentElement.value)\n})\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    v-bind=\"props\"\n  >\n    <slot />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { ComponentPublicInstance } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useCollection } from '@/Collection'\nimport { getActiveElement, useForwardExpose } from '@/shared'\n\nexport interface ToastViewportProps extends PrimitiveProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[]\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * Alternatively, you can pass in a custom function to generate the label.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string | ((hotkey: string) => string)\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { onKeyStroke, unrefElement } from '@vueuse/core'\nimport { computed, onMounted, ref, toRefs, watchEffect } from 'vue'\nimport { DismissableLayerBranch } from '@/DismissableLayer'\nimport { focusFirst, getTabbableCandidates } from '@/FocusScope/utils'\nimport { Primitive } from '@/Primitive'\nimport FocusProxy from './FocusProxy.vue'\nimport { injectToastProviderContext } from './ToastProvider.vue'\nimport { VIEWPORT_PAUSE, VIEWPORT_RESUME } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<ToastViewportProps>(), {\n  hotkey: () => ['F8'], // from VIEWPORT_DEFAULT_HOTKEY\n  label: 'Notifications ({hotkey})',\n  as: 'ol',\n})\nconst { hotkey, label } = toRefs(props)\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst { CollectionSlot, getItems } = useCollection()\nconst providerContext = injectToastProviderContext()\nconst hasToasts = computed(() => providerContext.toastCount.value > 0)\nconst headFocusProxyRef = ref<HTMLElement>()\nconst tailFocusProxyRef = ref<HTMLElement>()\n\nconst hotkeyMessage = computed(() => hotkey.value.join('+').replace(/Key/g, '').replace(/Digit/g, ''))\n\nonKeyStroke(hotkey.value, () => {\n  currentElement.value.focus()\n})\n\nonMounted(() => {\n  providerContext.onViewportChange(currentElement.value)\n})\n\nwatchEffect((cleanupFn) => {\n  const viewport = currentElement.value\n  if (hasToasts.value && viewport) {\n    const handlePause = () => {\n      if (!providerContext.isClosePausedRef.value) {\n        const pauseEvent = new CustomEvent(VIEWPORT_PAUSE)\n        viewport.dispatchEvent(pauseEvent)\n        providerContext.isClosePausedRef.value = true\n      }\n    }\n\n    const handleResume = () => {\n      if (providerContext.isClosePausedRef.value) {\n        const resumeEvent = new CustomEvent(VIEWPORT_RESUME)\n        viewport.dispatchEvent(resumeEvent)\n        providerContext.isClosePausedRef.value = false\n      }\n    }\n\n    const handleFocusOutResume = (event: FocusEvent) => {\n      const isFocusMovingOutside = !viewport.contains(event.relatedTarget as HTMLElement)\n      if (isFocusMovingOutside)\n        handleResume()\n    }\n\n    const handlePointerLeaveResume = () => {\n      const isFocusInside = viewport.contains(getActiveElement())\n      if (!isFocusInside)\n        handleResume()\n    }\n\n    // We programmatically manage tabbing as we are unable to influence\n    // the source order with portals, this allows us to reverse the\n    // tab order so that it runs from most recent toast to least\n    const handleKeyDown = (event: KeyboardEvent) => {\n      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey\n      const isTabKey = event.key === 'Tab' && !isMetaKey\n\n      if (isTabKey) {\n        const focusedElement = getActiveElement()\n        const isTabbingBackwards = event.shiftKey\n        const targetIsViewport = event.target === viewport\n\n        // If we're back tabbing after jumping to the viewport then we simply\n        // proxy focus out to the preceding document\n        if (targetIsViewport && isTabbingBackwards) {\n          headFocusProxyRef.value?.focus()\n          return\n        }\n\n        const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards'\n        const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection })\n        const index = sortedCandidates.findIndex(candidate => candidate === focusedElement)\n        if (focusFirst(sortedCandidates.slice(index + 1))) {\n          event.preventDefault()\n        }\n        else {\n          // If we can't focus that means we're at the edges so we\n          // proxy to the corresponding exit point and let the browser handle\n          // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n          isTabbingBackwards\n            ? headFocusProxyRef.value?.focus()\n            : tailFocusProxyRef.value?.focus()\n        }\n      }\n    }\n\n    viewport.addEventListener('focusin', handlePause)\n    viewport.addEventListener('focusout', handleFocusOutResume)\n    viewport.addEventListener('pointermove', handlePause)\n    viewport.addEventListener('pointerleave', handlePointerLeaveResume)\n    viewport.addEventListener('keydown', handleKeyDown)\n    window.addEventListener('blur', handlePause)\n    window.addEventListener('focus', handleResume)\n\n    cleanupFn(() => {\n      viewport.removeEventListener('focusin', handlePause)\n      viewport.removeEventListener('focusout', handleFocusOutResume)\n      viewport.removeEventListener('pointermove', handlePause)\n      viewport.removeEventListener('pointerleave', handlePointerLeaveResume)\n      viewport.removeEventListener('keydown', handleKeyDown)\n      window.removeEventListener('blur', handlePause)\n      window.removeEventListener('focus', handleResume)\n    })\n  }\n})\n\nfunction getSortedTabbableCandidates({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) {\n  const toastItems = getItems().map(i => i.ref)\n  const tabbableCandidates = toastItems.map((toastNode) => {\n    const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)]\n    return tabbingDirection === 'forwards'\n      ? toastTabbableCandidates\n      : toastTabbableCandidates.reverse()\n  })\n  return (\n    tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n  ).flat()\n}\n</script>\n\n<template>\n  <DismissableLayerBranch\n    role=\"region\"\n    :aria-label=\"typeof label === 'string' ? label.replace('{hotkey}', hotkeyMessage) : label(hotkeyMessage)\"\n    tabindex=\"-1\"\n    :style=\"{\n      // incase list has size when empty (e.g. padding), we remove pointer events so\n      // it doesn't prevent interactions with page elements that it overlays\n      pointerEvents: hasToasts ? undefined : 'none',\n    }\"\n  >\n    <FocusProxy\n      v-if=\"hasToasts\"\n      :ref=\"(node: ComponentPublicInstance) => {\n        headFocusProxyRef = unrefElement(node) as HTMLElement\n        return undefined\n      }\"\n      @focus-from-outside-viewport=\"() => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: 'forwards',\n        })\n        focusFirst(tabbableCandidates)\n      }\"\n    />\n    <CollectionSlot>\n      <Primitive\n        :ref=\"forwardRef\"\n        tabindex=\"-1\"\n        :as=\"as\"\n        :as-child=\"asChild\"\n        v-bind=\"$attrs\"\n      >\n        <slot />\n      </Primitive>\n    </CollectionSlot>\n    <FocusProxy\n      v-if=\"hasToasts\"\n      :ref=\"(node: ComponentPublicInstance) => {\n        tailFocusProxyRef = unrefElement(node) as HTMLElement\n        return undefined\n      }\"\n      @focus-from-outside-viewport=\"() => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: 'backwards',\n        })\n        focusFirst(tabbableCandidates)\n      }\"\n    />\n  </DismissableLayerBranch>\n</template>\n", "<script lang=\"ts\">\nimport type { ComputedRef, Ref } from 'vue'\nimport type { AcceptableValue, DataOrientation, Direction, FormFieldProps, SingleOrMultipleProps } from '../shared/types'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createContext, useDirection, useFormControl, useForwardExpose } from '@/shared'\nimport VisuallyHiddenInput from '@/VisuallyHidden/VisuallyHiddenInput.vue'\n\nexport interface ToggleGroupRootProps<T = AcceptableValue | AcceptableValue[]>\n  extends PrimitiveProps, FormFieldProps, SingleOrMultipleProps<T> {\n  /** When `false`, navigating through the items using arrow keys will be disabled. */\n  rovingFocus?: boolean\n  /** When `true`, prevents the user from interacting with the toggle group and all its items. */\n  disabled?: boolean\n  /** The orientation of the component, which determines how focus moves: `horizontal` for left/right arrows and `vertical` for up/down arrows. */\n  orientation?: DataOrientation\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** When `loop` and `rovingFocus` is `true`, keyboard navigation will loop from last item to first, and vice versa. */\n  loop?: boolean\n}\nexport type ToggleGroupRootEmits = {\n  /** Event handler called when the value changes. */\n  'update:modelValue': [payload: AcceptableValue | AcceptableValue[]]\n}\n\ninterface ToggleGroupRootContext {\n  isSingle: ComputedRef<boolean>\n  modelValue: Ref<AcceptableValue | AcceptableValue[] | undefined>\n  changeModelValue: (value: AcceptableValue) => void\n  dir?: Ref<Direction>\n  orientation?: DataOrientation\n  loop: Ref<boolean>\n  rovingFocus: Ref<boolean>\n  disabled?: Ref<boolean>\n}\n\nexport const [injectToggleGroupRootContext, provideToggleGroupRootContext]\n  = createContext<ToggleGroupRootContext>('ToggleGroupRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusGroup } from '@/RovingFocus'\nimport { useSingleOrMultipleValue } from '@/shared/useSingleOrMultipleValue'\n\nconst props = withDefaults(defineProps<ToggleGroupRootProps>(), {\n  loop: true,\n  rovingFocus: true,\n  disabled: false,\n})\nconst emits = defineEmits<ToggleGroupRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current toggle values */\n    modelValue: typeof modelValue.value\n  }) => any\n}>()\n\nconst { loop, rovingFocus, disabled, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props, emits)\nconst isFormControl = useFormControl(currentElement)\n\nprovideToggleGroupRootContext({\n  isSingle,\n  modelValue,\n  changeModelValue,\n  dir,\n  orientation: props.orientation,\n  loop,\n  rovingFocus,\n  disabled,\n})\n</script>\n\n<template>\n  <component\n    :is=\"rovingFocus ? RovingFocusGroup : Primitive\"\n    as-child\n    :orientation=\"rovingFocus ? orientation : undefined\"\n    :dir=\"dir\"\n    :loop=\"rovingFocus ? loop : undefined\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"group\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n    >\n      <slot :model-value=\"modelValue\" />\n\n      <VisuallyHiddenInput\n        v-if=\"isFormControl && name\"\n        :name=\"name\"\n        :required=\"required\"\n        :value=\"modelValue\"\n      />\n    </Primitive>\n  </component>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { FormFieldProps } from '@/shared/types'\nimport { useFormControl, useForwardExpose } from '@/shared'\nimport { injectToggleGroupRootContext } from '@/ToggleGroup/ToggleGroupRoot.vue'\nimport VisuallyHiddenInput from '@/VisuallyHidden/VisuallyHiddenInput.vue'\n\nexport type ToggleEmits = {\n  /** Event handler called when the value of the toggle changes. */\n  'update:modelValue': [value: boolean]\n}\n\nexport type DataState = 'on' | 'off'\n\nexport interface ToggleProps extends PrimitiveProps, FormFieldProps {\n  /**\n   * The pressed state of the toggle when it is initially rendered. Use when you do not need to control its open state.\n   */\n  defaultValue?: boolean\n  /**\n   * The controlled pressed state of the toggle. Can be bind as `v-model`.\n   */\n  modelValue?: boolean | null\n  /**\n   * When `true`, prevents the user from interacting with the toggle.\n   */\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { useVModel } from '@vueuse/core'\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\n\nconst props = withDefaults(defineProps<ToggleProps>(), {\n  modelValue: undefined,\n  disabled: false,\n  as: 'button',\n})\n\nconst emits = defineEmits<ToggleEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current value */\n    modelValue: typeof modelValue.value\n    /** Current state */\n    state: typeof dataState.value\n    /** Current pressed state */\n    pressed: typeof modelValue.value\n    /** Current disabled state */\n    disabled: boolean\n  }) => any\n}>()\n\nconst { forwardRef, currentElement } = useForwardExpose()\nconst toggleGroupContext = injectToggleGroupRootContext(null)\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  defaultValue: props.defaultValue,\n  passive: (props.modelValue === undefined) as false,\n}) as Ref<boolean>\n\nfunction togglePressed() {\n  modelValue.value = !modelValue.value\n}\n\nconst dataState = computed<DataState>(() => {\n  return modelValue.value ? 'on' : 'off'\n})\n\nconst isFormControl = useFormControl(currentElement)\n</script>\n\n<template>\n  <Primitive\n    :ref=\"forwardRef\"\n    :type=\"as === 'button' ? 'button' : undefined\"\n    :as-child=\"props.asChild\"\n    :as=\"as\"\n    :aria-pressed=\"modelValue\"\n    :data-state=\"dataState\"\n    :data-disabled=\"disabled ? '' : undefined\"\n    :disabled=\"disabled\"\n    @click=\"togglePressed\"\n  >\n    <slot\n      :model-value=\"modelValue\"\n      :disabled=\"disabled\"\n      :pressed=\"modelValue\"\n      :state=\"dataState\"\n    />\n\n    <VisuallyHiddenInput\n      v-if=\"isFormControl && name && !toggleGroupContext\"\n      type=\"checkbox\"\n      :name=\"name\"\n      :value=\"modelValue\"\n      :required=\"required\"\n    />\n  </Primitive>\n</template>\n", "<script lang=\"ts\">\nimport type { AcceptableValue } from '@/shared/types'\nimport type { ToggleProps } from '@/Toggle'\nimport { isValueEqualOrExist, useForwardExpose } from '@/shared'\n\nexport interface ToggleGroupItemProps extends Omit<ToggleProps, 'name' | 'required' | 'modelValue' | 'defaultValue'> {\n  /**\n   * A string value for the toggle group item. All items within a toggle group should use a unique value.\n   */\n  value: AcceptableValue\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\nimport { Toggle } from '@/Toggle'\nimport { injectToggleGroupRootContext } from './ToggleGroupRoot.vue'\n\nconst props = withDefaults(defineProps<ToggleGroupItemProps>(), {\n  as: 'button',\n})\n\nconst rootContext = injectToggleGroupRootContext()\nconst disabled = computed(() => rootContext.disabled?.value || props.disabled)\nconst pressed = computed(() => isValueEqualOrExist(rootContext.modelValue.value, props.value))\n\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <component\n    :is=\"rootContext.rovingFocus.value ? RovingFocusItem : Primitive\"\n    as-child\n    :focusable=\"!disabled\"\n    :active=\"pressed\"\n  >\n    <Toggle\n      v-bind=\"props\"\n      :ref=\"forwardRef\"\n      v-slot=\"slotProps\"\n      :disabled=\"disabled\"\n      :model-value=\"pressed\"\n      @update:model-value=\"rootContext.changeModelValue(value)\"\n    >\n      <slot v-bind=\"slotProps\" />\n    </Toggle>\n  </component>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ToolbarButtonProps extends PrimitiveProps {\n  disabled?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\n\nconst props = withDefaults(defineProps<ToolbarButtonProps>(), { as: 'button' })\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <RovingFocusItem\n    as-child\n    :focusable=\"!disabled\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :type=\"as === 'button' ? 'button' : undefined\"\n      v-bind=\"props\"\n    >\n      <slot />\n    </Primitive>\n  </RovingFocusItem>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ToolbarLinkProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\n\nconst props = withDefaults(defineProps<ToolbarLinkProps>(), { as: 'a' })\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <RovingFocusItem\n    as-child\n    focusable\n  >\n    <Primitive\n      v-bind=\"props\"\n      :ref=\"forwardRef\"\n      @keydown=\"(event: KeyboardEvent) => {\n        if (event.key === ' ') (event.currentTarget as HTMLElement)?.click()\n      }\"\n    >\n      <slot />\n    </Primitive>\n  </RovingFocusItem>\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport type { DataOrientation, Direction } from '@/shared/types'\nimport { createContext, useDirection, useForwardExpose } from '@/shared'\n\nexport interface ToolbarRootProps extends PrimitiveProps {\n  /** The orientation of the toolbar */\n  orientation?: DataOrientation\n  /** The reading direction of the combobox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** When `true`, keyboard navigation will loop from last tab to first, and vice versa. */\n  loop?: boolean\n}\n\nexport interface ToolbarRootContext {\n  orientation: Ref<DataOrientation>\n  dir: Ref<Direction>\n}\n\nexport const [injectToolbarRootContext, provideToolbarRootContext]\n  = createContext<ToolbarRootContext>('ToolbarRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusGroup } from '@/RovingFocus'\n\nconst props = withDefaults(defineProps<ToolbarRootProps>(), {\n  orientation: 'horizontal',\n})\nconst { orientation, dir: propDir } = toRefs(props)\nconst dir = useDirection(propDir)\nconst { forwardRef } = useForwardExpose()\n\nprovideToolbarRootContext({ orientation, dir })\n</script>\n\n<template>\n  <RovingFocusGroup\n    as-child\n    :orientation=\"orientation\"\n    :dir=\"dir\"\n    :loop=\"loop\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      role=\"toolbar\"\n      :aria-orientation=\"orientation\"\n      :as-child=\"asChild\"\n      :as=\"as\"\n    >\n      <slot />\n    </Primitive>\n  </RovingFocusGroup>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\n\nexport interface ToolbarSeparatorProps extends PrimitiveProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { useForwardExpose } from '@/shared'\nimport BaseSeparator from '../shared/component/BaseSeparator.vue'\nimport { injectToolbarRootContext } from './ToolbarRoot.vue'\n\nconst props = defineProps<ToolbarSeparatorProps>()\n\nconst rootContext = injectToolbarRootContext()\nuseForwardExpose()\n</script>\n\n<template>\n  <BaseSeparator\n    :orientation=\"rootContext.orientation.value\"\n    :as-child=\"props.asChild\"\n    :as=\"as\"\n  >\n    <slot />\n  </BaseSeparator>\n</template>\n", "<script lang=\"ts\">\nimport type {\n  ToggleGroupRootEmits,\n  ToggleGroupRootProps,\n} from '@/ToggleGroup'\n\nexport type ToolbarToggleGroupEmits = ToggleGroupRootEmits\n\nexport interface ToolbarToggleGroupProps extends ToggleGroupRootProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { useEmitAsProps, useForwardExpose } from '@/shared'\nimport { ToggleGroupRoot } from '@/ToggleGroup'\nimport { injectToolbarRootContext } from './ToolbarRoot.vue'\n\nconst props = defineProps<ToolbarToggleGroupProps>()\nconst emits = defineEmits<ToolbarToggleGroupEmits>()\n\nconst rootContext = injectToolbarRootContext()\n\nconst emitsAsProps = useEmitAsProps(emits)\nuseForwardExpose()\n</script>\n\n<template>\n  <ToggleGroupRoot\n    v-bind=\"{ ...props, ...emitsAsProps }\"\n    :data-orientation=\"rootContext.orientation.value\"\n    :dir=\"rootContext.dir.value\"\n    :roving-focus=\"false\"\n  >\n    <slot />\n  </ToggleGroupRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { ToggleGroupItemProps } from '@/ToggleGroup'\nimport { useForwardExpose } from '@/shared'\n\nexport interface ToolbarToggleItemProps extends ToggleGroupItemProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { ToggleGroupItem } from '@/ToggleGroup'\nimport ToolbarButton from './ToolbarButton.vue'\n\nconst props = defineProps<ToolbarToggleItemProps>()\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <ToolbarButton as-child>\n    <ToggleGroupItem\n      v-bind=\"props\"\n      :ref=\"forwardRef\"\n    >\n      <slot />\n    </ToggleGroupItem>\n  </ToolbarButton>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport interface TooltipArrowProps extends PrimitiveProps {\n  /**\n   * The width of the arrow in pixels.\n   *\n   * @defaultValue 10\n   */\n  width?: number\n\n  /**\n   * The height of the arrow in pixels.\n   *\n   * @defaultValue 5\n   */\n  height?: number\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { PopperArrow } from '@/Popper'\n\nconst props = withDefaults(defineProps<TooltipArrowProps>(), {\n  width: 10,\n  height: 5,\n  as: 'svg',\n})\nuseForwardExpose()\n</script>\n\n<template>\n  <PopperArrow v-bind=\"props\">\n    <slot />\n  </PopperArrow>\n</template>\n", "export const TOOLTIP_OPEN = 'tooltip.open'\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { createContext, useForwardExpose } from '@/shared'\n\ninterface TooltipProviderContext {\n  isOpenDelayed: Ref<boolean>\n  delayDuration: Ref<number>\n  onOpen: () => void\n  onClose: () => void\n  isPointerInTransitRef: Ref<boolean>\n  disableHoverableContent: Ref<boolean>\n  disableClosingTrigger: Ref<boolean>\n  disabled: Ref<boolean>\n  ignoreNonKeyboardFocus: Ref<boolean>\n}\n\nexport const [injectTooltipProviderContext, provideTooltipProviderContext]\n  = createContext<TooltipProviderContext>('TooltipProvider')\n\nexport interface TooltipProviderProps {\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 700\n   */\n  delayDuration?: number\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean\n  /**\n   * When `true`, clicking on trigger will not close the content.\n   * @defaultValue false\n   */\n  disableClosingTrigger?: boolean\n  /**\n   * When `true`, disable tooltip\n   * @defaultValue false\n   */\n  disabled?: boolean\n  /**\n   * Prevent the tooltip from opening if the focus did not come from\n   * the keyboard by matching against the `:focus-visible` selector.\n   * This is useful if you want to avoid opening it when switching\n   * browser tabs or closing a dialog.\n   * @defaultValue false\n   */\n  ignoreNonKeyboardFocus?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useTimeoutFn } from '@vueuse/shared'\nimport { ref, toRefs } from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<TooltipProviderProps>(), {\n  delayDuration: 700,\n  skipDelayDuration: 300,\n  disableHoverableContent: false,\n  ignoreNonKeyboardFocus: false,\n})\nconst { delayDuration, skipDelayDuration, disableHoverableContent, disableClosingTrigger, ignoreNonKeyboardFocus, disabled } = toRefs(props)\nuseForwardExpose()\n\nconst isOpenDelayed = ref(true)\n// Reset the inTransit state if idle/scrolled.\nconst isPointerInTransitRef = ref(false)\n\nconst { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {\n  isOpenDelayed.value = true\n}, skipDelayDuration, { immediate: false })\n\nprovideTooltipProviderContext({\n  isOpenDelayed,\n  delayDuration,\n  onOpen() {\n    clearTimer()\n    isOpenDelayed.value = false\n  },\n  onClose() {\n    startTimer()\n  },\n  isPointerInTransitRef,\n  disableHoverableContent,\n  disableClosingTrigger,\n  disabled,\n  ignoreNonKeyboardFocus,\n})\n</script>\n\n<template>\n  <slot />\n</template>\n", "<script lang=\"ts\">\nimport type { Ref } from 'vue'\nimport { createContext, useForwardExpose } from '@/shared'\n\nexport interface TooltipRootProps {\n  /**\n   * The open state of the tooltip when it is initially rendered.\n   * Use when you do not need to control its open state.\n   */\n  defaultOpen?: boolean\n  /**\n   * The controlled open state of the tooltip.\n   */\n  open?: boolean\n  /**\n   * Override the duration given to the `Provider` to customise\n   * the open delay for a specific tooltip.\n   *\n   * @defaultValue 700\n   */\n  delayDuration?: number\n  /**\n   * Prevents Tooltip.Content from remaining open when hovering.\n   * Disabling this has accessibility consequences. Inherits\n   * from Tooltip.Provider.\n   */\n  disableHoverableContent?: boolean\n  /**\n   * When `true`, clicking on trigger will not close the content.\n   * @defaultValue false\n   */\n  disableClosingTrigger?: boolean\n  /**\n   * When `true`, disable tooltip\n   * @defaultValue false\n   */\n  disabled?: boolean\n  /**\n   * Prevent the tooltip from opening if the focus did not come from\n   * the keyboard by matching against the `:focus-visible` selector.\n   * This is useful if you want to avoid opening it when switching\n   * browser tabs or closing a dialog.\n   * @defaultValue false\n   */\n  ignoreNonKeyboardFocus?: boolean\n}\n\nexport type TooltipRootEmits = {\n  /** Event handler called when the open state of the tooltip changes. */\n  'update:open': [value: boolean]\n}\n\nexport interface TooltipContext {\n  contentId: string\n  open: Ref<boolean>\n  stateAttribute: Ref<'closed' | 'delayed-open' | 'instant-open'>\n  trigger: Ref<HTMLElement | undefined>\n  onTriggerChange: (trigger: HTMLElement | undefined) => void\n  onTriggerEnter: () => void\n  onTriggerLeave: () => void\n  onOpen: () => void\n  onClose: () => void\n  disableHoverableContent: Ref<boolean>\n  disableClosingTrigger: Ref<boolean>\n  disabled: Ref<boolean>\n  ignoreNonKeyboardFocus: Ref<boolean>\n}\n\nexport const [injectTooltipRootContext, provideTooltipRootContext]\n  = createContext<TooltipContext>('TooltipRoot')\n</script>\n\n<script setup lang=\"ts\">\nimport { useTimeoutFn, useVModel } from '@vueuse/core'\nimport { computed, ref, watch } from 'vue'\nimport { PopperRoot } from '@/Popper'\nimport { injectTooltipProviderContext } from './TooltipProvider.vue'\nimport { TOOLTIP_OPEN } from './utils'\n\nconst props = withDefaults(defineProps<TooltipRootProps>(), {\n  defaultOpen: false,\n  open: undefined,\n  delayDuration: undefined,\n  disableHoverableContent: undefined,\n  disableClosingTrigger: undefined,\n  disabled: undefined,\n  ignoreNonKeyboardFocus: undefined,\n})\n\nconst emit = defineEmits<TooltipRootEmits>()\n\ndefineSlots<{\n  default?: (props: {\n    /** Current open state */\n    open: typeof open.value\n  }) => any\n}>()\n\nuseForwardExpose()\nconst providerContext = injectTooltipProviderContext()\n\nconst disableHoverableContent = computed(() => props.disableHoverableContent ?? providerContext.disableHoverableContent.value)\nconst disableClosingTrigger = computed(() => props.disableClosingTrigger ?? providerContext.disableClosingTrigger.value)\nconst disableTooltip = computed(() => props.disabled ?? providerContext.disabled.value)\n\nconst delayDuration = computed(() => props.delayDuration ?? providerContext.delayDuration.value)\nconst ignoreNonKeyboardFocus = computed(() => props.ignoreNonKeyboardFocus ?? providerContext.ignoreNonKeyboardFocus.value)\n\nconst open = useVModel(props, 'open', emit, {\n  defaultValue: props.defaultOpen,\n  passive: (props.open === undefined) as false,\n}) as Ref<boolean>\n\nwatch(open, (isOpen) => {\n  if (!providerContext.onClose)\n    return\n  if (isOpen) {\n    providerContext.onOpen()\n    // as `onChange` is called within a lifecycle method we\n    // avoid dispatching via `dispatchDiscreteCustomEvent`.\n    document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN))\n  }\n  else {\n    providerContext.onClose()\n  }\n})\n\nconst wasOpenDelayedRef = ref(false)\nconst trigger = ref<HTMLElement>()\n\nconst stateAttribute = computed(() => {\n  if (!open.value)\n    return 'closed'\n  return wasOpenDelayedRef.value ? 'delayed-open' : 'instant-open'\n})\n\nconst { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {\n  wasOpenDelayedRef.value = true\n  open.value = true\n}, delayDuration, { immediate: false })\n\nfunction handleOpen() {\n  clearTimer()\n  wasOpenDelayedRef.value = false\n  open.value = true\n}\nfunction handleClose() {\n  clearTimer()\n  open.value = false\n}\nfunction handleDelayedOpen() {\n  startTimer()\n}\n\nprovideTooltipRootContext({\n  contentId: '',\n  open,\n  stateAttribute,\n  trigger,\n  onTriggerChange(el) {\n    trigger.value = el\n  },\n  onTriggerEnter() {\n    if (providerContext.isOpenDelayed.value)\n      handleDelayedOpen()\n    else handleOpen()\n  },\n  onTriggerLeave() {\n    if (disableHoverableContent.value) {\n      handleClose()\n    }\n    else {\n      // Clear the timer in case the pointer leaves the trigger before the tooltip is opened.\n      clearTimer()\n    }\n  },\n  onOpen: handleOpen,\n  onClose: handleClose,\n  disableHoverableContent,\n  disableClosingTrigger,\n  disabled: disableTooltip,\n  ignoreNonKeyboardFocus,\n})\n</script>\n\n<template>\n  <PopperRoot>\n    <slot :open=\"open\" />\n  </PopperRoot>\n</template>\n", "<script lang=\"ts\">\nimport type { VNode } from 'vue'\nimport type { PopperContentProps } from '@/Popper'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { useForwardExpose } from '@/shared'\n\nexport type TooltipContentImplEmits = {\n  /** Event handler called when focus moves to the destructive action after opening. It can be prevented by calling `event.preventDefault` */\n  escapeKeyDown: [event: KeyboardEvent]\n  /** Event handler called when a pointer event occurs outside the bounds of the component. It can be prevented by calling `event.preventDefault`. */\n  pointerDownOutside: [event: Event]\n}\n\nexport interface TooltipContentImplProps\n  extends PrimitiveProps,\n  Pick<\n    PopperContentProps,\n    | 'side'\n    | 'sideOffset'\n    | 'align'\n    | 'alignOffset'\n    | 'avoidCollisions'\n    | 'collisionBoundary'\n    | 'collisionPadding'\n    | 'arrowPadding'\n    | 'sticky'\n    | 'hideWhenDetached'\n    | 'positionStrategy'\n    | 'updatePositionStrategy'\n  > {\n  /**\n   * By default, screenreaders will announce the content inside\n   * the component. If this is not descriptive enough, or you have\n   * content that cannot be announced, use aria-label as a more\n   * descriptive label.\n   *\n   * @defaultValue String\n   */\n  ariaLabel?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { useEventListener } from '@vueuse/core'\nimport { Comment, computed, onMounted, useSlots } from 'vue'\nimport { DismissableLayer } from '@/DismissableLayer'\nimport { PopperContent } from '@/Popper'\nimport { VisuallyHidden } from '@/VisuallyHidden'\nimport { injectTooltipRootContext } from './TooltipRoot.vue'\nimport { TOOLTIP_OPEN } from './utils'\n\nconst props = withDefaults(defineProps<TooltipContentImplProps>(), {\n  side: 'top',\n  sideOffset: 0,\n  align: 'center',\n  avoidCollisions: true,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  arrowPadding: 0,\n  sticky: 'partial',\n  hideWhenDetached: false,\n})\nconst emits = defineEmits<TooltipContentImplEmits>()\n\nconst rootContext = injectTooltipRootContext()\n\nconst { forwardRef } = useForwardExpose()\nconst slot = useSlots()\nconst defaultSlot = computed(() => slot.default?.({}))\nconst ariaLabel = computed(() => {\n  if (props.ariaLabel)\n    return props.ariaLabel\n  let content = ''\n\n  function recursiveTextSearch(node: VNode) {\n    if (typeof node.children === 'string' && node.type !== Comment)\n      content += node.children\n    else if (Array.isArray(node.children))\n      node.children.forEach(child => recursiveTextSearch(child as VNode))\n  }\n\n  defaultSlot.value?.forEach((node: VNode) => recursiveTextSearch(node))\n  return content\n})\n\nconst popperContentProps = computed(() => {\n  const { ariaLabel: _, ...restProps } = props\n  return restProps\n})\n\nonMounted(() => {\n  // Close the tooltip if the trigger is scrolled\n  useEventListener(window, 'scroll', (event) => {\n    const target = event.target as HTMLElement\n    if (target?.contains(rootContext.trigger.value!))\n      rootContext.onClose()\n  })\n  // Close this tooltip if another one opens\n  useEventListener(window, TOOLTIP_OPEN, rootContext.onClose)\n})\n</script>\n\n<template>\n  <DismissableLayer\n    as-child\n    :disable-outside-pointer-events=\"false\"\n    @escape-key-down=\"emits('escapeKeyDown', $event)\"\n    @pointer-down-outside=\"(event) => {\n      if (rootContext.disableClosingTrigger.value && rootContext.trigger.value?.contains(event.target as HTMLElement))\n        event.preventDefault()\n\n      emits('pointerDownOutside', event)\n    }\"\n    @focus-outside.prevent\n    @dismiss=\"rootContext.onClose()\"\n  >\n    <PopperContent\n      :ref=\"forwardRef\"\n      :data-state=\"rootContext.stateAttribute.value\"\n      v-bind=\"{ ...$attrs, ...popperContentProps }\"\n      :style=\"{\n        '--reka-tooltip-content-transform-origin': 'var(--reka-popper-transform-origin)',\n        '--reka-tooltip-content-available-width': 'var(--reka-popper-available-width)',\n        '--reka-tooltip-content-available-height': 'var(--reka-popper-available-height)',\n        '--reka-tooltip-trigger-width': 'var(--reka-popper-anchor-width)',\n        '--reka-tooltip-trigger-height': 'var(--reka-popper-anchor-height)',\n      }\"\n    >\n      <slot />\n      <VisuallyHidden\n        :id=\"rootContext.contentId\"\n        role=\"tooltip\"\n      >\n        {{ ariaLabel }}\n      </VisuallyHidden>\n    </PopperContent>\n  </DismissableLayer>\n</template>\n", "<script setup lang=\"ts\">\nimport type { TooltipContentImplProps } from './TooltipContentImpl.vue'\nimport { useForwardExpose, useForwardProps, useGraceArea } from '@/shared'\nimport TooltipContentImpl from './TooltipContentImpl.vue'\nimport { injectTooltipProviderContext } from './TooltipProvider.vue'\nimport { injectTooltipRootContext } from './TooltipRoot.vue'\n\nconst props = defineProps<TooltipContentImplProps>()\nconst forwardedProps = useForwardProps(props)\nconst { forwardRef, currentElement } = useForwardExpose()\n\nconst { trigger, onClose } = injectTooltipRootContext()\nconst providerContext = injectTooltipProviderContext()\n\nconst { isPointerInTransit, onPointerExit } = useGraceArea(trigger, currentElement)\n\nproviderContext.isPointerInTransitRef = isPointerInTransit\nonPointerExit(() => {\n  onClose()\n})\n</script>\n\n<template>\n  <TooltipContentImpl\n    :ref=\"forwardRef\"\n    v-bind=\"forwardedProps\"\n  >\n    <slot />\n  </TooltipContentImpl>\n</template>\n", "<script lang=\"ts\">\nimport type { TooltipContentImplEmits, TooltipContentImplProps } from './TooltipContentImpl.vue'\n\nexport type TooltipContentEmits = TooltipContentImplEmits\n\nexport interface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with Vue animation libraries.\n   */\n  forceMount?: boolean\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Presence } from '@/Presence'\nimport { useForwardExpose, useForwardPropsEmits } from '@/shared'\nimport TooltipContentHoverable from './TooltipContentHoverable.vue'\nimport TooltipContentImpl from './TooltipContentImpl.vue'\nimport { injectTooltipRootContext } from './TooltipRoot.vue'\n\nconst props = withDefaults(defineProps<TooltipContentProps>(), {\n  side: 'top',\n})\nconst emits = defineEmits<TooltipContentEmits>()\n\nconst rootContext = injectTooltipRootContext()\nconst forwarded = useForwardPropsEmits(props, emits)\nconst { forwardRef } = useForwardExpose()\n</script>\n\n<template>\n  <Presence :present=\"forceMount || rootContext.open.value\">\n    <component\n      :is=\"rootContext.disableHoverableContent.value ? TooltipContentImpl : TooltipContentHoverable\"\n      :ref=\"forwardRef\"\n      v-bind=\"forwarded\"\n    >\n      <slot />\n    </component>\n  </Presence>\n</template>\n", "<script lang=\"ts\">\nimport type { TeleportProps } from '@/Teleport'\n\nexport interface TooltipPortalProps extends TeleportProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport { TeleportPrimitive } from '@/Teleport'\n\nconst props = defineProps<TooltipPortalProps>()\n</script>\n\n<template>\n  <TeleportPrimitive v-bind=\"props\">\n    <slot />\n  </TeleportPrimitive>\n</template>\n", "<script lang=\"ts\">\nimport { useForwardExpose, useId } from '@/shared'\n\nexport type TooltipTriggerDataState =\n  | 'closed'\n  | 'delayed-open'\n  | 'instant-open'\n\nexport interface TooltipTriggerProps extends PopperAnchorProps {}\n</script>\n\n<script setup lang=\"ts\">\nimport type { PopperAnchorProps } from '@/Popper'\nimport { computed, onMounted, ref } from 'vue'\nimport { PopperAnchor } from '@/Popper'\nimport {\n  Primitive,\n} from '@/Primitive'\nimport { injectTooltipProviderContext } from './TooltipProvider.vue'\nimport { injectTooltipRootContext } from './TooltipRoot.vue'\n\nconst props = withDefaults(defineProps<TooltipTriggerProps>(), {\n  as: 'button',\n})\nconst rootContext = injectTooltipRootContext()\nconst providerContext = injectTooltipProviderContext()\n\nrootContext.contentId ||= useId(undefined, 'reka-tooltip-content')\n\nconst { forwardRef, currentElement: triggerElement } = useForwardExpose()\n\nconst isPointerDown = ref(false)\nconst hasPointerMoveOpened = ref(false)\n\nconst tooltipListeners = computed(() => {\n  if (rootContext.disabled.value)\n    return {}\n\n  return {\n    click: handleClick,\n    focus: handleFocus,\n    pointermove: handlePointerMove,\n    pointerleave: handlePointerLeave,\n    pointerdown: handlePointerDown,\n    blur: handleBlur,\n  }\n})\n\nonMounted(() => {\n  rootContext.onTriggerChange(triggerElement.value)\n})\n\nfunction handlePointerUp() {\n  setTimeout(() => {\n    isPointerDown.value = false\n  }, 1)\n}\n\nfunction handlePointerDown() {\n  if (rootContext.open && !rootContext.disableClosingTrigger.value) {\n    rootContext.onClose()\n  }\n  isPointerDown.value = true\n  document.addEventListener('pointerup', handlePointerUp, { once: true })\n}\n\nfunction handlePointerMove(event: PointerEvent) {\n  if (event.pointerType === 'touch')\n    return\n  if (\n    !hasPointerMoveOpened.value && !providerContext.isPointerInTransitRef.value\n  ) {\n    rootContext.onTriggerEnter()\n    hasPointerMoveOpened.value = true\n  }\n}\n\nfunction handlePointerLeave() {\n  rootContext.onTriggerLeave()\n  hasPointerMoveOpened.value = false\n}\n\nfunction handleFocus(event: FocusEvent) {\n  if (isPointerDown.value)\n    return\n\n  if (rootContext.ignoreNonKeyboardFocus.value && !(event.target as HTMLElement).matches?.(':focus-visible'))\n    return\n\n  rootContext.onOpen()\n}\n\nfunction handleBlur() {\n  rootContext.onClose()\n}\n\nfunction handleClick() {\n  if (!rootContext.disableClosingTrigger.value)\n    rootContext.onClose()\n}\n</script>\n\n<template>\n  <PopperAnchor\n    as-child\n    :reference=\"reference\"\n  >\n    <Primitive\n      :ref=\"forwardRef\"\n      :aria-describedby=\"\n        rootContext.open.value ? rootContext.contentId : undefined\n      \"\n      :data-state=\"rootContext.stateAttribute.value\"\n      :as=\"as\"\n      :as-child=\"props.asChild\"\n      data-grace-area-trigger\n      v-on=\"tooltipListeners\"\n    >\n      <slot />\n    </Primitive>\n  </PopperAnchor>\n</template>\n", "export function flatten<U, T extends { children: any[] }>(items: T[]): U[] {\n  return items.reduce((acc: any[], item: T) => {\n    acc.push(item)\n\n    if (item.children)\n      acc.push(...flatten(item.children))\n\n    return acc\n  }, [])\n}\n\n// TODO: expose more utility function to handle flattened item\n", "import type { Ref, UnwrapNestedRefs } from 'vue'\nimport { ref } from 'vue'\nimport { findValuesBetween } from './arrays'\n\nexport function useSelectionBehavior<T>(\n  modelValue: Ref<T | T[]>,\n  props: UnwrapNestedRefs<{ multiple?: boolean, selectionBehavior?: 'toggle' | 'replace' }>,\n) {\n  const firstValue = ref()\n\n  const onSelectItem = (val: T, condition: (existingValue: T) => boolean) => {\n    // multiple select\n    if (props.multiple && Array.isArray(modelValue.value)) {\n      if (props.selectionBehavior === 'replace') {\n        modelValue.value = [val]\n        firstValue.value = val\n      }\n      else {\n        const index = modelValue.value.findIndex(v => condition(v))\n        if (index !== -1)\n          modelValue.value = modelValue.value.filter((_, i) => i !== index)\n        else\n          modelValue.value = [...modelValue.value, val]\n      }\n    }\n    // single select\n    else {\n      if (props.selectionBehavior === 'replace') {\n        modelValue.value = { ...val }\n      }\n      else {\n        if (!Array.isArray(modelValue.value) && condition(modelValue.value))\n          modelValue.value = undefined as any\n        else\n          modelValue.value = { ...val }\n      }\n    }\n    return modelValue.value\n  }\n\n  function handleMultipleReplace(intent: 'first' | 'last' | 'prev' | 'next', currentElement: HTMLElement | Element | null, getItems: () => { ref: HTMLElement, value?: any }[], options: any[]) {\n    if (!firstValue?.value || !props.multiple || !Array.isArray(modelValue.value))\n      return\n\n    const collection = getItems().filter(i => i.ref.dataset.disabled !== '')\n    const lastValue = collection.find(i => i.ref === currentElement)?.value\n    if (!lastValue)\n      return\n\n    let value: T[] | null = null\n    switch (intent) {\n      case 'prev':\n      case 'next': {\n        value = findValuesBetween(options, firstValue.value, lastValue)\n        break\n      }\n      case 'first': {\n        value = findValuesBetween(options, firstValue.value, options?.[0])\n        break\n      }\n      case 'last': {\n        value = findValuesBetween(options, firstValue.value, options?.[options.length - 1])\n        break\n      }\n    }\n\n    modelValue.value = value\n  }\n\n  return {\n    firstValue,\n    onSelectItem,\n    handleMultipleReplace,\n  }\n}\n", "<script lang=\"ts\">\nimport type { Direction } from '@/shared/types'\nimport { createContext, getActiveElement, useDirection, useSelectionBehavior, useTypeahead } from '@/shared'\nimport { flatten } from './utils'\n\nexport interface TreeRootProps<T = Record<string, any>, U extends Record<string, any> = Record<string, any>, M extends boolean = false> extends PrimitiveProps {\n  /** The controlled value of the tree. Can be binded with with `v-model`. */\n  modelValue?: M extends true ? U[] : U\n  /** The value of the tree when initially rendered. Use when you do not need to control the state of the tree */\n  defaultValue?: M extends true ? U[] : U\n  /** List of items */\n  items?: T[]\n  /** The controlled value of the expanded item. Can be binded with with `v-model`. */\n  expanded?: string[]\n  /** The value of the expanded tree when initially rendered. Use when you do not need to control the state of the expanded tree */\n  defaultExpanded?: string[]\n  /** This function is passed the index of each item and should return a unique key for that item */\n  getKey: (val: T) => string\n  /** This function is passed the index of each item and should return a list of children for that item */\n  getChildren?: (val: T) => T[] | undefined\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: 'toggle' | 'replace'\n  /** Whether multiple options can be selected or not.  */\n  multiple?: M\n  /** The reading direction of the listbox when applicable. <br> If omitted, inherits globally from `ConfigProvider` or assumes LTR (left-to-right) reading mode. */\n  dir?: Direction\n  /** When `true`, prevents the user from interacting with tree  */\n  disabled?: boolean\n  /** When `true`, selecting parent will select the descendants. */\n  propagateSelect?: boolean\n  /** When `true`, selecting children will update the parent state. */\n  bubbleSelect?: boolean\n}\n\nexport type TreeRootEmits<T = Record<string, any>, M extends boolean = false> = {\n  'update:modelValue': [val: M extends true ? T[] : T]\n  'update:expanded': [val: string[]]\n}\n\ninterface TreeRootContext<T = Record<string, any>> {\n  modelValue: Ref<T | T[]>\n  selectedKeys: Ref<string[]>\n  onSelect: (val: T) => void\n  expanded: Ref<string[]>\n  onToggle: (val: T) => void\n  items: Ref<T[]>\n  expandedItems: Ref<T[]>\n  getKey: (val: T) => string\n  getChildren: (val: T) => T[] | undefined\n  multiple: Ref<boolean>\n  disabled: Ref<boolean>\n  dir: Ref<Direction>\n  propagateSelect: Ref<boolean>\n  bubbleSelect: Ref<boolean>\n  isVirtual: Ref<boolean>\n  virtualKeydownHook: EventHook<KeyboardEvent>\n\n  handleMultipleReplace: ReturnType<typeof useSelectionBehavior>['handleMultipleReplace']\n}\n\nexport type FlattenedItem<T> = {\n  _id: string\n  index: number\n  value: T\n  level: number\n  hasChildren: boolean\n  parentItem?: T\n  bind: {\n    value: T\n    level: number\n    [key: string]: any\n  }\n}\n\nexport const [injectTreeRootContext, provideTreeRootContext] = createContext<TreeRootContext<any>>('TreeRoot')\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends Record<string, any>, U extends Record<string, any>, M extends boolean = false\">\nimport type { EventHook } from '@vueuse/core'\nimport type { Ref } from 'vue'\nimport type { PrimitiveProps } from '@/Primitive'\nimport { createEventHook, useVModel } from '@vueuse/core'\nimport { computed, nextTick, ref, toRefs } from 'vue'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusGroup } from '@/RovingFocus'\nimport { MAP_KEY_TO_FOCUS_INTENT } from '@/RovingFocus/utils'\n\nconst props = withDefaults(defineProps<TreeRootProps<T, U, M>>(), {\n  as: 'ul',\n  selectionBehavior: 'toggle',\n  getChildren: (val: T) => val.children,\n})\nconst emits = defineEmits<TreeRootEmits<U, M>>()\n\ndefineSlots<{\n  default?: (props: {\n    flattenItems: FlattenedItem<T>[]\n    modelValue: M extends true ? U[] : U\n    expanded: typeof expanded.value\n  }) => any\n}>()\n\nconst { items, multiple, disabled, propagateSelect, dir: propDir, bubbleSelect } = toRefs(props)\nconst { handleTypeaheadSearch } = useTypeahead()\nconst dir = useDirection(propDir)\nconst rovingFocusGroupRef = ref<InstanceType<typeof RovingFocusGroup>>()\n\n// Virtualizer\nconst isVirtual = ref(false)\nconst virtualKeydownHook = createEventHook<KeyboardEvent>()\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  // @ts-expect-error idk\n  defaultValue: props.defaultValue ?? (multiple.value ? [] : undefined),\n  passive: (props.modelValue === undefined) as false,\n  deep: true,\n}) as Ref<U | U[]>\n\nconst expanded = useVModel(props, 'expanded', emits, {\n  // @ts-expect-error idk\n  defaultValue: props.defaultExpanded ?? [],\n  passive: (props.expanded === undefined) as false,\n  deep: true,\n}) as Ref<string[]>\n\nconst { onSelectItem, handleMultipleReplace } = useSelectionBehavior(modelValue, props)\n\nconst selectedKeys = computed(() => {\n  if (multiple.value && Array.isArray(modelValue.value))\n    return modelValue.value.map(i => props.getKey(i as any))\n  else\n    return [props.getKey(modelValue.value as any ?? {})]\n})\n\nfunction flattenItems(items: T[], level: number = 1, parentItem?: T): FlattenedItem<T>[] {\n  return items.reduce((acc: FlattenedItem<T>[], item: T, index: number) => {\n    const key = props.getKey(item)\n    const children = props.getChildren(item)\n    const isExpanded = expanded.value.includes(key)\n\n    const flattenedItem: FlattenedItem<T> = {\n      _id: key,\n      value: item,\n      index,\n      level,\n      parentItem,\n      hasChildren: !!children,\n      bind: {\n        'value': item,\n        level,\n        'aria-setsize': items.length,\n        'aria-posinset': index + 1,\n      },\n    }\n    acc.push(flattenedItem)\n\n    if (children && isExpanded)\n      acc.push(...flattenItems(children, level + 1, item))\n\n    return acc\n  }, [])\n}\n\nconst expandedItems = computed(() => {\n  const items = props.items\n  const expandedKeys = expanded.value.map(i => i)\n  return flattenItems(items ?? [])\n})\n\nfunction handleKeydown(event: KeyboardEvent) {\n  if (isVirtual.value) {\n    virtualKeydownHook.trigger(event)\n  }\n  else {\n    const collections = rovingFocusGroupRef.value?.getItems() ?? []\n    handleTypeaheadSearch(event.key, collections)\n  }\n}\n\nfunction handleKeydownNavigation(event: KeyboardEvent) {\n  if (isVirtual.value)\n    return\n\n  const intent = MAP_KEY_TO_FOCUS_INTENT[event.key]\n  nextTick(() => {\n    handleMultipleReplace(\n      intent,\n      getActiveElement(),\n      rovingFocusGroupRef.value?.getItems!,\n      expandedItems.value.map(i => i.value),\n    )\n  })\n}\n\nfunction handleBubbleSelect(item: FlattenedItem<T>) {\n  if (item.parentItem != null && Array.isArray(modelValue.value) && props.multiple) {\n    const parentItem = expandedItems.value.find((i) => {\n      return item.parentItem != null && props.getKey(i.value) === props.getKey(item.parentItem)\n    })\n\n    if (parentItem != null) {\n      const areAllChilredOfParentSelected = props.getChildren(parentItem.value)?.every(i => modelValue.value.find((v: any) => props.getKey(v) === props.getKey(i)))\n\n      if (areAllChilredOfParentSelected) {\n        modelValue.value = [...modelValue.value, parentItem.value as any]\n      }\n      else {\n        modelValue.value = modelValue.value.filter((v: any) => props.getKey(v) !== props.getKey(parentItem.value))\n      }\n\n      handleBubbleSelect(parentItem)\n    }\n  }\n}\n\nprovideTreeRootContext({\n  modelValue,\n  selectedKeys,\n  onSelect: (val) => {\n    const condition = (baseValue: U) => props.getKey(baseValue as any ?? {}) === props.getKey(val)\n    const exist = props.multiple && Array.isArray(modelValue.value) ? modelValue.value?.findIndex(condition) !== -1 : undefined\n    onSelectItem(val, condition)\n\n    if (props.bubbleSelect && props.multiple && Array.isArray(modelValue.value)) {\n      const item = expandedItems.value.find((i) => {\n        return props.getKey(i.value) === props.getKey(val)\n      })\n      if (item != null) {\n        handleBubbleSelect(item)\n      }\n    }\n\n    if (props.propagateSelect && props.multiple && Array.isArray(modelValue.value)) {\n      const children = flatten<U, any>(props.getChildren(val) ?? [])\n\n      if (exist) {\n        // remove all child\n        modelValue.value = [...modelValue.value]\n          .filter(i => !children.some(child => props.getKey(i as any ?? {}) === props.getKey(child as any)))\n      }\n      else {\n        // select all child\n        modelValue.value = [...modelValue.value, ...children]\n      }\n    }\n  },\n  expanded,\n  onToggle(val) {\n    const children = val ? props.getChildren(val) : undefined\n    if (!children)\n      return\n\n    const key = props.getKey(val) ?? val\n    if (expanded.value.includes(key))\n      expanded.value = expanded.value.filter(val => val !== key)\n    else\n      expanded.value.push(key)\n  },\n  getKey: props.getKey,\n  getChildren: props.getChildren,\n  items,\n  expandedItems,\n  disabled,\n  multiple,\n  dir,\n  propagateSelect,\n  bubbleSelect,\n\n  isVirtual,\n  virtualKeydownHook,\n  handleMultipleReplace,\n})\n</script>\n\n<template>\n  <RovingFocusGroup\n    ref=\"rovingFocusGroupRef\"\n    as-child\n    orientation=\"vertical\"\n    :dir=\"dir\"\n  >\n    <Primitive\n      role=\"tree\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :aria-multiselectable=\"multiple ? true : undefined\"\n      @keydown=\"handleKeydown\"\n      @keydown.up.down.shift=\"handleKeydownNavigation\"\n    >\n      <slot\n        :flatten-items=\"expandedItems\"\n        :model-value=\"modelValue as M extends true ? U[] : U\"\n        :expanded=\"expanded\"\n      />\n    </Primitive>\n  </RovingFocusGroup>\n</template>\n", "<script lang=\"ts\">\nexport interface TreeItemProps<T> extends PrimitiveProps {\n  /** Value given to this item */\n  value: T\n  /** Level of depth */\n  level: number\n}\n\nexport type SelectEvent<T> = CustomEvent<{ originalEvent: PointerEvent | KeyboardEvent, value?: T, isExpanded: boolean, isSelected: boolean }>\nexport type ToggleEvent<T> = CustomEvent<{ originalEvent: PointerEvent | KeyboardEvent, value?: T, isExpanded: boolean, isSelected: boolean }>\n\nexport type TreeItemEmits<T> = {\n  /** Event handler called when the selecting item. <br> It can be prevented by calling `event.preventDefault`. */\n  select: [event: SelectEvent<T>]\n  /** Event handler called when the selecting item. <br> It can be prevented by calling `event.preventDefault`. */\n  toggle: [event: ToggleEvent<T>]\n}\n\nconst TREE_SELECT = 'tree.select'\nconst TREE_TOGGLE = 'tree.toggle'\n</script>\n\n<script setup lang=\"ts\" generic=\"T extends Record<string, any>\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { computed } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { Primitive } from '@/Primitive'\nimport { RovingFocusItem } from '@/RovingFocus'\nimport { getActiveElement, handleAndDispatchCustomEvent } from '@/shared'\nimport { injectTreeRootContext } from './TreeRoot.vue'\nimport { flatten } from './utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<TreeItemProps<T>>(), {\n  as: 'li',\n})\n\nconst emits = defineEmits<TreeItemEmits<T>>()\n\ndefineSlots<{\n  default?: (props: {\n    isExpanded: boolean\n    isSelected: boolean\n    isIndeterminate: boolean | undefined\n    handleToggle: () => void\n    handleSelect: () => void\n  }) => any\n}>()\nconst rootContext = injectTreeRootContext()\nconst { getItems } = useCollection()\n\nconst hasChildren = computed(() => !!rootContext.getChildren(props.value))\n\nconst isExpanded = computed(() => {\n  const key = rootContext.getKey(props.value)\n  return rootContext.expanded.value.includes(key)\n})\n\nconst isSelected = computed(() => {\n  const key = rootContext.getKey(props.value)\n  return rootContext.selectedKeys.value.includes(key)\n})\n\nconst isIndeterminate = computed(() => {\n  if (rootContext.bubbleSelect.value && hasChildren.value && Array.isArray(rootContext.modelValue.value)) {\n    const children = flatten<T, any>(rootContext.getChildren(props.value) || [])\n\n    return children.some(child => rootContext.modelValue.value.find((v: any) => rootContext.getKey(v) === rootContext.getKey(child)))\n      && !children.every(child => rootContext.modelValue.value.find((v: any) => rootContext.getKey(v) === rootContext.getKey(child)))\n  }\n  else if (rootContext.propagateSelect.value && isSelected.value && hasChildren.value && Array.isArray(rootContext.modelValue.value)) {\n    const children = flatten<T, any>(rootContext.getChildren(props.value) || [])\n\n    return !children.every(child => rootContext.modelValue.value.find((v: any) => rootContext.getKey(v) === rootContext.getKey(child)))\n  }\n  else {\n    return undefined\n  }\n})\n\nfunction handleKeydownRight(ev: KeyboardEvent) {\n  if (!hasChildren.value)\n    return\n\n  if (isExpanded.value) {\n    // go to first child\n    const collection = getItems().map(i => i.ref)\n    const currentElement = getActiveElement() as HTMLElement\n    const currentIndex = collection.indexOf(currentElement)\n    const list = [...collection].slice(currentIndex)\n    const nextElement = list.find(el => Number(el.getAttribute('data-indent')) === (props.level + 1))\n\n    if (nextElement)\n      nextElement.focus()\n  }\n  else {\n    //  open expanded\n    handleToggleCustomEvent(ev)\n  }\n}\n\nfunction handleKeydownLeft(ev: KeyboardEvent) {\n  if (isExpanded.value) {\n    //  close expanded\n    handleToggleCustomEvent(ev)\n  }\n  else {\n    // go back to parent\n    const collection = getItems().map(i => i.ref)\n    const currentElement = getActiveElement() as HTMLElement\n    const currentIndex = collection.indexOf(currentElement)\n    const list = [...collection].slice(0, currentIndex).reverse()\n    const parentElement = list.find(el => Number(el.getAttribute('data-indent')) === (props.level - 1))\n\n    if (parentElement)\n      parentElement.focus()\n  }\n}\n\nasync function handleSelect(ev: SelectEvent<T>) {\n  emits('select', ev)\n  if (ev?.defaultPrevented)\n    return\n\n  rootContext.onSelect(props.value)\n}\nasync function handleToggle(ev: ToggleEvent<T>) {\n  emits('toggle', ev)\n  if (ev?.defaultPrevented)\n    return\n\n  rootContext.onToggle(props.value)\n}\n\nasync function handleSelectCustomEvent(ev?: PointerEvent | KeyboardEvent) {\n  if (!ev)\n    return\n\n  const eventDetail = { originalEvent: ev, value: props.value, isExpanded: isExpanded.value, isSelected: isSelected.value }\n  handleAndDispatchCustomEvent(TREE_SELECT, handleSelect, eventDetail)\n}\n\nasync function handleToggleCustomEvent(ev?: PointerEvent | KeyboardEvent) {\n  if (!ev)\n    return\n\n  const eventDetail = { originalEvent: ev, value: props.value, isExpanded: isExpanded.value, isSelected: isSelected.value }\n  handleAndDispatchCustomEvent(TREE_TOGGLE, handleToggle, eventDetail)\n}\n\ndefineExpose({\n  isExpanded,\n  isSelected,\n  isIndeterminate,\n  handleToggle: () => rootContext.onToggle(props.value),\n  handleSelect: () => rootContext.onSelect(props.value),\n})\n</script>\n\n<template>\n  <RovingFocusItem\n    as-child\n    :value=\"value\"\n    allow-shift-key\n  >\n    <Primitive\n      v-bind=\"$attrs\"\n      role=\"treeitem\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :aria-selected=\"isSelected\"\n      :aria-expanded=\"hasChildren ? isExpanded : undefined\"\n      :aria-level=\"level\"\n      :data-indent=\"level\"\n      :data-selected=\"isSelected ? '' : undefined\"\n      :data-expanded=\"isExpanded ? '' : undefined\"\n      @keydown.enter.space.self.prevent=\"handleSelectCustomEvent\"\n      @keydown.right.prevent=\"(ev) => rootContext.dir.value === 'ltr' ? handleKeydownRight(ev) : handleKeydownLeft(ev)\"\n      @keydown.left.prevent=\"(ev) => rootContext.dir.value === 'ltr' ? handleKeydownLeft(ev) : handleKeydownRight(ev)\"\n      @click.stop=\"(ev) => {\n        handleSelectCustomEvent(ev)\n        handleToggleCustomEvent(ev)\n      }\"\n    >\n      <slot\n        :is-expanded=\"isExpanded\"\n        :is-selected=\"isSelected\"\n        :is-indeterminate=\"isIndeterminate\"\n        :handle-select=\"() => rootContext.onSelect(value)\"\n        :handle-toggle=\"() => rootContext.onToggle(value)\"\n      />\n    </Primitive>\n  </RovingFocusItem>\n</template>\n", "<script lang=\"ts\">\nexport interface TreeVirtualizerProps {\n  /** Number of items rendered outside the visible area */\n  overscan?: number\n  /** Estimated size (in px) of each item */\n  estimateSize?: number\n  /** Text content for each item to achieve type-ahead feature */\n  textContent?: (item: Record<string, any>) => string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport type { VirtualItem, Virtualizer } from '@tanstack/vue-virtual'\nimport type { Ref } from 'vue'\nimport type { FlattenedItem } from './TreeRoot.vue'\nimport { useVirtualizer } from '@tanstack/vue-virtual'\nimport { refAutoReset, useParentElement } from '@vueuse/core'\nimport { cloneVNode, computed, nextTick, useSlots } from 'vue'\nimport { useCollection } from '@/Collection'\nimport { MAP_KEY_TO_FOCUS_INTENT } from '@/RovingFocus/utils'\nimport { getActiveElement } from '@/shared'\nimport { getNextMatch } from '@/shared/useTypeahead'\nimport { injectTreeRootContext } from './TreeRoot.vue'\n\nconst props = defineProps<TreeVirtualizerProps>()\n\ndefineSlots<{\n  default?: (props: {\n    item: FlattenedItem<Record<string, any>>\n    virtualizer: Virtualizer<Element | Window, Element>\n    virtualItem: VirtualItem\n  }) => any\n}>()\n\nconst slots = useSlots()\nconst rootContext = injectTreeRootContext()\nconst parentEl = useParentElement() as Ref<HTMLElement>\nconst { getItems } = useCollection()\n\n// Reset `search` 1 second after it was last updated\nconst search = refAutoReset('', 1000)\nconst optionsWithMetadata = computed(() => {\n  const parseTextContent = (option: Record<string, any>) => {\n    if (props.textContent)\n      return props.textContent(option)\n    else\n      return option.toString().toLowerCase()\n  }\n\n  return rootContext.expandedItems.value.map((option, index) => ({\n    index,\n    textContent: parseTextContent(option.value),\n  }))\n})\n\n// set virtual true when this component mounted\nrootContext.isVirtual.value = true\n\nconst padding = computed(() => {\n  const el = parentEl.value\n  if (!el) {\n    return { start: 0, end: 0 }\n  }\n  else {\n    const styles = window.getComputedStyle(el)\n    return {\n      start: Number.parseFloat(styles.paddingBlockStart || styles.paddingTop),\n      end: Number.parseFloat(styles.paddingBlockEnd || styles.paddingBottom),\n    }\n  }\n})\n\nconst virtualizer = useVirtualizer(\n  {\n    get scrollPaddingStart() { return padding.value.start },\n    get scrollPaddingEnd() { return padding.value.end },\n    get count() { return rootContext.expandedItems.value.length ?? 0 },\n    get horizontal() { return false },\n    getItemKey(index) {\n      return index + rootContext.getKey(rootContext.expandedItems.value[index].value)\n    },\n    estimateSize() {\n      return props.estimateSize ?? 28\n    },\n    getScrollElement() { return parentEl.value },\n    overscan: props.overscan ?? 12,\n  },\n)\n\nconst virtualizedItems = computed(() => virtualizer.value.getVirtualItems().map((item) => {\n  return {\n    item,\n    is: cloneVNode(slots.default!({\n      item: rootContext.expandedItems.value[item.index],\n      virtualizer: virtualizer.value,\n      virtualItem: item,\n    })![0], {\n      'data-index': item.index,\n      'style': {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        transform: `translateY(${item.start}px)`,\n        overflowAnchor: 'none',\n      },\n    }),\n  }\n}))\n\nfunction scrollToIndexAndFocus(index: number) {\n  virtualizer.value.scrollToIndex(index, { align: 'start' })\n  requestAnimationFrame(() => {\n    const item = parentEl.value.querySelector(`[data-index=\"${index}\"]`) as HTMLElement\n    if (item instanceof HTMLElement)\n      item.focus()\n  })\n}\n\nrootContext.virtualKeydownHook.on((event) => {\n  const isMetaKey = event.altKey || event.ctrlKey || event.metaKey\n  const isTabKey = event.key === 'Tab' && !isMetaKey\n  if (isTabKey)\n    return\n\n  const intent = MAP_KEY_TO_FOCUS_INTENT[event.key]\n\n  if (['first', 'last'].includes(intent)) {\n    event.preventDefault()\n\n    const index = intent === 'first' ? 0 : rootContext.expandedItems.value.length - 1\n    virtualizer.value.scrollToIndex(index)\n    requestAnimationFrame(() => {\n      const items = getItems()\n      const item = intent === 'first' ? items[0] : items[items.length - 1]\n      item.ref.focus()\n    })\n  }\n  else if (intent === 'prev' && event.key !== 'ArrowUp') {\n    const currentElement = getActiveElement() as HTMLElement\n    const currentIndex = Number(currentElement.getAttribute('data-index'))\n    const currentLevel = Number(currentElement.getAttribute('data-indent'))\n    const list = rootContext.expandedItems.value.slice(0, currentIndex).map((item, index) => ({ ...item, index })).reverse()\n\n    const parentItem = list.find(item => item.level === (currentLevel - 1))\n    if (parentItem)\n      scrollToIndexAndFocus(parentItem.index)\n  }\n  else if (!intent && !isMetaKey) {\n    search.value += event.key\n    const currentIndex = Number(getActiveElement()?.getAttribute('data-index'))\n    const currentMatch = optionsWithMetadata.value[currentIndex].textContent\n    const filteredOptions = optionsWithMetadata.value.map(i => i.textContent)\n    const next = getNextMatch(filteredOptions, search.value, currentMatch)\n\n    const nextMatch = optionsWithMetadata.value.find(option => option.textContent === next)\n    if (nextMatch)\n      scrollToIndexAndFocus(nextMatch.index)\n  }\n\n  nextTick(() => {\n    if (event.shiftKey && intent)\n      rootContext.handleMultipleReplace(intent, getActiveElement(), getItems, rootContext.expandedItems.value.map(i => i.value))\n  })\n})\n</script>\n\n<template>\n  <div\n    data-reka-virtualizer\n    :style=\"{\n      position: 'relative',\n      width: '100%',\n      height: `${virtualizer.getTotalSize()}px`,\n    }\"\n  >\n    <component\n      :is=\"is\"\n      v-for=\"{ is, item } in virtualizedItems\"\n      :key=\"item.key\"\n    />\n  </div>\n</template>\n", "<script lang=\"ts\">\nimport type { PrimitiveProps } from '@/Primitive'\nimport { toRefs } from 'vue'\nimport { useForwardExpose } from '@/shared'\nimport { useNonce } from '@/shared/useNonce'\n\nexport interface ViewportProps extends PrimitiveProps {\n  /**\n   * Will add `nonce` attribute to the style tag which can be used by Content Security Policy. <br> If omitted, inherits globally from `ConfigProvider`.\n   */\n  nonce?: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { Primitive } from '@/Primitive'\n\nconst props = defineProps<ViewportProps>()\nconst { forwardRef } = useForwardExpose()\n\nconst { nonce: propNonce } = toRefs(props)\nconst nonce = useNonce(propNonce)\n</script>\n\n<template>\n  <Primitive\n    v-bind=\"{ ...$attrs, ...props }\"\n    :ref=\"forwardRef\"\n    data-reka-viewport\n    role=\"presentation\"\n    :style=\"{\n      // we use position: 'relative' here on the `viewport` so that when we call\n      // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n      // (independent of the scrollUpButton).\n      position: 'relative',\n      flex: 1,\n      overflow: 'auto',\n    }\"\n  >\n    <slot />\n  </Primitive>\n  <Primitive\n    as=\"style\"\n    :nonce=\"nonce\"\n  >\n    /* Hide scrollbars cross-browser and enable momentum scroll for touch\n    devices */ [data-reka-viewport] { scrollbar-width:none; -ms-overflow-style: none;\n    -webkit-overflow-scrolling: touch; }\n    [data-reka-viewport]::-webkit-scrollbar { display: none; }\n  </Primitive>\n</template>\n", "import type { ComponentOptionsBase, DefineComponent, VNodeProps } from 'vue'\nimport type { ComponentProps } from 'vue-component-type-helpers'\nimport { h, mergeProps } from 'vue'\nimport { useForwardExpose } from './useForwardExpose'\n\n// TODO: TEST\n\n// From vue next\n// https://github.com/vuejs/core/blob/1f2a652a9d2e3bec472fb1786a4c16d6ccfa1fb1/packages/runtime-core/src/h.ts#L53-L58\ntype RawProps = VNodeProps & {\n  // used to differ from a single VNode object as children\n  __v_isVNode?: never\n  // used to differ from Array children\n  [Symbol.iterator]?: never\n} & Record<string, any>\n\n// types inspired from vue-test-utils\n// https://github.com/vuejs/test-utils/blob/main/src/mount.ts#L36\ninterface MountingOptions<Props> {\n  /**\n   * Default props for the component\n   */\n  props?: (RawProps & Props) | ({} extends Props ? null : never) | ((attrs: Record<string, any>) => (RawProps & Props))\n  /**\n   * Pass attributes into the component\n   */\n  attrs?: Record<string, unknown>\n}\n\nexport function withDefault<\n  T,\n  C = T extends ((...args: any) => any) | (new (...args: any) => any)\n    ? T\n    : T extends { props?: infer Props }\n      ? DefineComponent<\n        Props extends Readonly<(infer PropNames)[]> | (infer PropNames)[]\n          ? { [key in PropNames extends string ? PropNames : string]?: any }\n          : Props\n      >\n      : DefineComponent,\n  P extends ComponentProps<C> = ComponentProps<C>,\n>(\n  originalComponent: T,\n  options?: MountingOptions<P>\n): T\n\nexport function withDefault<T extends ComponentOptionsBase<{}, {}, {}, any, any, any, any, any>>(WrappedComponent: T, options?: MountingOptions<any>) {\n  return ({\n    inheritAttrs: false,\n    name: `${WrappedComponent.__name ?? ''}Wrapper`,\n    setup(_, ctx) {\n      return () => {\n        const optionProps = typeof options?.props === 'function' ? options?.props(ctx.attrs) : options?.props\n        const { forwardRef } = useForwardExpose()\n\n        const mergedProps = mergeProps(optionProps, ctx.attrs)\n        return h(WrappedComponent, { ...mergedProps, ref: forwardRef }, ctx.slots)\n      }\n    },\n  }) as T\n}\n", "<script lang=\"ts\">\nimport type { PopoverAnchorProps } from '..'\nimport { PopoverAnchor } from '..'\n\nexport interface DatePickerAnchorProps extends PopoverAnchorProps {}\n</script>\n\n<script setup lang=\"ts\">\nconst props = defineProps<DatePickerAnchorProps>()\n</script>\n\n<template>\n  <PopoverAnchor v-bind=\"props\">\n    <slot />\n  </PopoverAnchor>\n</template>\n"],
  "mappings": "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E,MAAM,OAAO,OAAO,QAAQ,KAAK,MAAM;EAChD,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,OAAO,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC9C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,OAAO,OAAO,OAAO,KAAK,MAAM;EAC9C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,OAAO,OAAO,QAAQ,KAAK,MAAM;EAC/C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,OAAO,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC9C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MAAM,QAAQ,OAAO,MAAM,KAAK,KAAK;EAC7C,MAAM,EAAE,MA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",
  "names": ["props", "keys", "toRef", "camelize", "c", "toRef", "transform", "toValue", "window", "document", "window", "document", "timestamp", "window", "window", "props", "context", "props", "props", "context", "ref", "props", "props", "focus", "props", "useId", "_a", "props", "props", "useId", "props", "props", "props", "props", "useId", "props", "props", "props", "focusFirst", "props", "focusFirst", "handlePointerDown", "props", "props", "useId", "props", "props", "props", "props", "props", "props", "props", "c", "context", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "props", "props", "props", "props", "calendarDateTimeGranularities", "size", "props", "props", "props", "opts", "part", "props", "firstPeriodOfNextPage", "lastPeriodOfPrevPage", "newDate", "newGrid", "context", "props", "readonly", "props", "computedIndex", "props", "readonly", "props", "props", "props", "props", "props", "props", "props", "props", "toValue", "context", "props", "key", "EVENT_OPTIONS", "focusFirst", "props", "EVENT_OPTIONS", "focusFirst", "props", "props", "props", "isIndeterminate", "props", "context", "useId", "focusFirst", "props", "isIndeterminate", "props", "props", "size", "width", "height", "props", "arrow", "floatingUIarrow", "wrapArray", "props", "props", "_a", "_b", "_c", "props", "props", "props", "props", "useId", "props", "props", "useId", "props", "useId", "context", "props", "props", "props", "useId", "handleSelect", "props", "useId", "props", "props", "props", "useId", "props", "props", "props", "context", "props", "range", "offset", "size", "offset", "opts", "count", "size", "range", "options", "props", "props", "props", "props", "props", "count", "props", "handlePointerMove", "props", "handlePointerMove", "props", "handleSelect", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "props", "props", "useId", "handlePointerMove", "props", "props", "handlePointerDown", "props", "cycleArgs", "readonly", "props", "props", "readonly", "props", "readonly", "props", "props", "props", "props", "props", "readonly", "props", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "props", "readonly", "_a", "_b", "props", "readonly", "props", "props", "props", "readonly", "_a", "props", "props", "readonly", "props", "props", "computedIndex", "props", "props", "props", "props", "readonly", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "readonly", "props", "context", "props", "context", "props", "context", "props", "context", "props", "context", "props", "context", "props", "props", "_a", "isPointInPolygon", "props", "handlePointerUp", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "props", "useId", "wrapArray", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "wrapArray", "props", "getOpenState", "getTabbableCandidates", "focusFirst", "props", "useId", "props", "context", "useId", "triggerRef", "getTabbableCandidates", "focusFirst", "props", "target", "getTabbableCandidates", "focusFirst", "props", "props", "props", "props", "props", "props", "handlePointerMove", "props", "size", "_a", "clamp", "props", "clamp", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "context", "props", "props", "props", "props", "props", "ARROW_KEYS", "props", "props", "clamp", "offset", "props", "handlePointerDown", "handlePointerMove", "handlePointerUp", "offset", "props", "props", "handlePointerDown", "handlePointerUp", "props", "SELECTION_KEYS", "valueComparator", "compare", "props", "props", "compare", "props", "clamp", "props", "props", "handlePointerMove", "handlePointerUp", "valueComparator", "props", "props", "props", "props", "useId", "_sfc_main", "props", "valueComparator", "useId", "handleSelect", "handlePointerMove", "SELECTION_KEYS", "props", "props", "props", "props", "handlePointerDown", "handlePointerMove", "props", "props", "useId", "props", "valueComparator", "_a", "props", "props", "props", "clamp", "offset", "linearScale", "props", "props", "linearScale", "props", "linearScale", "props", "clamp", "props", "size", "i", "props", "isMouseEvent", "size", "size", "debounce", "size", "panelConstraints", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "size", "compare", "size", "count", "compare", "size", "panelDataArray", "size", "panelData", "props", "useId", "debounce", "registerResizeHandle", "direction", "dragState", "groupId", "isMouseEvent", "resizePanel", "panelData", "layout", "props", "resizePanel", "useId", "size", "props", "useId", "_a", "props", "props", "useId", "props", "props", "props", "props", "props", "makeTriggerId", "makeContentId", "props", "useId", "props", "makeTriggerId", "makeContentId", "props", "context", "props", "context", "props", "makeTriggerId", "makeContentId", "props", "props", "context", "props", "context", "props", "context", "props", "context", "props", "useId", "props", "readonly", "props", "readonly", "_sfc_main", "props", "handleAndDispatchCustomEvent", "isHidden", "props", "duration", "props", "props", "props", "props", "props", "props", "props", "props", "focusFirst", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "props", "useId", "isPointerDown", "handlePointerMove", "handlePointerDown", "handlePointerUp", "props", "props", "items", "val", "props", "isIndeterminate", "handleSelect", "props", "props", "props"]
}
